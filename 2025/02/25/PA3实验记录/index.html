<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="x5-fullscreen" content="true">
<meta name="full-screen" content="yes">
<meta name="theme-color" content="#317EFB" />
<meta content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=0" name="viewport">
<meta name="description" content="PA3-穿越时空的旅程：批处理系统最简单的操作系统1. 批处理系统 批处理系统的思想： 事先准备好一组程序, 让计算机执行完一个程序之后, 就自动执行下一个程序   批处理系统的关键： 有一个后台程序, 当一个前台程序执行结束的时候, 后台程序就会自动加载一个新的前台程序来执行 这样的一个后台程序, 其实就是操作系统   操作系统具体又需要实现以下两点功能:  12- 用户程序执行结束之后, 可以">
<meta property="og:type" content="article">
<meta property="og:title" content="PA3实验记录">
<meta property="og:url" content="http://example.com/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="Universe Hamster">
<meta property="og:description" content="PA3-穿越时空的旅程：批处理系统最简单的操作系统1. 批处理系统 批处理系统的思想： 事先准备好一组程序, 让计算机执行完一个程序之后, 就自动执行下一个程序   批处理系统的关键： 有一个后台程序, 当一个前台程序执行结束的时候, 后台程序就会自动加载一个新的前台程序来执行 这样的一个后台程序, 其实就是操作系统   操作系统具体又需要实现以下两点功能:  12- 用户程序执行结束之后, 可以">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="article:published_time" content="2025-02-25T14:46:00.000Z">
<meta property="article:modified_time" content="2025-02-25T14:47:15.776Z">
<meta property="article:author" content="Zhang Keyaoo">
<meta property="article:tag" content="PA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/404.jpg">


<title >PA3实验记录</title>

<!-- Favicon -->

    <link href='/assets/favicon.png?v=2.2.4' rel='icon' type='image/png' sizes='16x16' ></link>


    <link href='/assets/favicon.png?v=2.2.4' rel='icon' type='image/png' sizes='32x32' ></link>




<!-- Plugin -->




    
<link rel="stylesheet" href="/css/plugins/bootstrap.row.css">

    
<link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui@4.0/dist/fancybox.css">

    
    




<!-- Icon -->

    
<link rel="stylesheet" href="/css/plugins/font-awesome.min.css">




<!-- Variable -->
<script>window.ASYNC_CONFIG = {"hostname":"example.com","author":"Zhang Keyaoo","root":"/","typed_text":null,"theme_version":"2.2.4","theme":{"switch":true,"default":"style-light"},"favicon":{"logo":"/assets/favicon.svg","icon16":"/assets/favicon.png","icon32":"/assets/favicon.png","apple_touch_icon":null,"webmanifest":null,"visibilitychange":false,"hidden":"/failure.ico","show_text":"(/≧▽≦/)Hey! Good again!","hide_text":"(●—●)Oh, crash!"},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms","author":"Post author: ","copyright_link":"Post link: ","copyright_license_title":"Copyright Notice: ","copyright_license_content":"All articles in this blog are licensed under undefined unless otherwise stated.","copy_success":"Copied","copy_failure":"Copy failed","open_read_mode":"Enter reading mode","exit_read_mode":"Exit reading mode","notice_outdate_message":"It has been undefined days since the last update, the content of the article may be outdated.","sticky":"TOP","just":"Just","min":"minutes ago","hour":"hours ago","day":"days ago","month":"months ago"},"swup":false,"plugin":{"flickr_justified_gallery":"https://unpkg.com/flickr-justified-gallery@latest/dist/fjGallery.min.js"},"icons":{"sun":"far fa-sun","moon":"far fa-moon","play":"fas fa-play","email":"far fa-envelope","next":"fas fa-arrow-right","calendar":"far fa-calendar-alt","clock":"far fa-clock","user":"far fa-user","back_top":"fas fa-arrow-up","close":"fas fa-times","search":"fas fa-search","reward":"fas fa-hand-holding-usd","toc_tag":"fas fa-th-list","read":"fas fa-book-reader","arrows":"fas fa-arrows-alt-h","double_arrows":"fas fa-angle-double-down","copy":"fas fa-copy"},"icontype":"font","highlight":{"plugin":"highlighjs","theme":true,"copy":true,"lang":true,"title":"default","height_limit":false},"toc":{"post_title":false},"live_time":{"start_time":"02/20/2025 00:00:00","prefix":"The blog has been lovely to run undefined day"},"danmu":{"enable":false,"el":".trm-banner"},"search":{"enable":true,"type":"local","href":"https://www.google.com/search?q=site:","domain":null,"path":"search.xml"}};</script>
<script id="async-page-config">window.PAGE_CONFIG = {"isPost":true,"isHome":false,"postUpdate":"2025-02-25 22:47:15"};</script>

<!-- Theme mode css -->
<link data-swup-theme rel="stylesheet" href="/css/index.css?v=2.2.4" id="trm-switch-style">
<script>
    let defaultMode = ASYNC_CONFIG.theme.default !=='auto' ?  ASYNC_CONFIG.theme.default : (window.matchMedia("(prefers-color-scheme: light)").matches ? 'style-light' : 'style-dark')
    let catchMode = localStorage.getItem('theme-mode') || defaultMode;
    let type = catchMode === 'style-dark' ? 'add' : 'remove';
    document.documentElement.classList[type]('dark')
</script>

<!-- CDN -->


    
    



<!-- Site Analytics -->

 
<meta name="generator" content="Hexo 7.3.0"></head>

<body>

  <!-- app wrapper -->
  <div class="trm-app-frame">

    <!-- page preloader -->
    <div class="trm-preloader">
    <div class="trm-holder">
        <div class="preloader">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
</div>
    <!-- page preloader end -->

    <!-- change mode preloader -->
    <div class="trm-mode-swich-animation-frame">
    <div class="trm-mode-swich-animation">
        <i class="i-sun"><i class="iconfont far fa-sun"></i></i>
        <div class="trm-horizon"></div>
        <i class="i-moon"><i class="iconfont far fa-moon"></i></i>
    </div>
</div>
    <!-- change mode preloader end -->

      <!-- scroll container -->
      <div id="trm-dynamic-content" class="trm-swup-animation">
        <div id="trm-scroll-container" class="trm-scroll-container" style="opacity: 0">
            <!-- top bar -->
            <header class="trm-top-bar">
	<div class="container">
		<div class="trm-left-side">
			<!-- logo -->
<a href="/" class="trm-logo-frame trm-anima-link">
    
        <img alt="logo" src="/assets/favicon.svg">
    
    
        <div class="trm-logo-text">
            Zhang<span>Keyaoo</span>
        </div>
    
</a>
<!-- logo end -->
		</div>
		<div class="trm-right-side">
			<!-- menu -->
<div class="trm-menu">
    <nav>
        <ul>
            
            <li class="menu-item-has-children ">
                <a  href="/" target="">
                    主页
                </a>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a  href="/archives/" target="">
                    归档
                </a>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a  href="/categories/" target="">
                    分类
                </a>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a  href="/tags/" target="">
                    标签
                </a>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a  href="/links/" target="">
                    友链
                </a>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a  href="/about/" target="">
                    关于
                </a>
                
            </li>
            
        </ul>
    </nav>
</div>
<!-- menu end -->
			
    <!-- mode switcher place -->
    <div class="trm-mode-switcher-place">
        <div class="trm-mode-switcher">
            <i class="iconfont far fa-sun"></i>
            <input class="tgl tgl-light" id="trm-swich" type="checkbox">
            <label class="trm-swich" for="trm-swich"></label>
            <i class="iconfont far fa-moon"></i>
        </div>
    </div>
    <!-- mode switcher place end -->

			
    
    <div id="trm-search-btn" class="trm-search-btn">
        <i class="iconfont fas fa-search"></i>
    </div>
     

		</div>
		<div class="trm-menu-btn">
			<span></span>
		</div>
	</div>
</header>
            <!-- top bar end -->

            <!-- body -->
            
<div class="trm-content-start">
    <!-- banner -->
    <div class="trm-banner">
    
    <!-- banner cover -->
    <img style="object-position:top;object-fit:cover;" alt="banner" class="trm-banner-cover" src="/assets/banner.png">
    <!-- banner cover end -->
    

    <!-- banner content -->
    <div class="trm-banner-content trm-overlay">
        <div class="container">
            <div class="row">
                
                <div class="col-lg-4"></div>
                
                <div class="col-lg-8">

                    <!-- banner title -->
                    <div class="trm-banner-text ">
                        <div class="trm-label trm-mb-20">
                            ^_^
                        </div>
                        <h1 class="trm-mb-30 trm-hsmb-font">
                            PA3实验记录
                        </h1>

                        
                            <ul class="trm-breadcrumbs trm-label">
                                <li>
                                    <a href="/" class="trm-anima-link">Home</a>
                                </li>
                                <li>
                                    <span>
                                        2025
                                    </span>
                                </li>
                            </ul>
                        
                    </div>
                    <!-- banner title end -->

                    <!-- scroll hint -->
                    <span id="scroll-triger" class="trm-scroll-hint-frame">
                        <div class="trm-scroll-hint"></div>
                        <span class="trm-label">Scroll down</span>
                    </span>
                    <!-- scroll hint end -->

                </div>
            </div>
        </div>
    </div>
    <!-- banner content end -->
</div>
    <!-- banner end -->
    <div class="container">
        <div class="row">
            
                <div class="trm-page-sidebar col-lg-4 hidden-sm">
                    <!-- main card -->
                    <div class="trm-main-card-frame trm-sidebar">
    <div class="trm-main-card"> 
        <!-- card header -->
<div class="trm-mc-header">
    <div class="trm-avatar-frame trm-mb-20">
        <img alt="Avatar" class="trm-avatar" src="/assets/avatar.jpg">
    </div>
    <h5 class="trm-name trm-mb-15">
        Universe Hamster
    </h5>
    
</div>
<!-- card header end -->
        <!-- sidebar social -->

<div class="trm-divider trm-mb-40 trm-mt-40"></div>
<div class="trm-social">
    
        <a href="https://github.com/zhangkeyaoo" title="github" rel="nofollow" target="_blank">
            <i class="iconfont fab fa-github"></i>
        </a>
    
        <a href="https://space.bilibili.com/28526670?spm_id_from=333.1007.0.0" title="bilibili" rel="nofollow" target="_blank">
            <i class="iconfont fas fa-bold"></i>
        </a>
    
        <a href="/assets/wechat.png" title="wechat" rel="nofollow" target="_blank">
            <i class="iconfont fab fa-weixin"></i>
        </a>
    
</div>

<!-- sidebar social end -->
        <!-- info -->
<div class="trm-divider trm-mb-40 trm-mt-40"></div>
<ul class="trm-table trm-mb-20">
    
        <li>
            <div class="trm-label">
                school:
            </div>
            <div class="trm-label trm-label-light">
                Nanjing University
            </div>
        </li>
    
        <li>
            <div class="trm-label">
                birth:
            </div>
            <div class="trm-label trm-label-light">
                2005.06.15
            </div>
        </li>
    
        <li>
            <div class="trm-label">
                email:
            </div>
            <div class="trm-label trm-label-light">
                231250159@smail.nju.edu.cn
            </div>
        </li>
    
        <li>
            <div class="trm-label">
                qq:
            </div>
            <div class="trm-label trm-label-light">
                3313720023
            </div>
        </li>
    
</ul>
<!-- info end -->

        
    <div class="trm-divider trm-mb-40 trm-mt-40"></div>
    <!-- action button -->
    <div class="text-center">
        <a href="mailto:231250159@smail.nju.edu.cn" class="trm-btn">
            Contact Me
            <i class="iconfont far fa-envelope"></i>
        </a>
    </div>
    <!-- action button end -->

    </div>
</div>
                    <!-- main card end -->
                </div>
            
            <div class="trm-page-content col-lg-8">
                <div id="trm-content" class="trm-content">
                    <div class="trm-post-info row hidden-sm">
    <div class="col-sm-4">
        <div class="trm-card trm-label trm-label-light text-center">
            <i class="iconfont far fa-calendar-alt trm-icon"></i><br>
            02/25
        </div>
    </div>
    <div class="col-sm-4">
        <div class="trm-card trm-label trm-label-light text-center">
            <i class="iconfont far fa-clock trm-icon"></i><br>
            22:46
        </div>
    </div>
    <div class="col-sm-4">
        <div id="post-author" class="trm-card trm-label trm-label-light text-center">
            <i class="iconfont far fa-user trm-icon"></i><br>
            Zhang Keyaoo
        </div>
    </div>
</div>
<div class="trm-card ">
    <article id="article-container" class="trm-publication">
    <h2 id="PA3-穿越时空的旅程：批处理系统"><a href="#PA3-穿越时空的旅程：批处理系统" class="headerlink" title="PA3-穿越时空的旅程：批处理系统"></a>PA3-穿越时空的旅程：批处理系统</h2><h1 id="最简单的操作系统"><a href="#最简单的操作系统" class="headerlink" title="最简单的操作系统"></a>最简单的操作系统</h1><h2 id="1-批处理系统"><a href="#1-批处理系统" class="headerlink" title="1. 批处理系统"></a>1. 批处理系统</h2><ul>
<li>批处理系统的思想：<ul>
<li>事先准备好一组程序, 让计算机执行完一个程序之后, 就自动执行下一个程序</li>
</ul>
</li>
<li>批处理系统的关键：<ul>
<li>有一个后台程序, 当一个前台程序执行结束的时候, 后台程序就会自动加载一个新的前台程序来执行</li>
<li>这样的一个后台程序, 其实就是<em>操作系统</em></li>
</ul>
</li>
<li>操作系统具体又需要实现以下两点功能:  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 用户程序执行结束之后, 可以跳转到操作系统的代码继续执行</span><br><span class="line">- 操作系统可以加载一个新的用户程序来执行</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-1-来自操作系统的新需求"><a href="#1-1-来自操作系统的新需求" class="headerlink" title="1.1 来自操作系统的新需求"></a>1.1 来自操作系统的新需求</h3><ul>
<li>上述两点功能中其实蕴含着一个新的需求: <strong>程序之间的执行流切换</strong></li>
<li>能否也使用call&#x2F;jal指令来实现程序之间的执行流切换呢?<ul>
<li>如果操作系统崩溃了, 整个计算机系统都将无法工作. 所以希望能把操作系统保护起来。</li>
<li>所以这样太随意了</li>
</ul>
</li>
<li>一种可以限制入口的执行流切换方式<ul>
<li>显然, 这种方式是无法通过程序代码来实现的.</li>
</ul>
</li>
</ul>
<h3 id="1-2-等级森严的制度"><a href="#1-2-等级森严的制度" class="headerlink" title="1.2 等级森严的制度"></a>1.2 等级森严的制度</h3><ul>
<li>eg：<code>RISC-V</code>处理器存在M, S, U三个特权模式, 分别代表机器模式, 监管者模式和用户模式<ul>
<li>M模式特权级最高, U模式特权级最低,</li>
</ul>
</li>
<li>如何判断一个进程是否执行了无权限操作呢<ul>
<li>在硬件上维护一个用于标识<strong>当前特权模式</strong>的寄存器(属于计算机状态的一部分), 然后在访问那些<strong>高特权级才能访问的资源</strong>时, 对当前特权模式进行<strong>检查</strong>.</li>
<li>eg：<code>RISC-V</code>中有一条特权指令<code>sfence.vma</code>, 手册要求只有当处理器当前的特权模式不低于S模式才能执行, 因此我们可以在硬件上添加一些简单的逻辑来实现特权模式的检查:<ul>
<li><code>is_sfence_vma_ok = (priv_mode == M_MODE) || (priv_mode == S_MODE);</code></li>
</ul>
</li>
<li>如果检查不通过, 此次操作将会被判定为非法操作, CPU将会抛出异常信号, 并跳转到一个和操作系统约定好的内存位置, 交由操作系统进行后续处理.</li>
</ul>
</li>
<li>通常来说, 操作系统运行在S模式, 因此有权限访问所有的代码和数据; 而一般的程序运行在U模式, 这就决定了它只能访问U模式的代码和数据. 这样, 只要<strong>操作系统将其私有代码和数据放S模式中</strong>, 恶意程序就永远没有办法访问到它们.</li>
</ul>
<h1 id="穿越时空的旅程"><a href="#穿越时空的旅程" class="headerlink" title="穿越时空的旅程"></a>穿越时空的旅程</h1><h2 id="1-穿越时空的旅程"><a href="#1-穿越时空的旅程" class="headerlink" title="1. 穿越时空的旅程"></a>1. 穿越时空的旅程</h2><ul>
<li>自陷指令：硬件提供的一种可以限制入口的执行流切换方式</li>
<li>程序执行自陷指令之后, 就会陷入到操作系统预先设置好的跳转目标</li>
<li>异常入口地址：操作系统预先设置好的这个跳转目标</li>
</ul>
<h3 id="1-1-x86"><a href="#1-1-x86" class="headerlink" title="1.1 x86"></a>1.1 x86</h3><ul>
<li>提供<code>int</code>指令作为自陷指令</li>
<li>异常入口地址是通过*门描述符(Gate Descriptor)*来指示</li>
<li>门描述符:一个8字节的结构体<ul>
<li>NEMU中简化了门描述符的结构, 只保留存在位P和偏移量OFFSET</li>
<li>P位来用表示这一个门描述符是否有效</li>
<li>OFFSET用来指示异常入口地址</li>
</ul>
</li>
<li>IDT(Interrupt Descriptor Table, 中断描述符表), 数组的一个元素就是一个门描述符<ul>
<li>从数组中找到一个门描述符——索引</li>
<li>在内存中找到IDT——IDTR寄存器，存放IDT的首地址和长度</li>
</ul>
</li>
</ul>
<h3 id="1-2-mips32"><a href="#1-2-mips32" class="headerlink" title="1.2 mips32"></a>1.2 mips32</h3><ul>
<li>提供<code>syscall</code>指令作为自陷指令</li>
<li>异常入口地址总是<code>0x80000180</code></li>
<li>0号协处理器(Co-Processor 0)</li>
</ul>
<h3 id="1-3-riscv32"><a href="#1-3-riscv32" class="headerlink" title="1.3 riscv32"></a>1.3 riscv32</h3><ul>
<li>提供<code>ecall</code>指令作为自陷指令</li>
<li><code>mtvec寄存器</code>来存放异常入口地址</li>
<li>为了保存程序当前的状态, riscv32提供了一些特殊的系统寄存器, 叫<strong>控制状态寄存器</strong>(<code>CSR</code>寄存器)<ul>
<li>PA中, 我们只使用如下3个CSR寄存器:</li>
</ul>
<ol>
<li>mepc寄存器 - 存放触发异常的PC</li>
<li>mstatus寄存器 - 存放处理器的状态</li>
<li>mcause寄存器 - 存放触发异常的原因</li>
</ol>
</li>
<li>riscv32触发异常后硬件的响应过程如下:<ol>
<li>将当前PC值保存到mepc寄存器</li>
<li>在mcause寄存器中设置异常号</li>
<li>从mtvec寄存器中取出异常入口地址</li>
<li>跳转到异常入口地址</li>
</ol>
</li>
<li>riscv32通过<code>mret</code>指令从异常处理过程中返回, 它将根据mepc寄存器恢复PC.</li>
</ul>
<h4 id="思考：特殊的原因-建议二周目思考"><a href="#思考：特殊的原因-建议二周目思考" class="headerlink" title="思考：特殊的原因? (建议二周目思考)"></a>思考：特殊的原因? (建议二周目思考)</h4><ul>
<li>这些程序状态(x86的eflags, cs, eip; mips32的epc, status, cause; riscv32的mepc, mstatus, mcause)必须由硬件来保存吗? 能否通过软件来保存? 为什么?</li>
<li>理论上应该可以软件来保存，但是：</li>
</ul>
<ol>
<li>硬件保存这些状态寄存器比软件保存要快得多，因为硬件操作是直接的，而软件保存需要额外的指令和时间。</li>
<li>硬件保存状态寄存器在保存过程中不会被其他中断或异常打断。</li>
<li>软件保存状态需要额外的指令和代码，这会增加处理异常或中断的时间，降低系统性能，增加程序复杂性。</li>
</ol>
<h3 id="1-4-状态机视角下的异常响应机制"><a href="#1-4-状态机视角下的异常响应机制" class="headerlink" title="1.4 状态机视角下的异常响应机制"></a>1.4 状态机视角下的异常响应机制</h3><ul>
<li>程序是个<code>S = &lt;R, M&gt;</code>的状态机, 如果要给计算机添加异常响应机制, 我们又应该如何对这个状态机进行扩充呢?</li>
</ul>
<ol>
<li>首先,是对R的扩充<ul>
<li>添加系统寄存器(System Register)</li>
<li>扩充之后的寄存器可以表示为<code>R = &#123;GPR, PC, SR&#125;</code></li>
</ul>
</li>
<li>异常响应机制和内存无关, 无需对<code>M</code>的含义进行修改</li>
<li>对状态转移的扩充<ul>
<li>为了描述指令执行失败的行为, 我们可以假设CPU有一条虚构的指令<code>raise_intr</code>,执行它的行为就是异常响应过程</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SR[mepc] &lt;- PC</span><br><span class="line">SR[mcause] &lt;- 一个描述失败原因的号码</span><br><span class="line">PC &lt;- SR[mtvec]</span><br></pre></td></tr></table></figure>
<ul>
<li>如果一条指令执行成功, 其行为和之前介绍的TRM与IOE相同; 如果一条指令执行失败, 其行为等价于执行了虚构的<code>raise_intr</code>指令.</li>
</ul>
</li>
</ol>
<h2 id="2-将上下文管理抽象成CTE"><a href="#2-将上下文管理抽象成CTE" class="headerlink" title="2. 将上下文管理抽象成CTE"></a>2. 将上下文管理抽象成CTE</h2><ul>
<li>操作系统的处理过程需要哪些信息<ol>
<li>引发这次执行流切换的原因</li>
<li>程序的上下文</li>
</ol>
</li>
<li>另外两个统一的API:<ul>
<li><code>bool cte_init(Context* (*handler)(Event ev, Context *ctx))</code>用于进行CTE相关的<strong>初始化操作</strong>. 其中它还接受一个来自操作系统的事件处理回调函数的指针, 当发生事件时, CTE将会把事件和相关的上下文作为参数, 来调用这个回调函数, 交由操作系统进行后续处理.</li>
<li><code>void yield()</code>用于进行<strong>自陷操作</strong>, 会触发一个编号为<code>EVENT_YIELD</code>事件. 不同的ISA会使用不同的自陷指令来触发自陷操作, 具体实现请RTFSC.</li>
</ul>
</li>
<li>接下来, 我们尝试通过<code>am-tests</code>中的<code>yield test</code>测试触发一次自陷操作, 来梳理过程中的细节</li>
</ul>
<h3 id="2-1-设置异常入口地址"><a href="#2-1-设置异常入口地址" class="headerlink" title="2.1 设置异常入口地址"></a>2.1 设置异常入口地址</h3><ul>
<li>当我们选择<code>yield test</code>时, <code>am-tests</code>会通过<code>cte_init()</code>函数对CTE进行初始化, 其中包含一些简单的宏展开代码. 这最终会调用位于<code>abstract-machine/am/src/$ISA/nemu/cte.c</code>中的<code>cte_init()</code>函数. <ul>
<li><code>cte_init()</code>函数会做两件事情, 第一件就是<em>设置异常入口地址</em>.<ul>
<li>对于riscv32来说, <strong>直接将异常入口地址设置到mtvec寄存器中</strong>即可.</li>
</ul>
</li>
<li><code>cte_init()</code>函数做的第二件事是<em>注册一个事件处理回调函数</em>, 这个回调函数由<code>yield test</code>提供, 更多信息会在下文进行介绍.</li>
</ul>
</li>
</ul>
<h3 id="2-2-触发自陷操作"><a href="#2-2-触发自陷操作" class="headerlink" title="2.2 触发自陷操作"></a>2.2 触发自陷操作</h3><ol>
<li>从<code>cte_init()</code>函数返回后, <code>yield test</code>将会调用<strong>测试主体函数</strong><code>hello_intr()</code>, 首先输出一些信息, 然后通过io_read(AM_INPUT_CONFIG)启动输入设备(不过在NEMU中, 这一启动并无实质性操作). </li>
<li>接下来<code>hello_intr()</code>将通过<code>iset(1)</code><strong>打开中断</strong>, 不过我们目前还没有实现中断相关的功能, 因此同样可以忽略这部分的代码. </li>
<li>最后<code>hello_intr()</code>将进入<strong>测试主循环</strong>: 代码将不断调用<code>yield()</code>进行<strong>自陷操作</strong>, 为了<em>防止调用频率过高导致输出过快</em>, 测试主循环中还添加了一个<em>空循环</em>用于空转.</li>
</ol>
<ul>
<li>为了<strong>支撑自陷操作</strong>, 同时<strong>测试异常入口地址是否已经设置正确</strong>, 你需要在NEMU中实现<code>isa_raise_intr()</code>函数 (在<code>nemu/src/isa/$ISA/system/intr.c</code>中定义)来模拟上文提到的异常响应机制.</li>
<li>需要注意的是:<ul>
<li>PA不涉及特权级的切换, RTFM的时候你不需要关心和特权级切换相关的内容.</li>
<li>你需要<strong>在自陷指令的实现中调用</strong><code>isa_raise_intr()</code>, 而不要把异常响应机制的代码放在自陷指令的helper函数中实现, 因为在后面我们会<strong>再次</strong>用到<code>isa_raise_intr()</code>函数.</li>
</ul>
</li>
</ul>
<h4 id="必做：实现异常响应机制"><a href="#必做：实现异常响应机制" class="headerlink" title="必做：实现异常响应机制"></a>必做：实现异常响应机制</h4><ul>
<li>你需要<ol>
<li>实现上文提到的<strong>新指令</strong>,</li>
<li>实现<code>isa_raise_intr()</code>函数</li>
<li>阅读<code>cte_init()</code>的代码, 找出相应的<strong>异常入口地址</strong>.</li>
</ol>
</li>
<li>如果你选择mips32和riscv32, 你会发现status&#x2F;mstatus寄存器中有非常多状态位, 不过目前完全不实现这些状态位的功能也不影响程序的执行, 因此目前<em>只需要将status&#x2F;mstatus寄存器看成一个只用于存放32位数据的寄存器即可</em>.</li>
<li>实现后, 重新运行<code>yield test</code>, 如果你发现NEMU确实跳转到你找到的异常入口地址, 说明你的实现正确(NEMU也可能因为触发了未实现指令而终止运行).</li>
</ul>
<ol>
<li>实现新指令在<code>nemu/src/isa/riscv32/inst.c</code><ul>
<li>实现csr写指令<code>csrrw</code></li>
<li>实现csr读指令<code>csrrs</code></li>
<li>实现<code>ecall</code></li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//csr相关宏定义</span></span><br><span class="line"><span class="type">static</span> <span class="type">vaddr_t</span> *<span class="title function_">csr_register</span><span class="params">(<span class="type">word_t</span> imm)</span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (imm)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x341</span>: <span class="keyword">return</span> &amp;(cpu.csr.mepc);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x342</span>: <span class="keyword">return</span> &amp;(cpu.csr.mcause);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x300</span>: <span class="keyword">return</span> &amp;(cpu.csr.mstatus);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x305</span>: <span class="keyword">return</span> &amp;(cpu.csr.mtvec);</span><br><span class="line">  <span class="keyword">default</span>: panic(<span class="string">&quot;Unknow csr_register:%x&quot;</span>, imm);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECALL(dnpc) &#123; bool success; dnpc = (isa_qraise_intr(isa_reg_str2val(<span class="string">&quot;a7&quot;</span>, &amp;success), s-&gt;pc)); &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR(i) *csr_register(i)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//csr有关指令</span></span><br><span class="line">INSTPAT(<span class="string">&quot;??????? ????? ????? 001 ????? 11100 11&quot;</span>, csrrw  , I, R(rd) = CSR(imm); CSR(imm) = src1);</span><br><span class="line">INSTPAT(<span class="string">&quot;??????? ????? ????? 010 ????? 11100 11&quot;</span>, csrrs  , I, R(rd) = CSR(imm); CSR(imm) |= src1);</span><br><span class="line">INSTPAT(<span class="string">&quot;0000000 00000 00000 000 00000 11100 11&quot;</span>, ecall  , N, ECALL(s-&gt;dnpc));</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在<code>nemu/src/isa/riscv32/include/isa-def.h</code>添加特殊寄存器</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">word_t</span> mepc;</span><br><span class="line">  <span class="type">word_t</span> mcause;</span><br><span class="line">  <span class="type">word_t</span> mtvec;</span><br><span class="line">  <span class="type">word_t</span> mstatus;</span><br><span class="line">&#125;MUXDEF(CONFIG_RV64, riscv64_CSRS, riscv32_CSRS);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在<code>nemu/src/isa/riscv32/system/intr.c</code>中实现<code>isa_raise_intr()</code>函数:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">word_t</span> <span class="title function_">isa_raise_intr</span><span class="params">(<span class="type">word_t</span> NO, <span class="type">vaddr_t</span> epc)</span> &#123;</span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> Trigger an interrupt/exception with ``NO&#x27;&#x27;.</span></span><br><span class="line"><span class="comment">   * Then return the address of the interrupt/exception vector.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//保存当前的pc到mepc寄存器</span></span><br><span class="line">  cpu.csr.mepc = epc;</span><br><span class="line">  <span class="comment">//设置mcause寄存器为异常号</span></span><br><span class="line">  cpu.csr.mcause = NO;</span><br><span class="line">  <span class="comment">//获取mtvec寄存器的值</span></span><br><span class="line">  <span class="type">word_t</span> mtvec = cpu.csr.mtvec;</span><br><span class="line">  <span class="comment">//返回异常向量地址</span></span><br><span class="line">  <span class="keyword">return</span> mtvec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在<code>abstract-machine/am/src/riscv/nemu/cte.c</code>中的<code>cte_init()</code>函数中找到异常入口地址。<ul>
<li><code>asm volatile(&quot;csrw mtvec, %0&quot; : : &quot;r&quot;(__am_asm_trap));</code><ul>
<li>这行代码使用内联汇编指令<code>csrw mtvec, %0</code>,将 <code>__am_asm_trap</code> 的地址写入 mtvec 寄存器。</li>
<li>mtvec 寄存器用于<em>存储异常入口地址</em>，当发生异常时，程序会跳转到这个地址执行异常处理程序。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>因此，<strong>异常入口地址</strong>是<code>__am_asm_trap</code> 的地址。</li>
</ul>
<ol start="5">
<li>重新运行<code>yield tests</code>：</li>
</ol>
<ul>
<li>在<code>am-kernels/tests/am-tests</code>目录下<code>make ARCH=riscv32-nemu run mainargs=i</code></li>
<li>NEMU确实跳转到你找到的异常入口地址, 说明你的实现正确(NEMU也可能因为触发了未实现指令而终止运行).</li>
</ul>
<ol start="6">
<li>一直第一个指令就不行，很疑惑，改了好久实在是不知道哪里没好<ul>
<li>结果发现是写指令的时候，把新写的csr相关指令不小心放到全“？”指令之后了，导致识别不到！</li>
</ul>
</li>
</ol>
<h3 id="2-3-保存上下文"><a href="#2-3-保存上下文" class="headerlink" title="2.3 保存上下文"></a>2.3 保存上下文</h3><ul>
<li>成功跳转到异常入口地址之后——开始真正的异常处理过程</li>
<li>上下文包括：<ul>
<li><strong>通用寄存器</strong>：<ul>
<li>riscv32通过<strong>sw指令</strong>将各个通用寄存器依次<strong>压栈</strong>.</li>
</ul>
</li>
<li><strong>触发异常时的PC和处理器状态</strong>：<ul>
<li>riscv32：<code>epc/mepc</code>和<code>status/mstatus</code>寄存器, 异常响应机制把它们保存在相应的系统寄存器中, 我们还需要将它们<strong>从系统寄存器中读出</strong>, 然后<strong>保存在堆栈上</strong>.</li>
</ul>
</li>
<li><strong>异常号</strong>:<ul>
<li>riscv32中, 异常号已经由硬件保存在<code>cause/mcause</code>寄存器中, 我们还需要将其<strong>保存在堆栈上</strong>.</li>
</ul>
</li>
<li><strong>地址空间</strong>:<ul>
<li>(这是为PA4准备的)riscv32是将地址空间信息与0号寄存器共用存储空间, 反正0号寄存器的值总是0, 也不需要保存和恢复. 不过目前我们暂时不使用地址空间信息, 你目前可以忽略它们的含义.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="思考：异常号的保存"><a href="#思考：异常号的保存" class="headerlink" title="思考：异常号的保存"></a>思考：异常号的保存</h4><ul>
<li>x86通过软件来保存异常号, 没有类似cause的寄存器. mips32和riscv32也可以这样吗? 为什么?</li>
<li>对于 mips32 和 riscv32 架构，它们都有专门的寄存器（如 cause 寄存器）来保存异常号。这些寄存器的存在有以下几个原因：<ul>
<li>性能：硬件寄存器保存异常号比通过软件保存要快得多，减少了异常处理的开销。</li>
<li>简化设计：硬件寄存器使得异常处理更加简单和直接，减少了软件处理的复杂性。</li>
<li>一致性：硬件寄存器可以确保在异常发生时立即保存异常号，避免了在软件保存过程中可能出现的竞态条件。</li>
</ul>
</li>
<li>虽然 mips32 和 riscv32 理论上可以通过软件来保存异常号，但这样做会带来性能下降和设计复杂性增加的问题。因此，使用硬件寄存器来保存异常号是更为合理和高效的选择。</li>
</ul>
<h4 id="思考：对比异常处理与函数调用"><a href="#思考：对比异常处理与函数调用" class="headerlink" title="思考：对比异常处理与函数调用"></a>思考：对比异常处理与函数调用</h4><ul>
<li>我们知道进行函数调用的时候也需要<strong>保存调用者的状态</strong>: <strong>返回地址</strong>, 以及calling convention中需要<strong>调用者保存的寄存器</strong>. 而<code>CTE</code>在保存上下文的时候却要保存<em>更多的信息</em>. 尝试对比它们, 并思考两者保存信息不同是什么原因造成的.</li>
</ul>
<ol>
<li>函数调用时的状态保存<ul>
<li>以便在函数执行完毕后能够正确返回并继续执行。保存的状态包括：</li>
</ul>
<ol>
<li>返回地址：函数执行完毕后需要返回的地址。</li>
<li>调用者保存的寄存器：根据调用约定（calling convention），需要调用者保存的寄存器（如 x86 中的 ebx, esi, edi 等）。</li>
</ol>
</li>
<li>异常处理（<code>CTE</code>）时的状态保存<ul>
<li>保存更多的信息，以便在处理完异常后能够正确恢复并继续执行。保存的状态包括：</li>
</ul>
<ol>
<li>程序计数器（PC）：发生异常时的指令地址。</li>
<li>状态寄存器：处理器的状态（如 x86 中的 eflags，mips32 中的 status，riscv32 中的 mstatus）。</li>
<li>异常号：表示发生了哪种异常（如 mips32 中的 cause，riscv32 中的 mcause）。</li>
<li>其他上下文信息：可能包括更多的寄存器和处理器状态，以确保异常处理程序能够正确执行。</li>
</ol>
</li>
<li>保存信息不同的原因<ul>
<li>复杂性：异常处理比函数调用更复杂，因为异常可能发生在任何时候，处理器需要保存更多的状态信息以确保能够正确恢复执行。</li>
<li>原子性：异常处理需要确保状态保存和恢复的原子性，以避免在处理中断或异常时出现竞态条件。</li>
<li>硬件支持：异常处理通常由硬件直接支持，硬件可以快速保存和恢复状态，而函数调用主要由软件管理，保存的状态较少。</li>
<li>恢复执行：函数调用的返回地址和调用者保存的寄存器足以恢复执行，而异常处理需要保存更多的状态信息，以确保在处理完异常后能够正确恢复到异常发生前的状态。</li>
</ul>
</li>
</ol>
<hr>
<ul>
<li>接下来代码会调用C函数<code>__am_irq_handle()</code>(在<code>abstract-machine/am/src/$ISA/nemu/cte.c</code>中定义), 来<strong>进行异常的处理</strong>.</li>
</ul>
<h4 id="必做：重新组织Context结构体"><a href="#必做：重新组织Context结构体" class="headerlink" title="必做：重新组织Context结构体"></a>必做：重新组织Context结构体</h4><ul>
<li>你的任务如下:<ul>
<li>实现这一过程中的<strong>新指令</strong>, 详情请RTFM.</li>
<li>理解上下文形成的过程并RTFSC, 然后<strong>重新组织</strong><code>abstract-machine/am/include/arch/$ISA-nemu.h</code> (如果你选择RISC-V, 则文件名为riscv.h) 中定义的<strong>Context结构体的成员</strong>, <strong>使得这些成员的定义顺序和</strong><code>abstract-machine/am/src/$ISA/nemu/trap.S</code><strong>中构造的上下文保持一致</strong>.</li>
</ul>
</li>
<li>需要注意的是, 虽然我们目前暂时不使用上文提到的地址空间信息, 但你在重新组织Context结构体时<strong>仍然需要正确地处理地址空间信息的位置</strong>, 否则你可能会在PA4中遇到难以理解的错误.</li>
<li>实现之后, 你可以在<code>__am_irq_handle()</code>中通过<code>printf</code>输出上下文c的内容, 然后通过简易调试器观察触发自陷时的寄存器状态, 从而检查你的Context实现是否正确.</li>
</ul>
<ol>
<li>实现新指令：<ul>
<li><code>INSTPAT(&quot;0011000 00010 00000 000 00000 11100 11&quot;, mret   , N, s-&gt;dnpc = CSR(0x341));</code></li>
</ul>
</li>
<li>在&#96;&#96;&#96;&#96;abstract-machine&#x2F;am&#x2F;include&#x2F;arch&#x2F;riscv.h<code>中，通过</code>trap.S&#96;&#96;重排Context：</li>
</ol>
<ul>
<li>分析：在<code>trap.S</code>中：<ul>
<li>#define CONTEXT_SIZE  ((NR_REGS + 3) * XLEN)<ul>
<li>NR_REGS：表示通用寄存器的数量——通用寄存器</li>
</ul>
</li>
<li>#define OFFSET_SP     ( 2 * XLEN)<ul>
<li>OFFSET_SP：表示堆栈指针（SP）在上下文中的偏移量——*pdir</li>
</ul>
</li>
<li>#define OFFSET_CAUSE  ((NR_REGS + 0) * XLEN)<ul>
<li>mcause</li>
</ul>
</li>
<li>#define OFFSET_STATUS ((NR_REGS + 1) * XLEN)<ul>
<li>mstatus</li>
</ul>
</li>
<li>#define OFFSET_EPC    ((NR_REGS + 2) * XLEN)<ul>
<li>mepc</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Context</span> &#123;</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> fix the order of these members to match trap.S</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// uintptr_t mepc, mcause, gpr[NR_REGS], mstatus;</span></span><br><span class="line">  <span class="type">uintptr_t</span> gpr[NR_REGS];<span class="comment">//通用寄存器</span></span><br><span class="line">  <span class="type">uintptr_t</span> mcause;<span class="comment">//异常号</span></span><br><span class="line">  <span class="type">uintptr_t</span> mstatus;<span class="comment">//处理器状态</span></span><br><span class="line">  <span class="type">uintptr_t</span> mepc;<span class="comment">//异常pc</span></span><br><span class="line">  <span class="type">void</span> *pdir;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在<code>abstract-machine/am/src/riscv/nemu/cte.c</code>的<code>__am_irq_handle()</code>函数中，通过<code>printf</code>输出上下文<code>c</code>的内容:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Context* __am_irq_handle(Context *c) &#123;<span class="comment">//异常处理函数</span></span><br><span class="line">  <span class="keyword">if</span> (user_handler) &#123;</span><br><span class="line">    Event ev = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">switch</span> (c-&gt;mcause) &#123;</span><br><span class="line">      <span class="keyword">default</span>: ev.event = EVENT_ERROR; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出上下文内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mcause = %x\n&quot;</span>, c-&gt;mcause);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mstatus = %x\n&quot;</span>, c-&gt;mstatus);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mepc = %x\n&quot;</span>, c-&gt;mepc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NR_REGS; i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;gpr[%d] = %x\n&quot;</span>, i, c-&gt;gpr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c = user_handler(ev, c);</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="必做：必答题-需要在实验报告中回答-理解上下文结构体的前世今生"><a href="#必做：必答题-需要在实验报告中回答-理解上下文结构体的前世今生" class="headerlink" title="必做：必答题(需要在实验报告中回答) - 理解上下文结构体的前世今生"></a>必做：必答题(需要在实验报告中回答) - 理解上下文结构体的前世今生</h4><ul>
<li>你会在__am_irq_handle()中看到有一个上下文结构指针c, c指向的上下文结构究竟在哪里? 这个上下文结构又是怎么来的? 具体地, 这个上下文结构有很多成员, 每一个成员究竟在哪里赋值的? $ISA-nemu.h, trap.S, 上述讲义文字, 以及你刚刚在NEMU中实现的新指令, 这四部分内容又有什么联系?</li>
<li>如果你不是脑袋足够灵光, 还是不要眼睁睁地盯着代码看了, 理解程序的细节行为还是要从状态机视角入手.</li>
</ul>
<ol>
<li>c指向的上下文结构的来源：<ul>
<li>上下文结构体<code>Context</code>是在异常处理过程中创建的。它包含了处理器的寄存器状态，包括通用寄存器、异常号、处理器状态和异常 PC 等。</li>
</ul>
</li>
<li>上下文结构体的创建过程<ol>
<li><strong>异常触发</strong>：当发生异常时，处理器会自动跳转到异常处理入口地址，该地址存储在<code>mtvec</code>寄存器中。ps:这个地址是<code>__am_asm_trap</code>。</li>
<li><strong>保存上下文</strong>：在 <code>__am_asm_trap</code> 中，使用汇编代码保存当前的处理器状态到栈中。具体来说，将所有通用寄存器、mcause、mstatus 和 mepc 寄存器的值保存到栈中。</li>
<li><strong>调用异常处理函数</strong>：保存完上下文后，我们将栈指针传递给 <code>__am_irq_handle</code> 函数，并调用它进行异常处理。</li>
</ol>
</li>
<li>上下文结构体的成员赋值:<ul>
<li>在 <code>trap.S</code> 中被赋值</li>
</ul>
<ol>
<li>保存<strong>通用寄存器</strong>：<code>MAP(REGS, PUSH)</code><ul>
<li>使用宏<code>PUSH</code>将所有通用寄存器的值保存到栈中。</li>
</ul>
</li>
<li>保存<strong>mcause、mstatus和mepc寄存器</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">csrr t0, mcause</span><br><span class="line">csrr t1, mstatus</span><br><span class="line">csrr t2, mepc</span><br><span class="line"></span><br><span class="line">STORE t0, OFFSET_CAUSE(sp)</span><br><span class="line">STORE t1, OFFSET_STATUS(sp)</span><br><span class="line">STORE t2, OFFSET_EPC(sp)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>csrr</code>指令将mcause、mstatus 和 mepc寄存器的值读取到临时寄存器t0、t1 和 t2，然后使用<code>STORE</code>宏将它们保存到栈中。</li>
</ul>
</li>
</ol>
</li>
<li>各部分内容的联系<ol>
<li><code>riscv.h</code>：定义了上下文结构体 Context，包括通用寄存器、mcause、mstatus 和 mepc 等成员。</li>
<li><code>trap.S</code>：在异常发生时，保存处理器的状态到栈中，并调用 __am_irq_handle 进行异常处理。</li>
<li><code>cte.c</code>：实现了异常处理函数 __am_irq_handle，通过指针 c 访问上下文结构体，并输出其成员的值。</li>
<li>新指令的实现：在 inst.c 中实现了 <code>csrr</code> 和 <code>csrw</code> 指令，用于读取和写入 CSR 寄存器的值。这些指令在 trap.S 中被使用，用于保存和恢复 mcause、mstatus 和 mepc 寄存器的值。</li>
</ol>
</li>
</ol>
<h3 id="2-4-事件分发"><a href="#2-4-事件分发" class="headerlink" title="2.4 事件分发"></a>2.4 事件分发</h3><ul>
<li><code>__am_irq_handle()</code>的代码会把执行流切换的原因打包成事件, 然后调用在<code>cte_init()</code>中注册的<strong>事件处理回调函数</strong>, 将事件交给<code>yield test</code>来处理.</li>
<li>在<code>yield test</code>中, 这一<strong>回调函数</strong>是<code>am-kernels/tests/am-tests/src/tests/intr.c</code>中的<code>simple_trap()</code>函数. <code>simple_trap()</code>函数会<em>根据事件类型再次进行分发</em>. 不过我们在这里会<strong>触发一个未处理的事件</strong>:<ul>
<li><code>AM Panic: Unhandled event @ am-kernels/tests/am-tests/src/tests/intr.c:12</code></li>
</ul>
</li>
<li>因为CTE的<code>__am_irq_handle()</code>函数<strong>并未正确识别出自陷事件</strong>. 根据<code>yield()</code>的定义, <code>__am_irq_handle()</code>函数需要将自陷事件打包成编号为<code>EVENT_YIELD</code>的事件.</li>
</ul>
<h4 id="必做：识别自陷事件"><a href="#必做：识别自陷事件" class="headerlink" title="必做：识别自陷事件"></a>必做：识别自陷事件</h4><ul>
<li>你需要在<code>__am_irq_handle()</code>中<strong>通过异常号识别出自陷异常</strong>, 并<strong>打包成编号为EVENT_YIELD的自陷事件</strong>. 重新运行yield test, 如果你的实现正确, 你会看到识别到自陷事件之后<strong>输出一个字符y</strong>.</li>
</ul>
<ol>
<li>在<code>__am_irq_handle()</code>中：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (c-&gt;mcause) &#123;</span><br><span class="line">      <span class="comment">//添加对异常号的处理</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: ev.event = EVENT_YIELD; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>: ev.event = EVENT_ERROR; <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>运行yield test效果：（有输出y,但很快很多，接着往下看吧！）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, AM World @ riscv32</span><br><span class="line">  t = timer, d = device, y = yield</span><br><span class="line">yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy</span><br></pre></td></tr></table></figure>
<h3 id="2-5-恢复上下文"><a href="#2-5-恢复上下文" class="headerlink" title="2.5 恢复上下文"></a>2.5 恢复上下文</h3><ul>
<li>代码将会一路返回到<code>trap.S</code>的<code>__am_asm_trap()</code>中, 接下来的事情就是<em>恢复程序的上下文</em>. </li>
<li>之前自陷指令保存的PC,对于riscv32的ecall, 保存的是自陷指令的PC<ul>
<li>因此软件需要<strong>在适当的地方对保存的PC加上4</strong>, 使得将来返回到自陷指令的下一条指令.</li>
</ul>
</li>
<li>代码最后会返回到<code>yield test</code>触发自陷的代码位置, 然后继续执行</li>
</ul>
<h4 id="思考：从加4操作看CISC和RISC"><a href="#思考：从加4操作看CISC和RISC" class="headerlink" title="思考：从加4操作看CISC和RISC"></a>思考：从加4操作看CISC和RISC</h4><ul>
<li>事实上, 自陷只是其中一种异常类型. 有一种故障类异常, 它们返回的PC和触发异常的PC是同一个, 例如缺页异常, 在系统将故障排除后, 将会重新执行相同的指令进行重试, 因此异常返回的PC无需加4. 所以根据异常类型的不同, 有时候需要加4, 有时候则不需要加.</li>
<li>这时候, 我们就可以考虑这样的一个问题了: 决定要不要加4的, 是硬件还是软件呢? CISC和RISC的做法正好相反, CISC都交给硬件来做, 而RISC则交给软件来做. 思考一下, 这两种方案各有什么取舍? 你认为哪种更合理呢? 为什么?</li>
</ul>
<ol>
<li>硬件 vs 软件决定加4<ul>
<li>CISC（复杂指令集计算机）：通常由硬件决定是否加4。硬件会根据异常类型自动调整PC。</li>
<li>RISC（精简指令集计算机）：通常由软件决定是否加4。软件在异常处理程序中根据异常类型调整PC。</li>
</ul>
</li>
<li>取舍分析<ul>
<li>硬件决定（CISC）：<ul>
<li>优点：<ol>
<li>简化软件设计：软件不需要关心异常类型和PC的调整，减少了异常处理程序的复杂性。</li>
<li>快速响应：硬件直接处理，速度更快。</li>
</ol>
</li>
<li>缺点：<ol>
<li>硬件复杂度增加：硬件需要识别各种异常类型并做出相应处理，增加了硬件设计的复杂性。</li>
<li>灵活性较低：硬件实现的处理方式固定，软件无法灵活调整。</li>
</ol>
</li>
</ul>
</li>
<li>软件决定（RISC）：<ul>
<li>优点：<ol>
<li>硬件简单：硬件只需触发异常，不需要处理PC的调整，简化了硬件设计。</li>
<li>灵活性高：软件可以根据具体需求灵活调整PC，适应不同的异常处理需求。</li>
</ol>
</li>
<li>缺点：<ol>
<li>增加软件复杂性：异常处理程序需要识别异常类型并调整PC，增加了软件设计的复杂性。</li>
<li>响应速度较慢：软件处理需要额外的指令，可能导致响应速度较慢。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>我认为合理性取决于设计目标，<ul>
<li>如果系统设计目标是简化软件开发，提高响应速度，CISC的硬件决定方式可能更合理。</li>
<li>如果系统设计目标是简化硬件设计，提高灵活性，RISC的软件决定方式可能更合理。</li>
</ul>
</li>
</ol>
<h4 id="必做：恢复上下文"><a href="#必做：恢复上下文" class="headerlink" title="必做：恢复上下文"></a>必做：恢复上下文</h4><ul>
<li>你需要<strong>实现这一过程中的新指令</strong>. 重新运行<code>yield test</code>. 如果你的实现正确, <code>yield test</code>将<strong>不断输出y</strong>.</li>
</ul>
<ol>
<li>在<code>mret</code>指令处进行“+4”：<ul>
<li><code>INSTPAT(&quot;0011000 00010 00000 000 00000 11100 11&quot;, mret   , N, s-&gt;dnpc = CSR(0x341)+4);</code></li>
</ul>
</li>
</ol>
<ul>
<li>实现后效果：不断输出y（有节奏地输出y，没有疯狂输出了，而是遇到再输出）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, AM World @ riscv32</span><br><span class="line">  t = timer, d = device, y = yield</span><br><span class="line">yyyyyyyyyyyyyyyyyyyyyyyyyy</span><br></pre></td></tr></table></figure>
<h4 id="必答题-需要在实验报告中回答-理解穿越时空的旅程"><a href="#必答题-需要在实验报告中回答-理解穿越时空的旅程" class="headerlink" title="必答题(需要在实验报告中回答) - 理解穿越时空的旅程"></a>必答题(需要在实验报告中回答) - 理解穿越时空的旅程</h4><ul>
<li>从<code>yield test</code>调用<code>yield()</code>开始, 到从<code>yield()</code>返回的期间, 这一趟旅程具体经历了什么? 软(AM, <code>yield test</code>)硬(NEMU)件是如何相互协助来完成这趟旅程的? 你需要解释这一过程中的每一处细节, 包括涉及的每一行汇编代码&#x2F;C代码的行为, 尤其是一些比较关键的指令&#x2F;变量. 事实上, 上文的必答题”理解上下文结构体的前世今生”已经涵盖了这趟旅程中的一部分, 你可以把它的回答包含进来.</li>
<li>别被”每一行代码”吓到了, 这个过程也就大约50行代码, 要完全理解透彻并不是不可能的. 我们之所以设置这道必答题, 是为了强迫你理解清楚这个过程中的每一处细节. 这一理解是如此重要, 以至于如果你缺少它, 接下来你面对bug几乎是束手无策.</li>
</ul>
<ol>
<li><code>yield()</code> 函数调用<ul>
<li>在 <code>yield test</code> 中，调用 <code>yield()</code> 函数：</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">yield</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __riscv_e</span></span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;li a5, -1; ecall&quot;</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;li a7, -1; ecall&quot;</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这段代码使用内联汇编触发一个环境调用（ECALL）</li>
<li><code>li a7, -1</code>：将立即数 -1 加载到寄存器 a7 中</li>
<li><code>ecall</code>：触发一个环境调用异常。</li>
</ul>
</li>
<li>触发异常<ul>
<li><code>ecall</code>指令触发一个环境调用异常，处理器进入异常处理模式，并跳转到由 <code>mtvec</code> 寄存器指定的异常处理程序地址。</li>
</ul>
</li>
<li>异常处理程序(在 <code>trap.S</code> 文件中定义)：<ul>
<li><code>addi sp, sp, -CONTEXT_SIZE</code>： 为保存上下文分配空间。</li>
<li><code>MAP(REGS, PUSH)</code>： 保存所有通用寄存器的值。</li>
<li><code>csrr t0, mcause</code>： 读取 mcause 寄存器的值到 t0。</li>
<li><code>csrr t1, mstatus</code>： 读取 mstatus 寄存器的值到 t1。</li>
<li><code>csrr t2, mepc</code>： 读取 mepc 寄存器的值到 t2。</li>
<li><code>STORE t0, OFFSET_CAUSE(sp)</code>： 将 mcause 的值保存到栈中。</li>
<li><code>STORE t1, OFFSET_STATUS(sp)</code>： 将 mstatus 的值保存到栈中。</li>
<li><code>STORE t2, OFFSET_EPC(sp)</code>： 将 mepc 的值保存到栈中。</li>
<li><code>li a0, (1 &lt;&lt; 17)</code>： 将立即数 1 &lt;&lt; 17 加载到 a0 中。</li>
<li><code>or t1, t1, a0</code>： 将 t1 和 a0 进行或运算，结果存入 t1。</li>
<li><code>csrw mstatus, t1</code>： 将 t1 的值写入 mstatus 寄存器。</li>
<li><code>mv a0, sp</code>： 将栈指针的值移动到 a0。</li>
<li><code>call __am_irq_handle</code>： 调用 __am_irq_handle 函数。</li>
</ul>
</li>
<li><code>__am_irq_handle</code>函数(在 <code>cte.c</code> 文件中定义)：<ul>
<li><code>switch (c-&gt;mcause)</code>：根据 mcause 的值判断异常类型。</li>
<li><code>case 0: ev.event = EVENT_YIELD; break;</code>：如果 mcause 为 0，表示自陷异常，将事件类型设置为 EVENT_YIELD。</li>
<li><code>c = user_handler(ev, c);</code>：调用用户注册的事件处理程序 user_handler，并传递事件和上下文。</li>
</ul>
</li>
<li>用户事件处理程序(在 <code>intr.c</code> 文件中定义)：<ul>
<li><code>case EVENT_YIELD: putch(&#39;y&#39;); break;</code>：如果事件类型为 EVENT_YIELD，输出字符 y。</li>
</ul>
</li>
<li>恢复上下文并返回<ul>
<li>回到异常处理程序：</li>
<li><code>LOAD t1, OFFSET_STATUS(sp)</code>：从栈中恢复 mstatus 的值到 t1。</li>
<li><code>LOAD t2, OFFSET_EPC(sp)</code>：从栈中恢复 mepc 的值到 t2。</li>
<li><code>csrw mstatus, t1</code>：将 t1 的值写入 mstatus 寄存器。</li>
<li><code>csrw mepc, t2</code>：将 t2 的值写入 mepc 寄存器。</li>
<li><code>MAP(REGS, POP)</code>：恢复所有通用寄存器的值。</li>
<li><code>addi sp, sp, CONTEXT_SIZE</code>：释放为保存上下文分配的空间。</li>
<li><code>mret</code>：从异常处理程序返回，恢复程序的正常执行。</li>
</ul>
</li>
</ol>
<h3 id="2-6-异常处理的踪迹-etrace"><a href="#2-6-异常处理的踪迹-etrace" class="headerlink" title="2.6 异常处理的踪迹-etrace"></a>2.6 异常处理的踪迹-etrace</h3><h4 id="必做：实现etrace"><a href="#必做：实现etrace" class="headerlink" title="必做：实现etrace"></a>必做：实现etrace</h4><ul>
<li>在<code>isa_raise_intr</code>中添加：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//etrace</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nmcause = %d\n&quot;</span>,NO);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;mepc = %x\n&quot;</span>,epc);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;mtvec = %x\n&quot;</span>,mtvec);</span><br></pre></td></tr></table></figure>
<ul>
<li>效果（运行yield test）：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Hello, AM World @ riscv32</span><br><span class="line">  t = timer, d = device, y = yield</span><br><span class="line"></span><br><span class="line">mcause = -1</span><br><span class="line">mepc = 80001438</span><br><span class="line">mtvec = 80001448</span><br><span class="line">y</span><br><span class="line">mcause = -1</span><br><span class="line">mepc = 80001438</span><br><span class="line">mtvec = 80001448</span><br><span class="line">y</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h2 id="PA-3-1到此结束"><a href="#PA-3-1到此结束" class="headerlink" title="PA 3.1到此结束"></a>PA 3.1到此结束</h2><hr>
<h1 id="用户程序和系统调用"><a href="#用户程序和系统调用" class="headerlink" title="用户程序和系统调用"></a>用户程序和系统调用</h1><h2 id="1-最简单的操作系统"><a href="#1-最简单的操作系统" class="headerlink" title="1. 最简单的操作系统"></a>1. 最简单的操作系统</h2><ul>
<li>在PA中使用的操作系统叫<code>Nanos-lite</code>, 它是南京大学操作系统<code>Nanos</code>的裁剪版</li>
<li>Nanos-lite的框架代码, 通过执行以下命令获取:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ics2024</span><br><span class="line">bash init.sh nanos-lite</span><br></pre></td></tr></table></figure>
<ul>
<li>会通过<code>nanos-lite/include/common.h</code>中一些<strong>与实验进度相关的宏</strong>来控制<code>Nanos-lite</code>的功能</li>
<li>由于Nanos-lite本质上也是一个AM程序, 我们可以采用相同的方式来<strong>编译&#x2F;运行</strong>Nanos-lite. 在nanos-lite&#x2F;目录下执行<code>make ARCH=$ISA-nemu run</code>即可</li>
<li>需要在<code>nanos-lite/include/common.h</code>中定义<strong>宏HAS_CTE</strong>, 这样以后, Nanos-lite会多进行以下操作:<ul>
<li>初始化时调用init_irq()函数, 它将通过cte_init()函数初始化CTE</li>
<li>在panic()前调用yield()来触发自陷操作</li>
</ul>
</li>
</ul>
<h4 id="必做：为Nanos-lite实现正确的事件分发"><a href="#必做：为Nanos-lite实现正确的事件分发" class="headerlink" title="必做：为Nanos-lite实现正确的事件分发"></a>必做：为Nanos-lite实现正确的事件分发</h4><ul>
<li><code>Nanos-lite</code>的事件处理回调函数默认不处理所有事件, 你需要在其中<strong>识别出自陷事件EVENT_YIELD</strong>, 然后<strong>输出一句话</strong>即可, 目前无需进行其它操作.</li>
<li>重新运行Nanos-lite, 如果你的实现正确, 你会看到识别到自陷事件之后输出的信息, 并且最后仍然触发了main()函数末尾设置的panic().</li>
</ul>
<ol>
<li>在<code>nanos-lite/include/common.h</code>中定义<strong>宏HAS_CTE</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HAS_CTE</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>ics2024/nanos-lite/src/irq.c</code>:(中断异常处理)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Context* <span class="title function_">do_event</span><span class="params">(Event e, Context* c)</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (e.event) &#123;</span><br><span class="line">    <span class="keyword">case</span> EVENT_YIELD: </span><br><span class="line">      Log(<span class="string">&quot;Yield event happened&quot;</span>); </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: panic(<span class="string">&quot;Unhandled event ID = %d&quot;</span>, e.event);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>现在运行<code>make ARCH=riscv32-nemu run </code>,得到有识别到自陷事件之后输出的信息, 也有触发main()函数末尾设置的panic()：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mcause = -1</span><br><span class="line">mepc = 800005d8</span><br><span class="line">mtvec = 800005e0</span><br><span class="line">[/home/xiaoyao/ics2024/nanos-lite/src/irq.c,6,do_event] Yield event happened</span><br><span class="line">[/home/xiaoyao/ics2024/nanos-lite/src/main.c,36,main] system panic: Should not reach here</span><br><span class="line">[src/cpu/cpu-exec.c:196 cpu_exec] nemu: HIT BAD TRAP at pc = 0x80000278</span><br></pre></td></tr></table></figure>
<h2 id="2-加载第一个用户程序"><a href="#2-加载第一个用户程序" class="headerlink" title="2. 加载第一个用户程序"></a>2. 加载第一个用户程序</h2><ul>
<li>在操作系统中, 加载用户程序是由<strong>loader(加载器)模块</strong>负责的<ul>
<li>加载的过程就是把可执行文件中的代码和数据放置在正确的内存位置, 然后跳转到程序入口, 程序就开始执行了</li>
</ul>
</li>
<li>为了实现loader()函数, 我们需要解决以下问题:<ul>
<li>可执行文件在哪里?</li>
<li>代码和数据在可执行文件的哪个位置?</li>
<li>代码和数据有多少?</li>
<li>“正确的内存位置”在哪里?</li>
</ul>
</li>
<li>用户程序是从哪里来的<ul>
<li>准备了一个新的子项目<strong>Navy-apps</strong>, 专门用于<strong>编译出操作系统的用户程序</strong></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ics2024</span><br><span class="line">bash init.sh navy-apps</span><br></pre></td></tr></table></figure>
<ul>
<li>用户程序的入口位于<code>navy-apps/libs/libos/src/crt0/start.S</code>中的<code>_start()</code>函数<ul>
<li>这里的crt是C RunTime的缩写, 0的含义表示最开始. </li>
<li><code>_start()</code>函数会<ol>
<li>调用<code>navy-apps/libs/libos/src/crt0/crt0.c</code>中的<code>call_main()</code>函数</li>
<li>然后调用用户程序的main()函数</li>
<li>从main()函数返回后会调用exit()结束运行.</li>
</ol>
</li>
</ul>
</li>
<li>C库的代码”总是”对的</li>
<li>要在Nanos-lite上运行的第一个用户程序是<code>navy-apps/tests/dummy/dummy.c</code><ul>
<li>为了编译dummy, 在<code>navy-apps/tests/dummy/</code>目录下执行<code>make ISA=$ISA</code></li>
<li>一直编译不了，终端执行了<code>export NAVY_HOME=/home/xiaoyao/ics2024/navy-apps</code>之后可以了</li>
<li>编译成功后把<code>navy-apps/tests/dummy/build/dummy-$ISA</code><strong>手动复制并重命名</strong>为<code>nanos-lite/build/ramdisk.img</code>, 然后在nanos-lite&#x2F;目录下执行<code>make ARCH=$ISA-nemu</code>会生成Nanos-lite的可执行文件,</li>
</ul>
</li>
</ul>
<h4 id="思考：堆和栈在哪里"><a href="#思考：堆和栈在哪里" class="headerlink" title="思考：堆和栈在哪里?"></a>思考：堆和栈在哪里?</h4><ul>
<li>我们提到了代码和数据都在可执行文件里面, 但却没有提到堆(heap)和栈(stack). 为什么堆和栈的内容没有放入可执行文件里面? 那程序运行时刻用到的堆和栈又是怎么来的? AM的代码是否能给你带来一些启发?</li>
</ul>
<ol>
<li>堆和栈的内容没有放入可执行文件里面的原因如下：<ul>
<li>堆和栈的动态性：<ul>
<li>栈：栈用于存储函数调用的局部变量、函数参数和返回地址等。栈的大小和内容在程序运行时是动态变化的，随着函数的调用和返回，栈上的数据不断变化。</li>
<li>堆：堆用于动态分配内存，程序在运行时可以根据需要分配和释放内存。堆的大小和内容也是动态变化的，取决于程序的运行情况。</li>
</ul>
</li>
<li>可执行文件的静态性：<ul>
<li>可执行文件在编译时生成，包含了程序的代码段和数据段。这些内容在程序运行时是相对固定的，不会像堆和栈那样动态变化。</li>
</ul>
</li>
<li>堆和栈的初始化：<ul>
<li>栈：栈在程序启动时由操作系统或运行时环境初始化。通常，栈的起始地址和大小在程序加载时由操作系统分配。</li>
<li>堆：堆在程序运行时由操作系统或运行时环境管理。程序通过动态内存分配函数（如 malloc、free 等）来请求和释放堆内存。</li>
</ul>
</li>
</ul>
</li>
<li>AM代码的启发：<ul>
<li>AM 的代码中有初始化堆和栈的部分。例如，在操作系统启动时，会设置栈指针（SP）和堆指针（HP），并为它们分配初始内存区域。</li>
</ul>
</li>
</ol>
<h4 id="思考：如何识别不同格式的可执行文件"><a href="#思考：如何识别不同格式的可执行文件" class="headerlink" title="思考：如何识别不同格式的可执行文件?"></a>思考：如何识别不同格式的可执行文件?</h4><ul>
<li>从如果你在GNU&#x2F;Linux下执行一个从Windows拷过来的可执行文件, 将会报告”格式错误”. 思考一下, GNU&#x2F;Linux是如何知道”格式错误”的?</li>
</ul>
<ol>
<li>在 GNU&#x2F;Linux 下，操作系统通过检查可执行文件的文件头（header）来识别不同格式的可执行文件。每种可执行文件格式都有其特定的文件头结构和魔数（magic number），操作系统可以通过这些信息来判断文件的格式是否正确。</li>
<li>以下是一些常见的可执行文件格式及其魔数：<ol>
<li>ELF（Executable and Linkable Format）：<ul>
<li>ELF 是 GNU&#x2F;Linux 系统中常见的可执行文件格式。</li>
<li>ELF 文件的魔数是 0x7F ‘E’ ‘L’ ‘F’，即文件的前四个字节是 0x7F 45 4C 46。</li>
</ul>
</li>
<li>PE（Portable Executable）：<ul>
<li>PE 是 Windows 系统中常见的可执行文件格式。</li>
<li>PE 文件的魔数是 0x4D 5A，即文件的前两个字节是 MZ（DOS MZ 可执行文件标记）。</li>
</ul>
</li>
<li>Mach-O：<ul>
<li>Mach-O 是 macOS 系统中常见的可执行文件格式。</li>
<li>Mach-O 文件的魔数是 0xFEEDFACE 或 0xCAFEBABE，具体取决于文件的字节序。</li>
</ul>
</li>
</ol>
</li>
<li>当你在 GNU&#x2F;Linux 下执行一个从 Windows 拷贝过来的可执行文件时，操作系统会检查文件头的魔数。如果魔数不匹配，操作系统会报告“格式错误”。</li>
</ol>
<h4 id="思考：-冗余的属性"><a href="#思考：-冗余的属性" class="headerlink" title="思考： 冗余的属性?"></a>思考： 冗余的属性?</h4><ul>
<li>使用readelf查看一个ELF文件的信息, 你会看到一个segment包含两个大小的属性, 分别是FileSiz和MemSiz, 这是为什么? 再仔细观察一下, 你会发现FileSiz通常不会大于相应的MemSiz, 这又是为什么?</li>
</ul>
<ol>
<li>FileSiz 和 MemSiz 的含义：<ul>
<li>FileSiz：表示段在文件中的大小。即该段在磁盘上的实际存储大小。</li>
<li>MemSiz：表示段在内存中的大小。即该段在程序加载到内存后占用的大小。</li>
</ul>
</li>
<li>为什么需要两个属性：<ul>
<li>某些段在加载到内存后需要额外的空间来存储运行时数据。例如，BSS 段（未初始化数据段）在文件中可能只占用很小的空间（甚至为零），但在内存中需要分配实际的大小来存储未初始化的全局变量。</li>
<li>通过区分 FileSiz 和 MemSiz，操作系统可以正确地分配内存并初始化段的内容。例如，对于 BSS 段，操作系统会根据 MemSiz 分配内存，并将其内容初始化为零。</li>
</ul>
</li>
<li>为什么 FileSiz 通常不会大于 MemSiz：<ul>
<li>通常情况下，段在文件中的大小不会超过其在内存中的大小，因为文件中的内容是段的实际数据，而内存中的内容可能包含额外的运行时数据。</li>
<li>例如，代码段（text segment）和已初始化数据段（data segment）的 FileSiz 和 MemSiz 通常是相等的，因为它们在文件中和内存中的大小是一致的。</li>
<li>对于 BSS 段，FileSiz 通常为零，而 MemSiz 则表示需要分配的内存大小。</li>
</ul>
</li>
</ol>
<h4 id="思考：为什么要清零"><a href="#思考：为什么要清零" class="headerlink" title="思考：为什么要清零?"></a>思考：为什么要清零?</h4><ul>
<li>为什么需要将 <code>[VirtAddr + FileSiz, VirtAddr + MemSiz)</code> 对应的物理区间清零?</li>
<li>原因：</li>
</ul>
<ol>
<li>未初始化数据段（BSS 段）：<ul>
<li>在 ELF 文件中，BSS 段（未初始化数据段）通常在文件中不占用空间（FileSiz 为 0），但在内存中需要分配实际的大小（MemSiz）。</li>
<li>BSS 段用于存储未初始化的全局变量和静态变量，这些变量在程序启动时默认初始化为零。</li>
<li>因此，需要将 BSS 段对应的内存区域清零，以确保这些变量在程序运行时被正确初始化为零。</li>
</ul>
</li>
<li>安全性和一致性：<ul>
<li>清零内存区域可以防止程序访问未初始化的内存，从而避免潜在的安全漏洞和未定义行为。</li>
<li>确保内存区域的一致性，使得程序在不同环境下运行时具有相同的初始状态。</li>
</ul>
</li>
<li>内存分配的规范：<ul>
<li>根据内存分配的规范，未初始化的数据段在加载到内存时应该被清零。这是操作系统和运行时环境的一部分职责。</li>
</ul>
</li>
</ol>
<h4 id="必做：实现loader"><a href="#必做：实现loader" class="headerlink" title="必做：实现loader"></a>必做：实现loader</h4><ul>
<li>你需要在<code>Nanos-lite</code>中实现loader的功能, 来<strong>把用户程序加载到正确的内存位置, 然后执行用户程序</strong>. <ul>
<li>loader()函数在<code>nanos-lite/src/loader.c</code>中定义, 其中的pcb参数目前暂不使用, 可以忽略, 而因为ramdisk中目前只有一个文件, filename参数也可以忽略. 在下一个阶段实现文件系统之后, filename就派上用场了.</li>
</ul>
</li>
<li>实现后, 在<code>init_proc()</code>中调用<code>naive_uload(NULL, NULL)</code>, 它会调用你实现的loader来加载第一个用户程序, 然后跳转到用户程序中执行. <ul>
<li>如果你的实现正确, 你会看到执行dummy程序时在Nanos-lite中<strong>触发了一个未处理的4号事件</strong>. 这说明loader已经成功加载dummy, 并且成功地跳转到dummy中执行了. 关于未处理的事件, 我们会在下文进行说明.</li>
</ul>
</li>
</ul>
<ol>
<li>在<code>loader.c</code>中：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;loader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ramdisk.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uintptr_t</span> <span class="title function_">loader</span><span class="params">(PCB *pcb, <span class="type">const</span> <span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">  <span class="comment">//TODO();</span></span><br><span class="line">  <span class="comment">//读取elf文件头</span></span><br><span class="line">  Elf_Ehdr ehdr;</span><br><span class="line">  ramdisk_read(&amp;ehdr, <span class="number">0</span>, <span class="keyword">sizeof</span>(Elf_Ehdr));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//读取程序头表</span></span><br><span class="line">  Elf_Phdr phdr[ehdr.e_phnum];</span><br><span class="line">  ramdisk_read(phdr, ehdr.e_phoff, ehdr.e_phnum * <span class="keyword">sizeof</span>(Elf_Phdr));</span><br><span class="line">  <span class="comment">//加载程序段</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ehdr.e_phnum; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (phdr[i].p_type == PT_LOAD) &#123;</span><br><span class="line">      ramdisk_read((<span class="type">void</span> *)phdr[i].p_vaddr, phdr[i].p_offset, phdr[i].p_filesz);</span><br><span class="line">      <span class="comment">//把.bss段初始化为0</span></span><br><span class="line">      <span class="built_in">memset</span>((<span class="type">void</span> *)(phdr[i].p_vaddr + phdr[i].p_filesz), <span class="number">0</span>, phdr[i].p_memsz - phdr[i].p_filesz);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//返回入口地址</span></span><br><span class="line">  <span class="keyword">return</span> ehdr.e_entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>新建loader.h</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">naive_uload</span><span class="params">(PCB *pcb, <span class="type">const</span> <span class="type">char</span> *filename)</span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>新建ramdisk.h</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;common.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">ramdisk_read</span><span class="params">(<span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">ramdisk_write</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_ramdisk</span><span class="params">()</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">get_ramdisk_size</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在proc.c中：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;loader.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_proc</span><span class="params">()</span> &#123;</span><br><span class="line">  switch_boot_pcb();</span><br><span class="line"></span><br><span class="line">  Log(<span class="string">&quot;Initializing processes...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// load program here</span></span><br><span class="line">  naive_uload(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>运行效果：<ul>
<li>出现了<strong>system panic: Unhandled event ID &#x3D; 4</strong>，与文档所说相符合</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[/home/xiaoyao/ics2024/nanos-lite/src/irq.c,8,do_event] system panic: Unhandled event ID = 4</span><br><span class="line">[src/cpu/cpu-exec.c:196 cpu_exec] nemu: HIT BAD TRAP at pc = 0x80000458</span><br><span class="line">[src/cpu/cpu-exec.c:147 statistic] host time spent = 30,635 us</span><br><span class="line">[src/cpu/cpu-exec.c:148 statistic] total guest instructions = 131,423</span><br><span class="line">[src/cpu/cpu-exec.c:149 statistic] simulation frequency = 4,289,962 inst/s</span><br><span class="line">make[1]: *** [/home/xiaoyao/ics2024/nemu/scripts/native.mk:38：run] 错误 1</span><br><span class="line">make[1]: 离开目录“/home/xiaoyao/ics2024/nemu”</span><br><span class="line">make: *** [/home/xiaoyao/ics2024/abstract-machine/scripts/platform/nemu.mk:32：run] 错误 2</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="选做：检查ELF文件的魔数"><a href="#选做：检查ELF文件的魔数" class="headerlink" title="选做：检查ELF文件的魔数"></a>选做：检查ELF文件的魔数</h4><ul>
<li>我们知道ELF文件的开头都有一个特殊的魔数, 为了防止loader加载了一个非ELF格式的文件, 我们可以在loader中对魔数进行检查:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(*(<span class="type">uint32_t</span> *)elf-&gt;e_ident == <span class="number">0xBadC0de</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>你需要把上述的0xBadC0de换成正确的魔数.</li>
<li>别小看这个表面上很蠢的assert(), 当你哪天手抖不知道做了什么而又被它抓到的时候, 你就知道谢天谢地了.</li>
</ul>
<ol>
<li>在loader.c中：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uintptr_t</span> <span class="title function_">loader</span><span class="params">(PCB *pcb, <span class="type">const</span> <span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 检查 ELF 文件头是否合法</span></span><br><span class="line">    assert(*(<span class="type">uint32_t</span> *)ehdr.e_ident == <span class="number">0x464c457f</span>);  <span class="comment">// 正确的 ELF 魔数</span></span><br><span class="line">    <span class="comment">//```</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-操作系统的运行时环境"><a href="#3-操作系统的运行时环境" class="headerlink" title="3. 操作系统的运行时环境"></a>3. 操作系统的运行时环境</h2><h4 id="思考：系统调用的必要性"><a href="#思考：系统调用的必要性" class="headerlink" title="思考：系统调用的必要性"></a>思考：系统调用的必要性</h4><ul>
<li>对于批处理系统来说, 系统调用是必须的吗? 如果直接把AM的API暴露给批处理系统中的程序, 会不会有问题呢?</li>
</ul>
<ol>
<li>对于批处理系统来说，系统调用是必须的。以下是原因和直接暴露 AM（Abstract Machine）API 给批处理系统中的程序可能带来的问题：<ol>
<li>资源管理和保护：<ul>
<li>系统调用：系统调用提供了一种受控的方式来访问系统资源。操作系统可以通过系统调用来管理和保护资源，确保资源的合理分配和使用，防止程序之间的相互干扰。</li>
<li>直接暴露 AM API：如果直接暴露 AM 的 API 给程序，程序可以直接访问硬件资源。这会导致资源管理混乱，程序之间可能会相互干扰，覆盖彼此的内存空间或屏幕内容，导致系统不稳定。</li>
</ul>
</li>
<li>安全性：<ul>
<li>系统调用：系统调用通过特权级别的转换来保护系统资源。用户程序在请求系统资源时，需要通过系统调用进入内核态，由操作系统进行权限检查和资源分配。</li>
<li>直接暴露 AM API：直接暴露 AM API 给程序，程序可以绕过操作系统直接访问硬件资源，可能会导致安全漏洞，恶意程序可以利用这些漏洞破坏系统或窃取敏感信息。</li>
</ul>
</li>
<li>抽象和简化：<ul>
<li>系统调用：系统调用提供了一种抽象的接口，隐藏了底层硬件的复杂性，使得程序员可以更方便地编写应用程序，而不需要关心底层硬件的细节。</li>
<li>直接暴露 AM API：直接暴露 AM API 给程序，程序员需要了解底层硬件的细节，增加了编程的复杂性和出错的可能性。</li>
</ul>
</li>
<li>可移植性：<ul>
<li>系统调用：系统调用提供了一种标准化的接口，使得应用程序可以在不同的硬件平台上运行，只需要操作系统提供相应的系统调用实现。</li>
<li>直接暴露 AM API：直接暴露 AM API 给程序，程序与特定硬件平台紧密耦合，降低了程序的可移植性。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="4-系统调用"><a href="#4-系统调用" class="headerlink" title="4. 系统调用"></a>4. 系统调用</h2><ul>
<li>触发一个系统调用的具体过程是怎么样的呢?</li>
<li>在<code>GNU/Linux</code>中, 用户程序通过<strong>自陷指令</strong>来触发系统调用, <code>Nanos-lite</code>也沿用这个约定</li>
<li>CTE中的<code>yield()</code>也是通过自陷指令来实现</li>
<li>那么对用户程序来说, 用来<em>向操作系统描述需求</em>的最方便手段就是使用<strong>通用寄存器</strong><ul>
<li>执行自陷指令之后, 执行流就会马上切换到<strong>事先设置好的入口</strong>, 通用寄存器也会作为<strong>上下文的一部分被保存</strong>起来</li>
<li><strong>系统调用处理函数</strong>只需要<em>从上下文中获取必要的信息</em>, 就能知道用户程序发出的服务请求是什么了.</li>
</ul>
</li>
<li>Navy已经为用户程序准备好了系统调用的接口了. <code>navy-apps/libs/libos/src/syscall.c</code>中定义的<code>_syscall_()</code>函数已经蕴含着上述过程:<ul>
<li>先把系统调用的参数依次放入寄存器中, 然后执行自陷指令. </li>
<li>由于寄存器和自陷指令都是ISA相关的, 因此这里根据不同的ISA定义了不同的宏, 来对它们进行抽象. </li>
<li>CTE会将这个自陷操作打包成一个系统调用事件EVENT_SYSCALL, 并交由Nanos-lite继续处理.</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">intptr_t</span> _syscall_(<span class="type">intptr_t</span> type, <span class="type">intptr_t</span> a0, <span class="type">intptr_t</span> a1, <span class="type">intptr_t</span> a2) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(SYSCALL : <span class="string">&quot;=r&quot;</span> (ret) : <span class="string">&quot;r&quot;</span>(_gpr1), <span class="string">&quot;r&quot;</span>(_gpr2), <span class="string">&quot;r&quot;</span>(_gpr3), <span class="string">&quot;r&quot;</span>(_gpr4))</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="必做：识别系统调用"><a href="#必做：识别系统调用" class="headerlink" title="必做：识别系统调用"></a>必做：识别系统调用</h4><ul>
<li>目前<code>dummy</code>已经通过<code>_syscall_()</code>直接触发系统调用, 你需要让<code>Nanos-lite</code><strong>识别出系统调用事件EVENT_SYSCALL</strong>.</li>
<li>处理器通常只会提供一条自陷指令, 这时EVENT_SYSCALL和EVENT_YIELD 都通过相同的自陷指令来实现, 因此CTE需要额外的方式区分它们. 如果自陷指令本身可以携带参数, 就可以用不同的参数指示不同的事件, 例如x86和mips32都可以采用这种方式; 如果自陷指令本身不能携带参数, 那就需要通过其他状态来区分, 一种方式是通过某个寄存器的值来区分, riscv32采用这种方式.</li>
<li>你可能需要对多处代码进行修改, 当你为代码无法实现正确而感到疑惑时, 请检查这个过程中的每一个细节. 我们已经强调了很多次, 理解细节是很重要的.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Context* __am_irq_handle(Context *c) &#123;</span><br><span class="line">  <span class="keyword">if</span> (user_handler) &#123;</span><br><span class="line">    Event ev = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">switch</span> (c-&gt;mcause) &#123;</span><br><span class="line">      <span class="comment">//添加对异常号的处理</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">-1</span>:ev.event=EVENT_YIELD;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:<span class="keyword">case</span> <span class="number">1</span>:<span class="keyword">case</span> <span class="number">2</span>:<span class="keyword">case</span> <span class="number">3</span>:<span class="keyword">case</span> <span class="number">4</span>:<span class="keyword">case</span> <span class="number">5</span>:<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:<span class="keyword">case</span> <span class="number">8</span>:<span class="keyword">case</span> <span class="number">9</span>:<span class="keyword">case</span> <span class="number">10</span>:<span class="keyword">case</span> <span class="number">11</span>:<span class="keyword">case</span> <span class="number">12</span>:<span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">14</span>:<span class="keyword">case</span> <span class="number">15</span>:<span class="keyword">case</span> <span class="number">16</span>:<span class="keyword">case</span> <span class="number">17</span>:<span class="keyword">case</span> <span class="number">18</span>:<span class="keyword">case</span> <span class="number">19</span>:ev.event=EVENT_SYSCALL;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>: ev.event = EVENT_ERROR; <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出上下文内容</span></span><br><span class="line">    <span class="comment">// printf(&quot;mcause = %x\n&quot;, c-&gt;mcause);</span></span><br><span class="line">    <span class="comment">// printf(&quot;mstatus = %x\n&quot;, c-&gt;mstatus);</span></span><br><span class="line">    <span class="comment">// printf(&quot;mepc = %x\n&quot;, c-&gt;mepc);</span></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; NR_REGS; i++) &#123;</span></span><br><span class="line">    <span class="comment">//   printf(&quot;gpr[%d] = %x\n&quot;, i, c-&gt;gpr[i]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    c = user_handler(ev, c);</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="必做：实现SYS-yield系统调用"><a href="#必做：实现SYS-yield系统调用" class="headerlink" title="必做：实现SYS_yield系统调用"></a>必做：实现SYS_yield系统调用</h4><ul>
<li>你需要:<ul>
<li>在<code>abstract-machine/am/include/arch/</code>目录下的<strong>相应头文件</strong>中实现正确的<code>GPR?</code>宏, 让它们从上下文c中获得正确的系统调用参数寄存器.</li>
<li>添加<code>SYS_yield</code>系统调用.</li>
<li>设置系统调用的返回值.</li>
</ul>
</li>
<li>重新运行dummy程序, 如果你的实现正确, 你会看到dummy程序又<strong>触发了一个号码为0的系统调用</strong>. 查看<code>nanos-lite/src/syscall.h</code>, 你会发现它是一个<code>SYS_exit</code>系统调用. 这说明之前的<code>SYS_yield</code>已经成功返回, 触发<code>SYS_exit</code>是因为dummy已经执行完毕, 准备退出了.</li>
</ul>
<ol>
<li>在<code>abstract-machine/am/include/arch/</code>目录下的相应头文件就是<code>riscv.h</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPR2 gpr[10] <span class="comment">//a0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPR3 gpr[11] <span class="comment">//a1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPR4 gpr[12] <span class="comment">//a2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPRx gpr[10] <span class="comment">//a0</span></span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>先补充完整syscall.h，再在irq.c中：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;common.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;syscall.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Context* <span class="title function_">do_event</span><span class="params">(Event e, Context* c)</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (e.event) &#123;</span><br><span class="line">    <span class="keyword">case</span> EVENT_YIELD: </span><br><span class="line">      Log(<span class="string">&quot;Yield event happened&quot;</span>); </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> EVENT_SYSCALL: do_syscall(c); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: panic(<span class="string">&quot;Unhandled event ID = %d&quot;</span>, e.event);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_irq</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  Log(<span class="string">&quot;Initializing interrupt![alt text](image-5.png)/exception handler...&quot;</span>);</span><br><span class="line">  cte_init(do_event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在syscall.c中，do_syscall:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_syscall</span><span class="params">(Context *c)</span> &#123;</span><br><span class="line">  <span class="type">uintptr_t</span> a[<span class="number">4</span>];</span><br><span class="line">  a[<span class="number">0</span>] = c-&gt;GPR1; <span class="comment">//a7</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (a[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      yield();</span><br><span class="line">      c-&gt;GPRx = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: panic(<span class="string">&quot;Unhandled syscall ID = %d&quot;</span>, a[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>成功,dummy程序又触发了一个号码为0的系统调用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[/home/xiaoyao/ics2024/nanos-lite/src/syscall.c,12,do_syscall] system panic: Unhandled syscall ID = 0</span><br><span class="line">[src/cpu/cpu-exec.c:196 cpu_exec] nemu: HIT BAD TRAP at pc = 0x800004d8</span><br><span class="line">[src/cpu/cpu-exec.c:147 statistic] host time spent = 19,768 us</span><br><span class="line">[src/cpu/cpu-exec.c:148 statistic] total guest instructions = 132,645</span><br><span class="line">[src/cpu/cpu-exec.c:149 statistic] simulation frequency = 6,710,087 inst/s</span><br><span class="line">make[1]: *** [/home/xiaoyao/ics2024/nemu/scripts/native.mk:38：run] 错误 1</span><br></pre></td></tr></table></figure>
<ul>
<li>查看nanos-lite&#x2F;src&#x2F;syscall.h, 你会发现它是一个SYS_exit系统调用</li>
</ul>
<h4 id="必做：实现SYS-exit系统调用"><a href="#必做：实现SYS-exit系统调用" class="headerlink" title="必做：实现SYS_exit系统调用"></a>必做：实现SYS_exit系统调用</h4><ul>
<li>你需要实现<code>SYS_exit</code>系统调用, 它会接收一个退出状态的参数. 为了方便测试, 我们目前先直接使用这个参数调用<code>halt()</code>. 实现成功后, 再次运行dummy程序, 你会看到HIT GOOD TRAP的信息.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      halt(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>成功！<code>[src/cpu/cpu-exec.c:196 cpu_exec] nemu: HIT GOOD TRAP at pc = 0x800004e4</code></li>
</ul>
<h2 id="5-系统调用的踪迹："><a href="#5-系统调用的踪迹：" class="headerlink" title="5. 系统调用的踪迹："></a>5. 系统调用的踪迹：</h2><h4 id="必做：实现strace"><a href="#必做：实现strace" class="headerlink" title="必做：实现strace"></a>必做：实现strace</h4><h2 id="6-操作系统之上的TRM"><a href="#6-操作系统之上的TRM" class="headerlink" title="6. 操作系统之上的TRM"></a>6. 操作系统之上的TRM</h2><h3 id="标准输出"><a href="#标准输出" class="headerlink" title="标准输出"></a>标准输出</h3><ul>
<li>根据write的函数声明(参考man 2 write), 你需要在do_syscall()中识别出系统调用号是SYS_write之后, 检查fd的值, 如果fd是1或2(分别代表stdout和stderr), 则将buf为首地址的len字节输出到串口(使用putch()即可). 最后还要设置正确的返回值, 否则系统调用的调用者会认为write没有成功执行, 从而进行重试. 至于write系统调用的返回值是什么, 请查阅man 2 write. 另外不要忘记在navy-apps&#x2F;libs&#x2F;libos&#x2F;src&#x2F;syscall.c的_write()中调用系统调用接口函数.</li>
</ul>
<h4 id="必做：在Nanos-lite上运行Hello-world"><a href="#必做：在Nanos-lite上运行Hello-world" class="headerlink" title="必做：在Nanos-lite上运行Hello world"></a>必做：在Nanos-lite上运行Hello world</h4><ul>
<li>Navy中提供了一个<code>hello</code>测试程序(<code>navy-apps/tests/hello</code>), 它首先通过<code>write()</code>来输出一句话, 然后通过<code>printf()</code>来不断输出.</li>
<li>你需要实现<code>write()</code>系统调用, 然后把Nanos-lite上运行的用户程序切换成<code>hello</code>程序来运行.</li>
</ul>
<ol>
<li>在do_syscall中补充+完成FSwrite</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_syscall</span><span class="params">(Context *c)</span> &#123;</span><br><span class="line">  <span class="type">uintptr_t</span> a[<span class="number">4</span>];</span><br><span class="line">  a[<span class="number">0</span>] = c-&gt;GPR1; <span class="comment">//a7</span></span><br><span class="line">  a[<span class="number">1</span>] = c-&gt;GPR2; <span class="comment">//a0</span></span><br><span class="line">  a[<span class="number">2</span>] = c-&gt;GPR3; <span class="comment">//a1</span></span><br><span class="line">  a[<span class="number">3</span>] = c-&gt;GPR4; <span class="comment">//a2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (a[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//exit</span></span><br><span class="line">      halt(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//yield</span></span><br><span class="line">      yield();</span><br><span class="line">      c-&gt;GPRx = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:<span class="comment">//write</span></span><br><span class="line">      c-&gt;GPRx = FSwrite((<span class="type">intptr_t</span> *)a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: panic(<span class="string">&quot;Unhandled syscall ID = %d&quot;</span>, a[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">FSwrite</span><span class="params">(<span class="type">void</span> *buf, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">  <span class="comment">// Log(&quot;FSwrite: buf=%p, count=%d&quot;, buf, count);</span></span><br><span class="line">  <span class="comment">// if (fd == 1 || fd == 2) &#123;//fd是1或2(分别代表stdout和stderr)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">      putch(((<span class="type">char</span> *)buf)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  Log(<span class="string">&quot;FSwrite failed&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>切换成hallo程序</li>
</ol>
<ul>
<li>运行，<code>HIT GOOD TRAP at pc = 0x80000560</code>但是没有正确输出！</li>
<li>没找出问题，先往后看</li>
<li>（实现堆区管理后成功了）</li>
</ul>
<h3 id="堆区管理"><a href="#堆区管理" class="headerlink" title="堆区管理"></a>堆区管理</h3><ul>
<li>调整堆区大小是通过sbrk()库函数来实现的, 它的原型是</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">sbrk</span><span class="params">(<span class="type">intptr_t</span> increment)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="必做：实现堆区管理"><a href="#必做：实现堆区管理" class="headerlink" title="必做：实现堆区管理"></a>必做：实现堆区管理</h4><ul>
<li>根据上述内容在Nanos-lite中实现<code>SYS_brk</code>系统调用, 然后在用户层实现<code>_sbrk()</code>. 你可以通过<code>man 2 sbrk</code>来查阅libc中<code>brk()</code>和<code>sbrk()</code>的行为, 另外通过man 3 end来查阅如何使用_end符号.</li>
<li>需要注意的是, 调试的时候不要在<code>_sbrk()</code>中通过<code>printf()</code>进行输出, 这是因为<code>printf()</code>还是会尝试通过<code>malloc()</code>来申请缓冲区, 最终会再次调用<code>_sbrk()</code>, 造成死递归. 你可以通过<code>sprintf()</code>先把调试信息输出到一个字符串缓冲区中, 然后通过<code>_write()</code>进行输出.</li>
<li>如果你的实现正确, 你可以借助<code>strace</code>看到<code>printf()</code>不再是逐个字符地通过<code>write()</code>进行输出, 而是将格式化完毕的字符串通过一次性进行输出.</li>
</ul>
<ol>
<li>在do_syscall中补充</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">9</span>:<span class="comment">// brk</span></span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        c-&gt;GPRx = program_break;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        program_break = a[<span class="number">1</span>];</span><br><span class="line">        c-&gt;GPRx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在<code>/navy-apps/libs/libos/src/syscall.c</code>中：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> _end;</span><br><span class="line"><span class="type">static</span> <span class="type">intptr_t</span> cur_brk = (<span class="type">intptr_t</span>)&amp;_end;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *_sbrk(<span class="type">intptr_t</span> increment) &#123;</span><br><span class="line">  <span class="comment">// Log(&quot;sbrk&quot;);</span></span><br><span class="line">  <span class="type">intptr_t</span> old_brk = cur_brk;</span><br><span class="line">  <span class="type">intptr_t</span> new_brk = old_brk + increment;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_syscall_(SYS_brk, new_brk, <span class="number">0</span>, <span class="number">0</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Log(&quot;sbrk success&quot;);</span></span><br><span class="line">      cur_brk = new_brk;</span><br><span class="line">      <span class="keyword">return</span> (<span class="type">void</span>*)old_brk;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Log(&quot;sbrk failed&quot;);</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>成功！</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br><span class="line">Hello World from Navy-apps for the 2th time!</span><br><span class="line">Hello World from Navy-apps for the 3th time!</span><br><span class="line">Hello World from Navy-apps for the 4th time!</span><br><span class="line">Hello World from Navy-apps for the 5th time!</span><br><span class="line">Hello World from Navy-apps for the 6th time!</span><br><span class="line">Hello World from Navy-apps for the 7th time!</span><br><span class="line">Hello World from Navy-apps for the 8th time!</span><br><span class="line">Hello World from Navy-apps for the 9th time!</span><br><span class="line">Hello World from Navy-apps for the 10th time!</span><br><span class="line">Hello World from Navy-apps for the 11th time!</span><br><span class="line">Hello World from Navy-apps for the 12th time!</span><br><span class="line">Hello World from Navy-apps for the 13th time!</span><br><span class="line">Hello World from Navy-apps for the 14th time!</span><br><span class="line">Hello World from Navy-apps for the 15th time!</span><br><span class="line">Hello World from Navy-apps for the 16th time!</span><br><span class="line">Hello World from Navy-apps for the 17th time!</span><br><span class="line">Hello World from Navy-apps for the 18th time!</span><br><span class="line">Hello World from Navy-apps for the 19th time!</span><br><span class="line">Hello World from Navy-apps for the 20th time!</span><br><span class="line">Hello World from Navy-apps for the 21th time!</span><br><span class="line">Hello World from Navy-apps for the 22th time!</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h4 id="必答题：hello程序是什么-它从而何来-要到哪里去"><a href="#必答题：hello程序是什么-它从而何来-要到哪里去" class="headerlink" title="必答题：hello程序是什么, 它从而何来, 要到哪里去"></a>必答题：hello程序是什么, 它从而何来, 要到哪里去</h4><p>（见文档最后）</p>
<h4 id="PA3-2结束"><a href="#PA3-2结束" class="headerlink" title="PA3.2结束"></a>PA3.2结束</h4><hr>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="1-简易文件系统"><a href="#1-简易文件系统" class="headerlink" title="1. 简易文件系统"></a>1. 简易文件系统</h2><h4 id="必做：让loader使用文件-实现完整的文件系统"><a href="#必做：让loader使用文件-实现完整的文件系统" class="headerlink" title="必做：让loader使用文件+实现完整的文件系统"></a>必做：让loader使用文件+实现完整的文件系统</h4><ul>
<li>我们之前是让loader来直接调用<code>ramdisk_read()</code>来加载用户程序. ramdisk中的文件数量增加之后, 这种方式就不合适了, 我们首先需要让loader享受到文件系统的便利.</li>
<li>你需要先实现<code>fs_open()</code>, <code>fs_read()</code>和<code>fs_close()</code>, 这样就可以在loader中使用文件名来指定加载的程序了, 例如”&#x2F;bin&#x2F;hello”.</li>
<li>实现之后, 以后更换用户程序只需要修改传入<code>naive_uload()</code>函数的文件名即可.</li>
<li>实现<code>fs_write()</code>和<code>fs_lseek()</code>, 然后运行测试程序<code>navy-apps/tests/file-test</code>. 为了编译它, 你需要把它加到<code>navy-apps/Makefile</code>的TESTS变量中, 这样它最终就会被包含在ramdisk镜像中. 这个测试程序用于进行一些简单的文件读写和定位操作. 如果你的实现正确, 你将会看到程序输出**PASS!!!**的信息.</li>
</ul>
<ol>
<li>补充do_syscall()</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SYS_open:<span class="comment">//open</span></span><br><span class="line">  c-&gt;GPRx = fs_open((<span class="type">const</span> <span class="type">char</span> *)a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SYS_read:<span class="comment">//read</span></span><br><span class="line">  c-&gt;GPRx = fs_read(a[<span class="number">1</span>], (<span class="type">char</span> *)a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SYS_lseek:<span class="comment">//lseek</span></span><br><span class="line">  c-&gt;GPRx = fs_lseek(a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SYS_close:<span class="comment">//close</span></span><br><span class="line">  c-&gt;GPRx = fs_close(a[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>libos：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _open(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> flags, <span class="type">mode_t</span> mode) &#123;</span><br><span class="line">  <span class="keyword">return</span> _syscall_(SYS_open, (<span class="type">intptr_t</span>)path, flags, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _read(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count) &#123;</span><br><span class="line">  <span class="keyword">return</span> _syscall_(SYS_read, fd, (<span class="type">intptr_t</span>)buf, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _close(<span class="type">int</span> fd) &#123;</span><br><span class="line">  <span class="keyword">return</span> _syscall_(SYS_close, fd, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> _lseek(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence) &#123;</span><br><span class="line">  <span class="keyword">return</span> _syscall_(SYS_lseek, fd, offset, whence);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>fs.c</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line">  <span class="type">size_t</span> disk_offset;</span><br><span class="line">  ReadFn read;</span><br><span class="line">  WriteFn write;</span><br><span class="line">  <span class="type">size_t</span> open_offset;</span><br><span class="line">&#125; Finfo;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fs_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">int</span> mode)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; NR_FILES; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(file_table[i].name, pathname) == <span class="number">0</span>) &#123;</span><br><span class="line">      file_table[i].open_offset = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;no such file: %s&quot;</span>, pathname);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fs_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  assert(fd &gt;= <span class="number">0</span> &amp;&amp; fd &lt; NR_FILES);</span><br><span class="line">  <span class="keyword">if</span> (fd == FD_STDIN || fd == FD_STDOUT || fd == FD_STDERR) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Finfo *f = &amp;file_table[fd];</span><br><span class="line">  <span class="type">size_t</span> read_len = len;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;open_offset + len &gt; f-&gt;size) &#123;</span><br><span class="line">    read_len = f-&gt;size - f-&gt;open_offset;</span><br><span class="line">  &#125;</span><br><span class="line">  ramdisk_read(buf, f-&gt;disk_offset + f-&gt;open_offset, read_len);</span><br><span class="line">  f-&gt;open_offset += read_len;</span><br><span class="line">  <span class="keyword">return</span> read_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fs_write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  assert(fd &gt;= <span class="number">0</span> &amp;&amp; fd &lt; NR_FILES);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">1</span> || fd == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      putch(((<span class="type">char</span> *)buf)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Finfo *f = &amp;file_table[fd];</span><br><span class="line">  <span class="type">size_t</span> write_len = len;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;open_offset + len &gt; f-&gt;size) &#123;</span><br><span class="line">    write_len = f-&gt;size - f-&gt;open_offset;</span><br><span class="line">  &#125;</span><br><span class="line">  ramdisk_write(buf, f-&gt;disk_offset + f-&gt;open_offset, write_len);</span><br><span class="line">  f-&gt;open_offset += write_len;</span><br><span class="line">  <span class="keyword">return</span> write_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fs_lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">size_t</span> offset, <span class="type">int</span> whence)</span> &#123;</span><br><span class="line">  assert(fd &gt;= <span class="number">0</span> &amp;&amp; fd &lt; NR_FILES);</span><br><span class="line">  Finfo *f = &amp;file_table[fd];</span><br><span class="line">  <span class="type">size_t</span> new_offset = f-&gt;open_offset;</span><br><span class="line">  <span class="keyword">switch</span> (whence) &#123;</span><br><span class="line">    <span class="keyword">case</span> SEEK_SET: new_offset = offset; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SEEK_CUR: new_offset += offset; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SEEK_END: new_offset = f-&gt;size + offset; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: assert(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (new_offset &gt; f-&gt;size) &#123;</span><br><span class="line">    new_offset = f-&gt;size;</span><br><span class="line">  &#125;</span><br><span class="line">  f-&gt;open_offset = new_offset;</span><br><span class="line">  <span class="keyword">return</span> new_offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fs_close</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">  assert(fd &gt;= <span class="number">0</span> &amp;&amp; fd &lt; NR_FILES);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>loader.c更改：<ul>
<li>ramdisk改成fs</li>
</ul>
</li>
<li>proc.c更改程序</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">naive_uload(<span class="literal">NULL</span>, <span class="string">&quot;/bin/file-test&quot;</span>);</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>makefile添加file-test到TEST</li>
</ol>
<ul>
<li>记得update再run——更新应用程序列表</li>
<li>成功</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PASS!!!</span><br><span class="line">[src/cpu/cpu-exec.c:196 cpu_exec] nemu: HIT GOOD TRAP at pc = 0x80000b30</span><br></pre></td></tr></table></figure>
<h4 id="支持sfs的strace"><a href="#支持sfs的strace" class="headerlink" title="支持sfs的strace"></a>支持sfs的strace</h4><ul>
<li>由于sfs的特性, 打开同一个文件总是会返回相同的文件描述符. 这意味着, 我们可以把strace中的文件描述符直接翻译成文件名, 得到可读性更好的trace信息. 尝试实现这一功能, 它可以为你将来使用strace提供一些便利.</li>
</ul>
<h2 id="2-一切皆文件"><a href="#2-一切皆文件" class="headerlink" title="2. 一切皆文件"></a>2. 一切皆文件</h2><ul>
<li>文件就是字节序列</li>
<li>为不同的事物提供了统一的接口: 我们可以使用文件的接口来操作计算机上的一切, 而不必对它们进行详细的区分</li>
</ul>
<h3 id="虚拟文件系统-VFS"><a href="#虚拟文件系统-VFS" class="headerlink" title="虚拟文件系统 VFS"></a>虚拟文件系统 VFS</h3><ul>
<li>VFS其实是对不同种类的真实文件系统的抽象, 它用一组API来描述了这些真实文件系统的抽象行为, 屏蔽了真实文件系统之间的差异, 上层模块(比如系统调用处理函数)不必关心当前操作的文件具体是什么类型, 只要调用这一组API即可完成相应的文件操作.</li>
<li>有了VFS的概念, 要添加一个真实文件系统就非常容易了: 只要把真实文件系统的访问方式包装成VFS的API, 上层模块无需修改任何代码, 就能支持一个新的真实文件系统了.</li>
<li>在Nanos-lite中, 实现VFS的关键就是<strong>Finfo结构体中的两个读写函数指针</strong>:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> *name;         <span class="comment">// 文件名</span></span><br><span class="line">  <span class="type">size_t</span> size;        <span class="comment">// 文件大小</span></span><br><span class="line">  <span class="type">size_t</span> disk_offset;  <span class="comment">// 文件在ramdisk中的偏移</span></span><br><span class="line">  ReadFn read;        <span class="comment">// 读函数指针</span></span><br><span class="line">  WriteFn write;      <span class="comment">// 写函数指针</span></span><br><span class="line">&#125; Finfo;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中ReadFn和WriteFn分别是两种函数指针, 它们用于指向真正进行读写的函数, 并返回成功读写的字节数. 有了这两个函数指针, 我们只需要<strong>在文件记录表中对不同的文件设置不同的读写函数</strong>, 就可以通过<code>f-&gt;read()</code>和<code>f-&gt;write()</code>的方式来调用具体的读写函数了.</li>
<li>约定, 当上述的函数指针为<strong>NULL</strong>时, 表示相应文件是一个<strong>普通文件</strong>, 通过ramdisk的API来进行文件的读写,</li>
</ul>
<h3 id="操作系统之上的IOE"><a href="#操作系统之上的IOE" class="headerlink" title="操作系统之上的IOE"></a>操作系统之上的IOE</h3><ol>
<li>在Nanos-lite中, stdout和stderr都会输出到串口. 之前你可能会通过判断fd是否为1或2, 来决定<code>sys_write()</code>是否写入到串口</li>
<li>有了VFS, 只需要在<code>nanos-lite/src/device.c</code>中实现<code>serial_write()</code>, 然后在文件记录表中设置相应的写函数, 就可以实现上述功能</li>
<li>由于串口是一个字符设备, 对应的字节序列没有”位置”的概念, 因此<code>serial_write()</code>中的offset参数可以忽略.</li>
<li>另外Nanos-lite也不打算支持stdin的读入, 因此在文件记录表中设置相应的报错函数即可.</li>
</ol>
<h4 id="必做：把串口抽象成文件"><a href="#必做：把串口抽象成文件" class="headerlink" title="必做：把串口抽象成文件"></a>必做：把串口抽象成文件</h4><ul>
<li>根据上述内容, 让VFS支持串口的写入.</li>
</ul>
<ol>
<li>在<code>nanos-lite/src/device.c</code>中实现<code>serial_write()</code>,并在common.h里补充函数原型</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">serial_write</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    putch(((<span class="type">char</span> *)buf)[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在文件记录表中设置相应的写函数:在 <code>nanos-lite/src/fs.c</code> 中，将stdout和stderr的写函数设置为<code>serial_write()</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Finfo file_table[] __attribute__((used)) = &#123;</span><br><span class="line">  [FD_STDIN]  = &#123;<span class="string">&quot;stdin&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, invalid_read, invalid_write&#125;,</span><br><span class="line">  [FD_STDOUT] = &#123;<span class="string">&quot;stdout&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, invalid_read, serial_write&#125;,</span><br><span class="line">  [FD_STDERR] = &#123;<span class="string">&quot;stderr&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, invalid_read, serial_write&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;files.h&quot;</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>修改<code>fs_read()</code>和<code>fs_write()</code>：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//read添加</span></span><br><span class="line"><span class="keyword">if</span> (f-&gt;read) &#123;</span><br><span class="line">    <span class="keyword">return</span> f-&gt;read(buf, f-&gt;open_offset, len);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//write添加</span></span><br><span class="line"><span class="keyword">if</span> (f-&gt;write) &#123;</span><br><span class="line">    <span class="keyword">return</span> f-&gt;write(buf, f-&gt;open_offset, len);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>运行helo来检验：成功！</li>
</ol>
<h4 id="必做：实现gettimeofday"><a href="#必做：实现gettimeofday" class="headerlink" title="必做：实现gettimeofday"></a>必做：实现gettimeofday</h4><ul>
<li>实现gettimeofday系统调用, 这一系统调用的参数含义请RTFM. 实现后, 在navy-apps&#x2F;tests&#x2F;中新增一个timer-test测试, 在测试中通过gettimeofday()获取当前时间, 并每过0.5秒输出一句话.</li>
</ul>
<ol>
<li>实现<code>SYS_gettimeofday</code>系统调用,syscall.c中：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_syscall</span><span class="params">(Context *c)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (a[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> SYS_gettimeofday:</span><br><span class="line">            c-&gt;GPRx = sys_gettimeofday((<span class="keyword">struct</span> timeval *)a[<span class="number">1</span>], (<span class="keyword">struct</span> timezone *)a[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_gettimeofday</span><span class="params">(<span class="keyword">struct</span> timeval *tv, <span class="keyword">struct</span> timezone *tz)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (tv) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> us = io_read(AM_TIMER_UPTIME).us;</span><br><span class="line">    tv-&gt;tv_sec = us / <span class="number">1000000</span>;</span><br><span class="line">    tv-&gt;tv_usec = us % <span class="number">1000000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>libos</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _gettimeofday(<span class="keyword">struct</span> timeval *tv, <span class="keyword">struct</span> timezone *tz) &#123;</span><br><span class="line">  <span class="keyword">return</span> _syscall_(SYS_gettimeofday, (<span class="type">intptr_t</span>)tv, (<span class="type">intptr_t</span>)tz, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>新增<code>timer-test</code>测试程序</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//timer-test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>, <span class="title">start</span>;</span></span><br><span class="line">  gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">long</span> elapsed = (tv.tv_sec - start.tv_sec) * <span class="number">1000000</span> + (tv.tv_usec - start.tv_usec);</span><br><span class="line">    <span class="keyword">if</span> (elapsed &gt;= <span class="number">500000</span>) &#123; <span class="comment">// 0.5 秒</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;0.5 seconds passed\n&quot;</span>);</span><br><span class="line">      start = tv; <span class="comment">// 重置起始时间</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME = timer-test</span><br><span class="line">SRCS = timer-test.c</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(NAVY_HOME)</span>/Makefile</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在 <code>navy-apps/Makefile</code> 中将<code>timer-test</code>添加到TESTS变量中</li>
<li>测试，成功！<br><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-6.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<h4 id="必做：实现NDL的时钟"><a href="#必做：实现NDL的时钟" class="headerlink" title="必做：实现NDL的时钟"></a>必做：实现NDL的时钟</h4><ul>
<li>你需要用<code>gettimeofday()</code>实现<code>NDL_GetTicks()</code>, 然后修改<code>timer-test</code>测试, 让它通过调用<code>NDL_GetTicks()</code>来获取当前时间. 你可以根据需要在<code>NDL_Init()</code>和<code>NDL_Quit()</code>中添加初始化代码和结束代码, 我们约定程序在使用NDL库的功能之前必须先调用<code>NDL_Init()</code>. 如果你认为无需添加初始化代码, 则无需改动它们.</li>
</ul>
<ol>
<li>NDL.c:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">NDL_GetTicks</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">  gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> tv.tv_sec * <span class="number">1000</span> + tv.tv_usec / <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>修改测试</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;NDL.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  NDL_Init(<span class="number">0</span>);  <span class="comment">// 初始化 NDL</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> start = NDL_GetTicks();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">uint32_t</span> current = NDL_GetTicks();</span><br><span class="line">    <span class="keyword">if</span> (current - start &gt;= <span class="number">500</span>) &#123; <span class="comment">// 0.5 秒</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;0.5 seconds passed\n&quot;</span>);</span><br><span class="line">      start = current; <span class="comment">// 重置起始时间</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  NDL_Quit();  <span class="comment">// 结束 NDL</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>timer-test的makefile里添加</li>
</ol>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIBS = libndl</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>运行检验，成功！</li>
</ol>
<h4 id="必做：把按键输入抽象成文件"><a href="#必做：把按键输入抽象成文件" class="headerlink" title="必做：把按键输入抽象成文件"></a>必做：把按键输入抽象成文件</h4><ul>
<li>你需要:<ul>
<li>实现<code>events_read()</code>(在<code>nanos-lite/src/device.c</code>中定义), 把事件写入到buf中, 最长写入len字节, 然后返回写入的实际长度. 其中按键名已经在字符串数组names中定义好了, 你需要借助IOE的API来获得设备的输入. 另外, 若当前没有有效按键, 则返回0即可.</li>
<li>在VFS中添加对<code>/dev/events</code>的支持.</li>
<li>在NDL中实现<code>NDL_PollEvent()</code>, 从<code>/dev/events</code>中读出事件并写入到buf中.</li>
</ul>
</li>
<li>我们可以假设一次最多只会读出一个事件, 这样可以简化你的实现. 实现后, 让Nanos-lite运行<code>navy-apps/tests/event-test</code>, 如果实现正确, 敲击按键时程序会输出按键事件的信息.</li>
</ul>
<ol>
<li>实现 events_read() 函数，将事件写入到 buf 中。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">events_read</span><span class="params">(<span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  AM_INPUT_KEYBRD_T ev=io_read(AM_INPUT_KEYBRD);</span><br><span class="line">  <span class="keyword">if</span> (ev.keycode == AM_KEY_NONE) &#123;</span><br><span class="line">    *(<span class="type">char</span> *)buf = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> n =<span class="built_in">sprintf</span>((<span class="type">char</span> *)buf,<span class="string">&quot;%s %s\n&quot;</span>, ev.keydown ? <span class="string">&quot;keydown&quot;</span> : <span class="string">&quot;keyup&quot;</span>,keyname[ev.keycode]);</span><br><span class="line">  <span class="keyword">return</span> n &lt; len ? n : len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 VFS 中添加对 &#x2F;dev&#x2F;events 的支持。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs.c</span></span><br><span class="line"><span class="type">static</span> Finfo file_table[] __attribute__((used)) = &#123;</span><br><span class="line">  [FD_STDIN]  = &#123;<span class="string">&quot;stdin&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, invalid_read, invalid_write&#125;,</span><br><span class="line">  [FD_STDOUT] = &#123;<span class="string">&quot;stdout&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, invalid_read, serial_write&#125;,</span><br><span class="line">  [FD_STDERR] = &#123;<span class="string">&quot;stderr&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, invalid_read, serial_write&#125;,</span><br><span class="line">  [FD_EVENTS] = &#123;<span class="string">&quot;/dev/events&quot;</span>, <span class="number">0</span>, <span class="number">0</span>,  events_read, invalid_write&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;files.h&quot;</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在 NDL 中实现 NDL_PollEvent()，从 &#x2F;dev&#x2F;events 中读出事件并写入到 buf 中。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">NDL_PollEvent</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/dev/events&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> read(fd, buf, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>改一下，运行event-test</li>
<li>成功！</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">receive event: keydown W</span><br><span class="line"></span><br><span class="line">receive event: keyup W</span><br><span class="line"></span><br><span class="line">receive event: keydown W</span><br><span class="line"></span><br><span class="line">receive event: keyup W</span><br><span class="line"></span><br><span class="line">receive event: keydown E</span><br><span class="line"></span><br><span class="line">receive event: keyup E</span><br><span class="line"></span><br><span class="line">receive event: keydown E</span><br><span class="line"></span><br><span class="line">receive event: keyup E</span><br></pre></td></tr></table></figure>
<h4 id="必做：在NDL中获取屏幕大小"><a href="#必做：在NDL中获取屏幕大小" class="headerlink" title="必做：在NDL中获取屏幕大小"></a>必做：在NDL中获取屏幕大小</h4><ul>
<li>实现<code>dispinfo_read()</code>(在<code>nanos-lite/src/device.c</code>中定义), 按照约定将文件的len字节写到buf中(我们认为这个文件不支持lseek, 可忽略offset).</li>
<li>在NDL中读出这个文件的内容, 从中解析出屏幕大小, 然后实现<code>NDL_OpenCanvas()</code>的功能. 目前<code>NDL_OpenCanvas()</code>只需要记录画布的大小就可以了, 当然我们要求画布大小不能超过屏幕大小.</li>
<li>让Nanos-lite运行<code>navy-apps/tests/bmp-test</code>, 由于目前还没有实现绘图功能, 因此无法输出图像内容, 但你可以先通过<code>printf()</code>输出解析出的屏幕大小.</li>
</ul>
<ol>
<li>实现 <code>dispinfo_read()</code> 函数，按照约定将文件的内容写到 buf 中。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">dispinfo_read</span><span class="params">(<span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  <span class="type">int</span> width = io_read(AM_GPU_CONFIG).width;</span><br><span class="line">  <span class="type">int</span> height = io_read(AM_GPU_CONFIG).height;</span><br><span class="line">  <span class="type">int</span> n = <span class="built_in">sprintf</span>(buf, <span class="string">&quot;WIDTH : %d\nHEIGHT : %d\n&quot;</span>, width, height);</span><br><span class="line">  <span class="keyword">return</span> n &lt; len ? n : len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>fs.c</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[FD_DISP] = &#123;<span class="string">&quot;/proc/dispinfo&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, dispinfo_read, invalid_write&#125;,</span><br><span class="line">[FD_FB] = &#123;<span class="string">&quot;/dev/fb&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, invalid_read, fb_write&#125;,</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在 NDL 中读出 <code>/proc/dispinfo</code> 文件的内容，从中解析出屏幕大小。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">NDL_Init</span><span class="params">(<span class="type">uint32_t</span> flags)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/dispinfo&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;WIDTH : %d\nHEIGHT : %d\n&quot;</span>, &amp;screen_w, &amp;screen_h);</span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;NWM_APP&quot;</span>)) &#123;</span><br><span class="line">    evtdev = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>实现 <code>NDL_OpenCanvas()</code> 的功能，记录画布的大小</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NDL_OpenCanvas</span><span class="params">(<span class="type">int</span> *w, <span class="type">int</span> *h)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;NWM_APP&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">int</span> fbctl = <span class="number">4</span>;</span><br><span class="line">    fbdev = <span class="number">5</span>;</span><br><span class="line">    screen_w = *w; screen_h = *h;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d %d&quot;</span>, screen_w, screen_h);</span><br><span class="line">    <span class="comment">// let NWM resize the window and create the frame buffer</span></span><br><span class="line">    write(fbctl, buf, len);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 3 = evtdev</span></span><br><span class="line">      <span class="type">int</span> nread = read(<span class="number">3</span>, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (nread &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      buf[nread] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, <span class="string">&quot;mmap ok&quot;</span>) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fbctl);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>实现 <code>NDL_DrawRect()</code> 的功能，向画布 (x, y) 坐标处绘制 w*h 的矩形图像</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NDL_DrawRect</span><span class="params">(<span class="type">uint32_t</span> *pixels, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/dev/fb&quot;</span>, O_WRONLY);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">    lseek(fd, ((y + i) * screen_w + x) * <span class="number">4</span>, SEEK_SET);</span><br><span class="line">    write(fd, pixels + i * w, w * <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="必做：把VGA显存抽象成文件"><a href="#必做：把VGA显存抽象成文件" class="headerlink" title="必做：把VGA显存抽象成文件"></a>必做：把VGA显存抽象成文件</h4><ul>
<li>在<code>init_fs()</code>(在<code>nanos-lite/src/fs.c</code>中定义)中对文件记录表中<code>/dev/fb</code>的大小进行初始化.</li>
<li>实现<code>fb_write()</code>(在<code>nanos-lite/src/device.c</code>中定义), 用于把buf中的len字节写到屏幕上offset处. 你需要先从offset计算出屏幕上的坐标, 然后调用IOE来进行绘图. 另外我们约定每次绘图后总是马上将frame buffer中的内容同步到屏幕上.</li>
<li>在NDL中实现<code>NDL_DrawRect()</code>, 通过往&#x2F;dev&#x2F;fb中的正确位置写入像素信息来绘制图像. 你需要梳理清楚系统屏幕(即frame buffer), <code>NDL_OpenCanvas()</code>打开的画布, 以及<code>NDL_DrawRect()</code>指示的绘制区域之间的位置关系.</li>
<li>让Nanos-lite运行<code>navy-apps/tests/bmp-test</code>, 如果实现正确, 你将会看到屏幕上显示Project-N的logo.</li>
</ul>
<ol>
<li><code>nanos-lite/src/fs.c</code> 中的 <code>init_fs()</code> 函数中对 <code>/dev/fb</code> 的大小进行初始化：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_fs</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> initialize the size of /dev/fb</span></span><br><span class="line">  <span class="comment">// 获取屏幕大小</span></span><br><span class="line">  <span class="type">int</span> width = io_read(AM_GPU_CONFIG).width;</span><br><span class="line">  <span class="type">int</span> height = io_read(AM_GPU_CONFIG).height;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 /dev/fb 的大小</span></span><br><span class="line">  file_table[FD_FB].size = width * height * <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在 <code>nanos-lite/src/device.c</code> 中实现 <code>fb_write()</code> 函数：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fb_write</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  <span class="type">int</span> width = io_read(AM_GPU_CONFIG).width;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算起始坐标</span></span><br><span class="line">  <span class="type">int</span> x = (offset / <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>)) % width;</span><br><span class="line">  <span class="type">int</span> y = (offset / <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>)) / width;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算写入的像素数</span></span><br><span class="line">  <span class="type">int</span> pixels = len / <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 IOE 绘图</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pixels; i++) &#123;</span><br><span class="line">    <span class="type">int</span> px = (x + i) % width;</span><br><span class="line">    <span class="type">int</span> py = y + (x + i) / width;</span><br><span class="line">    <span class="type">uint32_t</span> pixel = ((<span class="type">uint32_t</span> *)buf)[i];</span><br><span class="line">    io_write(AM_GPU_FBDRAW, px, py, &amp;pixel, <span class="number">1</span>, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在 <code>navy-apps/libs/libndl/NDL.c</code> 中实现 <code>NDL_DrawRect()</code> 函数：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NDL_DrawRect</span><span class="params">(<span class="type">uint32_t</span> *pixels, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/dev/fb&quot;</span>, O_WRONLY);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">    lseek(fd, ((y + i) * screen_w + x) * <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>), SEEK_SET);</span><br><span class="line">    write(fd, pixels + i * w, w * <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>成功！<br><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-7.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<hr>
<h1 id="精彩纷呈的应用程序"><a href="#精彩纷呈的应用程序" class="headerlink" title="精彩纷呈的应用程序"></a>精彩纷呈的应用程序</h1><h2 id="1-更丰富的运行时环境"><a href="#1-更丰富的运行时环境" class="headerlink" title="1. 更丰富的运行时环境"></a>1. 更丰富的运行时环境</h2><h3 id="多媒体库"><a href="#多媒体库" class="headerlink" title="多媒体库"></a>多媒体库</h3><ul>
<li>miniSDL的代码位于<code>navy-apps/libs/libminiSDL/</code>目录下, 它由6个模块组成:<ul>
<li>timer.c: 时钟管理</li>
<li>event.c: 事件处理</li>
<li>video.c: 绘图接口</li>
<li>file.c: 文件抽象</li>
<li>audio.c: 音频播放</li>
<li>general.c: 常规功能, 包括初始化, 错误管理等</li>
</ul>
</li>
</ul>
<h3 id="定点算术"><a href="#定点算术" class="headerlink" title="定点算术"></a>定点算术</h3><ul>
<li>定点数也可以实现实数!,而且定点数的运算可以通过整数运算来实现, 意味着我们可以通过整数运算指令来实现实数的逻辑, 而无需在硬件上引入FPU来运行这些程序. 这样的一个算术体系称为<strong>定点算术</strong>.</li>
<li>Navy中提供了一个fixedptc的库, 专门用于进行定点算术. fixedptc库默认采用32位整数来表示实数, 其具体格式为”24.8” (见<code>navy-apps/libs/libfixedptc/include/fixedptc.h</code>), 表示整数部分占24位, 小数部分占8位, 也可以认为实数的小数点总是固定位于第8位二进制数的左边.</li>
<li>fixedpt类型的常见运算<ul>
<li>加法可以直接用整数加法来进行</li>
<li>减法可以用整数减法来进行</li>
<li>乘法，相乘后将结果除以2^8</li>
<li>除法，结果再乘以2^8</li>
<li>关系运算，都可以用整数的关系运算来进行</li>
</ul>
</li>
</ul>
<h4 id="必做：实现更多的fixedptc-API"><a href="#必做：实现更多的fixedptc-API" class="headerlink" title="必做：实现更多的fixedptc API"></a>必做：实现更多的fixedptc API</h4><ul>
<li>为了让大家更好地理解定点数的表示, 我们在<code>fixedptc.h</code>中<strong>去掉了一些API的实现, 你需要实现它们</strong>. </li>
<li>关于<code>fixedpt_floor()</code>和<code>fixedpt_ceil()</code>, 你需要严格按照man中<code>floor()</code>和<code>ceil()</code>的语义来实现它们, 否则在程序中用<code>fixedpt_floor()</code>代替<code>floor()</code>之后行为会产生差异, 在类似仙剑奇侠传这种规模较大的程序中, 这种差异导致的现象是非常难以理解的. 因此你也最好自己编写一些测试用例来测试你的实现.</li>
</ul>
<ol>
<li>补充</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Multiplies a fixedpt number with an integer, returns the result. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_muli</span><span class="params">(fixedpt A, <span class="type">int</span> B)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> A * B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Divides a fixedpt number with an integer, returns the result. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_divi</span><span class="params">(fixedpt A, <span class="type">int</span> B)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> A / B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multiplies two fixedpt numbers, returns the result. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_mul</span><span class="params">(fixedpt A, fixedpt B)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (A * B) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Divides two fixedpt numbers, returns the result. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_div</span><span class="params">(fixedpt A, fixedpt B)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (A / B) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_abs</span><span class="params">(fixedpt A)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> A &lt; <span class="number">0</span> ? -A : A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_floor</span><span class="params">(fixedpt A)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> A &amp; ~FIXEDPT_FMASK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_ceil</span><span class="params">(fixedpt A)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (A &amp; FIXEDPT_FMASK) ? (A &amp; ~FIXEDPT_FMASK) + FIXEDPT_ONE : A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>编写测试用例</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../libs/libfixedptc/include/fixedptc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_fixedpt_floor</span><span class="params">()</span> &#123;</span><br><span class="line">    fixedpt a = fixedpt_rconst(<span class="number">1.2</span>);</span><br><span class="line">    fixedpt b = fixedpt_rconst(<span class="number">-1.2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fixedpt_floor(1.2) = %d\n&quot;</span>, fixedpt_floor(a) &gt;&gt; FIXEDPT_FBITS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fixedpt_floor(-1.2) = %d\n&quot;</span>, fixedpt_floor(b) &gt;&gt; FIXEDPT_FBITS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_fixedpt_ceil</span><span class="params">()</span> &#123;</span><br><span class="line">    fixedpt a = fixedpt_rconst(<span class="number">1.2</span>);</span><br><span class="line">    fixedpt b = fixedpt_rconst(<span class="number">-1.2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fixedpt_ceil(1.2) = %d\n&quot;</span>, fixedpt_ceil(a) &gt;&gt; FIXEDPT_FBITS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fixedpt_ceil(-1.2) = %d\n&quot;</span>, fixedpt_ceil(b) &gt;&gt; FIXEDPT_FBITS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_fixedpt_abs</span><span class="params">()</span> &#123;</span><br><span class="line">    fixedpt b = fixedpt_rconst(<span class="number">-1.2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fixedpt_abs(-1.2) = %d\n&quot;</span>, fixedpt_abs(b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_fixedpt_muli</span><span class="params">()</span> &#123;</span><br><span class="line">    fixedpt a = fixedpt_rconst(<span class="number">1.2</span>);</span><br><span class="line">    <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fixedpt_muli(1.2, 3) = %d\n&quot;</span>, fixedpt_muli(a, c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_fixedpt_divi</span><span class="params">()</span> &#123;</span><br><span class="line">    fixedpt a = fixedpt_rconst(<span class="number">1.2</span>);</span><br><span class="line">    <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fixedpt_divi(1.2, 3) = %d\n&quot;</span>, fixedpt_divi(a, c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_fixedpt_mul</span><span class="params">()</span> &#123;</span><br><span class="line">    fixedpt a = fixedpt_rconst(<span class="number">1.2</span>);</span><br><span class="line">    fixedpt b = fixedpt_rconst(<span class="number">-1.2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fixedpt_mul(1.2, -1.2) = %d\n&quot;</span>, fixedpt_mul(a, b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_fixedpt_div</span><span class="params">()</span> &#123;</span><br><span class="line">    fixedpt a = fixedpt_rconst(<span class="number">1.2</span>);</span><br><span class="line">    fixedpt b = fixedpt_rconst(<span class="number">-1.2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fixedpt_div(1.2, -1.2) = %d\n&quot;</span>, fixedpt_div(a, b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    test_fixedpt_floor();</span><br><span class="line">    test_fixedpt_ceil();</span><br><span class="line">    test_fixedpt_abs();</span><br><span class="line">    test_fixedpt_muli();</span><br><span class="line">    test_fixedpt_divi();</span><br><span class="line">    test_fixedpt_mul();</span><br><span class="line">    test_fixedpt_div();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0xfffffe00 = %d\n&quot;</span>, <span class="number">0xfffffe00</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>测试结果,正确</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fixedpt_floor(1.2) = 1</span><br><span class="line">fixedpt_floor(-1.2) = -2</span><br><span class="line">fixedpt_ceil(1.2) = 2</span><br><span class="line">fixedpt_ceil(-1.2) = -1</span><br><span class="line">fixedpt_abs(-1.2) = 307</span><br><span class="line">fixedpt_muli(1.2, 3) = 921</span><br><span class="line">fixedpt_divi(1.2, 3) = 102</span><br><span class="line">fixedpt_mul(1.2, -1.2) = -369</span><br><span class="line">fixedpt_div(1.2, -1.2) = -256</span><br><span class="line">0xfffffe00 = -512</span><br></pre></td></tr></table></figure>
<h3 id="Navy作为基础设施"><a href="#Navy作为基础设施" class="headerlink" title="Navy作为基础设施"></a>Navy作为基础设施</h3><ul>
<li>你可以在bmp-test所在的目录下运行<code>make ISA=native run</code>, 来把bmp-test编译到Navy native上并直接运行, 还可以通过<code>make ISA=native gdb</code>对它进行调试. 这样你就可以在Linux native的环境下单独测试Navy中除了libos和Newlib之外的所有代码了(例如NDL和miniSDL). 一个例外是Navy中的dummy, 由于它通过_syscall_()直接触发系统调用, 这样的代码并不能直接在Linux native上直接运行, 因为Linux不存在这个系统调用(或者编号不同).</li>
</ul>
<h2 id="2-Navy中的应用程序"><a href="#2-Navy中的应用程序" class="headerlink" title="2. Navy中的应用程序"></a>2. Navy中的应用程序</h2><h3 id="NSlider-NJU-Slider"><a href="#NSlider-NJU-Slider" class="headerlink" title="NSlider (NJU Slider)"></a>NSlider (NJU Slider)</h3><ul>
<li>一个支持翻页的幻灯片播放器</li>
<li>需要实现以下两个与Surface相关的API:<ul>
<li><code>SDL_BlitSurface()</code>: 将一张画布中的指定矩形区域复制到另一张画布的指定位置</li>
<li><code>SDL_UpdateRect()</code>: 将画布中的指定矩形区域同步到屏幕上</li>
</ul>
</li>
</ul>
<h4 id="必做：运行NSlider"><a href="#必做：运行NSlider" class="headerlink" title="必做：运行NSlider"></a>必做：运行NSlider</h4><ul>
<li>我们提供了一个脚本来把PDF版本的, 比例为4:3的幻灯片转换成BMP图像, 并拷贝到<code>navy-apps/fsimg/</code>中. 你需要提供一个满足条件的PDF文件, 然后参考相应的README文件进行操作. 但你可能会在转换时遇到一些问题, 具体请自行解决.</li>
<li>然后在miniSDL中实现<code>SDL_BlitSurface()</code>和<code>SDL_UpdateRect()</code>. 如果你的实现正确, 运行NSlider时将会显示第一张幻灯片. 你很可能是第一次接触SDL的API, 为此你还需要RTFM, 并通过RTFSC来理解已有代码的行为.</li>
</ul>
<ol>
<li><code>SDL_BlitSurface()</code>用于将一张画布中的指定矩形区域复制到另一张画布的指定位置。我们需要确保源画布和目标画布的像素格式相同。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SDL_BlitSurface</span><span class="params">(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect)</span> &#123;</span><br><span class="line">  assert(dst &amp;&amp; src);</span><br><span class="line">  assert(dst-&gt;format-&gt;BitsPerPixel == src-&gt;format-&gt;BitsPerPixel);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> src_x = srcrect ? srcrect-&gt;x : <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> src_y = srcrect ? srcrect-&gt;y : <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> src_w = srcrect ? srcrect-&gt;w : src-&gt;w;</span><br><span class="line">  <span class="type">int</span> src_h = srcrect ? srcrect-&gt;h : src-&gt;h;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> dst_x = dstrect ? dstrect-&gt;x : <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> dst_y = dstrect ? dstrect-&gt;y : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; src_h; y++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; src_w; x++) &#123;</span><br><span class="line">      <span class="type">int</span> src_index = (src_y + y) * src-&gt;pitch + (src_x + x) * src-&gt;format-&gt;BytesPerPixel;</span><br><span class="line">      <span class="type">int</span> dst_index = (dst_y + y) * dst-&gt;pitch + (dst_x + x) * dst-&gt;format-&gt;BytesPerPixel;</span><br><span class="line">      <span class="built_in">memcpy</span>((<span class="type">uint8_t</span> *)dst-&gt;pixels + dst_index, (<span class="type">uint8_t</span> *)src-&gt;pixels + src_index, src-&gt;format-&gt;BytesPerPixel);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>SDL_UpdateRect()</code>用于将画布中的指定矩形区域同步到屏幕上。我们需要调用 <code>NDL_DrawRect()</code>来实现这一功能。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SDL_UpdateRect</span><span class="params">(SDL_Surface *s, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (w == <span class="number">0</span>) w = s-&gt;w;</span><br><span class="line">  <span class="keyword">if</span> (h == <span class="number">0</span>) h = s-&gt;h;</span><br><span class="line">  NDL_DrawRect((<span class="type">uint32_t</span> *)s-&gt;pixels, x, y, w, h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>查看nslider的readme<ul>
<li>将 slides.pdf 复制到 <code>slides/</code> 目录</li>
<li>运行 <code>convert.sh</code></li>
<li>修改 <code>src/main.cpp</code> 中的变量 <code>N</code> 为幻灯片的总数</li>
</ul>
</li>
<li>记得app：nslider</li>
</ol>
<h4 id="必做：运行NSlider-2"><a href="#必做：运行NSlider-2" class="headerlink" title="必做：运行NSlider(2)"></a>必做：运行NSlider(2)</h4><ul>
<li>在miniSDL中实现<code>SDL_WaitEvent()</code>, 它用于等待一个事件. 你需要将NDL中提供的事件封装成SDL事件返回给应用程序, 具体可以通过阅读NSlider的代码来理解SDL事件的格式. 实现正确后, 你就可以在NSlider中进行翻页了, 翻页的操作方式请RTFSC.</li>
</ul>
<ol>
<li>debug好久才发现是最后的\n没去掉！！！</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//event.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">SDL_WaitEvent</span><span class="params">(SDL_Event *event)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">  <span class="keyword">while</span> (NDL_PollEvent(buf, <span class="keyword">sizeof</span>(buf)) == <span class="number">0</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析事件</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buf, <span class="string">&quot;keydown &quot;</span>, <span class="number">8</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    event-&gt;type = SDL_KEYDOWN;</span><br><span class="line">      <span class="comment">// 调试输出</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;SDL Received event: %s\n&quot;</span>, buf);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buf, <span class="string">&quot;keyup &quot;</span>, <span class="number">6</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    event-&gt;type = SDL_KEYUP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取按键名称</span></span><br><span class="line">  <span class="type">char</span> *key = buf + (event-&gt;type == SDL_KEYDOWN ? <span class="number">8</span> : <span class="number">6</span>);</span><br><span class="line">  key = strtok(key,<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(keyname) / <span class="keyword">sizeof</span>(keyname[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(key, keyname[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">      event-&gt;key.keysym.sym = i;</span><br><span class="line">      <span class="comment">// 调试输出</span></span><br><span class="line">      <span class="comment">// printf(&quot;Parsed key: %s, keycode: %d\n&quot;, key, i);</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Unknown key: %s&quot;</span>, key);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>成功<br><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-9.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-8.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="MENU-开机菜单"><a href="#MENU-开机菜单" class="headerlink" title="MENU (开机菜单)"></a>MENU (开机菜单)</h3><ul>
<li>开机菜单是另一个行为比较简单的程序, 它会展示一个菜单, 用户可以选择运行哪一个程序. 为了运行它, 你还需要在miniSDL中实现<code>SDL_FillRect()</code>, 它用于往画布的指定矩形区域中填充指定的颜色.</li>
<li>开机菜单还会显示一些英文字体, 这些字体的信息以BDF格式存储, Navy中提供了一个libbdf库来解析BDF格式, 生成相应字符的像素信息, 并封装成SDL的Surface. 有了<code>SDL_BlitSurface()</code>之后, 我们就可以很方便地在屏幕上输出字符串的像素信息了.</li>
</ul>
<h4 id="必做：运行开机菜单"><a href="#必做：运行开机菜单" class="headerlink" title="必做：运行开机菜单"></a>必做：运行开机菜单</h4><ul>
<li>正确实现上述API后, 你将会看到一个可以翻页的开机菜单. 但你尝试选择菜单项的时候将会出现错误, 这是因为开机菜单的运行还需要一些系统调用的支持. 我们会在下文进行介绍, 目前通过开机菜单来测试miniSDL即可.</li>
</ul>
<ol>
<li>SDL_FillRect</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SDL_FillRect</span><span class="params">(SDL_Surface *dst, SDL_Rect *dstrect, <span class="type">uint32_t</span> color)</span> &#123;</span><br><span class="line">  assert(dst);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> x = dstrect ? dstrect-&gt;x : <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> y = dstrect ? dstrect-&gt;y : <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> w = dstrect ? dstrect-&gt;w : dst-&gt;w;</span><br><span class="line">  <span class="type">int</span> h = dstrect ? dstrect-&gt;h : dst-&gt;h;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">      <span class="type">int</span> index = (y + i) * dst-&gt;pitch + (x + j) * dst-&gt;format-&gt;BytesPerPixel;</span><br><span class="line">      <span class="built_in">memcpy</span>((<span class="type">uint8_t</span> *)dst-&gt;pixels + index, &amp;color, dst-&gt;format-&gt;BytesPerPixel);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>debug非常痛苦最后发现是<code>NDL_OpenCanvas</code>,</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (*w == <span class="number">0</span> &amp;&amp; *h == <span class="number">0</span>) &#123;</span><br><span class="line">  *w = screen_w;</span><br><span class="line">  *h = screen_h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>应该放在循环外</li>
</ul>
<ol start="3">
<li>终于成功TAT<br><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-11.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<h3 id="NTerm-NJU-Terminal"><a href="#NTerm-NJU-Terminal" class="headerlink" title="NTerm (NJU Terminal)"></a>NTerm (NJU Terminal)</h3><ul>
<li>NTerm是一个模拟终端, 它实现了终端的基本功能, 包括字符的键入和回退, 以及命令的获取等. 终端一般会和Shell配合使用, 从终端获取到的命令将会传递给Shell进行处理, Shell又会把信息输出到终端. NTerm自带一个非常简单的內建Shell(见<code>builtin-sh.cpp</code>), 它默认忽略所有的命令. NTerm也可以和外部程序进行通信, 但这超出了ICS的范围, 我们在PA中不会使用这个功能.</li>
<li>为了运行NTerm, 你还需要实现miniSDL的两个API:<ul>
<li><code>SDL_GetTicks()</code>: 它和<code>NDL_GetTicks()</code>的功能类似, 但有一个额外的小要求, 具体请RTFM</li>
<li><code>SDL_PollEvent()</code>: 它和<code>SDL_WaitEvent()</code>不同的是, 如果当前没有任何事件, 就会立即返回</li>
</ul>
</li>
</ul>
<h4 id="必做：运行NTerm"><a href="#必做：运行NTerm" class="headerlink" title="必做：运行NTerm"></a>必做：运行NTerm</h4><ul>
<li>正确实现上述API后, 你会看到NTerm的光标以每秒一次的频率闪烁, 并且可以键入字符. 为了让NTerm可以启动其它程序, 你还需要实现一些系统调用, 我们会在下文进行介绍.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> start_ticks = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">SDL_GetTicks</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (start_ticks == <span class="number">0</span>) &#123;</span><br><span class="line">    start_ticks = NDL_GetTicks();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> NDL_GetTicks() - start_ticks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SDL_PollEvent</span><span class="params">(SDL_Event *event)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">  <span class="keyword">if</span> (NDL_PollEvent(buf, <span class="keyword">sizeof</span>(buf)) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 没有事件</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析事件</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buf, <span class="string">&quot;keydown &quot;</span>, <span class="number">8</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    event-&gt;type = SDL_KEYDOWN;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SDL Received event: %s\n&quot;</span>, buf); <span class="comment">// 调试输出</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buf, <span class="string">&quot;keyup &quot;</span>, <span class="number">6</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    event-&gt;type = SDL_KEYUP;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 未知事件</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取按键名称</span></span><br><span class="line">  <span class="type">char</span> *key = buf + (event-&gt;type == SDL_KEYDOWN ? <span class="number">8</span> : <span class="number">6</span>);</span><br><span class="line">  key = strtok(key, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(keyname) / <span class="keyword">sizeof</span>(keyname[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(key, keyname[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">      event-&gt;key.keysym.sym = i;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Unknown key: %s\n&quot;</span>, key);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>成功！<br><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-10.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="Flappy-Bird"><a href="#Flappy-Bird" class="headerlink" title="Flappy Bird"></a>Flappy Bird</h3><ol>
<li>在<code>navy-apps/apps/bird/</code>目录下运行<code>make init</code>, 将会从github上克隆移植后的项目</li>
<li>为了在Navy中运行<code>Flappy Bird</code>, 你还需要实现另一个库SDL_image中的一个API: <code>IMG_Load()</code></li>
</ol>
<h4 id="必做：运行Flappy-Bird"><a href="#必做：运行Flappy-Bird" class="headerlink" title="必做：运行Flappy Bird"></a>必做：运行Flappy Bird</h4><ul>
<li>实现<code>IMG_Load()</code>, 在Navy中运行Flappy Bird. 这本质上是一个文件操作的练习. 另外, Flappy Bird<strong>默认使用400像素的屏幕高度</strong>, 但NEMU的屏幕高度默认为300像素, 为了在NEMU运行Flappy Bird, 你需要将<code>navy-apps/apps/bird/repo/include/Video.h</code>中的 <strong>SCREEN_HEIGHT修改为300</strong>.</li>
<li>Flappy Bird默认还会尝试打开声卡播放音效, miniSDL默认会让音频相关的API返回0或NULL, 程序会认为相应操作失败, 但仍然可以在无音效的情况下运行.</li>
</ul>
<ol>
<li>在对应目录下克隆</li>
</ol>
<h3 id="PAL（仙剑奇侠传）"><a href="#PAL（仙剑奇侠传）" class="headerlink" title="PAL（仙剑奇侠传）"></a>PAL（仙剑奇侠传）</h3><ol>
<li>在<code>navy-apps/apps/pal/</code>目录下运行<code>make init</code>, 将会从github上克隆移植后的项目.</li>
</ol>
<h4 id="必做：运行仙剑奇侠传"><a href="#必做：运行仙剑奇侠传" class="headerlink" title="必做：运行仙剑奇侠传"></a>必做：运行仙剑奇侠传</h4><ul>
<li>为miniSDL中的<strong>绘图API添加8位像素格式的支持</strong>. 实现正确之后, 你就可以看到游戏画面了. 为了操作, 你还需要实现其它的API, 具体要实现哪些API, 就交给你来寻找吧. 实现正确后, 你就可以在自己实现的NEMU中运行仙剑奇侠传了! </li>
<li>你可以在游戏中进行各种操作来对你的实现进行测试, 我们提供的数据文件中包含一些游戏存档, 5个存档中的场景分别如下, 可用于进行不同的测试:<ul>
<li>无敌人的机关迷宫</li>
<li>无动画的剧情</li>
<li>有动画的剧情</li>
<li>已进入敌人视野的迷宫</li>
<li>未进入敌人视野的迷宫</li>
</ul>
</li>
</ul>
<ol>
<li>为miniSDL中的*<em>绘图API添加8位像素格式的支持</em></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以及SDL_BlitSurface</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SDL_FillRect</span><span class="params">(SDL_Surface *dst, SDL_Rect *dstrect, <span class="type">uint32_t</span> color)</span> &#123;</span><br><span class="line">  assert(dst);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> x = dstrect ? dstrect-&gt;x : <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> y = dstrect ? dstrect-&gt;y : <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> w = dstrect ? dstrect-&gt;w : dst-&gt;w;</span><br><span class="line">  <span class="type">int</span> h = dstrect ? dstrect-&gt;h : dst-&gt;h;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (w &lt;= <span class="number">0</span> || h &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dst-&gt;format-&gt;BitsPerPixel == <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="type">uint8_t</span> *pixels = (<span class="type">uint8_t</span> *)dst-&gt;pixels;</span><br><span class="line">    <span class="type">uint8_t</span> palette_index = (<span class="type">uint8_t</span>)color; <span class="comment">// Assuming color is the palette index</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">        pixels[(y + i) * dst-&gt;w + (x + j)] = palette_index;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dst-&gt;format-&gt;BytesPerPixel == <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="type">uint32_t</span> *pixels = (<span class="type">uint32_t</span> *)dst-&gt;pixels;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">        pixels[(y + i) * dst-&gt;w + (x + j)] = color;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SDL_UpdateRect</span><span class="params">(SDL_Surface *s, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (w == <span class="number">0</span>) w = s-&gt;w;</span><br><span class="line">  <span class="keyword">if</span> (h == <span class="number">0</span>) h = s-&gt;h;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s-&gt;format-&gt;BitsPerPixel == <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="comment">// 8位像素格式，需要转换为32位颜色格式</span></span><br><span class="line">    <span class="type">uint32_t</span> *converted_pixels = (<span class="type">uint32_t</span> *)<span class="built_in">malloc</span>(w * h * <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> *src_pixels = (<span class="type">uint8_t</span> *)s-&gt;pixels;</span><br><span class="line">    SDL_Color *palette = s-&gt;format-&gt;palette-&gt;colors;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">        <span class="type">uint8_t</span> index = src_pixels[(y + i) * s-&gt;w + (x + j)];</span><br><span class="line">        SDL_Color color = palette[index];</span><br><span class="line">        converted_pixels[i * w + j] = (color.r &lt;&lt; <span class="number">16</span>) | (color.g &lt;&lt; <span class="number">8</span>) | color.b;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NDL_DrawRect(converted_pixels, x, y, w, h);</span><br><span class="line">    <span class="built_in">free</span>(converted_pixels);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s-&gt;format-&gt;BytesPerPixel == <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="comment">// 直接使用32位颜色格式</span></span><br><span class="line">    NDL_DrawRect((<span class="type">uint32_t</span> *)s-&gt;pixels, x, y, w, h);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>补充完善按键</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span>* <span class="title function_">SDL_GetKeyState</span><span class="params">(<span class="type">int</span> *numkeys)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (numkeys) &#123;</span><br><span class="line">    *numkeys = SDL_NUM_SCANCODES;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> keystate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以及SDL_PollEvent和SDL_WaitEvent部分</span></span><br></pre></td></tr></table></figure>
<ul>
<li>成功！！<br><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-12.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>画面是偏移的，修改一下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NDL.h</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> canva_w = <span class="number">0</span>, canva_h =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">NDL_OpenCanvas</span><span class="params">(<span class="type">int</span> *w, <span class="type">int</span> *h)</span> &#123;</span><br><span class="line"></span><br><span class="line">  canva_w = *w;</span><br><span class="line">  canva_h = *h;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;NWM_APP&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d %d&quot;</span>, canva_w, canva_h);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">NDL_DrawRect</span><span class="params">(<span class="type">uint32_t</span> *pixels, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h)</span> &#123;</span><br><span class="line"></span><br><span class="line">  x += (screen_w - canva_w)/<span class="number">2</span>;</span><br><span class="line">  y += (screen_h - canva_h)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>画面成功到最中间啦！！<ul>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-13.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li>测试一下</li>
</ul>
<ol>
<li>无敌人的机关迷宫</li>
</ol>
<ul>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-14.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<ol start="2">
<li>无动画的剧情</li>
</ol>
<ul>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-15.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<ol start="3">
<li>有动画的剧情</li>
</ol>
<ul>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-16.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<ol start="4">
<li>已进入敌人视野的迷宫</li>
</ol>
<ul>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-17.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-18.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<ol start="5">
<li>未进入敌人视野的迷宫</li>
</ol>
<ul>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-19.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="3-展示你的批处理系统"><a href="#3-展示你的批处理系统" class="headerlink" title="3. 展示你的批处理系统"></a>3. 展示你的批处理系统</h2><ul>
<li>“执行其它程序”需要一个新的系统调用来支持, 这个系统调用就是<code>SYS_execve</code><ul>
<li>它的作用是结束当前程序的运行, 并启动一个指定的程序</li>
</ul>
</li>
<li>为了实现这个系统调用, 你只需要在相应的系统调用处理函数中调用<code>naive_uload()</code>就可以了. 目前我们只需要关心<code>filename</code>即可, <code>argv</code>和<code>envp</code>这两个参数可以暂时忽略.</li>
</ul>
<h4 id="必做：可以运行其它程序的开机菜单"><a href="#必做：可以运行其它程序的开机菜单" class="headerlink" title="必做：可以运行其它程序的开机菜单"></a>必做：可以运行其它程序的开机菜单</h4><ul>
<li>你需要实现<code>SYS_execve</code>系统调用, 然后通过开机菜单来运行其它程序. 你已经实现过很多系统调用了, 需要注意哪些细节, 这里就不啰嗦了.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//do_syscall()</span></span><br><span class="line"><span class="keyword">case</span> SYS_execve:</span><br><span class="line">      naive_uload(<span class="literal">NULL</span>, (<span class="type">const</span> <span class="type">char</span> *)a[<span class="number">1</span>]);</span><br><span class="line">      c-&gt;GPRx = <span class="number">0</span>; <span class="comment">// 如果成功，不会返回到当前程序</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _execve(<span class="type">const</span> <span class="type">char</span> *fname, <span class="type">char</span> * <span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[]) &#123;</span><br><span class="line">  <span class="comment">// _exit(SYS_execve);</span></span><br><span class="line">  <span class="comment">// return 0;</span></span><br><span class="line">  <span class="keyword">return</span> _syscall_(SYS_execve, (<span class="type">intptr_t</span>)fname, (<span class="type">intptr_t</span>)argv, (<span class="type">intptr_t</span>)envp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>成功<ul>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-20.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
<h4 id="必做：展示你的批处理系统"><a href="#必做：展示你的批处理系统" class="headerlink" title="必做：展示你的批处理系统"></a>必做：展示你的批处理系统</h4><ul>
<li>有了开机菜单程序之后, 就可以很容易地实现一个有点样子的批处理系统了. 你只需要修改<code>SYS_exit</code>的实现, 让它调用<code>SYS_execve</code>来再次运行<code>/bin/menu</code>, 而不是直接调用<code>halt()</code>来结束整个系统的运行. 这样以后, 在一个用户程序结束的时候, 操作系统就会<strong>自动再次运行开机菜单程序, 让用户选择一个新的程序来运行</strong>.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//do_syscall</span></span><br><span class="line">    <span class="keyword">case</span> SYS_exit:</span><br><span class="line">      naive_uload(<span class="literal">NULL</span>, <span class="string">&quot;/bin/menu&quot;</span>);</span><br><span class="line">      c-&gt;GPRx = <span class="number">0</span>; <span class="comment">// 如果成功，不会返回到当前程序</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>成功<ul>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-21.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-22.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
<h4 id="必做：展示你的批处理系统-2"><a href="#必做：展示你的批处理系统-2" class="headerlink" title="必做：展示你的批处理系统(2)"></a>必做：展示你的批处理系统(2)</h4><ul>
<li>在NTerm的<strong>內建Shell中实现命令解</strong>析, 把键入的命令作为参数调用<code>execve()</code>. 然后<strong>把NTerm作为Nanos-lite第一个启动的程序</strong>, 并修改<code>SYS_exit</code>的实现, 让它<strong>再次运行&#x2F;bin&#x2F;nterm</strong>. 目前我们暂不支持参数的传递, 你可以先忽略命令的参数.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//builtin-sh.cpp</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sh_handle_cmd</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd)</span> &#123;</span><br><span class="line">  <span class="comment">// 忽略命令的参数</span></span><br><span class="line">  <span class="type">char</span> *args[] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">  execve(cmd, args, <span class="literal">NULL</span>);</span><br><span class="line">  sh_printf(<span class="string">&quot;Command not found: %s\n&quot;</span>, cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//do_syscall</span></span><br><span class="line">  <span class="keyword">switch</span> (a[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> SYS_exit:</span><br><span class="line">      naive_uload(<span class="literal">NULL</span>, <span class="string">&quot;/bin/nterm&quot;</span>);</span><br><span class="line">      c-&gt;GPRx = <span class="number">0</span>; <span class="comment">// 如果成功，不会返回到当前程序</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>成功！<ul>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-23.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
<h4 id="必做：为NTerm中的內建Shell添加环境变量的支持"><a href="#必做：为NTerm中的內建Shell添加环境变量的支持" class="headerlink" title="必做：为NTerm中的內建Shell添加环境变量的支持"></a>必做：为NTerm中的內建Shell添加环境变量的支持</h4><ul>
<li>这是一个非常简单的任务, 你只需要RTFM了解<code>setenv()</code>和<code>execvp()</code>的行为, 并对內建Shell的代码进行少量修改, 就可以得到一个和你平时的使用体验非常相似的Shell了.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sh_handle_cmd</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd)</span> &#123;</span><br><span class="line">  <span class="type">char</span> tmp_cmd[<span class="number">64</span>];</span><br><span class="line">  <span class="built_in">strncpy</span>(tmp_cmd, cmd, <span class="keyword">sizeof</span>(tmp_cmd) - <span class="number">1</span>);</span><br><span class="line">  tmp_cmd[<span class="keyword">sizeof</span>(tmp_cmd) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 确保字符串以 &#x27;\0&#x27; 结尾</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 去掉命令末尾的换行符</span></span><br><span class="line">  <span class="type">char</span> *newline = <span class="built_in">strchr</span>(tmp_cmd, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (newline) *newline = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 PATH 环境变量</span></span><br><span class="line">  setenv(<span class="string">&quot;PATH&quot;</span>, <span class="string">&quot;/bin&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 忽略命令的参数</span></span><br><span class="line">  <span class="type">char</span> *args[] = &#123;tmp_cmd, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行命令</span></span><br><span class="line">  execvp(tmp_cmd, args);</span><br><span class="line">  sh_printf(<span class="string">&quot;Command not found: %s\n&quot;</span>, tmp_cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>成功！<ul>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-24.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-25.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
<hr>
<h3 id="必答题：理解计算机系统"><a href="#必答题：理解计算机系统" class="headerlink" title="必答题：理解计算机系统"></a>必答题：理解计算机系统</h3><ul>
<li>理解上下文结构体的前世今生 (见PA3.1阶段)</li>
<li>理解穿越时空的旅程 (见PA3.1阶段)</li>
<li>hello程序是什么, 它从而何来, 要到哪里去 (见PA3.2阶段)</li>
<li>仙剑奇侠传究竟如何运行 运行仙剑奇侠传时会播放启动动画, 动画里仙鹤在群山中飞过. 这一动画是通过navy-apps&#x2F;apps&#x2F;pal&#x2F;repo&#x2F;src&#x2F;main.c中的PAL_SplashScreen()函数播放的. 阅读这一函数, 可以得知仙鹤的像素信息存放在数据文件mgo.mkf中. 请回答以下问题: 库函数, libos, Nanos-lite, AM, NEMU是如何相互协助, 来帮助仙剑奇侠传的代码从mgo.mkf文件中读出仙鹤的像素信息, 并且更新到屏幕上? 换一种PA的经典问法: 这个过程究竟经历了些什么? (Hint: 合理使用各种trace工具, 可以帮助你更容易地理解仙剑奇侠传的行为)</li>
</ul>
<h4 id="理解上下文结构体的前世今生"><a href="#理解上下文结构体的前世今生" class="headerlink" title="理解上下文结构体的前世今生"></a>理解上下文结构体的前世今生</h4><ul>
<li>你会在__am_irq_handle()中看到有一个上下文结构指针c, c指向的上下文结构究竟在哪里? 这个上下文结构又是怎么来的? 具体地, 这个上下文结构有很多成员, 每一个成员究竟在哪里赋值的? $ISA-nemu.h, trap.S, 上述讲义文字, 以及你刚刚在NEMU中实现的新指令, 这四部分内容又有什么联系?</li>
<li>如果你不是脑袋足够灵光, 还是不要眼睁睁地盯着代码看了, 理解程序的细节行为还是要从状态机视角入手.</li>
</ul>
<ol>
<li>c指向的上下文结构的来源：<ul>
<li>上下文结构体<code>Context</code>是在异常处理过程中创建的。它包含了处理器的寄存器状态，包括通用寄存器、异常号、处理器状态和异常 PC 等。</li>
</ul>
</li>
<li>上下文结构体的创建过程<ol>
<li><strong>异常触发</strong>：当发生异常时，处理器会自动跳转到异常处理入口地址，该地址存储在<code>mtvec</code>寄存器中。ps:这个地址是<code>__am_asm_trap</code>。</li>
<li><strong>保存上下文</strong>：在 <code>__am_asm_trap</code> 中，使用汇编代码保存当前的处理器状态到栈中。具体来说，将所有通用寄存器、mcause、mstatus 和 mepc 寄存器的值保存到栈中。</li>
<li><strong>调用异常处理函数</strong>：保存完上下文后，我们将栈指针传递给 <code>__am_irq_handle</code> 函数，并调用它进行异常处理。</li>
</ol>
</li>
<li>上下文结构体的成员赋值:<ul>
<li>在 <code>trap.S</code> 中被赋值</li>
</ul>
<ol>
<li>保存<strong>通用寄存器</strong>：<code>MAP(REGS, PUSH)</code><ul>
<li>使用宏<code>PUSH</code>将所有通用寄存器的值保存到栈中。</li>
</ul>
</li>
<li>保存<strong>mcause、mstatus和mepc寄存器</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">csrr t0, mcause</span><br><span class="line">csrr t1, mstatus</span><br><span class="line">csrr t2, mepc</span><br><span class="line"></span><br><span class="line">STORE t0, OFFSET_CAUSE(sp)</span><br><span class="line">STORE t1, OFFSET_STATUS(sp)</span><br><span class="line">STORE t2, OFFSET_EPC(sp)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>csrr</code>指令将mcause、mstatus 和 mepc寄存器的值读取到临时寄存器t0、t1 和 t2，然后使用<code>STORE</code>宏将它们保存到栈中。</li>
</ul>
</li>
</ol>
</li>
<li>各部分内容的联系<ol>
<li><code>riscv.h</code>：定义了上下文结构体 Context，包括通用寄存器、mcause、mstatus 和 mepc 等成员。</li>
<li><code>trap.S</code>：在异常发生时，保存处理器的状态到栈中，并调用 __am_irq_handle 进行异常处理。</li>
<li><code>cte.c</code>：实现了异常处理函数 __am_irq_handle，通过指针 c 访问上下文结构体，并输出其成员的值。</li>
<li>新指令的实现：在 inst.c 中实现了 <code>csrr</code> 和 <code>csrw</code> 指令，用于读取和写入 CSR 寄存器的值。这些指令在 trap.S 中被使用，用于保存和恢复 mcause、mstatus 和 mepc 寄存器的值。</li>
</ol>
</li>
</ol>
<h4 id="理解穿越时空的旅程"><a href="#理解穿越时空的旅程" class="headerlink" title="理解穿越时空的旅程"></a>理解穿越时空的旅程</h4><ul>
<li>从<code>yield test</code>调用<code>yield()</code>开始, 到从<code>yield()</code>返回的期间, 这一趟旅程具体经历了什么? 软(AM, <code>yield test</code>)硬(NEMU)件是如何相互协助来完成这趟旅程的? 你需要解释这一过程中的每一处细节, 包括涉及的每一行汇编代码&#x2F;C代码的行为, 尤其是一些比较关键的指令&#x2F;变量. 事实上, 上文的必答题”理解上下文结构体的前世今生”已经涵盖了这趟旅程中的一部分, 你可以把它的回答包含进来.</li>
<li>别被”每一行代码”吓到了, 这个过程也就大约50行代码, 要完全理解透彻并不是不可能的. 我们之所以设置这道必答题, 是为了强迫你理解清楚这个过程中的每一处细节. 这一理解是如此重要, 以至于如果你缺少它, 接下来你面对bug几乎是束手无策.</li>
</ul>
<ol>
<li><code>yield()</code> 函数调用<ul>
<li>在 <code>yield test</code> 中，调用 <code>yield()</code> 函数：</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">yield</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __riscv_e</span></span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;li a5, -1; ecall&quot;</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;li a7, -1; ecall&quot;</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这段代码使用内联汇编触发一个环境调用（ECALL）</li>
<li><code>li a7, -1</code>：将立即数 -1 加载到寄存器 a7 中</li>
<li><code>ecall</code>：触发一个环境调用异常。</li>
</ul>
</li>
<li>触发异常<ul>
<li><code>ecall</code>指令触发一个环境调用异常，处理器进入异常处理模式，并跳转到由 <code>mtvec</code> 寄存器指定的异常处理程序地址。</li>
</ul>
</li>
<li>异常处理程序(在 <code>trap.S</code> 文件中定义)：<ul>
<li><code>addi sp, sp, -CONTEXT_SIZE</code>： 为保存上下文分配空间。</li>
<li><code>MAP(REGS, PUSH)</code>： 保存所有通用寄存器的值。</li>
<li><code>csrr t0, mcause</code>： 读取 mcause 寄存器的值到 t0。</li>
<li><code>csrr t1, mstatus</code>： 读取 mstatus 寄存器的值到 t1。</li>
<li><code>csrr t2, mepc</code>： 读取 mepc 寄存器的值到 t2。</li>
<li><code>STORE t0, OFFSET_CAUSE(sp)</code>： 将 mcause 的值保存到栈中。</li>
<li><code>STORE t1, OFFSET_STATUS(sp)</code>： 将 mstatus 的值保存到栈中。</li>
<li><code>STORE t2, OFFSET_EPC(sp)</code>： 将 mepc 的值保存到栈中。</li>
<li><code>li a0, (1 &lt;&lt; 17)</code>： 将立即数 1 &lt;&lt; 17 加载到 a0 中。</li>
<li><code>or t1, t1, a0</code>： 将 t1 和 a0 进行或运算，结果存入 t1。</li>
<li><code>csrw mstatus, t1</code>： 将 t1 的值写入 mstatus 寄存器。</li>
<li><code>mv a0, sp</code>： 将栈指针的值移动到 a0。</li>
<li><code>call __am_irq_handle</code>： 调用 __am_irq_handle 函数。</li>
</ul>
</li>
<li><code>__am_irq_handle</code>函数(在 <code>cte.c</code> 文件中定义)：<ul>
<li><code>switch (c-&gt;mcause)</code>：根据 mcause 的值判断异常类型。</li>
<li><code>case 0: ev.event = EVENT_YIELD; break;</code>：如果 mcause 为 0，表示自陷异常，将事件类型设置为 EVENT_YIELD。</li>
<li><code>c = user_handler(ev, c);</code>：调用用户注册的事件处理程序 user_handler，并传递事件和上下文。</li>
</ul>
</li>
<li>用户事件处理程序(在 <code>intr.c</code> 文件中定义)：<ul>
<li><code>case EVENT_YIELD: putch(&#39;y&#39;); break;</code>：如果事件类型为 EVENT_YIELD，输出字符 y。</li>
</ul>
</li>
<li>恢复上下文并返回<ul>
<li>回到异常处理程序：</li>
<li><code>LOAD t1, OFFSET_STATUS(sp)</code>：从栈中恢复 mstatus 的值到 t1。</li>
<li><code>LOAD t2, OFFSET_EPC(sp)</code>：从栈中恢复 mepc 的值到 t2。</li>
<li><code>csrw mstatus, t1</code>：将 t1 的值写入 mstatus 寄存器。</li>
<li><code>csrw mepc, t2</code>：将 t2 的值写入 mepc 寄存器。</li>
<li><code>MAP(REGS, POP)</code>：恢复所有通用寄存器的值。</li>
<li><code>addi sp, sp, CONTEXT_SIZE</code>：释放为保存上下文分配的空间。</li>
<li><code>mret</code>：从异常处理程序返回，恢复程序的正常执行。</li>
</ul>
</li>
</ol>
<h4 id="hello程序是什么-它从而何来-要到哪里去"><a href="#hello程序是什么-它从而何来-要到哪里去" class="headerlink" title="hello程序是什么, 它从而何来, 要到哪里去"></a>hello程序是什么, 它从而何来, 要到哪里去</h4><ul>
<li>hello程序从C源文件到在终端上打印字符串，经历了编译、链接、加载、执行等多个步骤：</li>
</ul>
<ol>
<li>hello程序一开始在哪里?</li>
</ol>
<ul>
<li>一开始在源文件<code>navy-apps/tests/hello/hello.c</code>。这个源文件通过编译器（如GCC）编译成目标文件，然后通过链接器链接成一个可执行的ELF文件。</li>
</ul>
<ol start="2">
<li>它是怎么出现内存中的?</li>
</ol>
<ul>
<li>当我们运行hello程序时，操作系统的加载器会将ELF文件加载到内存中。加载器会解析ELF文件的头部信息，确定程序的入口点、代码段、数据段等信息，并将这些段加载到内存中的相应位置。</li>
</ul>
<ol start="3">
<li>为什么会出现在目前的内存位置?</li>
</ol>
<ul>
<li>ELF文件中包含了段表和程序头表，这些表格定义了各个段在内存中的位置。加载器根据这些信息将各个段加载到指定的内存地址。例如，代码段通常加载到一个固定的地址（如0x8048000），数据段加载到另一个地址。</li>
</ul>
<ol start="4">
<li>它的第一条指令在哪里?</li>
</ol>
<ul>
<li>hello程序的第一条指令位于ELF文件的入口点。入口点地址在ELF文件头中指定，通常是程序的<code>_start</code>函数的地址。加载器在加载完程序后，会将控制权转移到这个入口点，开始执行程序的第一条指令。</li>
</ul>
<ol start="5">
<li>究竟是怎么执行到它的第一条指令的?</li>
</ol>
<ul>
<li>加载器将程序加载到内存后，会设置CPU的程序计数器（PC）指向程序的入口点地址。然后，CPU开始从这个地址执行指令，逐条执行程序的代码。</li>
</ul>
<ol start="6">
<li>hello程序在不断地打印字符串, 每一个字符又是经历了什么才会最终出现在终端上?</li>
</ol>
<ul>
<li>hello程序使用<code>printf</code>函数打印字符串。<code>printf</code>函数会将字符串格式化后，通过系统调用（如<code>write</code>）将字符串写入标准输出（通常是终端）。系统调用会将数据从用户空间传递到内核空间，内核再将数据写入终端设备的缓冲区，最终显示在终端上。</li>
</ul>
<h4 id="仙剑奇侠传究竟如何运行"><a href="#仙剑奇侠传究竟如何运行" class="headerlink" title="仙剑奇侠传究竟如何运行"></a>仙剑奇侠传究竟如何运行</h4><ul>
<li>过程：</li>
</ul>
<ol>
<li><p>应用程序层（仙剑奇侠传）</p>
</li>
<li><p><strong>调用 <code>PAL_SplashScreen</code> 函数</strong>：<br>- 仙剑奇侠传的代码调用 <code>PAL_SplashScreen</code> 函数来播放启动动画。<br>- 该函数读取 <code>mgo.mkf</code> 文件中的数据，并将其解码为像素信息。</p>
</li>
<li><p><strong>读取文件</strong>：<br>- <code>PAL_SplashScreen</code> 函数调用 <code>PAL_MKFReadChunk</code> 函数来读取 <code>mgo.mkf</code> 文件中的数据。<br>- <code>PAL_MKFReadChunk</code> 函数通过标准库函数（如 <code>fopen</code>、<code>fread</code> 等）来读取文件数据。</p>
</li>
<li><p>库函数层</p>
</li>
<li><p><strong>标准库函数</strong>：<br>- 标准库函数（如 <code>fopen</code>、<code>fread</code> 等）被调用来读取文件数据。<br>- 这些函数最终会调用系统调用接口来执行实际的文件操作。</p>
</li>
<li><p>操作系统层（Nanos-lite）</p>
</li>
<li><p><strong>系统调用</strong>：<br>- 标准库函数通过系统调用接口（如 <code>SYS_open</code>、<code>SYS_read</code> 等）与操作系统交互。<br>- 这些系统调用由 Nanos-lite 实现。</p>
</li>
<li><p><strong>文件系统操作</strong>：<br>- Nanos-lite 的文件系统模块处理这些系统调用，执行实际的文件操作。<br>- 文件系统模块读取文件数据，并将其返回给应用程序。</p>
</li>
<li><p>抽象机器层（AM）</p>
</li>
<li><p><strong>硬件抽象</strong>：<br>- AM 提供硬件抽象层，处理底层硬件操作。<br>- AM 负责处理内存映射、设备 I&#x2F;O 等操作。</p>
</li>
<li><p>模拟器层（NEMU）</p>
</li>
<li><p><strong>指令模拟</strong>：<br>- NEMU 模拟 CPU 指令执行，处理应用程序和操作系统的指令。<br>- NEMU 负责模拟内存访问、设备 I&#x2F;O 等操作。</p>
</li>
<li><p>显示更新</p>
</li>
<li><p><strong>解码像素数据</strong>：<br>- <code>PAL_SplashScreen</code> 函数解码从 <code>mgo.mkf</code> 文件中读取的像素数据。<br>- 解码后的像素数据存储在内存中。</p>
</li>
<li><p><strong>更新屏幕</strong>：<br>- <code>PAL_SplashScreen</code> 函数调用显示更新函数（如 <code>VIDEO_UpdateScreen</code>）来更新屏幕。<br>- 显示更新函数通过系统调用接口与操作系统交互，执行实际的屏幕更新操作。</p>
</li>
<li><p>系统调用和硬件交互</p>
</li>
<li><p><strong>系统调用</strong>：<br>- 显示更新函数通过系统调用接口（如 <code>SYS_write</code>）与操作系统交互。<br>- 操作系统处理这些系统调用，执行实际的屏幕更新操作。</p>
</li>
<li><p><strong>硬件交互</strong>：<br>- 操作系统通过 AM 与底层硬件交互，执行屏幕更新操作。<br>- AM 负责处理内存映射、设备 I&#x2F;O 等操作，将像素数据写入帧缓冲区。</p>
</li>
</ol>

</article>
    
    <div class="trm-reward">
        
            <span class="trm-reward-btn trm-glow" onclick='var qr = document.getElementById("qr"); qr.style.display = (qr.style.display === "none") ? "block" : "none";'>
                <i class="iconfont fas fa-hand-holding-usd"></i>
            </span>
        
        <p class="trm-reward-comment">If you like my blog, you can approve me by scanning the QR code below.</p>
        <div id="qr" style="display:none;">
            
                <div style="display:inline-block">
                    <a rel="noopener noreferrer" href='/assets/reward.jpg' target='_blank' >
                       <img src="/assets/reward.jpg" alt="微信" loading="lazy">
                    </a>
                    <p>微信</p>
                </div>
            
        </div>
    </div>

    

</div>
<div class="trm-post-next-prev row">
    <div class="col-lg-12">
        <!-- title -->
        <h5 class="trm-title-with-divider">
            Other Articles
            <span data-number="02"></span>
        </h5>
    </div>
    
        <div class="col-lg-6">
    <div class="trm-blog-card trm-scroll-animation">
        <a href="/2025/02/25/PA2%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/" class="trm-cover-frame trm-anima-link">
            
            
                <img alt="cover" class="no-fancybox" src="/img/block.jpg">
            
        </a>
        
        <div class="trm-card-descr">
            <div class="trm-label trm-category trm-mb-20">
                <a href=" /categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/">
                    计算机系统基础实验
                </a>
            </div>
            <h5>
                <a href="/2025/02/25/PA2%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/" class="trm-anima-link">
                    PA2实验记录
                </a>
            </h5>
            <div class="trm-divider trm-mb-20 trm-mt-20"></div>
            <ul class="trm-card-data trm-label">
                <li>25/02/25</li>
                <li>22:48</li>
                
                    <li>33.4k</li>
                
                
                    <li>140</li>
                
            </ul>
        </div>
    </div>
</div>
    
    
        <div class="col-lg-6">
    <div class="trm-blog-card trm-scroll-animation">
        <a href="/2025/02/25/PA4%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/" class="trm-cover-frame trm-anima-link">
            
            
                <img alt="cover" class="no-fancybox" src="/img/block.jpg">
            
        </a>
        
        <div class="trm-card-descr">
            <div class="trm-label trm-category trm-mb-20">
                <a href=" /categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/">
                    计算机系统基础实验
                </a>
            </div>
            <h5>
                <a href="/2025/02/25/PA4%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/" class="trm-anima-link">
                    PA4实验记录
                </a>
            </h5>
            <div class="trm-divider trm-mb-20 trm-mt-20"></div>
            <ul class="trm-card-data trm-label">
                <li>25/02/25</li>
                <li>22:45</li>
                
                    <li>3k</li>
                
                
                    <li>11</li>
                
            </ul>
        </div>
    </div>
</div>
    
</div>

    



                    <div class="trm-divider footer-divider"></div>

                    <!-- footer -->
                    <footer class="trm-footer-card trm-scroll-animation">

    

    

      

    
        <div class="trm-footer-item blog-run-long"></div>
     

    
        <div class="trm-footer-item">
            你走过的弯路，都是通向正轨的必经之路。
        </div>
     
</footer>
                    <!-- footer end -->

                </div>
            </div>
        </div>
    </div>
</div>
            <!-- body end -->

            

    <div id="post-toc" class="trm-post-toc">
      <div class="trm-post-toc-header">
        Article table of contents
				<span id="post-toc-top">
					TOP
				</span>
      </div>
      <div class="trm-post-toc-content">
        <ol class="trm-toc"><li class="trm-toc-item trm-toc-level-2" title="PA3-穿越时空的旅程：批处理系统"><a rel="nofollow" class="trm-toc-link" href="#PA3-穿越时空的旅程：批处理系统"><span class="trm-toc-number">1.</span> <span class="trm-toc-text">PA3-穿越时空的旅程：批处理系统</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-1" title="最简单的操作系统"><a rel="nofollow" class="trm-toc-link" href="#最简单的操作系统"><span class="trm-toc-number"></span> <span class="trm-toc-text">最简单的操作系统</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-2" title="1. 批处理系统"><a rel="nofollow" class="trm-toc-link" href="#1-批处理系统"><span class="trm-toc-number">1.</span> <span class="trm-toc-text">1. 批处理系统</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="1.1 来自操作系统的新需求"><a rel="nofollow" class="trm-toc-link" href="#1-1-来自操作系统的新需求"><span class="trm-toc-number">1.1.</span> <span class="trm-toc-text">1.1 来自操作系统的新需求</span></a></li><li class="trm-toc-item trm-toc-level-3" title="1.2 等级森严的制度"><a rel="nofollow" class="trm-toc-link" href="#1-2-等级森严的制度"><span class="trm-toc-number">1.2.</span> <span class="trm-toc-text">1.2 等级森严的制度</span></a></li></ol></li></ol></li><li class="trm-toc-item trm-toc-level-1" title="穿越时空的旅程"><a rel="nofollow" class="trm-toc-link" href="#穿越时空的旅程"><span class="trm-toc-number"></span> <span class="trm-toc-text">穿越时空的旅程</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-2" title="1. 穿越时空的旅程"><a rel="nofollow" class="trm-toc-link" href="#1-穿越时空的旅程"><span class="trm-toc-number">1.</span> <span class="trm-toc-text">1. 穿越时空的旅程</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="1.1 x86"><a rel="nofollow" class="trm-toc-link" href="#1-1-x86"><span class="trm-toc-number">1.1.</span> <span class="trm-toc-text">1.1 x86</span></a></li><li class="trm-toc-item trm-toc-level-3" title="1.2 mips32"><a rel="nofollow" class="trm-toc-link" href="#1-2-mips32"><span class="trm-toc-number">1.2.</span> <span class="trm-toc-text">1.2 mips32</span></a></li><li class="trm-toc-item trm-toc-level-3" title="1.3 riscv32"><a rel="nofollow" class="trm-toc-link" href="#1-3-riscv32"><span class="trm-toc-number">1.3.</span> <span class="trm-toc-text">1.3 riscv32</span></a></li><li class="trm-toc-item trm-toc-level-3" title="1.4 状态机视角下的异常响应机制"><a rel="nofollow" class="trm-toc-link" href="#1-4-状态机视角下的异常响应机制"><span class="trm-toc-number">1.4.</span> <span class="trm-toc-text">1.4 状态机视角下的异常响应机制</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-2" title="2. 将上下文管理抽象成CTE"><a rel="nofollow" class="trm-toc-link" href="#2-将上下文管理抽象成CTE"><span class="trm-toc-number">2.</span> <span class="trm-toc-text">2. 将上下文管理抽象成CTE</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="2.1 设置异常入口地址"><a rel="nofollow" class="trm-toc-link" href="#2-1-设置异常入口地址"><span class="trm-toc-number">2.1.</span> <span class="trm-toc-text">2.1 设置异常入口地址</span></a></li><li class="trm-toc-item trm-toc-level-3" title="2.2 触发自陷操作"><a rel="nofollow" class="trm-toc-link" href="#2-2-触发自陷操作"><span class="trm-toc-number">2.2.</span> <span class="trm-toc-text">2.2 触发自陷操作</span></a></li><li class="trm-toc-item trm-toc-level-3" title="2.3 保存上下文"><a rel="nofollow" class="trm-toc-link" href="#2-3-保存上下文"><span class="trm-toc-number">2.3.</span> <span class="trm-toc-text">2.3 保存上下文</span></a></li><li class="trm-toc-item trm-toc-level-3" title="2.4 事件分发"><a rel="nofollow" class="trm-toc-link" href="#2-4-事件分发"><span class="trm-toc-number">2.4.</span> <span class="trm-toc-text">2.4 事件分发</span></a></li><li class="trm-toc-item trm-toc-level-3" title="2.5 恢复上下文"><a rel="nofollow" class="trm-toc-link" href="#2-5-恢复上下文"><span class="trm-toc-number">2.5.</span> <span class="trm-toc-text">2.5 恢复上下文</span></a></li><li class="trm-toc-item trm-toc-level-3" title="2.6 异常处理的踪迹-etrace"><a rel="nofollow" class="trm-toc-link" href="#2-6-异常处理的踪迹-etrace"><span class="trm-toc-number">2.6.</span> <span class="trm-toc-text">2.6 异常处理的踪迹-etrace</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-2" title="PA 3.1到此结束"><a rel="nofollow" class="trm-toc-link" href="#PA-3-1到此结束"><span class="trm-toc-number">3.</span> <span class="trm-toc-text">PA 3.1到此结束</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-1" title="用户程序和系统调用"><a rel="nofollow" class="trm-toc-link" href="#用户程序和系统调用"><span class="trm-toc-number"></span> <span class="trm-toc-text">用户程序和系统调用</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-2" title="1. 最简单的操作系统"><a rel="nofollow" class="trm-toc-link" href="#1-最简单的操作系统"><span class="trm-toc-number">1.</span> <span class="trm-toc-text">1. 最简单的操作系统</span></a></li><li class="trm-toc-item trm-toc-level-2" title="2. 加载第一个用户程序"><a rel="nofollow" class="trm-toc-link" href="#2-加载第一个用户程序"><span class="trm-toc-number">2.</span> <span class="trm-toc-text">2. 加载第一个用户程序</span></a></li><li class="trm-toc-item trm-toc-level-2" title="3. 操作系统的运行时环境"><a rel="nofollow" class="trm-toc-link" href="#3-操作系统的运行时环境"><span class="trm-toc-number">3.</span> <span class="trm-toc-text">3. 操作系统的运行时环境</span></a></li><li class="trm-toc-item trm-toc-level-2" title="4. 系统调用"><a rel="nofollow" class="trm-toc-link" href="#4-系统调用"><span class="trm-toc-number">4.</span> <span class="trm-toc-text">4. 系统调用</span></a></li><li class="trm-toc-item trm-toc-level-2" title="5. 系统调用的踪迹："><a rel="nofollow" class="trm-toc-link" href="#5-系统调用的踪迹："><span class="trm-toc-number">5.</span> <span class="trm-toc-text">5. 系统调用的踪迹：</span></a></li><li class="trm-toc-item trm-toc-level-2" title="6. 操作系统之上的TRM"><a rel="nofollow" class="trm-toc-link" href="#6-操作系统之上的TRM"><span class="trm-toc-number">6.</span> <span class="trm-toc-text">6. 操作系统之上的TRM</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="标准输出"><a rel="nofollow" class="trm-toc-link" href="#标准输出"><span class="trm-toc-number">6.1.</span> <span class="trm-toc-text">标准输出</span></a></li><li class="trm-toc-item trm-toc-level-3" title="堆区管理"><a rel="nofollow" class="trm-toc-link" href="#堆区管理"><span class="trm-toc-number">6.2.</span> <span class="trm-toc-text">堆区管理</span></a></li></ol></li></ol></li><li class="trm-toc-item trm-toc-level-1" title="文件系统"><a rel="nofollow" class="trm-toc-link" href="#文件系统"><span class="trm-toc-number"></span> <span class="trm-toc-text">文件系统</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-2" title="1. 简易文件系统"><a rel="nofollow" class="trm-toc-link" href="#1-简易文件系统"><span class="trm-toc-number">1.</span> <span class="trm-toc-text">1. 简易文件系统</span></a></li><li class="trm-toc-item trm-toc-level-2" title="2. 一切皆文件"><a rel="nofollow" class="trm-toc-link" href="#2-一切皆文件"><span class="trm-toc-number">2.</span> <span class="trm-toc-text">2. 一切皆文件</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="虚拟文件系统 VFS"><a rel="nofollow" class="trm-toc-link" href="#虚拟文件系统-VFS"><span class="trm-toc-number">2.1.</span> <span class="trm-toc-text">虚拟文件系统 VFS</span></a></li><li class="trm-toc-item trm-toc-level-3" title="操作系统之上的IOE"><a rel="nofollow" class="trm-toc-link" href="#操作系统之上的IOE"><span class="trm-toc-number">2.2.</span> <span class="trm-toc-text">操作系统之上的IOE</span></a></li></ol></li></ol></li><li class="trm-toc-item trm-toc-level-1" title="精彩纷呈的应用程序"><a rel="nofollow" class="trm-toc-link" href="#精彩纷呈的应用程序"><span class="trm-toc-number"></span> <span class="trm-toc-text">精彩纷呈的应用程序</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-2" title="1. 更丰富的运行时环境"><a rel="nofollow" class="trm-toc-link" href="#1-更丰富的运行时环境"><span class="trm-toc-number">1.</span> <span class="trm-toc-text">1. 更丰富的运行时环境</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="多媒体库"><a rel="nofollow" class="trm-toc-link" href="#多媒体库"><span class="trm-toc-number">1.1.</span> <span class="trm-toc-text">多媒体库</span></a></li><li class="trm-toc-item trm-toc-level-3" title="定点算术"><a rel="nofollow" class="trm-toc-link" href="#定点算术"><span class="trm-toc-number">1.2.</span> <span class="trm-toc-text">定点算术</span></a></li><li class="trm-toc-item trm-toc-level-3" title="Navy作为基础设施"><a rel="nofollow" class="trm-toc-link" href="#Navy作为基础设施"><span class="trm-toc-number">1.3.</span> <span class="trm-toc-text">Navy作为基础设施</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-2" title="2. Navy中的应用程序"><a rel="nofollow" class="trm-toc-link" href="#2-Navy中的应用程序"><span class="trm-toc-number">2.</span> <span class="trm-toc-text">2. Navy中的应用程序</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="NSlider (NJU Slider)"><a rel="nofollow" class="trm-toc-link" href="#NSlider-NJU-Slider"><span class="trm-toc-number">2.1.</span> <span class="trm-toc-text">NSlider (NJU Slider)</span></a></li><li class="trm-toc-item trm-toc-level-3" title="MENU (开机菜单)"><a rel="nofollow" class="trm-toc-link" href="#MENU-开机菜单"><span class="trm-toc-number">2.2.</span> <span class="trm-toc-text">MENU (开机菜单)</span></a></li><li class="trm-toc-item trm-toc-level-3" title="NTerm (NJU Terminal)"><a rel="nofollow" class="trm-toc-link" href="#NTerm-NJU-Terminal"><span class="trm-toc-number">2.3.</span> <span class="trm-toc-text">NTerm (NJU Terminal)</span></a></li><li class="trm-toc-item trm-toc-level-3" title="Flappy Bird"><a rel="nofollow" class="trm-toc-link" href="#Flappy-Bird"><span class="trm-toc-number">2.4.</span> <span class="trm-toc-text">Flappy Bird</span></a></li><li class="trm-toc-item trm-toc-level-3" title="PAL（仙剑奇侠传）"><a rel="nofollow" class="trm-toc-link" href="#PAL（仙剑奇侠传）"><span class="trm-toc-number">2.5.</span> <span class="trm-toc-text">PAL（仙剑奇侠传）</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-2" title="3. 展示你的批处理系统"><a rel="nofollow" class="trm-toc-link" href="#3-展示你的批处理系统"><span class="trm-toc-number">3.</span> <span class="trm-toc-text">3. 展示你的批处理系统</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="必答题：理解计算机系统"><a rel="nofollow" class="trm-toc-link" href="#必答题：理解计算机系统"><span class="trm-toc-number">3.1.</span> <span class="trm-toc-text">必答题：理解计算机系统</span></a></li></ol></li></ol>
      </div>
    </div>

            
<div class="trm-fixed-container">
    
        <div class="trm-fixed-btn post-toc-btn" data-title="Open toc">
            <i class="iconfont fas fa-th-list"></i>
        </div>
    
    
        <div class="trm-fixed-btn" data-title="Read Mode" onclick="asyncFun.switchReadMode()">
            <i class="iconfont fas fa-book-reader"></i>
        </div>
    
    
    <div id="trm-back-top" class="trm-fixed-btn" data-title="Back To Top">
        <i class="iconfont fas fa-arrow-up"></i>
    </div>
</div>
        </div>
      </div>
      <!-- scroll container end -->
  </div>
  <!-- app wrapper end -->

  
    <div class="trm-search-popup">
        <div class="trm-search-wrapper">
            <div class="form trm-search-form">
                <div class="trm-search-input-icon">
                    <i class="iconfont fas fa-search"></i>
                </div>
                <input class="trm-search-input" type="text" placeholder="Searching...">
                <div class="trm-search-btn-close">
                    <i class="iconfont fas fa-times"></i>
                </div>
            </div>
            <div class="trm-search-result-container">
                <div class="trm-search-empty">
                    Please enter keywords to search
                </div>
            </div>
            <div class="trm-search-footer">
                <div class="trm-search-stats"></div>
                <ul class="trm-search-commands">
                    <li>
                        <kbd class="command-palette-commands-key">
                            <svg width="15" height="15" aria-label="Escape key" role="img">
                                <g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"
                                    stroke-width="1.2">
                                    <path
                                        d="M13.6167 8.936c-.1065.3583-.6883.962-1.4875.962-.7993 0-1.653-.9165-1.653-2.1258v-.5678c0-1.2548.7896-2.1016 1.653-2.1016.8634 0 1.3601.4778 1.4875 1.0724M9 6c-.1352-.4735-.7506-.9219-1.46-.8972-.7092.0246-1.344.57-1.344 1.2166s.4198.8812 1.3445.9805C8.465 7.3992 8.968 7.9337 9 8.5c.032.5663-.454 1.398-1.4595 1.398C6.6593 9.898 6 9 5.963 8.4851m-1.4748.5368c-.2635.5941-.8099.876-1.5443.876s-1.7073-.6248-1.7073-2.204v-.4603c0-1.0416.721-2.131 1.7073-2.131.9864 0 1.6425 1.031 1.5443 2.2492h-2.956">
                                    </path>
                                </g>
                            </svg>
                        </kbd>
                        <span class="command-palette-Label">to close</span>
                    </li>
                </ul>
            </div>
        </div>
    </div>

  <!-- Plugin -->




    
    
<script src="https://unpkg.com/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script>

    

    

    
        
<script src="https://unpkg.com/hexo-generator-searchdb@1.4.0/dist/search.js"></script>

        <script src="/js/plugins/local_search.js?v=2.2.4"></script>
    

    <!-- 数学公式 -->
    

    <!-- 评论插件 -->
    
        

        
    

		




    <!-- Service Worker -->
    
    <!-- baidu push -->
    


<script id="async-script" src="/js/main.js?v=2.2.4"></script>

<!-- CDN -->


    

    

    



</body>

</html>