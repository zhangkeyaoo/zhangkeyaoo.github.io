<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="x5-fullscreen" content="true">
<meta name="full-screen" content="yes">
<meta name="theme-color" content="#317EFB" />
<meta content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=0" name="viewport">
<meta name="description" content="PA2 - 简单复杂的机器: 冯诺依曼计算机系统 首先切换到pa2分支 task PA2.1: 实现更多的指令, 在NEMU中运行大部分cpu-tests task PA2.2: 实现klib和基础设施 task PA2.3: 运行FCEUX, 提交完整的实验报告  不停计算的机器 CPU究竟是怎么执行一条指令的： 对于大部分指令来说, 执行它们都可以抽象成取指-译码-执行的指令周期.   计算机">
<meta property="og:type" content="article">
<meta property="og:title" content="PA2实验记录">
<meta property="og:url" content="http://example.com/2025/02/25/PA2%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="Universe Hamster">
<meta property="og:description" content="PA2 - 简单复杂的机器: 冯诺依曼计算机系统 首先切换到pa2分支 task PA2.1: 实现更多的指令, 在NEMU中运行大部分cpu-tests task PA2.2: 实现klib和基础设施 task PA2.3: 运行FCEUX, 提交完整的实验报告  不停计算的机器 CPU究竟是怎么执行一条指令的： 对于大部分指令来说, 执行它们都可以抽象成取指-译码-执行的指令周期.   计算机">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="article:published_time" content="2025-02-25T14:48:00.000Z">
<meta property="article:modified_time" content="2025-02-25T14:48:31.248Z">
<meta property="article:author" content="Zhang Keyaoo">
<meta property="article:tag" content="PA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/404.jpg">


<title >PA2实验记录</title>

<!-- Favicon -->

    <link href='/assets/favicon.png?v=2.2.4' rel='icon' type='image/png' sizes='16x16' ></link>


    <link href='/assets/favicon.png?v=2.2.4' rel='icon' type='image/png' sizes='32x32' ></link>




<!-- Plugin -->




    
<link rel="stylesheet" href="/css/plugins/bootstrap.row.css">

    
<link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui@4.0/dist/fancybox.css">

    
    




<!-- Icon -->

    
<link rel="stylesheet" href="/css/plugins/font-awesome.min.css">




<!-- Variable -->
<script>window.ASYNC_CONFIG = {"hostname":"example.com","author":"Zhang Keyaoo","root":"/","typed_text":null,"theme_version":"2.2.4","theme":{"switch":true,"default":"style-light"},"favicon":{"logo":"/assets/favicon.svg","icon16":"/assets/favicon.png","icon32":"/assets/favicon.png","apple_touch_icon":null,"webmanifest":null,"visibilitychange":false,"hidden":"/failure.ico","show_text":"(/≧▽≦/)Hey! Good again!","hide_text":"(●—●)Oh, crash!"},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms","author":"Post author: ","copyright_link":"Post link: ","copyright_license_title":"Copyright Notice: ","copyright_license_content":"All articles in this blog are licensed under undefined unless otherwise stated.","copy_success":"Copied","copy_failure":"Copy failed","open_read_mode":"Enter reading mode","exit_read_mode":"Exit reading mode","notice_outdate_message":"It has been undefined days since the last update, the content of the article may be outdated.","sticky":"TOP","just":"Just","min":"minutes ago","hour":"hours ago","day":"days ago","month":"months ago"},"swup":false,"plugin":{"flickr_justified_gallery":"https://unpkg.com/flickr-justified-gallery@latest/dist/fjGallery.min.js"},"icons":{"sun":"far fa-sun","moon":"far fa-moon","play":"fas fa-play","email":"far fa-envelope","next":"fas fa-arrow-right","calendar":"far fa-calendar-alt","clock":"far fa-clock","user":"far fa-user","back_top":"fas fa-arrow-up","close":"fas fa-times","search":"fas fa-search","reward":"fas fa-hand-holding-usd","toc_tag":"fas fa-th-list","read":"fas fa-book-reader","arrows":"fas fa-arrows-alt-h","double_arrows":"fas fa-angle-double-down","copy":"fas fa-copy"},"icontype":"font","highlight":{"plugin":"highlighjs","theme":true,"copy":true,"lang":true,"title":"default","height_limit":false},"toc":{"post_title":false},"live_time":{"start_time":"02/20/2025 00:00:00","prefix":"The blog has been lovely to run undefined day"},"danmu":{"enable":false,"el":".trm-banner"},"search":{"enable":true,"type":"local","href":"https://www.google.com/search?q=site:","domain":null,"path":"search.xml"}};</script>
<script id="async-page-config">window.PAGE_CONFIG = {"isPost":true,"isHome":false,"postUpdate":"2025-02-25 22:48:31"};</script>

<!-- Theme mode css -->
<link data-swup-theme rel="stylesheet" href="/css/index.css?v=2.2.4" id="trm-switch-style">
<script>
    let defaultMode = ASYNC_CONFIG.theme.default !=='auto' ?  ASYNC_CONFIG.theme.default : (window.matchMedia("(prefers-color-scheme: light)").matches ? 'style-light' : 'style-dark')
    let catchMode = localStorage.getItem('theme-mode') || defaultMode;
    let type = catchMode === 'style-dark' ? 'add' : 'remove';
    document.documentElement.classList[type]('dark')
</script>

<!-- CDN -->


    
    



<!-- Site Analytics -->

 
<meta name="generator" content="Hexo 7.3.0"></head>

<body>

  <!-- app wrapper -->
  <div class="trm-app-frame">

    <!-- page preloader -->
    <div class="trm-preloader">
    <div class="trm-holder">
        <div class="preloader">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
</div>
    <!-- page preloader end -->

    <!-- change mode preloader -->
    <div class="trm-mode-swich-animation-frame">
    <div class="trm-mode-swich-animation">
        <i class="i-sun"><i class="iconfont far fa-sun"></i></i>
        <div class="trm-horizon"></div>
        <i class="i-moon"><i class="iconfont far fa-moon"></i></i>
    </div>
</div>
    <!-- change mode preloader end -->

      <!-- scroll container -->
      <div id="trm-dynamic-content" class="trm-swup-animation">
        <div id="trm-scroll-container" class="trm-scroll-container" style="opacity: 0">
            <!-- top bar -->
            <header class="trm-top-bar">
	<div class="container">
		<div class="trm-left-side">
			<!-- logo -->
<a href="/" class="trm-logo-frame trm-anima-link">
    
        <img alt="logo" src="/assets/favicon.svg">
    
    
        <div class="trm-logo-text">
            Zhang<span>Keyaoo</span>
        </div>
    
</a>
<!-- logo end -->
		</div>
		<div class="trm-right-side">
			<!-- menu -->
<div class="trm-menu">
    <nav>
        <ul>
            
            <li class="menu-item-has-children ">
                <a  href="/" target="">
                    主页
                </a>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a  href="/archives/" target="">
                    归档
                </a>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a  href="/categories/" target="">
                    分类
                </a>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a  href="/tags/" target="">
                    标签
                </a>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a  href="/links/" target="">
                    友链
                </a>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a  href="/about/" target="">
                    关于
                </a>
                
            </li>
            
        </ul>
    </nav>
</div>
<!-- menu end -->
			
    <!-- mode switcher place -->
    <div class="trm-mode-switcher-place">
        <div class="trm-mode-switcher">
            <i class="iconfont far fa-sun"></i>
            <input class="tgl tgl-light" id="trm-swich" type="checkbox">
            <label class="trm-swich" for="trm-swich"></label>
            <i class="iconfont far fa-moon"></i>
        </div>
    </div>
    <!-- mode switcher place end -->

			
    
    <div id="trm-search-btn" class="trm-search-btn">
        <i class="iconfont fas fa-search"></i>
    </div>
     

		</div>
		<div class="trm-menu-btn">
			<span></span>
		</div>
	</div>
</header>
            <!-- top bar end -->

            <!-- body -->
            
<div class="trm-content-start">
    <!-- banner -->
    <div class="trm-banner">
    
    <!-- banner cover -->
    <img style="object-position:top;object-fit:cover;" alt="banner" class="trm-banner-cover" src="/assets/banner.png">
    <!-- banner cover end -->
    

    <!-- banner content -->
    <div class="trm-banner-content trm-overlay">
        <div class="container">
            <div class="row">
                
                <div class="col-lg-4"></div>
                
                <div class="col-lg-8">

                    <!-- banner title -->
                    <div class="trm-banner-text ">
                        <div class="trm-label trm-mb-20">
                            ^_^
                        </div>
                        <h1 class="trm-mb-30 trm-hsmb-font">
                            PA2实验记录
                        </h1>

                        
                            <ul class="trm-breadcrumbs trm-label">
                                <li>
                                    <a href="/" class="trm-anima-link">Home</a>
                                </li>
                                <li>
                                    <span>
                                        2025
                                    </span>
                                </li>
                            </ul>
                        
                    </div>
                    <!-- banner title end -->

                    <!-- scroll hint -->
                    <span id="scroll-triger" class="trm-scroll-hint-frame">
                        <div class="trm-scroll-hint"></div>
                        <span class="trm-label">Scroll down</span>
                    </span>
                    <!-- scroll hint end -->

                </div>
            </div>
        </div>
    </div>
    <!-- banner content end -->
</div>
    <!-- banner end -->
    <div class="container">
        <div class="row">
            
                <div class="trm-page-sidebar col-lg-4 hidden-sm">
                    <!-- main card -->
                    <div class="trm-main-card-frame trm-sidebar">
    <div class="trm-main-card"> 
        <!-- card header -->
<div class="trm-mc-header">
    <div class="trm-avatar-frame trm-mb-20">
        <img alt="Avatar" class="trm-avatar" src="/assets/avatar.jpg">
    </div>
    <h5 class="trm-name trm-mb-15">
        Universe Hamster
    </h5>
    
</div>
<!-- card header end -->
        <!-- sidebar social -->

<div class="trm-divider trm-mb-40 trm-mt-40"></div>
<div class="trm-social">
    
        <a href="https://github.com/zhangkeyaoo" title="github" rel="nofollow" target="_blank">
            <i class="iconfont fab fa-github"></i>
        </a>
    
        <a href="https://space.bilibili.com/28526670?spm_id_from=333.1007.0.0" title="bilibili" rel="nofollow" target="_blank">
            <i class="iconfont fas fa-bold"></i>
        </a>
    
        <a href="/assets/wechat.png" title="wechat" rel="nofollow" target="_blank">
            <i class="iconfont fab fa-weixin"></i>
        </a>
    
</div>

<!-- sidebar social end -->
        <!-- info -->
<div class="trm-divider trm-mb-40 trm-mt-40"></div>
<ul class="trm-table trm-mb-20">
    
        <li>
            <div class="trm-label">
                school:
            </div>
            <div class="trm-label trm-label-light">
                Nanjing University
            </div>
        </li>
    
        <li>
            <div class="trm-label">
                birth:
            </div>
            <div class="trm-label trm-label-light">
                2005.06.15
            </div>
        </li>
    
        <li>
            <div class="trm-label">
                email:
            </div>
            <div class="trm-label trm-label-light">
                231250159@smail.nju.edu.cn
            </div>
        </li>
    
        <li>
            <div class="trm-label">
                qq:
            </div>
            <div class="trm-label trm-label-light">
                3313720023
            </div>
        </li>
    
</ul>
<!-- info end -->

        
    <div class="trm-divider trm-mb-40 trm-mt-40"></div>
    <!-- action button -->
    <div class="text-center">
        <a href="mailto:231250159@smail.nju.edu.cn" class="trm-btn">
            Contact Me
            <i class="iconfont far fa-envelope"></i>
        </a>
    </div>
    <!-- action button end -->

    </div>
</div>
                    <!-- main card end -->
                </div>
            
            <div class="trm-page-content col-lg-8">
                <div id="trm-content" class="trm-content">
                    <div class="trm-post-info row hidden-sm">
    <div class="col-sm-4">
        <div class="trm-card trm-label trm-label-light text-center">
            <i class="iconfont far fa-calendar-alt trm-icon"></i><br>
            02/25
        </div>
    </div>
    <div class="col-sm-4">
        <div class="trm-card trm-label trm-label-light text-center">
            <i class="iconfont far fa-clock trm-icon"></i><br>
            22:48
        </div>
    </div>
    <div class="col-sm-4">
        <div id="post-author" class="trm-card trm-label trm-label-light text-center">
            <i class="iconfont far fa-user trm-icon"></i><br>
            Zhang Keyaoo
        </div>
    </div>
</div>
<div class="trm-card ">
    <article id="article-container" class="trm-publication">
    <h1 id="PA2-简单复杂的机器-冯诺依曼计算机系统"><a href="#PA2-简单复杂的机器-冯诺依曼计算机系统" class="headerlink" title="PA2 - 简单复杂的机器: 冯诺依曼计算机系统"></a>PA2 - 简单复杂的机器: 冯诺依曼计算机系统</h1><ul>
<li>首先切换到pa2分支</li>
<li>task PA2.1: 实现更多的指令, 在NEMU中运行大部分<code>cpu-tests</code></li>
<li>task PA2.2: 实现klib和基础设施</li>
<li>task PA2.3: 运行FCEUX, 提交完整的实验报告</li>
</ul>
<h1 id="不停计算的机器"><a href="#不停计算的机器" class="headerlink" title="不停计算的机器"></a>不停计算的机器</h1><ul>
<li>CPU究竟是怎么执行一条指令的：<ul>
<li>对于大部分指令来说, 执行它们都可以抽象成<strong>取指-译码-执行</strong>的<strong>指令周期</strong>.</li>
</ul>
</li>
<li>计算机不断重复下面四个步骤</li>
</ul>
<h3 id="1-取指-instruction-fetch-IF"><a href="#1-取指-instruction-fetch-IF" class="headerlink" title="1.取指(instruction fetch, IF)"></a>1.取指(instruction fetch, IF)</h3><ul>
<li>“存储控制，程序控制”——<strong>指令在存储器中, 由PC指出当前指令的位置</strong>.<ul>
<li>事实上, PC就是一个指针</li>
</ul>
</li>
<li>取指令要做的事情：将<strong>PC指向的指令</strong>从<strong>内存</strong>读入到<strong>CPU</strong>中.</li>
</ul>
<h3 id="2-译码-instruction-decode-ID"><a href="#2-译码-instruction-decode-ID" class="headerlink" title="2.译码(instruction decode, ID)"></a>2.译码(instruction decode, ID)</h3><ul>
<li>取指后发现是个01组成的比特串</li>
<li>指令是做什么的：CPU是用来处理数据的, 指令则是用来指示CPU具体对<em>什么数据</em>进行<em>什么样的处理</em>.  <ul>
<li>CPU需要从指令中解读出”<strong>操作码</strong>“和”<strong>操作数</strong>“两部分信息</li>
</ul>
</li>
<li>译码：CPU拿到一条指令之后, 可以通过<strong>查表</strong>的方式得知这条指令的操作数和操作码.</li>
</ul>
<h3 id="3-执行-execute-EX"><a href="#3-执行-execute-EX" class="headerlink" title="3.执行(execute, EX)"></a>3.执行(execute, EX)</h3><ul>
<li>执行阶段就是真正完成指令的工作</li>
</ul>
<h3 id="4-更新PC"><a href="#4-更新PC" class="headerlink" title="4.更新PC"></a>4.更新PC</h3><ul>
<li>执行完一条指令之后, CPU就要<strong>执行下一条指令</strong>. 在这之前, CPU需要更新PC的值</li>
<li>让PC<strong>加上刚才执行完的指令的长度</strong>, 即可指向下一条指令的位置.</li>
</ul>
<h2 id="YEMU-一个简单的CPU模拟器"><a href="#YEMU-一个简单的CPU模拟器" class="headerlink" title="YEMU: 一个简单的CPU模拟器"></a>YEMU: 一个简单的CPU模拟器</h2><ul>
<li>一个简单计算机：<ul>
<li>有4个8位的寄存器, 一个4位PC, 以及一段16字节的内存.</li>
<li>它支持R型和M型两种指令格式, 4条指令.</li>
</ul>
</li>
</ul>
<h4 id="必做：理解YEMU如何执行程序"><a href="#必做：理解YEMU如何执行程序" class="headerlink" title="必做：理解YEMU如何执行程序"></a>必做：理解YEMU如何执行程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YEMU可以看成是一个简化版的NEMU, 它们的原理是相通的, 因此你需要理解YEMU是如何执行程序的. 具体地, 你需要</span><br><span class="line">    1. 画出在YEMU上执行的加法程序的状态机</span><br><span class="line">    2. 通过RTFSC理解YEMU如何执行一条指令</span><br><span class="line">思考一下, 以上两者有什么联系?</span><br></pre></td></tr></table></figure>
<ol>
<li>画出在YEMU上执行的加法程序的状态机</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+---------+    +---------+    +---------+    +---------+    +---------+</span><br><span class="line">|         |    |         |    |         |    |         |    |         |</span><br><span class="line">|  取指    +---&gt;|  译码   +---&gt;|  加法    +---&gt;|  写回    +---&gt;|  更新PC |</span><br><span class="line">|         |    |         |    |         |    |         |    |         |</span><br><span class="line">+---------+    +---------+    +---------+    +---------+    +---------+</span><br><span class="line">                                                        |</span><br><span class="line">                                                        v</span><br><span class="line">                                                    +---------+</span><br><span class="line">                                                    |         |</span><br><span class="line">                                                    |  结束   |</span><br><span class="line">                                                    |         |</span><br><span class="line">                                                    +---------+</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>通过RTFSC理解YEMU如何执行一条指令<ol>
<li>取指</li>
</ol>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.inst = M[pc]; <span class="comment">// 从内存中取出当前PC指向的指令</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>译码</li>
</ol>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (this.rtype.op) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>执行<ul>
<li>对于操作码0b0000 (复制操作):</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0b0000</span>: &#123; DECODE_R(this); R[rt] = R[rs]; <span class="keyword">break</span>; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于操作码0b0001 (加法操作):</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0b0001</span>: &#123; DECODE_R(this); R[rt] += R[rs]; <span class="keyword">break</span>; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于操作码0b1110 (从内存加载):</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0b1110</span>: &#123; DECODE_M(this); R[<span class="number">0</span>] = M[addr]; <span class="keyword">break</span>; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于操作码0b1111 (存储到内存):</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0b1111</span>: &#123; DECODE_M(this); M[addr] = R[<span class="number">0</span>]; <span class="keyword">break</span>; &#125;</span><br></pre></td></tr></table></figure></li>
<li>更新PC</li>
</ol>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pc ++; <span class="comment">// 更新PC</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>结束<ul>
<li>如果遇到无效指令:</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Invalid instruction with opcode = %x, halting...\n&quot;</span>, this.rtype.op);</span><br><span class="line">halt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>两者联系<ul>
<li>状态机图展示了YEMU执行加法程序的各个阶段，从取指到更新PC，再到结束。</li>
<li>RTFSC分析展示了这些阶段在代码中的具体实现。</li>
</ul>
</li>
</ol>
<h1 id="RTFSC-2"><a href="#RTFSC-2" class="headerlink" title="RTFSC(2)"></a>RTFSC(2)</h1><h2 id="RTFM"><a href="#RTFM" class="headerlink" title="RTFM"></a>RTFM</h2><ul>
<li>决定往TRM中添加各种高效指令</li>
<li>ISA手册(riscv32)中一般都会有以下内容, 尝试RTFM并寻找这些内容的位置:<ol>
<li>每一条指令具体行为的描述</li>
<li>指令opcode的编码表格</li>
</ol>
<ul>
<li>在PA中, riscv32的客户程序只会由RV32I和RV32M两类指令组成</li>
</ul>
</li>
<li>例子：在RISC-V手册中查找加法指令<code>ADD</code>的具体行为的描述和操作码编码表格<ol>
<li>具体行为的描述<ul>
<li><code>ADD rd, rs1, rs2</code>：将寄存器rs1和rs2的值相加，并将结果存储到寄存器rd中。</li>
<li>功能：rd &#x3D; rs1 + rs2</li>
<li>操作数：rd、rs1、rs2</li>
<li>执行结果：rd中存储相加结果</li>
<li>副作用：无</li>
</ul>
</li>
<li>操作码编码表格<ul>
<li>操作码：0b0110011</li>
<li>功能码：0b000</li>
<li>表格：</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------+---------+---------+---------+---------+---------+</span><br><span class="line">| funct7  | rs2     | rs1     | funct3  | rd      | opcode  |</span><br><span class="line">+---------+---------+---------+---------+---------+---------+</span><br><span class="line">| 0000000 | rs2(5)  | rs1(5)  | 000     | rd(5)   | 0110011 |</span><br><span class="line">+---------+---------+---------+---------+---------+---------+</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="RTFSC-2-1"><a href="#RTFSC-2-1" class="headerlink" title="RTFSC(2)"></a>RTFSC(2)</h2><ul>
<li>介绍NEMU的框架代码如何实现指令的执行.</li>
</ul>
<h4 id="NEMU-ISA相关的API说明文档"><a href="#NEMU-ISA相关的API说明文档" class="headerlink" title="NEMU ISA相关的API说明文档"></a>NEMU ISA相关的API说明文档</h4><ul>
<li>全局类型<ul>
<li><code>word_t</code>表示与ISA字长等长的<strong>无符号</strong>类型, 在32位的ISA中为uint32_t</li>
<li><code>sword_t</code>表示与ISA字长等长的<strong>有符号</strong>类型, 在32位的ISA中为int32_t</li>
<li><code>char *FMT_WORD</code>word_t类型对应的十六进制格式化说明符, 在32位的ISA中为”0x%08x”</li>
</ul>
</li>
<li>Monitor相关<ul>
<li><code>unsigned char isa_logo[];</code>用于在未实现指令的报错信息中提示开发者阅读相关的手册.</li>
<li>&#96;&#96;word_t RESET_VECTOR;&#96;表示<strong>PC的初始值</strong>.</li>
<li><code>void init_isa();</code>在<strong>monitor初始化</strong>时调用, 进行至少如下ISA相关的初始化工作:<ul>
<li>设置必要的<strong>寄存器初值</strong>, 如PC等</li>
<li>加载<strong>内置客户程序</strong></li>
</ul>
</li>
</ul>
</li>
<li>寄存器相关<ul>
<li><pre><code>  struct &#123;
  // ...
  word_t pc;
  &#125; CPU_state;
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        寄存器结构的类型定义, 其中必须包含一个名为pc, 类型为word_t的成员.</span><br><span class="line">    - ``CPU_state cpu;``寄存器结构的全局定义.</span><br><span class="line">    - ``void isa_reg_display();``打印寄存器当前的值.</span><br><span class="line">    - ``word_t isa_reg_str2val(const char *name, bool *success);``若存在名称为name的寄存器, 则返回其当前值, 并设置success为true; 否则设置success为false.</span><br><span class="line">- 指令执行相关</span><br><span class="line">    - ```</span><br><span class="line">        struct &#123;</span><br><span class="line">        // ...</span><br><span class="line">        &#125; ISADecodeInfo;</span><br></pre></td></tr></table></figure>
  用于存放ISA相关的译码信息, 会嵌入在译码信息结构体Decode的定义中.
</code></pre>
</li>
<li><code>int isa_exec_once(Decode *s);</code>取出<strong>s-&gt;pc指向的指令</strong>并译码<strong>执行</strong>, 同时<strong>更新s-&gt;snpc</strong>.</li>
</ul>
</li>
<li>虚拟内存相关<ul>
<li><code>int isa_mmu_check(vaddr_t vaddr, int len, int type);</code>检查当前系统状态下对内存区间为(vaddr, vaddr + len), 类型为type的访问是否需要经过地址转换.</li>
<li><code>paddr_t isa_mmu_translate(vaddr_t vaddr, int len, int type);</code>对内存区间为(vaddr, vaddr + len), 类型为type的内存访问进行地址转换.</li>
</ul>
</li>
<li>中断异常相关<ul>
<li><code>vaddr_t isa_raise_intr(word_t NO, vaddr_t epc);</code>抛出一个号码为NO的异常, 其中epc为触发异常的指令PC, 返回异常处理的出口地址.</li>
<li><code>word_t isa_query_intr();</code>查询当前是否有未处理的中断, 若有则返回中断号码, 否则返回INTR_EMPTY.</li>
</ul>
</li>
<li>DiffTest相关<ul>
<li><code>bool isa_difftest_checkregs(CPU_state *ref_r, vaddr_t pc);</code>检查当前的寄存器状态是否与ref_r相同, 其中pc为cpu.pc的上一条动态指令的PC, 即cpu.pc的旧值. 如果状态相同, 则返回true, 否则返回false.</li>
<li><code>void isa_difftest_attach();</code>将当前的所有状态同步到REF, 并在之后的执行中开启DiffTest.</li>
</ul>
</li>
</ul>
<h3 id="取指-instruction-fetch-IF"><a href="#取指-instruction-fetch-IF" class="headerlink" title="取指(instruction fetch, IF)"></a>取指(instruction fetch, IF)</h3><ol>
<li>在NEMU中, 有一个函数<code>inst_fetch()</code>(在<code>nemu/include/cpu/ifetch.h</code>中定义)专门负责取指令的工作.</li>
<li><code>inst_fetch()</code>最终会根据参数<strong>len</strong>来调用<code>vaddr_ifetch()</code>(在<code>nemu/src/memory/vaddr.c</code>中定义), 而目前<code>vaddr_ifetch()</code>又会通过<code>paddr_read()</code>来<strong>访问物理内存中的内容</strong>.</li>
</ol>
<ul>
<li>取指操作的本质：一次内存的访存</li>
</ul>
<ol start="3">
<li><code>isa_exec_once()</code>在调用<code>inst_fetch()</code>的时候<strong>传入了s-&gt;snpc的地址</strong>, 因此inst_fetch()最后还会根据len来<strong>更新s-&gt;snpc</strong>, 从而让s-&gt;snpc<strong>指向下一条指令</strong>.</li>
</ol>
<h3 id="译码-instruction-decode-ID"><a href="#译码-instruction-decode-ID" class="headerlink" title="译码(instruction decode, ID)"></a>译码(instruction decode, ID)</h3><h4 id="指令的具体操作"><a href="#指令的具体操作" class="headerlink" title="指令的具体操作"></a>指令的具体操作</h4><ul>
<li>代码进入<code>decode_exec()</code>函数, 它首先进行的是译码相关的操作<ul>
<li>译码的目的是得到<em>指令的操作</em>和<em>操作对象</em>, 这主要是通过查看指令的<strong>opcode</strong>来决定的</li>
</ul>
</li>
<li>NEMU的译码方式：<strong>模式匹配</strong>, NEMU可以通过一个模式字符串来指定指令中opcode</li>
<li>riscv32中有如下模式:例子（<code>auipc</code>指令，是<em>将当前PC值与立即数相加并写入寄存器</em>）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSTPAT_START();</span><br><span class="line">INSTPAT(<span class="string">&quot;??????? ????? ????? ??? ????? 00101 11&quot;</span>, auipc, U, R(rd) = s-&gt;pc + imm);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">INSTPAT_END();</span><br></pre></td></tr></table></figure>
<ul>
<li>其中<code>INSTPAT</code>(意思是instruction pattern)是一个<strong>宏</strong>(在nemu&#x2F;include&#x2F;cpu&#x2F;decode.h中定义), 它用于定义一条模式匹配规则. 其格式如下:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSTPAT(模式字符串, 指令名称, 指令类型, 指令执行操作);</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>模式字符串</strong>中只允许出现4种字符:<ol>
<li>0表示相应的位只能匹配0</li>
<li>1表示相应的位只能匹配1</li>
<li>?表示相应的位可以匹配0或1</li>
<li>空格是分隔符, 只用于提升模式字符串的可读性, 不参与匹配</li>
</ol>
</li>
<li><strong>指令名称</strong>在代码中仅当注释使用, 不参与宏展开; </li>
<li><strong>指令类型</strong>用于后续译码过程; </li>
<li><strong>指令执行操作</strong>则是通过C代码来模拟指令执行的真正行为.</li>
</ol>
<ul>
<li>此外, nemu&#x2F;include&#x2F;cpu&#x2F;decode.h中还定义了宏INSTPAT_START和INSTPAT_END. INSTPAT又使用了另外两个宏INSTPAT_INST和INSTPAT_MATCH, 它们在nemu&#x2F;src&#x2F;isa&#x2F;$ISA&#x2F;inst.c中定义. </li>
<li>对上述代码进行宏展开并简单整理代码之后, 最后将会得到:  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="type">const</span> <span class="type">void</span> * __instpat_end = &amp;&amp;__instpat_end_;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="type">uint64_t</span> key, mask, shift;</span><br><span class="line">pattern_decode(<span class="string">&quot;??????? ????? ????? ??? ????? 00101 11&quot;</span>, <span class="number">38</span>, &amp;key, &amp;mask, &amp;shift);</span><br><span class="line"><span class="keyword">if</span> ((((<span class="type">uint64_t</span>)s-&gt;isa.inst &gt;&gt; shift) &amp; mask) == key) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="type">int</span> rd = <span class="number">0</span>;</span><br><span class="line">    <span class="type">word_t</span> src1 = <span class="number">0</span>, src2 = <span class="number">0</span>, imm = <span class="number">0</span>;</span><br><span class="line">    decode_operand(s, &amp;rd, &amp;src1, &amp;src2, &amp;imm, TYPE_U);</span><br><span class="line">    R(rd) = s-&gt;pc + imm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> *(__instpat_end);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">__instpat_end_: ; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述代码中的&amp;&amp;__instpat_end_使用了GCC提供的标签地址扩展功能, goto语句将会跳转到最后的__instpat_end_标签. </li>
<li><code>pattern_decode()</code>函数在<code>nemu/include/cpu/decode.h</code>中定义, 它用于<strong>将模式字符串转换成3个整型变量</strong><ul>
<li><code>pattern_decode()</code>函数<em>将模式字符串中的0和1抽取到整型变量key</em>中, <code>mask</code>表示key的<strong>掩码</strong>, 而<code>shift</code>则表示<strong>opcode距离最低位的比特数量</strong>, 用于帮助编译器进行优化.</li>
</ul>
</li>
<li>NEMU取指令的时候会把指令记录到<code>s-&gt;isa.inst</code>中, 此时指令满足上述宏展开的<code>if语句</code>, 表示匹配到auipc指令的编码, 因此将会进行进一步的译码操作.</li>
</ul>
</li>
</ul>
<h4 id="指令的操作对象"><a href="#指令的操作对象" class="headerlink" title="指令的操作对象"></a>指令的操作对象</h4><ul>
<li>eg:已知<code>auipc</code>是将当前PC值与立即数相加并写入寄存器, 但我们还是<em>不知道操作对象</em>(比如立即数是多少, 写入到哪个寄存器).<ul>
<li>调用<code>decode_operand()</code>函数来完成</li>
</ul>
</li>
<li><code>decode_operand()函数</code><ul>
<li>会根据<strong>传入的指令类型type</strong>来进行操作数的译码, </li>
<li>译码<strong>结果</strong>将记录到<strong>函数参数rd, src1, src2和imm中</strong>, 它们分别代表<strong>目的操作数的寄存器号码, 两个源操作数和立即数</strong>.</li>
</ul>
</li>
<li>为了进一步实现<em>操作数译码和指令译码的解耦</em>, 我们对这些操作数的译码进行了<strong>抽象封装</strong>:<ul>
<li>框架代码定义了<code>src1R()</code>和<code>src2R()</code>两个辅助宏, 用于<strong>寄存器的读取结果</strong><em>记录到相应的操作数变量中</em></li>
<li>框架代码还定义了<code>immI</code>等辅助宏, 用于<strong>从指令中抽取出立即数</strong></li>
</ul>
</li>
<li>例如RISC-V中I型指令的译码过程可以通过如下代码实现:  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> TYPE_I: src1R(); immI(); <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="立即数背后的故事"><a href="#立即数背后的故事" class="headerlink" title="立即数背后的故事"></a>立即数背后的故事</h4><ul>
<li>Motorola 68k系列的处理器都是大端架构的. 现在问题来了, 考虑以下两种情况:<ol>
<li>假设我们需要将NEMU运行在Motorola 68k的机器上(把NEMU的源代码编译成Motorola 68k的机器码)</li>
<li>假设我们需要把Motorola 68k作为一个新的ISA加入到NEMU中<br>在这两种情况下, 你需要注意些什么问题? 为什么会产生这些问题? 怎么解决它们?<br>事实上不仅仅是立即数的访问, 长度大于1字节的内存访问都需要考虑类似的问题.</li>
</ol>
</li>
</ul>
<ol>
<li>情况1：将NEMU运行在Motorola 68k的机器上<ul>
<li>问题<ol>
<li>字节序问题<ul>
<li>Motorola 68k是大端架构，而NEMU可能是为小端架构设计的。</li>
<li>需要确保数据在内存中的存储顺序正确。</li>
</ul>
</li>
<li>编译器和工具链<ul>
<li>需要使用支持Motorola 68k架构的编译器和工具链。</li>
<li>可能需要修改Makefile或构建脚本以适应新的编译环境。</li>
</ul>
</li>
<li>系统调用和库函数<ul>
<li>需要确保NEMU使用的系统调用和库函数在Motorola 68k平台上可用。</li>
<li>可能需要对代码进行移植和适配。</li>
</ul>
</li>
</ol>
</li>
<li>解决方案<ol>
<li>字节序处理<ul>
<li>使用条件编译或宏定义来处理大端和小端的差异。</li>
<li>例如：</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> BIG_ENDIAN</span></span><br><span class="line"><span class="comment">// 大端处理代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// 小端处理代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>编译器和工具链<ul>
<li>安装并配置支持Motorola 68k的编译器和工具链。</li>
<li>修改构建脚本以使用新的编译器。</li>
</ul>
</li>
<li>系统调用和库函数<ul>
<li>检查并移植系统调用和库函数，确保它们在Motorola 68k平台上正常工作。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>情况 2: 将Motorola 68k作为一个新的ISA加入到NEMU中<ul>
<li>问题+解决方案<ol>
<li>指令集架构 (ISA) 支持<ul>
<li>需要在NEMU中添加对Motorola 68k指令集的支持。</li>
<li>包括指令的译码、执行和模拟。</li>
</ul>
</li>
<li>寄存器和内存模型<ul>
<li>需要定义Motorola 68k的寄存器和内存模型。</li>
<li>确保模拟器能够正确处理寄存器和内存操作。</li>
</ul>
</li>
<li>异常和中断处理<ul>
<li>需要实现Motorola 68k的异常和中断处理机制。</li>
<li>确保模拟器能够正确模拟这些行为。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="立即数背后的故事-2"><a href="#立即数背后的故事-2" class="headerlink" title="立即数背后的故事(2)"></a>立即数背后的故事(2)</h4><ul>
<li>mips32和riscv32的指令长度只有32位, 因此它们不能像x86那样, 把C代码中的32位常数直接编码到一条指令中. 思考一下, mips32和riscv32应该如何解决这个问题?<ul>
<li>MIPS32和RISC-V32通过组合<strong>使用两条指令</strong>和<strong>伪指令</strong><code>li</code>来加载32位立即数。</li>
</ul>
</li>
</ul>
<h3 id="执行-execute-EX"><a href="#执行-execute-EX" class="headerlink" title="执行(execute, EX)"></a>执行(execute, EX)</h3><ul>
<li>模式匹配规则中指定的<code>指令执行操作</code></li>
<li>译码的结果+C代码——模拟指令执行的真正行为</li>
<li>eg：如对于auipc指令<ul>
<li>由于<code>译码阶段</code>已经把<code>U型立即数</code>记录到操作数<code>imm</code>中了</li>
<li>只需要通过<code>R(rd) = s-&gt;pc + imm</code>将立即数与当前PC值相加并写入目标寄存器中, 这样就完成了指令的执行.</li>
</ul>
</li>
<li>指令执行的阶段结束之后, <code>decode_exec()</code>函数将会返回<code>0</code>, 并一路返回到<code>exec_once()</code>函数中. 不过目前代码并没有使用这个返回值, 因此可以忽略它</li>
</ul>
<h3 id="更新PC"><a href="#更新PC" class="headerlink" title="更新PC"></a>更新PC</h3><ul>
<li>更新PC：把<code>s-&gt;dnpc</code><strong>赋值</strong>给<code>cpu.pc</code></li>
</ul>
<h4 id="静态指令snpc和动态指令dnpc"><a href="#静态指令snpc和动态指令dnpc" class="headerlink" title="静态指令snpc和动态指令dnpc"></a>静态指令snpc和动态指令dnpc</h4><ul>
<li>在程序分析领域中, 静态指令是指程序代码中的指令, 动态指令是指程序运行过程中的指令. 例如对于以下指令序列</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">100: jmp 102</span><br><span class="line">101: add</span><br><span class="line">102: xor</span><br></pre></td></tr></table></figure>
<ul>
<li>jmp指令的下一条静态指令是add指令, 而下一条动态指令则是xor指令.</li>
<li><strong>snpc和dnpc的区别</strong>: <strong>snpc是下一条静态指令, 而dnpc是下一条动态指令</strong><ul>
<li>对于顺序执行的指令, 它们的snpc和dnpc是一样的;</li>
<li>对于跳转指令, snpc和dnpc就会有所不同, <strong>dnpc应该指向跳转目标的指令</strong>.</li>
<li>显然, 我们应该使用<strong>s-&gt;dnpc来更新PC</strong>, 并且<strong>在指令执行的过程中正确地维护s-&gt;dnpc</strong>.</li>
</ul>
</li>
</ul>
<h3 id="结构化程序设计"><a href="#结构化程序设计" class="headerlink" title="结构化程序设计"></a>结构化程序设计</h3><ul>
<li>如果指令集越复杂, 指令之间的共性特征就越多——Copy-Paste的话，维护难度很大！<ul>
<li>对于同一条指令的不同形式, 它们的执行阶段是相同的</li>
<li>对于不同指令的同一种形式, 它们的译码阶段是相同的</li>
<li>对于同一条指令同一种形式的不同操作数宽度</li>
</ul>
</li>
<li>一种好的做法是把译码, 执行和操作数宽度的<em>相关代码分离开来</em>, 实现<strong>解耦</strong>, 也就是在程序设计课上提到的<em>结构化程序设计</em>.</li>
</ul>
<h4 id="必做：RTFSC理解指令执行的过程"><a href="#必做：RTFSC理解指令执行的过程" class="headerlink" title="必做：RTFSC理解指令执行的过程"></a>必做：RTFSC理解指令执行的过程</h4><ul>
<li>请整理一条指令在NEMU中的执行过程</li>
</ul>
<ol>
<li>取指<ul>
<li>从内存中取出当前PC指向的指令</li>
<li>更新PC，指向下一条指令 <code>cpu.pc += 4;</code></li>
</ul>
</li>
<li>译码<ul>
<li>解析指令的操作码&amp;操作数</li>
<li>根据指令类型和操作数，确定指令的具体操作</li>
</ul>
</li>
<li>执行<ul>
<li>根据译码结果执行指令的具体操作<ul>
<li>对于算术运算指令，执行相应的算术运算</li>
<li>对于跳转指令。计算跳转目标地址</li>
</ul>
</li>
</ul>
</li>
<li>访存<ul>
<li>如果指令需要访问内存（加载&#x2F;存储指令）</li>
</ul>
</li>
<li>写回<ul>
<li>将执行结果写回寄存器或内存</li>
</ul>
</li>
<li>更新PC<ul>
<li>在指令执行完毕后，根据指令的类型和执行结果更新PC。</li>
<li>对于顺序执行的指令，PC已经在取指阶段更新过了，这里不需要再次更新。</li>
<li>对于跳转指令，PC需要更新为跳转目标地址。</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpu.pc = s-&gt;dnpc; <span class="comment">// 将dnpc的值赋给cpu.pc，更新PC</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="运行第一个C程序"><a href="#运行第一个C程序" class="headerlink" title="运行第一个C程序"></a>运行第一个C程序</h2><ul>
<li>开始实践啦！</li>
</ul>
<h4 id="必做：准备交叉编译环境"><a href="#必做：准备交叉编译环境" class="headerlink" title="必做：准备交叉编译环境"></a>必做：准备交叉编译环境</h4><ul>
<li>准备相应的gcc和binutils, 才能正确地进行编译</li>
<li>riscv32(64)<ul>
<li><code>apt-get install g++-riscv64-linux-gnu binutils-riscv64-linux-gnu</code></li>
</ul>
</li>
</ul>
<ol>
<li>报错 <code>/usr/riscv64-linux-gnu/include/gnu/stubs.h:8:11: fatal error: gnu/stubs-ilp32.h: No such file or directory</code></li>
<li>键入<code>sudo code --no-sandbox --user-data-dir=/home/xiaoyao/.vscode-root /usr/riscv64-linux-gnu/include/gnu/stubs.h</code></li>
<li>修改</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 32 &amp;&amp; defined __riscv_float_abi_soft</span></span><br><span class="line">-<span class="meta"># <span class="keyword">include</span> <span class="string">&lt;gnu/stubs-ilp32.h&gt;</span></span></span><br><span class="line">+<span class="comment">//# include &lt;gnu/stubs-ilp32.h&gt;</span></span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>报错</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ OBJCOPY -&gt; build/dummy-riscv32-nemu.bin</span><br><span class="line">/bin/sh: 1: python: not found</span><br><span class="line">make[1]: *** [/home/xiaoyao/ics2024/abstract-machine/scripts/platform/nemu.mk:22：insert-arg] 错误 127</span><br><span class="line">test list [1 item(s)]: dummy</span><br><span class="line">[         dummy] ***FAIL***</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>检查python3已安装，则创建python命令的符号链接<code>sudo ln -s /usr/bin/python3 /usr/bin/python</code><ul>
<li><code>python --version</code>确保可用后，重新运行</li>
</ul>
</li>
<li>输入<code>c</code>,报错<ul>
<li>这是因为你还没有实现<code>0x00000413</code>的指令, 因此, 你需要开始在NEMU中添加指令了.</li>
</ul>
</li>
</ol>
<h5 id="为什么执行了未实现指令会出现上述报错信息"><a href="#为什么执行了未实现指令会出现上述报错信息" class="headerlink" title="为什么执行了未实现指令会出现上述报错信息"></a>为什么执行了未实现指令会出现上述报错信息</h5><ul>
<li><p>RTFSC, 理解执行未实现指令的时候, NEMU具体会怎么做.</p>
</li>
<li><p>因为NEMU在执行指令时，会检查指令是否已实现。如果指令未实现，NEMU会触发异常并输出错误信息。</p>
</li>
<li><p>查看反汇编结果<code>am-kernels/tests/cpu-tests/build/dummy-$ISA-nemu.txt</code></p>
<ul>
<li>你只需实现那些目前还没实现的指令</li>
<li>为了实现一条新指令, 你只需要在<code>nemu/src/isa/$ISA/inst.c</code>中添加正确的模式匹配规则即可</li>
</ul>
</li>
</ul>
<h4 id="必做：运行第一个客户程序"><a href="#必做：运行第一个客户程序" class="headerlink" title="必做：运行第一个客户程序"></a>必做：运行第一个客户程序</h4><ul>
<li>在NEMU中<strong>实现上文提到的指令</strong>, 具体细节请务必<strong>参考手册</strong>. 实现成功后, 在NEMU中运行客户程序dummy, 你将会看到HIT GOOD TRAP的信息. 如果你没有看到这一信息, 说明你的指令实现不正确, 你可以使用PA1中实现的简易调试器帮助你调试.</li>
<li>li是一个伪指令，在riscv32里面汇编器会将它替换为lui和&#x2F;或addi<ul>
<li>根据func3字段判断,这里其实是要实现addi指令</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSTPAT(<span class="string">&quot;??????? ????? ????? ??? ????? 00100 11&quot;</span>, li     , I, R(rd) = imm);</span><br></pre></td></tr></table></figure>
<ul>
<li>jal<ol>
<li>添加TYPE_J</li>
<li><code>#define immJ() do &#123; *imm = (SEXT(BITS(i, 31, 31), 1) &lt;&lt; 20) | BITS(i, 30, 21) &lt;&lt; 1| BITS(i, 20, 20) &lt;&lt; 11 | BITS(i, 19, 12) &lt;&lt; 12 ; &#125; while(0)</code></li>
<li><code>case TYPE_J:                  immJ(); break; // 新增 J 类型</code></li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSTPAT(<span class="string">&quot;??????? ????? ????? ??? ????? 11011 11&quot;</span>, jal    , J, R(rd) = s -&gt; pc + <span class="number">4</span>; s -&gt; dnpc += imm <span class="number">-4</span>;); <span class="comment">// jal指令</span></span><br></pre></td></tr></table></figure>
<ul>
<li>sw</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSTPAT(<span class="string">&quot;??????? ????? ????? 010 ????? 01000 11&quot;</span>, sw     , S, Mw(src1 + imm, <span class="number">4</span>, src2)); <span class="comment">// 新增 sw 指令</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>src/cpu/cpu-exec.c:126 cpu_exec] nemu: HIT GOOD TRAP at pc = 0x80000030</code>成功！</li>
</ul>
<h2 id="运行更多的程序"><a href="#运行更多的程序" class="headerlink" title="运行更多的程序"></a>运行更多的程序</h2><ul>
<li>测试用例：<code>am-kernels/tests/cpu-tests/</code><ul>
<li>在该目录下执行<code>make ARCH=$ISA-nemu ALL=xxx run</code><ul>
<li>其中xxx为测试用例的名称(不包含.c后缀).</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="必做：实现更多的指令"><a href="#必做：实现更多的指令" class="headerlink" title="必做：实现更多的指令"></a>必做：实现更多的指令</h4><h5 id="1-add-c"><a href="#1-add-c" class="headerlink" title="1. add.c"></a>1. add.c</h5><ol>
<li>lw<br><code>0x80000078: 00 0a a9 03 lw	s2, 0(s5)</code></li>
</ol>
<ul>
<li><code>INSTPAT(&quot;??????? ????? ????? 010 ????? 00000 11&quot;, lw     , I, R(rd) = Mr(src1 + imm, 4));</code></li>
</ul>
<ol start="2">
<li>add<br><code>0x80000090: 00 a9 05 33 add	a0, s2, a0</code></li>
</ol>
<ul>
<li><code>INSTPAT(&quot;0000000 ????? ????? 000 ????? 01100 11&quot;, add    , R, R(rd) = src1 + src2);</code></li>
</ul>
<ol start="3">
<li>sub<br><code>0x80000094: 40 f5 05 33 sub	a0, a0, a5</code></li>
</ol>
<ul>
<li><code>INSTPAT(&quot;0100000 ????? ????? 000 ????? 01100 11&quot;, sub    , R, R(rd) = src1 - src2);</code></li>
</ul>
<ol start="4">
<li>seqz：<code>0x80000098: 00 15 35 13 seqz	a0, a0</code><ul>
<li>此伪指令的实现原理为，使用SLTIU指令，并将立即数设置为1；此时只有当rs1寄存器值为0时，才能小于立即数，rd寄存器才会被赋值为1：</li>
</ul>
</li>
</ol>
<ul>
<li><code>INSTPAT(&quot;??????? ????? ????? 011 ????? 00100 11&quot;, seqz   , I, R(rd) = (uint32_t)src1 &lt; (uint32_t)imm ? 1: 0);</code></li>
</ul>
<ol start="5">
<li>beqz：<code>0x80000010: 00 05 04 63 beqz	a0, 8</code><ul>
<li>伪指令，可用beq指令来实现</li>
<li><code> INSTPAT(&quot;??????? ????? ????? 000 ????? 11000 11&quot;, beqz   , B, if (src1 == src2) s-&gt;dnpc = s-&gt;pc + imm);</code></li>
<li><code>#define immB() do &#123; *imm = (SEXT(BITS(i, 31, 31), 1) &lt;&lt; 12) | (BITS(i, 7, 7) &lt;&lt; 11) | (BITS(i, 30, 25) &lt;&lt; 5) | (BITS(i, 11, 8) &lt;&lt; 1); &#125; while(0)</code></li>
</ul>
</li>
<li>bne:<code>0x800000a4: fe 89 90 e3 bne	s3, s0, -0x20</code><ul>
<li><code>  INSTPAT(&quot;??????? ????? ????? 001 ????? 11000 11&quot;, bne    , B, if (src1 != src2) s-&gt;dnpc = s-&gt;pc + imm);</code></li>
<li>bne，比较两个寄存器的值，如果它们不相等，则跳转到目标地址</li>
</ul>
</li>
</ol>
<ul>
<li><code>HIT GOOD TRAP at pc = 0x80000120</code>,add.c成功！</li>
</ul>
<h5 id="2-add—longlong-c"><a href="#2-add—longlong-c" class="headerlink" title="2. add—longlong.c"></a>2. add—longlong.c</h5><ol>
<li>sltu:<code>0x800000a0: 01 97 b6 b3 sltu	a3, a5, s9</code><ul>
<li><code>  INSTPAT(&quot;0000000 ????? ????? 011 ????? 01100 11&quot;, sltu   , R, R(rd) = (uint32_t)src1 &lt; (uint32_t)src2 ? 1: 0);</code></li>
<li>sltu，无符号比较两个寄存器的值，如果第一个寄存器的值小于第二个，则将目标寄存器设置为 1，否则设置为 0</li>
</ul>
</li>
<li>xor:<code>0x800000ac: 00 f5 45 33 xor	a0, a0, a5</code><ul>
<li><code>INSTPAT(&quot;0000000 ????? ????? 100 ????? 01100 11&quot;, xor    , R, R(rd) = src1 ^ src2);</code></li>
<li>xor，异或运算，将两个寄存器的值进行异或运算，结果存入目标寄存器</li>
</ul>
</li>
<li>or:<code>0x800000b4: 00 f5 65 33 or	a0, a0, a5</code><ul>
<li><code>INSTPAT(&quot;0000000 ????? ????? 110 ????? 01100 11&quot;, or    , R, R(rd) = src1 | src2);</code></li>
<li>or，或运算，将两个寄存器的值进行或运算，结果存入目标寄存器</li>
</ul>
</li>
</ol>
<ul>
<li><code>HIT GOOD TRAP at pc = 0x80000138</code>,成功！</li>
</ul>
<h5 id="3-bit-c"><a href="#3-bit-c" class="headerlink" title="3. bit.c"></a>3. bit.c</h5><ol>
<li>sh:<code>0x800000bc: 00 f1 16 23 sh	a5, 0xc(sp)</code><ul>
<li><code>INSTPAT(&quot;??????? ????? ????? 001 ????? 01000 11&quot;, sh     , S, Mw(src1 + imm, 2, src2));</code></li>
<li>sh,将src2的低16位存入src1+imm地址</li>
</ul>
</li>
<li>srai:<code>0x80000028: 40 35 d7 93 srai	a5, a1, 3</code><ul>
<li><code>INSTPAT(&quot;0100000 ????? ????? 101 ????? 00100 11&quot;, srai   , I, R(rd) = (int32_t)src1 &gt;&gt; (imm &amp; 0x1F));</code></li>
<li>srai,算术右移，将src1的值右移imm位，空位用src1的符号位填充，结果存入rd</li>
</ul>
</li>
<li>andi:<code>0x80000034: 00 75 f5 93 andi	a1, a1, 7</code><ul>
<li><code>INSTPAT(&quot;??????? ????? ????? 111 ????? 00100 11&quot;, andi   , I, R(rd) = src1 &amp; imm);</code></li>
<li>andi,与立即数，将src1的值与imm进行与运算，结果存入rd</li>
</ul>
</li>
<li>sll:<code>0x8000003c: 00 b7 97 b3 sll	a5, a5, a1</code><ul>
<li><code>INSTPAT(&quot;0000000 ????? ????? 001 ????? 01100 11&quot;, sll    , R, R(rd) = src1 &lt;&lt; (src2 &amp; 0x1F));</code></li>
<li>sll,逻辑左移，将src1的值左移src2位，空位用0填充，结果存入rd</li>
</ul>
</li>
<li>and：<ul>
<li><code>INSTPAT(&quot;0000000 ????? ????? 111 ????? 01100 11&quot;, and    , R, R(rd) = src1 &amp; src2);</code></li>
<li>and,与运算，将src1的值与src2的值进行与运算，结果存入rd</li>
</ul>
</li>
<li>xori:<ul>
<li><code>INSTPAT(&quot;??????? ????? ????? 100 ????? 00100 11&quot;, xori   , I, R(rd) = src1 ^ imm);</code></li>
<li>xori,异或立即数，将src1的值与imm进行异或运算，结果存入rd</li>
</ul>
</li>
</ol>
<ul>
<li><code>HIT GOOD TRAP at pc = 0x8000021c</code>成功！</li>
</ul>
<h5 id="4-bubble-sort-c"><a href="#4-bubble-sort-c" class="headerlink" title="4. bubble-sort.c"></a>4. bubble-sort.c</h5><ol>
<li>blez:<code>0x80000040: 02 b0 50 63 blez	a1, 0x20</code><ul>
<li><code>INSTPAT(&quot;??????? ????? ????? 101 ????? 11000 11&quot;, blez   , B, if (src1 &gt;= src2) s-&gt;dnpc +=imm-4);</code></li>
<li>blez,伪指令可用bgz,当寄存器的值小于等于0时跳转，可用bgez指令实现</li>
</ul>
</li>
</ol>
<ul>
<li><code>HIT GOOD TRAP at pc = 0x80000140</code>成功！</li>
</ul>
<h5 id="5-crc32-c"><a href="#5-crc32-c" class="headerlink" title="5. crc32.c"></a>5. crc32.c</h5><ul>
<li>看<code>tests/cpu-tests/build/crc32-riscv32-nemu.txt</code></li>
</ul>
<ol>
<li>lui:<code>0x80000038: ed b8 88 b7 lui	a7, 0xedb88</code><ul>
<li><code>INSTPAT(&quot;??????? ????? ????? ??? ????? 01101 11&quot;, lui    , U, R(rd) = imm);</code></li>
<li>lui,将imm的值左移12位存入rd</li>
</ul>
</li>
<li>srli:<code>0x8000005c: 00 17 d7 93 srli	a5, a5, 1</code><ul>
<li><code>INSTPAT(&quot;0000000 ????? ????? 101 ????? 00100 11&quot;, srli   , I, R(rd) = (uint32_t)src1 &gt;&gt; (imm &amp; 0x1F));</code></li>
<li>srli,逻辑右移，将src1的值右移imm位，空位用0填充，结果存入rd</li>
</ul>
</li>
<li>bgeu:<code>8000008c:	02c5fc63          	bgeu	a1,a2,800000c4 &lt;rc_crc32+0x9c&gt;</code><ul>
<li><code>INSTPAT(&quot;??????? ????? ????? 111 ????? 11000 11&quot;, bgeu   , B, if ((uint32_t)src1 &gt;= (uint32_t)src2) s-&gt;dnpc = s-&gt;pc + imm);</code></li>
<li>bgeu，无符号比较两个寄存器的值，如果第一个寄存器的值大于等于第二个，则跳转到目标地址</li>
</ul>
</li>
<li>slli:<code>800000a8:	00279793          	slli	a5,a5,0x2</code><ul>
<li><code>   INSTPAT(&quot;0000000 ????? ????? 001 ????? 00100 11&quot;, slli   , I, R(rd) = src1 &lt;&lt; (imm &amp; 0x1F));</code></li>
</ul>
</li>
</ol>
<ul>
<li>slli,逻辑左移，将src1的值左移imm位，空位用0填充，结果存入rd</li>
<li><code>HIT GOOD TRAP at pc = 0x8000012c</code>成功！</li>
</ul>
<h5 id="6-div-c"><a href="#6-div-c" class="headerlink" title="6. div.c"></a>6. div.c</h5><ul>
<li><code>tests/cpu-tests/build/div-riscv32-nemu.txt</code></li>
</ul>
<ol>
<li>mul:<code>8000007c:	02f70733          	mul	a4,a4,a5</code><ul>
<li><code>INSTPAT(&quot;0000001 ????? ????? 000 ????? 01100 11&quot;, mul    , R, R(rd) = src1 * src2);</code></li>
</ul>
</li>
<li>div:<code>800000a8:	02f74733          	div	a4,a4,a5</code><ul>
<li><code>INSTPAT(&quot;0000001 ????? ????? 100 ????? 01100 11&quot;, div    , R, R(rd) = (int32_t)src1 / (int32_t)src2);</code></li>
</ul>
</li>
</ol>
<ul>
<li><code>HIT GOOD TRAP at pc = 0x80000124</code>成功！</li>
</ul>
<h5 id="7-fact-c-fib-c"><a href="#7-fact-c-fib-c" class="headerlink" title="7. fact.c+fib.c"></a>7. fact.c+fib.c</h5><ul>
<li>直接<code>HIT GOOD TRAP</code>了</li>
</ul>
<h5 id="8-goldbach-c"><a href="#8-goldbach-c" class="headerlink" title="8. goldbach.c"></a>8. goldbach.c</h5><ol>
<li>rem:<code>8000007c:	02f666b3          	rem	a3,a2,a5</code><ul>
<li><code>INSTPAT(&quot;0000001 ????? ????? 110 ????? 01100 11&quot;, rem    , R, R(rd) = (int32_t)src1 % (int32_t)src2);</code></li>
<li>求余</li>
</ul>
</li>
</ol>
<ul>
<li><code>HIT GOOD TRAP at pc = 0x80000118</code>成功</li>
</ul>
<h5 id="9-if-else-c"><a href="#9-if-else-c" class="headerlink" title="9. if-else.c"></a>9. if-else.c</h5><ol>
<li>blt:<code>80000080:	02f94063          	blt	s2,a5,800000a0 &lt;main+0x78&gt;</code><ul>
<li><code>INSTPAT(&quot;??????? ????? ????? 100 ????? 11000 11&quot;, blt    , B, if ((int32_t)src1 &lt;(int32_t)src2) s-&gt;dnpc += imm-4);</code></li>
<li>blt,比较两个寄存器的值，如果第一个小于第二个，则跳转到目标地址</li>
</ul>
</li>
<li>slt:<code>80000084:	00fa2733          	slt	a4,s4,a5</code><ul>
<li><code>INSTPAT(&quot;0000000 ????? ????? 010 ????? 01100 11&quot;, slt    , R, R(rd) = (int32_t)src1 &lt; (int32_t)src2 ? 1 : 0);</code></li>
<li>slt,有符号比较两个寄存器的值，如果第一个寄存器的值小于第二个，则将目标寄存器设置为 1，否则设置为 0</li>
</ul>
</li>
</ol>
<ul>
<li><code>HIT GOOD TRAP at pc = 0x80000110</code>成功！</li>
</ul>
<h5 id="10-leap-year-c-load-store-c"><a href="#10-leap-year-c-load-store-c" class="headerlink" title="10. leap-year.c+load-store.c"></a>10. leap-year.c+load-store.c</h5><ul>
<li><code>HIT GOOD TRAP at pc = 0x800000dc</code></li>
</ul>
<ol>
<li>lh:<code>80000064:	00049503          	lh	a0,0(s1)</code><ul>
<li><code>INSTPAT(&quot;??????? ????? ????? 001 ????? 00000 11&quot;, lh     , I, R(rd) = SEXT(Mr(src1 + imm, 2), 16));</code></li>
<li>lh,将src1+imm地址的值的低16位存入rd</li>
</ul>
</li>
<li>lhu:<code>8000008c:	00045503          	lhu	a0,0(s0)</code><ul>
<li><code>INSTPAT(&quot;??????? ????? ????? 101 ????? 00000 11&quot;, lhu    , I, R(rd) = Mr(src1 + imm, 2));</code></li>
<li>lhu,将src1+imm地址的值存入rd</li>
</ul>
</li>
</ol>
<ul>
<li><code>HIT GOOD TRAP at pc = 0x800001ec</code></li>
</ul>
<h5 id="11-matrix-mul-c-max-c"><a href="#11-matrix-mul-c-max-c" class="headerlink" title="11. matrix-mul.c+max.c"></a>11. matrix-mul.c+max.c</h5><ul>
<li><code>HIT GOOD TRAP at pc = 0x8000015c</code></li>
<li>出错：<code>0x8000008c: 01 25 54 63 bge	a0, s2, 8</code></li>
<li>bge：<code>INSTPAT(&quot;??????? ????? ????? 101 ????? 11000 11&quot;, blez   , B, if ((int)src1 &gt;= (int)src2) s-&gt;dnpc +=imm-4); </code><ul>
<li>无符号改成有符号（加上（int））！</li>
</ul>
</li>
<li><code>HIT GOOD TRAP at pc = 0x80000124</code></li>
</ul>
<h5 id="12-mersenne-c"><a href="#12-mersenne-c" class="headerlink" title="12. mersenne.c"></a>12. mersenne.c</h5><ol>
<li>mulh:<code>80000098:	02f795b3          	mulh	a1,a5,a5</code><ul>
<li><code>INSTPAT(&quot;0000001 ????? ????? 001 ????? 01100 11&quot;, mulh   , R, R(rd) = ((int64_t)src1 * (int64_t)src2) &gt;&gt; 32);</code></li>
</ul>
</li>
<li>remu:<code>8000018c:	02c577b3          	remu	a5,a0,a2</code><ul>
<li><code>INSTPAT(&quot;0000001 ????? ????? 111 ????? 01100 11&quot;, remu   , R, R(rd) = (uint32_t)src1 % (uint32_t)src2);</code></li>
<li>remu,无符号数，求余数</li>
</ul>
</li>
<li>divu:<code>80000198:	03695533          	divu	a0,s2,s6</code><ul>
<li><code>INSTPAT(&quot;0000001 ????? ????? 101 ????? 01100 11&quot;, divu   , R, R(rd) = (uint32_t)src1 / (uint32_t)src2);</code></li>
</ul>
</li>
</ol>
<ul>
<li><code>HIT GOOD TRAP at pc = 0x80000144</code></li>
</ul>
<h5 id="13-min3-c-mov-c-c-movsx-c-mul-longlong-c"><a href="#13-min3-c-mov-c-c-movsx-c-mul-longlong-c" class="headerlink" title="13. min3.c+mov-c.c+movsx.c+mul-longlong.c"></a>13. min3.c+mov-c.c+movsx.c+mul-longlong.c</h5><ul>
<li><code>HIT GOOD TRAP at pc = 0x80000170</code></li>
<li><code>HIT GOOD TRAP at pc = 0x80000124</code></li>
<li><code>HIT GOOD TRAP at pc = 0x800001d0</code></li>
<li><code>HIT BAD TRAP at pc = 0x80000140</code>!!</li>
<li>mul有问题，改：<code>  INSTPAT(&quot;0000001 ????? ????? 001 ????? 01100 11&quot;, mulh   , R, int32_t a1 = src1; int32_t a2 = src2; int64_t tmp = (int64_t)a1 * (int64_t)a2; R(rd) = BITS(tmp, 63, 32));</code></li>
<li>为什么原方法不对：<ol>
<li>符号扩展问题：<ul>
<li>src1 和 src2 被直接转换为 int64_t 类型。如果 src1 和 src2 是负数，符号扩展可能会导致错误的结果。</li>
<li>通过将 src1 和 src2 显式转换为 int32_t 类型，然后再转换为 int64_t 类型，确保了符号扩展的正确性。</li>
</ul>
</li>
<li>位移操作的行为：<ul>
<li>若乘积直接右移 32 位。如果乘积是负数，右移操作可能会保留符号位，导致错误的结果。</li>
<li>而通过使用 BITS 宏提取特定位数，确保了结果的正确性。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h5 id="14-pascal-c-prime-c-quick-sort-c-recursion-c-select-sort-c-shuixianhua-c"><a href="#14-pascal-c-prime-c-quick-sort-c-recursion-c-select-sort-c-shuixianhua-c" class="headerlink" title="14. pascal.c + prime.c + quick-sort.c + recursion.c + select-sort.c + shuixianhua.c"></a>14. pascal.c + prime.c + quick-sort.c + recursion.c + select-sort.c + shuixianhua.c</h5><ul>
<li><code>HIT GOOD TRAP at pc = 0x80000128</code></li>
<li><code>HIT GOOD TRAP at pc = 0x800000dc</code></li>
<li><code>HIT GOOD TRAP at pc = 0x800003cc</code></li>
<li><code>HIT GOOD TRAP at pc = 0x8000026c</code></li>
<li><code>HIT GOOD TRAP at pc = 0x8000015c</code></li>
<li><code>HIT GOOD TRAP at pc = 0x8000011c</code></li>
</ul>
<h5 id="15-shift-c"><a href="#15-shift-c" class="headerlink" title="15. shift.c"></a>15. shift.c</h5><ol>
<li>sra:<code>800000a8:	40855533          	sra	a0,a0,s0</code><ul>
<li><code>INSTPAT(&quot;0100000 ????? ????? 101 ????? 01100 11&quot;, sra    , R, R(rd) = (int32_t)src1 &gt;&gt; (src2 &amp; 0x1F));</code></li>
<li>sra,算术右移，将src1的值右移src2位，空位用src1的符号位填充，结果存入rd</li>
</ul>
</li>
<li>srl:<code>800000e0:	00855533          	srl	a0,a0,s0</code><ul>
<li><code>INSTPAT(&quot;0000000 ????? ????? 101 ????? 01100 11&quot;, srl    , R, R(rd) = (uint32_t)src1 &gt;&gt; (src2 &amp; 0x1F));</code></li>
<li>srl,逻辑右移，将src1的值右移src2位，空位用0填充，结果存入rd</li>
</ul>
</li>
</ol>
<ul>
<li><code>HIT GOOD TRAP at pc = 0x80000144</code></li>
</ul>
<h5 id="16-sub-longlong-c-sum-c-switch-c-to-lower-case-c-unalign-c-wanshu-c"><a href="#16-sub-longlong-c-sum-c-switch-c-to-lower-case-c-unalign-c-wanshu-c" class="headerlink" title="16. sub-longlong.c + sum.c + switch.c + to-lower-case.c + unalign.c + wanshu.c"></a>16. sub-longlong.c + sum.c + switch.c + to-lower-case.c + unalign.c + wanshu.c</h5><ul>
<li><code>HIT GOOD TRAP at pc = 0x80000138</code></li>
<li><code>HIT GOOD TRAP at pc = 0x8000009c</code></li>
</ul>
<ol>
<li>bltu:<code>80000070:	009a6463          	bltu	s4,s1,80000078 &lt;main+0x50&gt;</code><ul>
<li><code>INSTPAT(&quot;??????? ????? ????? 110 ????? 11000 11&quot;, bltu   , B, if ((uint32_t)src1 &lt; (uint32_t)src2) s-&gt;dnpc = s-&gt;pc + imm);</code></li>
<li>bltu，无符号比较两个寄存器的值，如果第一个寄存器的值小于第二个，则跳转到目标地址</li>
</ul>
</li>
</ol>
<ul>
<li><code>HIT GOOD TRAP at pc = 0x800000e8</code></li>
<li><code>HIT GOOD TRAP at pc = 0x800000d4</code></li>
<li><code>HIT GOOD TRAP at pc = 0x80000144</code></li>
<li><code>HIT GOOD TRAP at pc = 0x80000104</code></li>
</ul>
<h5 id="ps-hello-str-c和string-c"><a href="#ps-hello-str-c和string-c" class="headerlink" title="ps:hello-str.c和string.c"></a>ps:hello-str.c和string.c</h5><ul>
<li>还需要实现额外的内容才能运行(具体在后续小节介绍), 目前可以先使用其它测试用例进行测试.</li>
</ul>
<h4 id="mips32的分支延迟槽"><a href="#mips32的分支延迟槽" class="headerlink" title="mips32的分支延迟槽"></a>mips32的分支延迟槽</h4><ul>
<li>为了提升处理器的性能, mips使用了一种叫<strong>分支延迟槽</strong>的技术。</li>
<li>程序的执行顺序发生一些改变: <ul>
<li>把<em>紧跟在跳转指令(包括有条件和无条件)之后</em>的<em>静态指令</em>称为<strong>延迟槽</strong></li>
<li>那么程序在执行完跳转指令后, 会<em>先执行延迟槽中的指令</em>, 再<em>执行位于跳转目标的指令</em>。</li>
</ul>
</li>
<li>延迟槽技术需要软硬件协同才能正确工作: mips手册中描述了这一约定, 处理器设计者按照这一约定设计处理器, 而编译器开发者则会让编译器负责在延迟槽中放置一条有意义的指令, 使得无论是否跳转, 按照这一约定的执行顺序都能得到正确的执行结果.</li>
<li>如果你是编译器开发者, 你将会如何寻找合适的指令放到延迟槽中呢?<ol>
<li>尽量选择不会影响程序逻辑的无副作用的指令</li>
<li>选择与跳转指令无关的独立的指令，即不依赖于跳转指令的结果，也不影响跳转目标的执行。</li>
<li>将原本在跳转目标处执行的指令提前到延迟槽中执行，可以减少跳转目标处的指令数量，提升性能</li>
</ol>
</li>
</ul>
<h4 id="指令名对照"><a href="#指令名对照" class="headerlink" title="指令名对照"></a>指令名对照</h4><ul>
<li>AT&amp;T格式反汇编结果中的少量指令, <strong>与手册中列出的指令名称不符</strong>, 如x86的cltd, mips32和riscv32则有不少<strong>伪指令</strong>(pseudo instruction). 除了STFW之外, 你有办法在手册中找到对应的指令吗? 如果有的话, 为什么这个办法是有效的呢?</li>
<li>办法：</li>
</ul>
<ol>
<li>获取指令的机器码<ul>
<li>使用反汇编工具获取指令的机器码。</li>
</ul>
</li>
<li>查找操作码和功能码<ul>
<li>从机器码中提取操作码和功能码。</li>
<li>对于RISC-V指令，可以提取操作码（opcode）、功能码（funct3）和功能码（funct7）。</li>
</ul>
</li>
<li>查阅手册<ul>
<li>然后在指令手册中查找对应的操作码和功能码。</li>
</ul>
</li>
</ol>
<ul>
<li>为什么有效：<ol>
<li>唯一性：每条指令在机器码级别都有唯一的编码，通过操作码和功能码可以唯一确定一条指令。</li>
<li>标准化：指令手册中提供了详细的指令编码表和描述，通过这些表可以准确地找到指令的定义。</li>
<li>准确性：相比于直接搜索指令名称，通过操作码和功能码查找指令可以避免名称不一致的问题，确保查找结果的准确性。</li>
</ol>
</li>
</ul>
<h3 id="PA2-1结束"><a href="#PA2-1结束" class="headerlink" title="PA2.1结束"></a>PA2.1结束</h3><h1 id="程序-运行时环境与AM"><a href="#程序-运行时环境与AM" class="headerlink" title="程序, 运行时环境与AM"></a>程序, 运行时环境与AM</h1><h2 id="运行时环境"><a href="#运行时环境" class="headerlink" title="运行时环境"></a>运行时环境</h2><ul>
<li>“并不是每一个程序都可以在NEMU中运行”背后的缘由：<ul>
<li>应用程序的运行都需要运行时环境的支持, 包括<em>加载, 销毁程序</em>, 以及<em>提供程序运行时的各种动态链接库</em>(你经常使用的库函数就是运行时环境提供的)等</li>
</ul>
</li>
<li>要提供相应的运行时环境的支持了！</li>
<li>为了运行最简单的程序, 我们需要提供什么呢? 其实答案已经在PA1中了: <ul>
<li>只要<em>把程序放在正确的内存位置, 然后让PC指向第一条指令</em>, 计算机就会自动执行这个程序, 永不停止.</li>
</ul>
</li>
<li>so：只要有内存, 有结束运行的方式, 加上实现正确的指令, 就可以支撑最简单程序的运行了</li>
</ul>
<h2 id="将运行时环境封装成库函数"><a href="#将运行时环境封装成库函数" class="headerlink" title="将运行时环境封装成库函数"></a>将运行时环境封装成库函数</h2><ul>
<li>我们只需要定义一个结束程序的API, 比如<code>void halt()</code>, 它对不同架构上程序的不同结束方式进行了<strong>抽象</strong>: 程序只要调用<code>halt()</code>就可以结束运行, 而不需要关心自己运行在哪一个架构上.</li>
<li>运行时环境的一种普遍的存在方式: <strong>库</strong></li>
<li>通过库, 运行程序所需要的公共要素被抽象成API, 不同的架构只需要实现这些API, 也就相当于实现了支撑程序运行的运行时环境, 这提升了程序开发的效率: 需要的时候只要调用这些API, 就能使用运行时环境提供的相应功能.</li>
</ul>
<h4 id="思考：这又能怎么样呢"><a href="#思考：这又能怎么样呢" class="headerlink" title="思考：这又能怎么样呢"></a>思考：这又能怎么样呢</h4><ul>
<li>思考一下, 这样的抽象还会带来哪些好处呢? 你很快就会体会到这些好处了.</li>
</ul>
<ol>
<li>代码复用<ul>
<li>通过定义统一的API，可以在不同的架构上复用相同的程序代码。只需要为每个架构实现对应的API，而不需要为每个程序和每个架构分别编写代码。</li>
</ul>
</li>
<li>简化维护<ul>
<li>维护n个程序和m个架构相关的API实现，只需要维护n+m份代码，而不是n*m份代码。</li>
</ul>
</li>
<li>提高开发效率<ul>
<li>只需要关注程序逻辑，而不需要关心底层架构的具体实现。</li>
</ul>
</li>
<li>增强了程序的可移植性</li>
</ol>
<h2 id="AM-裸机-bare-metal-运行时环境"><a href="#AM-裸机-bare-metal-运行时环境" class="headerlink" title="AM - 裸机(bare-metal)运行时环境"></a>AM - 裸机(bare-metal)运行时环境</h2><ul>
<li>只进行纯粹计算任务的程序在TRM上就可以运行, 更复杂的应用程序<strong>对运行时环境必定还有其它的需求</strong><ul>
<li>eg：超级玛丽需要和用户进行交互</li>
</ul>
</li>
<li>如果我们把这些需求都收集起来, 将它们<strong>抽象成统一的API</strong>提供给程序, 这样我们就得到了一个可以支撑各种程序运行在各种架构上的<strong>库</strong>了! <ul>
<li>每个架构都按照它们的特性实现这组API</li>
<li>应用程序只需要直接调用这组API即可, 无需关心自己将来运行在哪个架构上.</li>
</ul>
</li>
<li>这组API被称为<strong>抽象计算机</strong>，即<strong>AM(Abstract machine)</strong></li>
<li>AM根据程序的需求把库划分成以下模块:  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AM = TRM + IOE + CTE + VME + MPE</span><br></pre></td></tr></table></figure>
<ul>
<li>TRM(Turing Machine) - 图灵机, 最简单的运行时环境, 为程序提供基本的计算能力</li>
<li>IOE(I&#x2F;O Extension) - 输入输出扩展, 为程序提供输出输入的能力</li>
<li>CTE(Context Extension) - 上下文扩展, 为程序提供上下文管理的能力</li>
<li>VME(Virtual Memory Extension) - 虚存扩展, 为程序提供虚存管理的能力</li>
<li>MPE(Multi-Processor Extension) - 多处理器扩展, 为程序提供多处理器通信的能力 (MPE超出了ICS课程的范围, 在PA中不会涉及)</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(在NEMU中)实现硬件功能 -&gt; (在AM中)提供运行时环境 -&gt; (在APP层)运行程序</span><br><span class="line">(在NEMU中)实现更强大的硬件功能 -&gt; (在AM中)提供更丰富的运行时环境 -&gt; (在APP层)运行更复杂的程序</span><br></pre></td></tr></table></figure>
<h4 id="思考-为什么要有AM-建议二周目思考"><a href="#思考-为什么要有AM-建议二周目思考" class="headerlink" title="思考:为什么要有AM? (建议二周目思考)"></a>思考:为什么要有AM? (建议二周目思考)</h4><ul>
<li>操作系统也有自己的运行时环境. AM和操作系统提供的运行时环境有什么不同呢? 为什么会有这些不同?</li>
<li>不同：<ol>
<li>抽象层次：<ul>
<li>AM：主要关注于硬件抽象，提供基本的硬件功能抽象，如上下文管理、虚存管理、多处理器通信等。它直接运行在硬件之上，提供一个简化的、统一的硬件接口。</li>
<li>操作系统：提供更高层次的抽象，包括进程管理、文件系统、网络通信、安全机制等。操作系统不仅抽象硬件，还管理系统资源，提供丰富的系统服务。</li>
</ul>
</li>
<li>功能范围<ul>
<li>AM：功能相对简单，主要提供硬件抽象和基本的运行时环境。</li>
<li>操作系统：功能丰富，提供全面的系统服务和资源管理，包括内存管理、进程调度、文件系统、网络堆栈等。</li>
</ul>
</li>
<li>目标和用途<ul>
<li>AM：主要用于简化应用程序的开发和移植，使得应用程序可以在不同的硬件平台上运行。它通常用于嵌入式系统、模拟器和教学环境中。</li>
<li>操作系统：主要用于管理计算机系统的资源，提供稳定和高效的运行环境。它用于通用计算平台，如桌面计算机、服务器和移动设备。</li>
</ul>
</li>
</ol>
</li>
<li>为什么会有这些不同：<ol>
<li>设计目标<ul>
<li>AM：设计目标是提供一个统一的硬件抽象层，简化应用程序的开发和移植。因此，它的功能范围相对简单，主要关注于硬件抽象。</li>
<li>操作系统：设计目标是管理系统资源，提供丰富的系统服务，确保系统的稳定性和高效性。因此，它的功能范围广泛，涉及资源管理和系统服务。</li>
</ul>
</li>
<li>复杂性和性能要求<ul>
<li>AM：由于功能简单，AM的实现相对简单，性能开销较小。它适用于对性能要求高、资源有限的环境。</li>
<li>操作系统：由于功能丰富，操作系统的实现复杂，性能开销较大。它适用于通用计算平台，提供全面的系统服务。</li>
</ul>
</li>
<li>应用场景不同<ul>
<li>AM：适用于嵌入式系统、模拟器和教学环境，提供一个简化的硬件抽象层，方便应用程序的开发和移植。</li>
<li>操作系统：适用于通用计算平台，提供全面的系统服务和资源管理，确保系统的稳定性和高效性。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="RTFSC-3"><a href="#RTFSC-3" class="headerlink" title="RTFSC(3)"></a>RTFSC(3)</h2><ul>
<li>AM的子项目<code>abstract-machine</code></li>
<li>整个AM项目分为两大部分:<ul>
<li><code>abstract-machine/am/</code> - 不同架构的AM API实现, 目前我们<strong>只需要关注NEMU相关的内容</strong>即可. 此外, abstract-machine&#x2F;am&#x2F;include&#x2F;am.h列出了AM中的所有API, 我们会在后续逐一介绍它们.</li>
<li><code>abstract-machine/klib/</code> - 一些架构无关的库函数, 方便应用程序的开发</li>
</ul>
</li>
<li>TRM的API：<ul>
<li><code>Area heap</code>结构用于指示<strong>堆区的起始和末尾</strong></li>
<li><code>void putch(char ch)</code>用于输出一个字符</li>
<li><code>void halt(int code)</code>用于结束程序的运行</li>
<li><code>void _trm_init()</code>用于进行TRM相关的初始化工作</li>
</ul>
</li>
<li><strong>堆区</strong>是<strong>给程序自由使用的一段内存区间</strong>, 为程序提供<strong>动态分配内存</strong>的功能. </li>
<li><code>halt()</code>里面调用了<code>nemu_trap()</code>宏 (在<code>abstract-machine/am/src/platform/nemu/include/nemu.h</code>中定义), 这个宏展开之后是一条内联汇编语句. 内联汇编语句允许我们在C代码中嵌入汇编语句, 以riscv32为例, 宏展开之后将会得到:<code>asm volatile(&quot;mv a0, %0; ebreak&quot; : :&quot;r&quot;(code));</code><ul>
<li>正是那条特殊的<code>nemu_trap</code></li>
</ul>
</li>
<li><code>am-kernels</code>子项目用于收录一些可以在AM上运行的测试集和简单程序</li>
<li>在让NEMU运行客户程序之前, 我们需要将客户程序的代码编译成可执行文件<ul>
<li>不能使用gcc的默认选项直接编译<ul>
<li>默认选项会根据GNU&#x2F;Linux的运行时环境将代码编译成运行在GNU&#x2F;Linux下的可执行文件,但此时的NEMU并不能为客户程序提供GNU&#x2F;Linux的运行时环境</li>
</ul>
</li>
<li>使用<strong>交叉编译</strong><ul>
<li>需要在GNU&#x2F;Linux下根据AM的运行时环境编译出能够在<code>$ISA-nemu</code>这个新环境中运行的可执行文件</li>
<li>为了不让链接器ld使用默认的方式链接, 我们还需要提供描述<code>$ISA-nemu</code>的运行时环境的链接脚本</li>
</ul>
</li>
</ul>
</li>
<li>交叉编译生成一个可以在NEMU的运行时环境上运行的程序的过程大致如下:<ul>
<li>gcc将<code>$ISA-nemu</code>的AM实现源文件编译成目标文件, 然后通过ar将这些目标文件作为一个库, 打包成一个归档文件<code>abstract-machine/am/build/am-$ISA-nemu.a</code></li>
<li>gcc把应用程序源文件(如<code>am-kernels/tests/cpu-tests/tests/dummy.c</code>)编译成目标文件</li>
<li>通过gcc和ar把程序依赖的运行库(如<code>abstract-machine/klib/</code>)也编译并打包成归档文件</li>
<li>根据Makefile文件<code>abstract-machine/scripts/$ISA-nemu.mk</code>中的指示, 让ld根据链接脚本<code>abstract-machine/scripts/linker.ld</code>, 将上述目标文件和归档文件链接成可执行文件</li>
</ul>
</li>
<li>对编译得到的可执行文件的行为进行简单的梳理:<ol>
<li>第一条指令从<code>abstract-machine/am/src/$ISA/nemu/start.S</code>开始, 设置好栈顶之后就跳转到<code>abstract-machine/am/src/platform/nemu/trm.c的_trm_init()</code>函数处执行.</li>
<li>在<code>_trm_init()</code>中调用<code>main()</code>函数执行程序的主体功能, main()函数还带一个参数, 目前我们暂时不会用到, 后面我们再介绍它.</li>
<li>从main()函数返回后, 调用<code>halt()</code>结束运行.</li>
</ol>
</li>
</ul>
<h4 id="必做：阅读Makefile"><a href="#必做：阅读Makefile" class="headerlink" title="必做：阅读Makefile"></a>必做：阅读Makefile</h4><ul>
<li><code>abstract-machine</code>项目的Makefile设计得非常巧妙, 你需要把它们看成一种代码来RTFSC, 从而理解它们是如何工作的. 这样一来, 你就知道怎么编写有一定质量的Makefile了; 同时, 如果哪天Makefile出现了非预期的行为, 你就可以尝试对Makefile进行调试了. 当然, 这少不了RTFM.</li>
</ul>
<ol>
<li>基本设置和检查<ul>
<li>默认目标：如果没有指定目标，默认构建<code>image</code>。</li>
<li>环境变量检查：确保<code>$AM_HOME</code>和<code>$ARCH</code>环境变量设置正确。</li>
<li>提取架构和平台：从<code>$ARCH</code>中提取指令集架构（ISA）和平台。</li>
<li>检查源文件：确保有源文件可供构建。</li>
</ul>
</li>
<li>通用编译目标<ul>
<li>创建目标目录：在<code>build/$ARCH</code>目录下创建构建输出目录。</li>
<li>编译目标：定义生成的二进制镜像或归档文件的路径。</li>
<li>收集链接文件：收集所有需要链接的对象文件和库文件。</li>
</ul>
</li>
<li>通用编译标志<ul>
<li>编译器和工具链：定义交叉编译工具链的路径。</li>
<li>编译标志：设置编译标志，包括包含路径、架构定义和优化选项。</li>
</ul>
</li>
<li>架构特定配置<ul>
<li>包含架构特定配置：从<code>scripts/$(ARCH).mk</code>文件中包含架构特定的配置。</li>
</ul>
</li>
<li>编译规则<ul>
<li>编译规则：定义如何从<code>.c</code>、<code>.cc</code>、<code>.cpp</code>和<code>.S</code>文件生成对象文件。</li>
<li>递归构建库：递归调用 Makefile 构建依赖库。</li>
<li>链接规则：定义如何从对象文件和库文件生成最终的 ELF 二进制文件。</li>
<li>归档规则：定义如何从对象文件生成归档文件（<code>.a</code>）。</li>
<li>依赖文件：包含由 gcc 生成的依赖文件（<code>.d</code>）。</li>
</ul>
</li>
<li>杂项<ul>
<li>构建顺序控制：定义构建顺序，确保依赖关系正确。</li>
<li>清理规则：定义清理单个项目和所有子项目的规则。</li>
</ul>
</li>
</ol>
<h4 id="必做：通过批处理模式运行NEMU"><a href="#必做：通过批处理模式运行NEMU" class="headerlink" title="必做：通过批处理模式运行NEMU"></a>必做：通过批处理模式运行NEMU</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我们知道, 大部分同学很可能会这么想: 反正我不阅读Makefile, 老师助教也不知道, 总觉得不看也无所谓.</span><br><span class="line"></span><br><span class="line">所以在这里我们加一道必做题: 我们之前启动NEMU的时候, 每次都需要手动键入c才能运行客户程序. 但如果不是为了使用NEMU中的sdb, 我们其实可以节省c的键入. NEMU中实现了一个批处理模式, 可以在启动NEMU之后直接运行客户程序. 请你阅读NEMU的代码并合适地修改Makefile, 使得通过AM的Makefile可以默认启动批处理模式的NEMU.</span><br><span class="line"></span><br><span class="line">你现在仍然可以跳过这道必做题, 但很快你就会感到不那么方便了.</span><br></pre></td></tr></table></figure>
<ul>
<li>看nemu的代码:  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sdb_mainloop</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//检查是否处于批处理模式</span></span><br><span class="line">    <span class="keyword">if</span>(is_batch_mode)&#123;</span><br><span class="line">        cmd_c(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......<span class="comment">//其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>进入sdb循环前要进行<code>is_batch_mode</code>的判断，为true，就会自动执行cmd_c函数，且不会进入sdb循环</li>
</ul>
</li>
<li>所以使<code>is_batch_mode=true</code>,而nemu提供了<code>sdb_set_batch_mode()</code>函数,应该调用它。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:sdb_set_batch_mode();<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>所以：在<strong>运行NEMU时传入参数b</strong>即可。</li>
<li>添加<code>NEMUFLAGS += -b -l $(shell dirname $(IMAGE).elf)/nemu-log.txt</code></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### Compilation flags</span></span><br><span class="line">INC_PATH += <span class="variable">$(WORK_DIR)</span>/<span class="keyword">include</span> <span class="variable">$(<span class="built_in">addsuffix</span> /include/, $(<span class="built_in">addprefix</span> <span class="variable">$(AM_HOME)</span>/, <span class="variable">$(LIBS)</span>)</span>)</span><br><span class="line">INCFLAGS += <span class="variable">$(<span class="built_in">addprefix</span> -I, <span class="variable">$(INC_PATH)</span>)</span></span><br><span class="line"></span><br><span class="line">ARCH_H := arch/<span class="variable">$(ARCH)</span>.h</span><br><span class="line">CFLAGS   += -O2 -MMD -Wall -Werror <span class="variable">$(INCFLAGS)</span> \</span><br><span class="line">            -D__ISA__=\<span class="string">&quot;<span class="variable">$(ISA)\&quot;</span> -D__ISA_$(shell echo <span class="variable">$(ISA)</span> | tr a-z A-Z)__ \</span></span><br><span class="line"><span class="string">            -D__ARCH__=<span class="variable">$(ARCH)</span> -D__ARCH_$(shell echo <span class="variable">$(ARCH)</span> | tr a-z A-Z | tr - _) \</span></span><br><span class="line"><span class="string">            -D__PLATFORM__=<span class="variable">$(PLATFORM)</span> -D__PLATFORM_$(shell echo <span class="variable">$(PLATFORM)</span> | tr a-z A-Z | tr - _) \</span></span><br><span class="line"><span class="string">            -DARCH_H=\&quot;<span class="variable">$(ARCH_H)\&quot;</span> \</span></span><br><span class="line"><span class="string">            -fno-asynchronous-unwind-tables -fno-builtin -fno-stack-protector \</span></span><br><span class="line"><span class="string">            -Wno-main -U_FORTIFY_SOURCE -fvisibility=hidden</span></span><br><span class="line"><span class="string">CXXFLAGS +=  <span class="variable">$(CFLAGS)</span> -ffreestanding -fno-rtti -fno-exceptions</span></span><br><span class="line"><span class="string">ASFLAGS  += -MMD <span class="variable">$(INCFLAGS)</span></span></span><br><span class="line"><span class="string">LDFLAGS  += -z noexecstack $(addprefix -T, <span class="variable">$(LDSCRIPTS)</span>)</span></span><br><span class="line"><span class="string">NEMUFLAGS += -b -l $(shell dirname <span class="variable">$(IMAGE)</span>.elf)/nemu-log.txt</span></span><br></pre></td></tr></table></figure>
<h2 id="实现常用的库函数"><a href="#实现常用的库函数" class="headerlink" title="实现常用的库函数"></a>实现常用的库函数</h2><ul>
<li>把运行时环境分成两部分: <ol>
<li>一部分是架构相关的运行时环境, 也就是我们之前介绍的AM</li>
<li>另一部分是架构无关的运行时环境, 类似<code>memcpy()</code>这种常用的函数应该归入这部分, <code>abstract-machine/klib/</code>用于收录这些架构无关的库函数. <ul>
<li><code>klib</code>是<code>kernel library</code>的意思, 用于提供一些兼容<code>libc</code>的基础功能.</li>
</ul>
</li>
</ol>
</li>
<li>框架代码在<code>abstract-machine/klib/src/string.c</code>和<code>abstract-machine/klib/src/stdio.c</code>中列出了将来可能会用到的库函数, 但并没有提供相应的实现.</li>
</ul>
<h4 id="必做：实现字符串处理函数"><a href="#必做：实现字符串处理函数" class="headerlink" title="必做：实现字符串处理函数"></a>必做：实现字符串处理函数</h4><ul>
<li>根据需要实现<code>abstract-machine/klib/src/string.c</code>中列出的字符串处理函数, 让<code>cpu-tests</code>中的测试用例<code>string</code>可以成功运行. 关于这些库函数的具体行为, 请务必RTFM.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;klib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;klib-macros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(__ISA_NATIVE__) || defined(__NATIVE_USE_KLIB__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算字符串长度</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">size_t</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(s[n] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    n++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制字符串</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dst, <span class="type">const</span> <span class="type">char</span> *src)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (src == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">char</span> *ret = dst;</span><br><span class="line">  <span class="keyword">while</span> ((*dst++ = *src++) != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制一定长度的字符串</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dst, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *ret = dst;</span><br><span class="line">  <span class="keyword">while</span>(n&amp;&amp;(*dst++ = *src++) != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    n--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">    *dst++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将源字符串连接到目标字符串的末尾</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dst, <span class="type">const</span> <span class="type">char</span> *src)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *ret = dst;</span><br><span class="line">  <span class="keyword">while</span>(*dst != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    dst++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>((*dst++ = *src++) != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较字符串,返回差值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span>(*s1&amp;&amp; *s1 == *s2) &#123;</span><br><span class="line">    s1++;</span><br><span class="line">    s2++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *)s1 - *(<span class="type">unsigned</span> <span class="type">char</span> *)s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较字符串的前n个字符,返回差值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span>(n!=<span class="number">0</span> &amp;&amp; *s1 &amp;&amp; *s1 == *s2) &#123;</span><br><span class="line">    n--;</span><br><span class="line">    s1++;</span><br><span class="line">    s2++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *)s1 - *(<span class="type">unsigned</span> <span class="type">char</span> *)s2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将内存块的前n个字节设置为指定的值</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *s, <span class="type">int</span> c, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">  <span class="comment">//使用unsigned char类型指针遍历内存块，并将每个字节设置为c</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">unsigned</span> <span class="type">char</span> *)s;</span><br><span class="line">  <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)c;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//安全地移动内存块，处理源和目标内存区域重叠的情况</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memmove</span><span class="params">(<span class="type">void</span> *dst, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *d = (<span class="type">unsigned</span> <span class="type">char</span> *)dst;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)src;</span><br><span class="line">  <span class="keyword">if</span>(d &lt; s) &#123;<span class="comment">//如果目标地址小于源地址，从前往后复制。</span></span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">      *d++ = *s++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;<span class="comment">//如果目标地址大于源地址，从后往前复制</span></span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *lasts = s + (n - <span class="number">1</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *lastd = d + (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">      *lastd-- = *lasts--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将内存块的前n个字节从源复制到目标</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *out, <span class="type">const</span> <span class="type">void</span> *in, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *dst = (<span class="type">unsigned</span> <span class="type">char</span> *)out;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *src = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)in;</span><br><span class="line">  <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">    *dst++ = *src++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逐字节比较两个内存块的前n个字节，返回它们的差值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *s1, <span class="type">const</span> <span class="type">void</span> *s2, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *p1 = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)s1;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *p2 = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)s2;</span><br><span class="line">  <span class="keyword">while</span>(n--) &#123;<span class="comment">//使用unsigned char类型指针遍历两个内存块，并比较每个字节</span></span><br><span class="line">    <span class="keyword">if</span>(*p1 != *p2) &#123;<span class="comment">//如果发现不同的字节，返回差值</span></span><br><span class="line">      <span class="keyword">return</span> *p1 - *p2;</span><br><span class="line">    &#125;</span><br><span class="line">    p1++;</span><br><span class="line">    p2++;</span><br><span class="line">  &#125;<span class="comment">//所有字节都相同，返回0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="实现sprintf"><a href="#实现sprintf" class="headerlink" title="实现sprintf"></a>实现sprintf</h4><ul>
<li>实现<code>abstract-machine/klib/src/stdio.c</code>中的<code>sprintf()</code>, 具体行为可以参考<code>man 3 printf</code>. 目前你只需要实现<code>%s</code>和<code>%d</code>就能通过<code>hello-str</code>的测试了, <strong>其它功能(包括位宽, 精度等)可以在将来需要的时候再自行实现</strong>.</li>
<li>和其它库函数相比, <code>sprintf()</code>比较特殊, 因为它的参数数目是可变的. 为了获得<strong>数目可变的参数</strong>, 你可以使用C库<code>stdarg.h</code>中提供的<strong>宏</strong>, 具体用法请查阅<code>man stdarg</code>.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（辅助）将整数转换为字符串</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">itoa</span><span class="params">(<span class="type">int</span> num,<span class="type">char</span> *str)</span>&#123;</span><br><span class="line">  <span class="type">char</span> *p = str;</span><br><span class="line">  <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;<span class="comment">//为0</span></span><br><span class="line">    *p++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(num &lt; <span class="number">0</span>)&#123;<span class="comment">//负数</span></span><br><span class="line">    *p++ = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    num = -num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//计算整数的长度，并将每一位转换为字符</span></span><br><span class="line">  <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> temp = num;</span><br><span class="line">  <span class="keyword">while</span>(temp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    temp /= <span class="number">10</span>;</span><br><span class="line">    len++;</span><br><span class="line">  &#125;</span><br><span class="line">  str[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    str[--len] = num % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    num /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *out, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start(ap, fmt);</span><br><span class="line">  <span class="type">char</span> *p = out;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *f=fmt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(*f)&#123;</span><br><span class="line">    <span class="keyword">if</span>(*f == <span class="string">&#x27;%&#x27;</span>)&#123;<span class="comment">//遇到%，检查下一个字符以确定格式类型</span></span><br><span class="line">      f++;</span><br><span class="line">      <span class="keyword">if</span>(*f == <span class="string">&#x27;d&#x27;</span>)&#123;<span class="comment">//如果是%d，将整数参数转换为字符串并复制到输出缓冲区</span></span><br><span class="line">        <span class="type">int</span> num = va_arg(ap, <span class="type">int</span>);</span><br><span class="line">        <span class="type">char</span> num_str[<span class="number">20</span>];<span class="comment">//足够大</span></span><br><span class="line">        itoa(num, num_str);</span><br><span class="line">        <span class="type">char</span> *num_p = num_str;</span><br><span class="line">        <span class="keyword">while</span>(*num_p)&#123;</span><br><span class="line">          *p++ = *num_p++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(*f == <span class="string">&#x27;s&#x27;</span>)&#123;<span class="comment">//如果是%s，将字符串参数复制到输出缓冲区</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *str = va_arg(ap, <span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">        <span class="keyword">while</span>(*str)&#123;</span><br><span class="line">          *p++ = *str++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//未知格式</span></span><br><span class="line">      *p++ = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">      *p++ = *f;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    *p++ = *f;</span><br><span class="line">  &#125;</span><br><span class="line">  f++;</span><br><span class="line">  &#125;</span><br><span class="line">  *p = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//末尾设置为&#x27;\0&#x27;</span></span><br><span class="line">  va_end(ap);</span><br><span class="line">  <span class="keyword">return</span> p - out;<span class="comment">//返回写入的字符数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重新认识计算机-计算机是个抽象层"><a href="#重新认识计算机-计算机是个抽象层" class="headerlink" title="重新认识计算机: 计算机是个抽象层"></a>重新认识计算机: 计算机是个抽象层</h2><ul>
<li>讨论在TRM上运行的程序, 我们对这些程序的需求进行分类, 来看看我们的计算机系统是如何支撑这些需求的<ul>
<li>计算</li>
<li>内存申请</li>
<li>结束运行</li>
<li>打印信息</li>
</ul>
</li>
<li>宏观视角：底层——&gt;高层<ul>
<li>微观视角: 程序是个状态机</li>
<li>宏观视角: 计算机是个抽象层</li>
<li>理解计算机是如何把底层的功能经过层层抽象, 最终支撑程序的运行.</li>
</ul>
</li>
</ul>
<h1 id="基础设施（2）"><a href="#基础设施（2）" class="headerlink" title="基础设施（2）"></a>基础设施（2）</h1><h2 id="bug诊断的利器-踪迹"><a href="#bug诊断的利器-踪迹" class="headerlink" title="bug诊断的利器 - 踪迹"></a>bug诊断的利器 - 踪迹</h2><ul>
<li>为了提高效率, 我们可以通过<code>printf()</code>来输出我们关心的某些信息. </li>
<li>在软件工程领域, <strong>记录程序执行过程的信息</strong>称为<strong>踪迹(trace)</strong>. 有了踪迹信息, 我们就可以判断程序的执行过程是否符合预期, 从而进行bug的诊断.</li>
</ul>
<h3 id="指令执行的踪迹-itrace"><a href="#指令执行的踪迹-itrace" class="headerlink" title="指令执行的踪迹 - itrace"></a>指令执行的踪迹 - itrace</h3><ul>
<li>NEMU已经实现– <code>itrace (instruction trace)</code>, 它可以记录客户程序执行的每一条指令. </li>
<li>itrace会输出<strong>指令的PC, 二进制表示以及反汇编结果</strong></li>
<li>框架代码默认已经打开了这个功能, 客户程序执行的指令都会被记录到<code>build/nemu-log.txt</code>中</li>
<li>NEMU可以限制trace输出的时机, 你可以<strong>手动指定</strong>什么时候才输出它们, 甚至还可以自定义输出trace的条件. 具体如何指定, RTFSC. </li>
<li>对于一些输出规整的trace, 我们还可以通过<strong>grep, awk, sed</strong>等文本处理工具来对它们进行<strong>筛选和处理</strong>. </li>
<li><code>nemu/src/cpu/cpu-exec.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">exec_once</span><span class="params">(Decode *s, <span class="type">vaddr_t</span> pc)</span> &#123;</span><br><span class="line">  s-&gt;pc = pc;<span class="comment">///</span></span><br><span class="line">  s-&gt;snpc = pc;</span><br><span class="line">  isa_exec_once(s);</span><br><span class="line">  cpu.pc = s-&gt;dnpc;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Executed instruction at pc = 0x%x, next pc = 0x%x\n&quot;</span>, s-&gt;pc, s-&gt;dnpc);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ITRACE</span></span><br><span class="line">  <span class="type">char</span> *p = s-&gt;logbuf;</span><br><span class="line">  p += <span class="built_in">snprintf</span>(p, <span class="keyword">sizeof</span>(s-&gt;logbuf), FMT_WORD <span class="string">&quot;:&quot;</span>, s-&gt;pc);</span><br><span class="line">  <span class="type">int</span> ilen = s-&gt;snpc - s-&gt;pc;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">uint8_t</span> *inst = (<span class="type">uint8_t</span> *)&amp;s-&gt;isa.inst.val;</span><br><span class="line">  <span class="keyword">for</span> (i = ilen - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">    p += <span class="built_in">snprintf</span>(p, <span class="number">4</span>, <span class="string">&quot; %02x&quot;</span>, inst[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ilen_max = MUXDEF(CONFIG_ISA_x86, <span class="number">8</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="type">int</span> space_len = ilen_max - ilen;</span><br><span class="line">  <span class="keyword">if</span> (space_len &lt; <span class="number">0</span>) space_len = <span class="number">0</span>;</span><br><span class="line">  space_len = space_len * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">memset</span>(p, <span class="string">&#x27; &#x27;</span>, space_len);</span><br><span class="line">  p += space_len;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">disassemble</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> size, <span class="type">uint64_t</span> pc, <span class="type">uint8_t</span> *code, <span class="type">int</span> nbyte)</span>;</span><br><span class="line">  disassemble(p, s-&gt;logbuf + <span class="keyword">sizeof</span>(s-&gt;logbuf) - p,</span><br><span class="line">      MUXDEF(CONFIG_ISA_x86, s-&gt;snpc, s-&gt;pc), (<span class="type">uint8_t</span> *)&amp;s-&gt;isa.inst.val, ilen);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指令环形缓冲区-iringbuf"><a href="#指令环形缓冲区-iringbuf" class="headerlink" title="指令环形缓冲区 - iringbuf"></a>指令环形缓冲区 - iringbuf</h3><ul>
<li>我们能不能在<strong>客户程序出错</strong>(例如访问物理内存越界)的时候<strong>输出最近执行的若干条指令</strong>呢?</li>
<li><strong>环形缓冲区(ring buffer)</strong><ul>
<li>在每执行一条指令的时候, 就把这条指令的信息写入到环形缓冲区中</li>
<li>如果缓冲区满了, 就会覆盖旧的内容</li>
<li>客户程序出错的时候, 就把环形缓冲区中的指令打印出来, 供调试进行参考.</li>
</ul>
</li>
</ul>
<h4 id="必做：实现iringbuf"><a href="#必做：实现iringbuf" class="headerlink" title="必做：实现iringbuf"></a>必做：实现iringbuf</h4><ul>
<li>根据上述内容, 在NEMU中实现iringbuf. 你可以按照自己的喜好来设计输出的格式, 如果你想输出指令的反汇编, 可以参考itrace的相关代码; 如果你不知道应该在什么地方添加什么样的代码, 你就需要RTFSC了.</li>
<li>思考在哪添加代码：<ul>
<li><code>nemu/src/memory/padder.c</code></li>
</ul>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">out_of_bound</span><span class="params">(<span class="type">paddr_t</span> addr)</span> &#123;</span><br><span class="line">panic(<span class="string">&quot;address = &quot;</span> FMT_PADDR <span class="string">&quot; is out of bound of pmem [&quot;</span> FMT_PADDR <span class="string">&quot;, &quot;</span> FMT_PADDR <span class="string">&quot;] at pc = &quot;</span> FMT_WORD,</span><br><span class="line">    addr, PMEM_LEFT, PMEM_RIGHT, cpu.pc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>panic定义在<code>nemu/include/debug.h</code></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//nemu/include/debug.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DEBUG_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DEBUG_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;common.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Log(format, ...) \</span></span><br><span class="line"><span class="meta">    _Log(ANSI_FMT(<span class="string">&quot;[%s:%d %s] &quot;</span> format, ANSI_FG_BLUE) <span class="string">&quot;\n&quot;</span>, \</span></span><br><span class="line"><span class="meta">        __FILE__, __LINE__, __func__, ## __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Assert(cond, format, ...) \</span></span><br><span class="line"><span class="meta">  do &#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!(cond)) &#123; \</span></span><br><span class="line"><span class="meta">      MUXDEF(CONFIG_TARGET_AM, printf(ANSI_FMT(format, ANSI_FG_RED) <span class="string">&quot;\n&quot;</span>, ## __VA_ARGS__), \</span></span><br><span class="line"><span class="meta">        (fflush(stdout), fprintf(stderr, ANSI_FMT(format, ANSI_FG_RED) <span class="string">&quot;\n&quot;</span>, ##  __VA_ARGS__))); \</span></span><br><span class="line"><span class="meta">      IFNDEF(CONFIG_TARGET_AM, extern FILE* log_fp; fflush(log_fp)); \</span></span><br><span class="line"><span class="meta">      extern void assert_fail_msg(); \</span></span><br><span class="line"><span class="meta">      assert_fail_msg(); \</span></span><br><span class="line"><span class="meta">      assert(cond); \</span></span><br><span class="line"><span class="meta">    &#125; \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> panic(format, ...) Assert(0, format, ## __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TODO() panic(<span class="string">&quot;please implement me&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>由此可知panic通过Assert实现</li>
<li>推出要在<code>assert_fail_msg()</code>实现</li>
</ul>
<ol>
<li>新建<code>src/cpu/iringbuf.h</code>定义环形缓冲区的数据结构和接口</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> IRINGBUF_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRINGBUF_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRINGBUF_SIZE 16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">uint64_t</span> pc;</span><br><span class="line">  <span class="type">char</span> asm_code[<span class="number">128</span>];</span><br><span class="line">&#125; IRingBufEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  IRingBufEntry entries[IRINGBUF_SIZE];</span><br><span class="line">  <span class="type">int</span> head;</span><br><span class="line">  <span class="type">int</span> tail;</span><br><span class="line">  <span class="type">int</span> count;</span><br><span class="line">&#125; IRingBuf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> iringbuf_nowidx;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">record_inst</span><span class="params">(<span class="type">uint64_t</span> pc, <span class="type">const</span> <span class="type">char</span> *asm_code)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">display_iringbuf</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// IRINGBUF_H</span></span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>新建<code>src/cpu/iringbuf.c</code>，实现环形缓冲区的操作函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../include/common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../include/debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iringbuf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> IRingBuf iringbuf = &#123; .head = <span class="number">0</span>, .tail = <span class="number">0</span>, .count = <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> iringbuf_nowidx=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">record_inst</span><span class="params">(<span class="type">uint64_t</span> pc, <span class="type">const</span> <span class="type">char</span> *asm_code)</span> &#123;</span><br><span class="line">  IRingBufEntry *entry = &amp;iringbuf.entries[iringbuf.head];</span><br><span class="line">  entry-&gt;pc = pc;</span><br><span class="line">  <span class="built_in">strncpy</span>(entry-&gt;asm_code, asm_code, <span class="keyword">sizeof</span>(entry-&gt;asm_code) - <span class="number">1</span>);</span><br><span class="line">  entry-&gt;asm_code[<span class="keyword">sizeof</span>(entry-&gt;asm_code) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  iringbuf_nowidx = iringbuf.head;</span><br><span class="line"></span><br><span class="line">  iringbuf.head = (iringbuf.head + <span class="number">1</span>) % IRINGBUF_SIZE;</span><br><span class="line">  <span class="keyword">if</span> (iringbuf.count &lt; IRINGBUF_SIZE) &#123;</span><br><span class="line">    iringbuf.count++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    iringbuf.tail = (iringbuf.tail + <span class="number">1</span>) % IRINGBUF_SIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调试输出</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;record_inst: pc = 0x%016lx, count = %d, head = %d, tail = %d\n&quot;</span>, pc, iringbuf.count, iringbuf.head, iringbuf.tail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display_iringbuf</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Recent instructions:\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iringbuf.count; i++) &#123;</span><br><span class="line">    <span class="type">int</span> index = (iringbuf.tail + i) % IRINGBUF_SIZE;</span><br><span class="line">    IRingBufEntry *entry = &amp;iringbuf.entries[index];</span><br><span class="line">    <span class="keyword">if</span> (index == iringbuf_nowidx) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;--&gt; &quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;    &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%016lx: %s\n&quot;</span>, entry-&gt;pc, entry-&gt;asm_code);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在<code>src/cpu/cpu-exec.c</code>的<code>trace_and_difftest</code>函数中，将原本打印指令的位置更改为将指令记录到缓冲区：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">trace_and_difftest</span><span class="params">(Decode *_this, <span class="type">vaddr_t</span> dnpc)</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ITRACE_COND</span></span><br><span class="line">  <span class="keyword">if</span> (ITRACE_COND) &#123; log_write(<span class="string">&quot;%s\n&quot;</span>, _this-&gt;logbuf); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (g_print_step) &#123; </span><br><span class="line">    IFDEF(CONFIG_ITRACE, <span class="built_in">puts</span>(_this-&gt;logbuf)); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记录指令到环形缓冲区</span></span><br><span class="line">  record_inst(_this-&gt;pc, _this-&gt;logbuf);</span><br><span class="line">  IFDEF(CONFIG_DIFFTEST, difftest_step(_this-&gt;pc, dnpc));</span><br><span class="line">  IFDEF(CONFIG_WATCHPOINT, check_watchpoints());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在<code>src/cpu/cpu-exec.c</code>中,在<code>assert_fail_msg</code>函数中，调用<code>display_iringbuf()</code>来打印缓冲区中的指令信息。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">assert_fail_msg</span><span class="params">()</span> &#123;</span><br><span class="line">  isa_reg_display();</span><br><span class="line">  display_iringbuf();</span><br><span class="line">  statistic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>在<code>src/memory/paddr.c</code>中添加引用</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">out_of_bound</span><span class="params">(<span class="type">paddr_t</span> addr)</span> &#123;</span><br><span class="line">  panic(<span class="string">&quot;address = &quot;</span> FMT_PADDR <span class="string">&quot; is out of bound of pmem [&quot;</span> FMT_PADDR <span class="string">&quot;, &quot;</span> FMT_PADDR <span class="string">&quot;] at pc = &quot;</span> FMT_WORD,</span><br><span class="line">      addr, PMEM_LEFT, PMEM_RIGHT, cpu.pc);</span><br><span class="line">  assert_fail_msg();</span><br><span class="line">  assert(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>效果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Recent instructions:</span><br><span class="line">    0x0000000080000050: 0x80000050: 0d 00 00 ef jal	0xd0</span><br><span class="line">    0x0000000080000120: 0x80000120: fd 01 01 13 addi	sp, sp, -0x30</span><br><span class="line">    0x0000000080000124: 0x80000124: 00 81 24 23 sw	s0, 8(sp)</span><br><span class="line">    0x0000000080000128: 0x80000128: 00 11 26 23 sw	ra, 0xc(sp)</span><br><span class="line">    0x000000008000012c: 0x8000012c: 00 c1 2c 23 sw	a2, 0x18(sp)</span><br><span class="line">    0x0000000080000130: 0x80000130: 00 d1 2e 23 sw	a3, 0x1c(sp)</span><br><span class="line">    0x0000000080000134: 0x80000134: 02 e1 20 23 sw	a4, 0x20(sp)</span><br><span class="line">    0x0000000080000138: 0x80000138: 02 f1 22 23 sw	a5, 0x24(sp)</span><br><span class="line">    0x000000008000013c: 0x8000013c: 03 01 24 23 sw	a6, 0x28(sp)</span><br><span class="line">    0x0000000080000140: 0x80000140: 03 11 26 23 sw	a7, 0x2c(sp)</span><br><span class="line">    0x0000000080000144: 0x80000144: 00 00 04 17 auipc	s0, 0</span><br><span class="line">    0x0000000080000148: 0x80000148: 12 04 04 13 addi	s0, s0, 0x120</span><br><span class="line">    0x000000008000014c: 0x8000014c: 04 10 05 13 addi	a0, zero, 0x41</span><br><span class="line">    0x0000000080000150: 0x80000150: 00 14 04 13 addi	s0, s0, 1</span><br><span class="line">    0x0000000080000154: 0x80000154: f9 5f f0 ef jal	-0x6c</span><br><span class="line">--&gt; 0x00000000800000e8: 0x800000e8: a0 00 07 b7 lui	a5, 0xa0000</span><br></pre></td></tr></table></figure>
<h3 id="内存访问的踪迹-mtrace"><a href="#内存访问的踪迹-mtrace" class="headerlink" title="内存访问的踪迹 - mtrace"></a>内存访问的踪迹 - mtrace</h3><ul>
<li>可以很容易地对访存的结果进行追踪, 从而记录访存的踪迹(memory trace).</li>
</ul>
<h4 id="必做：实现mtrace"><a href="#必做：实现mtrace" class="headerlink" title="必做：实现mtrace"></a>必做：实现mtrace</h4><ul>
<li>这个功能非常简单, 你已经想好如何实现了: 只需要在<code>paddr_read()</code>和<code>paddr_write()</code>中进行记录即可. 你可以自行定义mtrace输出的格式.</li>
<li>不过和最后只输出一次的iringbuf不同, 程序一般会执行很多访存指令, 这意味着开启mtrace将会产生大量的输出, 因此<strong>最好可以在不需要的时候关闭mtrace</strong>. 噢, 那就参考一下itrace的相关实现吧: <strong>尝试在Kconfig和相关文件中添加相应的代码</strong>, 使得我们可以通过<strong>menuconfig</strong>来打开或者关闭mtrace. 另外也可以实现mtrace输出的条件, 例如你可能只会关心某一段内存区间的访问, 有了相关的条件控制功能, mtrace使用起来就更加灵活了.</li>
</ul>
<ol>
<li>更新<code>Kconfig</code>文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config MTRACE</span><br><span class="line">    bool &quot;Enable memory trace&quot;</span><br><span class="line">    default n</span><br><span class="line">    help</span><br><span class="line">      Enable memory trace to record memory access behavior.</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在<code>include/common.h</code>中添加 mtrace 宏定义</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MTRACE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MTRACE_COND (1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MTRACE_COND (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在<code>paddr.c</code>文件中实现<code>mtrace</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../include/common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">word_t</span> <span class="title function_">paddr_read</span><span class="params">(<span class="type">paddr_t</span> addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (MTRACE_COND) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MTRACE: Read from address 0x%08x, length %d\n&quot;</span>, addr, len);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (likely(in_pmem(addr))) <span class="keyword">return</span> pmem_read(addr, len);</span><br><span class="line">  IFDEF(CONFIG_DEVICE, <span class="keyword">return</span> mmio_read(addr, len));</span><br><span class="line">  out_of_bound(addr);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">paddr_write</span><span class="params">(<span class="type">paddr_t</span> addr, <span class="type">int</span> len, <span class="type">word_t</span> data)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (MTRACE_COND) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MTRACE: Write to address 0x%08x, length %d, data 0x%08x\n&quot;</span>, addr, len, data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (likely(in_pmem(addr))) &#123; pmem_write(addr, len, data); <span class="keyword">return</span>; &#125;</span><br><span class="line">  IFDEF(CONFIG_DEVICE, mmio_write(addr, len, data); <span class="keyword">return</span>);</span><br><span class="line">  out_of_bound(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><code>make menuconfig</code>,找到<code>Enable memory trace</code>选项,打开即启用</li>
</ol>
<ul>
<li>belike：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MTRACE: Read from address 0x80000000, length 4</span><br><span class="line">Executed instruction at pc = 0x80000000, next pc = 0x80000004</span><br><span class="line">MTRACE: Read from address 0x80000004, length 4</span><br><span class="line">Executed instruction at pc = 0x80000004, next pc = 0x80000008</span><br><span class="line">MTRACE: Read from address 0x80000008, length 4</span><br><span class="line">Executed instruction at pc = 0x80000008, next pc = 0x8000000c</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>实现mtrace输出的条件, 例如你可能只会关心某一段内存区间的访问;在<code>paddr.c</code>文件中实现:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">in_mtrace_range</span><span class="params">(<span class="type">paddr_t</span> addr)</span> &#123;</span><br><span class="line">  <span class="comment">// 假设只关心某一段内存区间的访问，例如 [0x80000000, 0x8000ffff]</span></span><br><span class="line">  <span class="keyword">return</span> (addr &gt;= <span class="number">0x80000000</span> &amp;&amp; addr &lt;= <span class="number">0x8000ffff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">word_t</span> <span class="title function_">paddr_read</span><span class="params">(<span class="type">paddr_t</span> addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (MTRACE_COND &amp;&amp; in_mtrace_range(addr)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MTRACE: Read from address 0x%08x, length %d\n&quot;</span>, addr, len);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (likely(in_pmem(addr))) <span class="keyword">return</span> pmem_read(addr, len);</span><br><span class="line">  IFDEF(CONFIG_DEVICE, <span class="keyword">return</span> mmio_read(addr, len));</span><br><span class="line">  out_of_bound(addr);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">paddr_write</span><span class="params">(<span class="type">paddr_t</span> addr, <span class="type">int</span> len, <span class="type">word_t</span> data)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (MTRACE_COND &amp;&amp; in_mtrace_range(addr)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MTRACE: Write to address 0x%08x, length %d, data 0x%08x\n&quot;</span>, addr, len, data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (likely(in_pmem(addr))) &#123; pmem_write(addr, len, data); <span class="keyword">return</span>; &#125;</span><br><span class="line">  IFDEF(CONFIG_DEVICE, mmio_write(addr, len, data); <span class="keyword">return</span>);</span><br><span class="line">  out_of_bound(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数调用的踪迹-ftrace"><a href="#函数调用的踪迹-ftrace" class="headerlink" title="函数调用的踪迹 - ftrace"></a>函数调用的踪迹 - ftrace</h3><ul>
<li>要实现ftrace, 我们只需要关心<strong>函数调用</strong>和<strong>返回相关的指令</strong>就可以了.<ul>
<li>我们可以<strong>在函数调用指令中记录目标地址</strong>, 表示<strong>将要调用某个函数</strong>;</li>
<li>然后在<strong>函数返回指令中记录当前PC</strong>, 表示<strong>将要从PC所在的函数返回</strong>.</li>
<li>我们很容易在相关指令的实现中添加代码来实现这些功能. 但目标地址和PC值仍然缺少程序语义, 如果我们能把它们翻译成函数名, 就更容易理解了</li>
</ul>
</li>
<li>给定一个位于代码段的地址, 如何得知它位于哪一个函数<ul>
<li>这就需要<strong>ELF文件中符号表</strong>(symbol table)的帮助了. </li>
<li>符号表是可执行文件的一个section, 它记录了程序编译时刻的一些信息, 其中就包括变量和函数的信息. 为了实现ftrace, 我们首先需要了解符号表中都记录了哪些信息.</li>
</ul>
</li>
<li>以cpu-tests中add这个用户程序为例, 使用readelf命令查看ELF可执行文件的信息:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">riscv64-linux-gnu-readelf -a add-riscv32-nemu.elf</span><br></pre></td></tr></table></figure>
<ul>
<li>符号表<ul>
<li>Type属性为FUNC的表项</li>
<li>仔细观察Name属性之后, 你会发现这些表项正好对应了程序中定义的函数</li>
<li>相应的Value属性正好是它们的起始地址(你可以与反汇编结果进行对比)</li>
<li>而相应的Size属性则给出了函数的大小.</li>
</ul>
</li>
</ul>
<h4 id="思考：消失的符号"><a href="#思考：消失的符号" class="headerlink" title="思考：消失的符号"></a>思考：消失的符号</h4><ul>
<li>我们在<code>am-kernels/tests/cpu-tests/tests/add.c</code>中定义了宏NR_DATA, 同时也在add()函数中定义了局部变量c和形参a, b, 但你会发现在符号表中找不到和它们对应的表项, 为什么会这样? 思考一下, 什么才算是一个符号(symbol)?</li>
</ul>
<ol>
<li>符号表中记录的是全局变量、函数和其他具有名称和地址的实体。局部变量和宏定义不会出现在符号表中，因为它们的作用域和生命周期<em>局限于函数内部或预处理阶段</em>。</li>
<li>一个符号（Symbol）通常是指在编译和链接过程中具有名称和地址的实体。以下是一些常见的符号类型：<ul>
<li>全局变量（Global Variables）<ul>
<li>在程序的全局作用域中定义的变量。</li>
<li>这些变量在符号表中有对应的表项，记录了它们的名称、类型和地址。</li>
</ul>
</li>
<li>函数（Functions）<ul>
<li>在程序中定义的函数。</li>
<li>符号表中记录了函数的名称、类型（FUNC）和起始地址。</li>
</ul>
</li>
<li>常量（Constants）<ul>
<li>在程序中定义的具有名称的常量。</li>
<li>这些常量在符号表中有对应的表项。</li>
</ul>
</li>
<li>外部变量（External Variables）<ul>
<li>在一个文件中声明但在另一个文件中定义的变量。</li>
<li>符号表中记录了这些变量的名称和类型。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="思考：寻找”Hello-World-”"><a href="#思考：寻找”Hello-World-”" class="headerlink" title="思考：寻找”Hello World!”"></a>思考：寻找”Hello World!”</h4><ul>
<li>在Linux下编写一个Hello World程序, 编译后通过上述方法找到ELF文件的字符串表, 你发现”Hello World!”字符串在字符串表中的什么位置? 为什么会这样?</li>
</ul>
<ol>
<li>在编译后的ELF文件中，”Hello World!”字符串通常位于.rodata（只读数据段）或.data（数据段）中，而不是在字符串表（.strtab）中。字符串表主要用于存储符号名称和调试信息，而程序中的字符串常量则存储在数据段中。</li>
<li>原因：<ul>
<li>字符串表的用途：<ul>
<li>字符串表（.strtab）用于存储符号名称、调试信息等与程序执行无关的字符串。</li>
<li>它主要用于链接和调试阶段，而不是程序运行时的数据存储。</li>
</ul>
</li>
<li>字符串常量的存储：</li>
<li>程序中的字符串常量（如”Hello World!”）存储在数据段（如.rodata或.data）中。</li>
<li>这些段用于存储程序运行时需要访问的常量和变量。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="必做：实现ftrace"><a href="#必做：实现ftrace" class="headerlink" title="必做：实现ftrace"></a>必做：实现ftrace</h4><ul>
<li>根据上述内容, 在NEMU中实现ftrace. 你可以自行决定输出的格式. 你需要注意以下内容:<ul>
<li>你需要为NEMU传入一个ELF文件, 你可以通过在parse_args()中添加相关代码来实现这一功能</li>
<li>你可能需要在初始化ftrace时从ELF文件中读出符号表和字符串表, 供你后续使用</li>
<li>关于如何解析ELF文件, 可以参考man 5 elf</li>
<li>如果你选择的是riscv32, 你还需要考虑如何从jal和jalr指令中正确识别出函数调用指令和函数返回指令</li>
</ul>
</li>
<li>注意, 你不应该通过readelf等工具直接解析ELF文件. 在真实的项目中, 这个方案确实可以解决问题; 但作为一道学习性质的题目, 其目标是让你了解ELF文件的组织结构, 使得将来你在必要的时候(例如在裸机环境中)可以自己从中解析出所需的信息. 如果你通过readelf等工具直接解析ELF文件, 相当于自动放弃训练的机会, 与我们设置这道题目的目的背道而驰.</li>
</ul>
<ol>
<li>为NEMU传入一个ELF文件, 在<code>src/monitor/monitor.c</code>的<code>parse_args()</code>中添加:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *elf_file = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">parse_args</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">table</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;batch&quot;</span>    , no_argument      , <span class="literal">NULL</span>, <span class="string">&#x27;b&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;log&quot;</span>      , required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;l&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;diff&quot;</span>     , required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;d&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;port&quot;</span>     , required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;p&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;help&quot;</span>     , no_argument      , <span class="literal">NULL</span>, <span class="string">&#x27;h&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;elf&quot;</span>      , required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;e&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>          , <span class="number">0</span>                , <span class="literal">NULL</span>,  <span class="number">0</span> &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="type">int</span> o;</span><br><span class="line">  <span class="keyword">while</span> ( (o = getopt_long(argc, argv, <span class="string">&quot;-bhl:d:p:e:&quot;</span>, table, <span class="literal">NULL</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (o) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: sdb_set_batch_mode(); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>: <span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%d&quot;</span>, &amp;difftest_port); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>: log_file = optarg; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>: elf_file = optarg; <span class="keyword">break</span>;  <span class="comment">// 解析ELF文件路径并解析ELF文件</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: diff_so_file = optarg; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: img_file = optarg; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s [OPTION...] IMAGE [args]\n\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t-b,--batch              run with batch mode\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t-l,--log=FILE           output log to FILE\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t-d,--diff=REF_SO        run DiffTest with reference REF_SO\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t-p,--port=PORT          run DiffTest with port PORT\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t-e,--elf=FILE           parse elf from FILE\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_monitor</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"> <span class="comment">/* 函数调用踪迹,ftrace. */</span></span><br><span class="line">	IFDEF(CONFIG_FTRACE, init_ftrace(elf_file));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>新建<code>nemu/src/cpu/elf_parser.c</code>和<code>nemu/src/cpu/elf_parser.h</code>,</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//nemu/src/cpu/elf_parser.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ELF_PARSER_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ELF_PARSER_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;elf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="type">paddr_t</span> addr;      <span class="comment">// the function head address</span></span><br><span class="line">    Elf32_Xword size;</span><br><span class="line">&#125;FuncSymbol;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_STACK_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> pc;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *func_name;</span><br><span class="line">&#125; CallStackEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> CallStackEntry call_stack[CALL_STACK_SIZE];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> call_stack_top ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> FuncSymbol *func_symbols;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> func_symbol_count;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">parse_elf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *elf_file)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// __ELF_PARSER_H__</span></span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在初始化ftrace时从ELF文件中读出符号表和字符串表, 供后续使用</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//nemu/src/cpu/elf_parser.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;elf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;elf_parser.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">FuncSymbol *func_symbols = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> func_symbol_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">parse_elf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *elf_file)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elf_file == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    FILE *fp = fopen(elf_file, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open ELF file&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 ELF 头</span></span><br><span class="line">    Elf32_Ehdr ehdr;</span><br><span class="line">    <span class="keyword">if</span> (fread(&amp;ehdr, <span class="keyword">sizeof</span>(Elf32_Ehdr), <span class="number">1</span>, fp) != <span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to read ELF header&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证文件是否是 ELF 格式</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(ehdr.e_ident, ELFMAG, SELFMAG) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Not a valid ELF file\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fseek(fp, ehdr.e_shoff, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    Elf32_Shdr shdr;</span><br><span class="line">    <span class="type">char</span> *string_table = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找字符串表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ehdr.e_shnum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fread(&amp;shdr, <span class="keyword">sizeof</span>(Elf32_Shdr), <span class="number">1</span>, fp) != <span class="number">1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;Failed to read section header&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shdr.sh_type == SHT_STRTAB) &#123;</span><br><span class="line">            <span class="comment">// 获取字符串表</span></span><br><span class="line">            string_table = <span class="built_in">malloc</span>(shdr.sh_size);</span><br><span class="line">            fseek(fp, shdr.sh_offset, SEEK_SET);</span><br><span class="line">            <span class="keyword">if</span> (fread(string_table, shdr.sh_size, <span class="number">1</span>, fp) != <span class="number">1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;Failed to read string table&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找符号表</span></span><br><span class="line">    fseek(fp, ehdr.e_shoff, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ehdr.e_shnum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fread(&amp;shdr, <span class="keyword">sizeof</span>(Elf32_Shdr), <span class="number">1</span>, fp) != <span class="number">1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;Failed to read section header&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shdr.sh_type == SHT_SYMTAB) &#123;</span><br><span class="line">            fseek(fp, shdr.sh_offset, SEEK_SET);</span><br><span class="line"></span><br><span class="line">            Elf32_Sym sym;</span><br><span class="line">            <span class="type">size_t</span> sym_count = shdr.sh_size / shdr.sh_entsize;</span><br><span class="line">            func_symbols = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(FuncSymbol) * sym_count);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; sym_count; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fread(&amp;sym, <span class="keyword">sizeof</span>(Elf32_Sym), <span class="number">1</span>, fp) != <span class="number">1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;Failed to read symbol table&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ELF32_ST_TYPE(sym.st_info) == STT_FUNC) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="type">char</span> *name = string_table + sym.st_name;</span><br><span class="line">                    <span class="built_in">strncpy</span>(func_symbols[func_symbol_count].name, name, <span class="keyword">sizeof</span>(func_symbols[func_symbol_count].name) - <span class="number">1</span>);</span><br><span class="line">                    func_symbols[func_symbol_count].name[<span class="keyword">sizeof</span>(func_symbols[func_symbol_count].name) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 确保字符串以 null 结尾</span></span><br><span class="line">                    func_symbols[func_symbol_count].addr = sym.st_value;</span><br><span class="line">                    func_symbols[func_symbol_count].size = sym.st_size;</span><br><span class="line">                    func_symbol_count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">free</span>(string_table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在<code>abstract-machine/scripts/platform/nemu.mk</code>中添加</li>
</ol>
<ul>
<li><code>NEMUFLAGS += -e $(IMAGE).elf</code></li>
</ul>
<ol start="5">
<li>在<code>nemu/src/cpu/cpu-exec.c</code>中：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> FuncSymbol *func_symbols;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> func_symbol_count;</span><br><span class="line"></span><br><span class="line">CallStackEntry call_stack[CALL_STACK_SIZE];</span><br><span class="line"><span class="type">int</span> call_stack_top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title function_">find_func_name</span><span class="params">(<span class="type">paddr_t</span> addr)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; func_symbol_count; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (func_symbols[i].addr &lt;= addr &amp;&amp; addr &lt; func_symbols[i].addr + func_symbols[i].size) &#123;</span><br><span class="line">      <span class="keyword">return</span> func_symbols[i].name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;???&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">trace_and_difftest</span><span class="params">(Decode *_this, <span class="type">vaddr_t</span> dnpc)</span> &#123;</span><br><span class="line"><span class="comment">//其它</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 记录函数调用和返回</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *func_name = find_func_name(_this-&gt;pc);</span><br><span class="line">  <span class="keyword">if</span> (func_name) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FTRACE: Call %s at 0x%08x\n&quot;</span>, func_name, _this-&gt;pc);</span><br><span class="line">  &#125;</span><br><span class="line">  func_name = find_func_name(dnpc);</span><br><span class="line">  <span class="keyword">if</span> (func_name) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FTRACE: Return from %s to 0x%08x\n&quot;</span>, func_name, dnpc);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//其它</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">exec_once</span><span class="params">(Decode *s, <span class="type">vaddr_t</span> pc)</span> &#123;</span><br><span class="line">  s-&gt;pc = pc;</span><br><span class="line">  s-&gt;snpc = pc;</span><br><span class="line">  isa_exec_once(s);</span><br><span class="line">  cpu.pc = s-&gt;dnpc;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 识别函数调用和返回指令</span></span><br><span class="line">  <span class="type">uint32_t</span> inst = s-&gt;isa.inst.val;</span><br><span class="line">  <span class="keyword">if</span> ((inst &amp; <span class="number">0x7f</span>) == <span class="number">0x6f</span>) &#123; <span class="comment">// JAL</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *func_name = find_func_name(s-&gt;dnpc);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(func_name, <span class="string">&quot;???&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;FTRACE: Call %s at 0x%08x\n&quot;</span>, func_name, s-&gt;dnpc);</span><br><span class="line">      <span class="keyword">if</span> (call_stack_top &lt; CALL_STACK_SIZE) &#123;</span><br><span class="line">        call_stack[call_stack_top].pc = s-&gt;dnpc;</span><br><span class="line">        call_stack[call_stack_top].func_name = func_name;</span><br><span class="line">        call_stack_top++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((inst &amp; <span class="number">0x7f</span>) == <span class="number">0x67</span>) &#123; <span class="comment">// JALR</span></span><br><span class="line">    <span class="keyword">if</span> (((inst &gt;&gt; <span class="number">7</span>) &amp; <span class="number">0x1f</span>) == <span class="number">1</span>) &#123; <span class="comment">// rd == ra</span></span><br><span class="line">      <span class="type">const</span> <span class="type">char</span> *func_name = find_func_name(s-&gt;dnpc);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(func_name, <span class="string">&quot;???&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;FTRACE: Return from %s to 0x%08x\n&quot;</span>, func_name, s-&gt;dnpc);</span><br><span class="line">        <span class="keyword">if</span> (call_stack_top &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          call_stack_top--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Executed instruction at pc = 0x%08x, next pc = 0x%08x\n&quot;</span>, s-&gt;pc, s-&gt;dnpc);</span><br><span class="line"><span class="comment">//其它</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">assert_fail_msg</span><span class="params">()</span> &#123;</span><br><span class="line">  isa_reg_display();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 输出当前函数调用信息</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Current function call information:\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; call_stack_top; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%08x: call [%s@0x%08x]\n&quot;</span>, call_stack[i].pc, call_stack[i].func_name, call_stack[i].pc);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *func_name = find_func_name(cpu.pc);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(func_name, <span class="string">&quot;???&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FTRACE: Current function %s at 0x%08x\n&quot;</span>, func_name, cpu.pc);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FTRACE: No function found at 0x%08x\n&quot;</span>, cpu.pc);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  display_iringbuf();</span><br><span class="line">  statistic();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>一直没有解析ELF，调试后发现:在当前的代码实现中，只有在命令行参数中提供 -e 选项时，才会解析 ELF 文件。要实现不提供 -e 选项时自动解析 ELF 文件，可以在<code>nemu/src/monitor/monitor.c</code>的<code>init_monitor</code> 函数中添加一个默认的 ELF 文件路径，并在没有提供 -e 选项时使用这个默认路径。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数调用踪迹,ftrace. */</span></span><br><span class="line">  <span class="keyword">if</span> (elf_file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    elf_file = <span class="string">&quot;default.elf&quot;</span>;  <span class="comment">// 设置默认的ELF文件路径</span></span><br><span class="line">  &#125;</span><br><span class="line">  init_ftrace(elf_file);</span><br></pre></td></tr></table></figure>
<ul>
<li>删掉<code>elf_file = &quot;default.elf&quot;;</code>，不自动启动，需要在命令行提供-e和elf文件</li>
</ul>
<ol start="7">
<li>成功！类似：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Executed instruction at pc = 0x800002c4, next pc = 0x800000cc</span><br><span class="line">FTRACE: Call strcmp at 0x800002c4</span><br><span class="line">FTRACE: Return from main to 0x800000cc</span><br><span class="line">Executed instruction at pc = 0x800000cc, next pc = 0x800000d0</span><br><span class="line">FTRACE: Call main at 0x800000cc</span><br><span class="line">FTRACE: Return from main to 0x800000d0</span><br><span class="line">FTRACE: Call check at 0x80000010</span><br><span class="line">Executed instruction at pc = 0x800000d0, next pc = 0x80000010</span><br><span class="line">FTRACE: Call main at 0x800000d0</span><br><span class="line">FTRACE: Return from check to 0x80000010</span><br><span class="line">Executed instruction at pc = 0x80000010, next pc = 0x80000014</span><br><span class="line">FTRACE: Call check at 0x80000010</span><br><span class="line">FTRACE: Return from check to 0x80000014</span><br></pre></td></tr></table></figure>
<ul>
<li>但是有点丑，<ul>
<li>把<code>printf(&quot;Executed instruction at pc = 0x%08x, next pc = 0x%08x\n&quot;, s-&gt;pc, s-&gt;dnpc);</code>注释后，片段如下：</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FTRACE: Call main at 0x800000dc</span><br><span class="line">FTRACE: Return from main to 0x800000e0</span><br><span class="line">FTRACE: Call main at 0x800000e0</span><br><span class="line">FTRACE: Return from main to 0x800000e4</span><br><span class="line">FTRACE: Call main at 0x800000e4</span><br><span class="line">FTRACE: Return from _trm_init to 0x80000108</span><br><span class="line">FTRACE: Call _trm_init at 0x80000108</span><br><span class="line">FTRACE: Return from _trm_init to 0x8000010c</span><br><span class="line">FTRACE: Call _trm_init at 0x8000010c</span><br><span class="line">FTRACE: Return from _trm_init to 0x80000110</span><br></pre></td></tr></table></figure>
<h4 id="思考：不匹配的函数调用和返回"><a href="#思考：不匹配的函数调用和返回" class="headerlink" title="思考：不匹配的函数调用和返回"></a>思考：不匹配的函数调用和返回</h4><ul>
<li>如果你仔细观察上文recursion的示例输出, 你会发现一些有趣的现象. 具体地, 注释(1)处的ret的函数是和对应的call匹配的, 也就是说, call调用了f2, 而与之对应的ret也是从f2返回; 但注释(2)所指示的一组call和ret的情况却有所不同, call调用了f1, 但却从f0返回; 注释(3)所指示的一组call和ret也出现了类似的现象, call调用了f1, 但却从f3返回.</li>
<li>尝试结合反汇编结果, 分析为什么会出现这一现象.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">0x8000000c: call [_trm_init@0x80000260]</span><br><span class="line">0x80000270:   call [main@0x800001d4]</span><br><span class="line">0x800001f8:     call [f0@0x80000010]</span><br><span class="line">0x8000016c:       call [f2@0x800000a4]</span><br><span class="line">0x800000e8:         call [f1@0x8000005c]</span><br><span class="line">0x8000016c:           call [f2@0x800000a4]</span><br><span class="line">0x800000e8:             call [f1@0x8000005c]</span><br><span class="line">0x8000016c:               call [f2@0x800000a4]</span><br><span class="line">0x800000e8:                 call [f1@0x8000005c]</span><br><span class="line">0x8000016c:                   call [f2@0x800000a4]</span><br><span class="line">0x800000e8:                     call [f1@0x8000005c]</span><br><span class="line">0x8000016c:                       call [f2@0x800000a4]</span><br><span class="line">0x800000e8:                         call [f1@0x8000005c]</span><br><span class="line">0x80000058:                         ret  [f0]              # 注释(2)</span><br><span class="line">0x800000fc:                       ret  [f2]                # 注释(1)</span><br><span class="line">0x80000180:                       call [f2@0x800000a4]</span><br><span class="line">0x800000e8:                         call [f1@0x8000005c]</span><br><span class="line">0x80000058:                         ret  [f0]</span><br><span class="line">0x800000fc:                       ret  [f2]</span><br><span class="line">0x800001b0:                     ret  [f3]                  # 注释(3)</span><br><span class="line">0x800000fc:                   ret  [f2]</span><br><span class="line">0x80000180:                   call [f2@0x800000a4]</span><br><span class="line">0x800000e8:                     call [f1@0x8000005c]</span><br><span class="line">0x8000016c:                       call [f2@0x800000a4]</span><br><span class="line">0x800000e8:                         call [f1@0x8000005c]</span><br><span class="line">0x80000058:                         ret  [f0]</span><br></pre></td></tr></table></figure>
<ol>
<li>现象描述</li>
<li>注释(1)<br>- call [f2@0x800000a4]<br>- ret [f2]<br>- 这是正常的函数调用和返回，call调用了f2，并从f2返回。</li>
<li>注释(2)<br>- call [f1@0x8000005c]<br>- ret [f0]<br>- 这里出现了不匹配的现象，call调用了f1，但却从f0返回。</li>
<li>注释(3)<br>- call [f1@0x8000005c]<br>- ret [f3]<br>- 这里也出现了不匹配的现象，call调用了f1，但却从f3返回。</li>
<li>可能的原因</li>
</ol>
<ul>
<li>这种不匹配的现象通常是由于函数调用过程中存在间接调用或尾调用优化（Tail Call Optimization, TCO）导致的。以下是两种可能的原因：</li>
</ul>
<ol>
<li>间接调用<br>- 在函数f1内部，可能存在对其他函数（如f0或f3）的间接调用。<br>- 这种情况下，f1在执行过程中调用了f0或f3，并直接从这些函数返回，而不是从f1返回。</li>
<li>尾调用优化<br>- 尾调用优化是一种编译器优化技术，当一个函数的最后一个操作是调用另一个函数时，编译器可以优化为直接跳转到被调用函数，而不需要返回到调用者。<br>- 这种优化可以减少栈帧的开销，提高程序的执行效率。<br>- 在这种情况下，f1的最后一个操作是调用f0或f3，编译器优化为直接跳转到f0或f3，并从这些函数返回。</li>
</ol>
<h4 id="思考：冗余的符号表"><a href="#思考：冗余的符号表" class="headerlink" title="思考：冗余的符号表"></a>思考：冗余的符号表</h4><ol>
<li>在Linux下编写一个Hello World程序, 然后使用strip命令丢弃可执行文件中的符号表:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br><span class="line">strip -s hello</span><br></pre></td></tr></table></figure>
<ul>
<li>用readelf查看hello的信息, 你会发现符号表被丢弃了, 此时的hello程序能成功运行吗?</li>
</ul>
<ol start="2">
<li>目标文件中也有符号表, 我们同样可以丢弃它:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c</span><br><span class="line">strip -s hello.o</span><br></pre></td></tr></table></figure>
<ul>
<li>用readelf查看hello.o的信息, 你会发现符号表被丢弃了. 尝试对hello.o进行链接:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello hello.o</span><br></pre></td></tr></table></figure>
<ul>
<li>你发现了什么问题? 尝试对比上述两种情况, 并分析其中的原因.</li>
</ul>
<ol>
<li>Hello World程序: 即使符号表被丢弃，hello程序仍然能够成功运行。</li>
</ol>
<ul>
<li>因为可执行文件中的符号表主要用于调试和链接阶段，而不是程序运行时所需的内容。</li>
<li>程序运行时所需的所有信息（如代码和数据）已经被嵌入到可执行文件中，因此丢弃符号表不会影响程序的运行。</li>
</ul>
<ol start="2">
<li>目标文件中的符号表: 在尝试链接时，发现链接失败，出现错误信息：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: hello.o: in function `main&#x27;:</span><br><span class="line">(.text+0x1b): undefined reference to `printf&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
<ul>
<li>目标文件中的符号表用于链接阶段，记录了函数和变量的名称、类型和地址等信息。</li>
<li>链接器需要这些符号信息来解析外部引用和生成最终的可执行文件。</li>
<li>如果目标文件中的符号表被丢弃，链接器将无法解析外部引用（如printf函数），导致链接失败。</li>
</ul>
<h2 id="AM作为基础设施"><a href="#AM作为基础设施" class="headerlink" title="AM作为基础设施"></a>AM作为基础设施</h2><ul>
<li>AM的核心思想了: 通过一组抽象的API把程序和架构解耦<ul>
<li>保证了运行在AM之上的代码(包括klib)都是架构无关的, 这恰恰增加了代码的可移植性.</li>
</ul>
</li>
</ul>
<ol>
<li><code>abstract-machine</code>中有一个特殊的架构叫<code>native</code>, 是用GNU&#x2F;Linux默认的运行时环境来实现的AM API. </li>
<li>在<code>abstract-machine</code>中, 我们可以很容易地把程序编译到另一个架构上运行, 例如在<code>am-kernels/tests/cpu-tests/</code>目录下执行</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ALL=string ARCH=native run</span><br></pre></td></tr></table></figure>
<ul>
<li>即可将string程序编译到native并运行. 由于我们会将程序编译到不同的架构中, 因此你需要注意make命令中的ARCH参数.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exit code = 00h</span><br><span class="line">test list [1 item(s)]: string</span><br><span class="line">[        string] PASS</span><br></pre></td></tr></table></figure>
<ul>
<li>如果string程序没有通过测试, 终端将会输出</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make[1]: *** [run] Error 1</span><br></pre></td></tr></table></figure>
<ul>
<li>当然也有可能输出段错误等信息.</li>
</ul>
<h4 id="思考：奇怪的错误码"><a href="#思考：奇怪的错误码" class="headerlink" title="思考：奇怪的错误码"></a>思考：奇怪的错误码</h4><ul>
<li>为什么错误码是1呢? 你知道make程序是如何得到这个错误码的吗?</li>
</ul>
<ol>
<li>错误码1的含义：</li>
</ol>
<ul>
<li>在Unix和Linux系统中，程序的退出状态码（exit code）是一个整数值，用于表示程序的执行结果。</li>
<li>通常，0表示成功，非0表示失败。</li>
<li>错误码1通常表示一般性错误（general error），即程序执行过程中发生了某种错误，但没有具体的错误类型。</li>
</ul>
<ol start="2">
<li>make得到错误码的过程：</li>
</ol>
<ul>
<li>make程序通过执行命令并检查其退出状态码来确定命令是否成功。如果命令返回非0的退出状态码，make会认为该命令失败，并输出相应的错误信息</li>
</ul>
<hr>
<ul>
<li>框架代码编译到native的时候默认链接到<code>glibc</code>, 我们需要把这些库函数的调用链接到我们编写的<code>klib</code>来进行测试. <ul>
<li>我们可以通过在<code>abstract-machine/klib/include/klib.h</code> 中通过<strong>定义宏</strong><code>__NATIVE_USE_KLIB__</code>来把库函数链接到klib. </li>
<li>如果不定义这个宏, 库函数将会链接到glibc,** 可以作为正确的参考实现来进行对比**.</li>
</ul>
</li>
</ul>
<h4 id="思考：这是如何实现的"><a href="#思考：这是如何实现的" class="headerlink" title="思考：这是如何实现的?"></a>思考：这是如何实现的?</h4><ul>
<li>为什么定义宏__NATIVE_USE_KLIB__之后就可以把native上的这些库函数链接到klib? 这具体是如何发生的? 尝试根据你在课堂上学习的链接相关的知识解释这一现象.</li>
<li>当定义了宏__NATIVE_USE_KLIB__时，编译器会包含klib_impl.h，从而使用我们自己实现的klib库函数；否则，编译器会包含标准库的头文件，使用glibc的实现。</li>
<li>具体过程：<ol>
<li>定义宏：在编译时定义宏__NATIVE_USE_KLIB__。</li>
<li>条件编译：编译器根据宏__NATIVE_USE_KLIB__选择性地包含klib_impl.h，从而使用我们自己实现的klib库函数。</li>
<li>链接过程：链接器在链接过程中将printf函数链接到klib_impl.c中实现的printf函数，而不是标准库中的printf函数。</li>
</ol>
</li>
</ul>
<h2 id="测试你的klib"><a href="#测试你的klib" class="headerlink" title="测试你的klib"></a>测试你的klib</h2><ul>
<li>需要编写一些充分的测试用例来专门对klib的实现进行测试.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----&gt; 测试对象 ----&gt; 实际输出</span><br><span class="line"> |                        |</span><br><span class="line">输入                      +----&gt; 一致?</span><br><span class="line"> |                        |</span><br><span class="line"> +----&gt; 某种方法 ----&gt; 预期输出</span><br></pre></td></tr></table></figure>
<h4 id="选做：编写更多的测试"><a href="#选做：编写更多的测试" class="headerlink" title="选做：编写更多的测试"></a>选做：编写更多的测试</h4><ul>
<li>尝试理解上述测试代码是如何进行测试的, 并在<code>am-kernels/tests/</code>目录下新增一个针对<code>klib</code>的测试集<code>klib-tests</code>, 测试集的文件结构可以参考<code>am-kernels/tests/am-tests</code>或<code>am-kernels/kernels/hello</code>.</li>
<li>然后针对上文所述的第一类写入函数编写相应的测试代码. 编写测试的时候需要注意一些地方:<ul>
<li><code>memcpy()</code>的行为在区间重叠的时候是UB, 你可以在遍历的时候检查区间是否重叠, 若是, 则跳过此次检查; 或者使用另一个相同的数组来作为src, 这样就不会出现重叠的情况</li>
<li>字符串处理函数需要额外注意\0和缓冲区溢出的问题</li>
</ul>
</li>
<li>编写后, 你可以先在native上用glibc的库函数来测试你编写的测试代码, 然后在native上用这些测试代码来测试你的klib实现, 最后再在NEMU上运行这些测试代码来测试你的NEMU实现.</li>
</ul>
<ol>
<li>创建目录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">am-kernels/tests/klib-tests/</span><br><span class="line">├── include/</span><br><span class="line">│   └── klib.h</span><br><span class="line">├── src/</span><br><span class="line">│   └── test_memset.c</span><br><span class="line">├── Makefile</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在<code>klib.h</code>中包含需要测试的函数声明</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KLIB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KLIB_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *s, <span class="type">int</span> c, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// KLIB_H</span></span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在<code>src/test_type1.c</code>中编写测试代码</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;klib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> data[N];</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> src[N];</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> str_data[N];</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> src_str[N] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置数据数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reset</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        data[i] = i + <span class="number">1</span>;</span><br><span class="line">        src[i] = i + <span class="number">101</span>;</span><br><span class="line">        str_data[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查[l,r)区间中的值是否依次为val, val + 1, val + 2...</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_seq</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt; r; i++) &#123;</span><br><span class="line">        assert(data[i] == val + i - l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查[l,r)区间中的值是否均为val</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_eq</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt; r; i++) &#123;</span><br><span class="line">        assert(data[i] == val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 memset 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_memset</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="keyword">for</span> (l = <span class="number">0</span>; l &lt; N; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (r = l + <span class="number">1</span>; r &lt;= N; r++) &#123;</span><br><span class="line">            reset();</span><br><span class="line">            <span class="type">uint8_t</span> val = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">memset</span>(data + l, val, r - l);</span><br><span class="line">            check_seq(<span class="number">0</span>, l, <span class="number">1</span>);</span><br><span class="line">            check_eq(l, r, val);</span><br><span class="line">            check_seq(r, N, r + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test_memset passed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 memcpy 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_memcpy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="keyword">for</span> (l = <span class="number">0</span>; l &lt; N; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (r = l + <span class="number">1</span>; r &lt;= N; r++) &#123;</span><br><span class="line">            reset();</span><br><span class="line">            <span class="built_in">memcpy</span>(data + l, src + l, r - l);</span><br><span class="line">            check_seq(<span class="number">0</span>, l, <span class="number">1</span>);</span><br><span class="line">            check_seq(l, r, <span class="number">101</span> + l);</span><br><span class="line">            check_seq(r, N, r + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test_memcpy passed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 strcpy 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_strcpy</span><span class="params">()</span> &#123;</span><br><span class="line">    reset();</span><br><span class="line">    <span class="built_in">strcpy</span>(str_data, src_str);</span><br><span class="line">    assert(<span class="built_in">strcmp</span>(str_data, src_str) == <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test_strcpy passed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    test_memset();</span><br><span class="line">    test_memcpy();</span><br><span class="line">    test_strcpy();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在<code>Makefile</code>中添加编译和运行测试的规则</li>
</ol>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ARCH ?= native</span><br><span class="line">CFLAGS := -I<span class="variable">$(PWD)</span>/<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: test_type1</span></span><br><span class="line"></span><br><span class="line"><span class="section">test_type1: src/test_type1.c</span></span><br><span class="line">  <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">run: test_type1</span></span><br><span class="line">	./test_type1</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f test_type1</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>在<code>am-kernels/tests/klib-tests</code>下<code>make</code>,</li>
</ol>
<ul>
<li>报错<code>make Makefile:7: *** 缺失分隔符。 停止。</code></li>
<li>改了设置的：使用Tab键时插入空格”为用缩进！</li>
<li>编译成功得到</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc -I/home/xiaoyao/ics2024/am-kernels/tests/klib-tests/include -o test_type1 src/test_type1.c</span><br></pre></td></tr></table></figure>
<ol start="6">
<li><code>make run</code>,成功则得到：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./test_type1</span><br><span class="line">test_memset passed.</span><br><span class="line">test_memcpy passed.</span><br><span class="line">test_strcpy passed.</span><br></pre></td></tr></table></figure>
<h4 id="选做：编写更多的测试-2"><a href="#选做：编写更多的测试-2" class="headerlink" title="选做：编写更多的测试(2)"></a>选做：编写更多的测试(2)</h4><ul>
<li>尝试为klib-tests添加针对<strong>第二类只读函数</strong>的测试, 例如<code>memcmp()</code>, <code>strlen()</code>等. 思考一下, 应该如何得到函数的预期输出?</li>
</ul>
<ol>
<li><code>tests/klib-tests/src/test_type2.c</code>:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/klib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> data[N];</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> str_data[N] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> str_data2[N] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> str_data3[N] = <span class="string">&quot;Hello, Klib!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置数据数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reset</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        data[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 memcmp 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_memcmp</span><span class="params">()</span> &#123;</span><br><span class="line">    reset();</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(data, data, N) == <span class="number">0</span>);</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(data, data + <span class="number">1</span>, N - <span class="number">1</span>) &lt; <span class="number">0</span>);</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(data + <span class="number">1</span>, data, N - <span class="number">1</span>) &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test_memcmp passed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 strlen 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_strlen</span><span class="params">()</span> &#123;</span><br><span class="line">    assert(<span class="built_in">strlen</span>(str_data) == <span class="number">13</span>);</span><br><span class="line">    assert(<span class="built_in">strlen</span>(str_data2) == <span class="number">13</span>);</span><br><span class="line">    assert(<span class="built_in">strlen</span>(str_data3) == <span class="number">12</span>);<span class="comment">//字符串&quot;Hello, Klib!&quot;的实际长度是 12，因为它包含了一个终止字符\0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test_strlen passed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    test_memcmp();</span><br><span class="line">    test_strlen();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>klib.h</code>增加：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *s1, <span class="type">const</span> <span class="type">void</span> *s2, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>Makefile</code>补充为:</li>
</ol>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ARCH ?= native</span><br><span class="line">CFLAGS := -I<span class="variable">$(PWD)</span>/<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: test_type1 test_type2</span></span><br><span class="line"></span><br><span class="line"><span class="section">test_type1: src/test_type1.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">test_type2: src/test_type2.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">run: test_type1 test_type2</span></span><br><span class="line">    ./test_type1</span><br><span class="line">    ./test_type2</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f test_type1 test_type2</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><code>make</code>一下,然后<code>make run</code>：(成功！)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/test_type2.c</span><br><span class="line">./test_type1</span><br><span class="line">test_memset passed.</span><br><span class="line">test_memcpy passed.</span><br><span class="line">test_strcpy passed.</span><br><span class="line">./test_type2</span><br><span class="line">test_memcmp passed.</span><br><span class="line">test_strlen passed.</span><br></pre></td></tr></table></figure>
<h4 id="选做：编写更多的测试-3"><a href="#选做：编写更多的测试-3" class="headerlink" title="选做：编写更多的测试(3)"></a>选做：编写更多的测试(3)</h4><ul>
<li>尝试为klib-tests添加针对<strong>格式化输出函数</strong>的测试. 你可以先通过<code>sprintf()</code>把实际输出打印到一个缓冲区中, 然后通过<code>strcmp()</code>来和预期输出进行对比.</li>
<li>你也可以考虑实现位宽, 精度, 长度修饰符等功能, 然后生成相应的测试用例来进行测试.</li>
<li>以<code>%d</code>为例, 我们需要构造一些输入. 但整数的范围太大了, 不能全部遍历它们, 因此我们需要挑选一些有代表性的整数.<code>limits.h</code>这个C标准头文件里面包含了一些最大数和最小数的定义, 你可以打开<code>/usr/include/limits.h</code>来阅读它们. 一些有代表性的整数可以是:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int data[] = &#123;0, INT_MAX / 17, INT_MAX, INT_MIN, INT_MIN + 1,</span><br><span class="line">              UINT_MAX / 17, INT_MAX / 17, UINT_MAX&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>为了得到相应的预期输出, 我们可以先编写一个<code>native</code>程序来用<code>printf</code>输出它们, 然后把输出结果整理到测试代码里面. <code>cpu-tests</code>中的预期输出也是这样生成的.</li>
</ul>
<h5 id="先编写一个native程序来用printf输出它们"><a href="#先编写一个native程序来用printf输出它们" class="headerlink" title="先编写一个native程序来用printf输出它们"></a>先编写一个native程序来用printf输出它们</h5><ol>
<li>在<code>klib-tests</code>目录下创建一个新的文件<code>generate_expected_output.c</code>：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> data[] = &#123;<span class="number">0</span>, INT_MAX / <span class="number">17</span>, INT_MAX, INT_MIN, INT_MIN + <span class="number">1</span>,</span><br><span class="line">                  UINT_MAX / <span class="number">17</span>, INT_MAX / <span class="number">17</span>, UINT_MAX&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(data) / <span class="keyword">sizeof</span>(data[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>编译<code>generate_expected_output.c</code>:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /path/to/am-kernels/tests/klib-tests</span><br><span class="line">gcc -o generate_expected_output generate_expected_output.c</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>运行生成的可执行文件&#96;:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./generate_expected_output</span><br></pre></td></tr></table></figure>
<ul>
<li>输出结果为：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">126322567</span><br><span class="line">2147483647</span><br><span class="line">-2147483648</span><br><span class="line">-2147483647</span><br><span class="line">252645135</span><br><span class="line">126322567</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<h5 id="把输出结果整理到测试代码里面，编写nemu的测试"><a href="#把输出结果整理到测试代码里面，编写nemu的测试" class="headerlink" title="把输出结果整理到测试代码里面，编写nemu的测试"></a>把输出结果整理到测试代码里面，编写nemu的测试</h5><ol>
<li><code>src/test_type3.c</code>中编写测试代码：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/klib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_sprintf</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> data[] = &#123;<span class="number">0</span>, INT_MAX / <span class="number">17</span>, INT_MAX, INT_MIN, INT_MIN + <span class="number">1</span>,</span><br><span class="line">                  UINT_MAX / <span class="number">17</span>, INT_MAX / <span class="number">17</span>, UINT_MAX&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *expected[] = &#123;</span><br><span class="line">        <span class="string">&quot;0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;126322567&quot;</span>,</span><br><span class="line">        <span class="string">&quot;2147483647&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-2147483648&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-2147483647&quot;</span>,</span><br><span class="line">        <span class="string">&quot;252645135&quot;</span>,</span><br><span class="line">        <span class="string">&quot;126322567&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-1&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(data) / <span class="keyword">sizeof</span>(data[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%d&quot;</span>, data[i]);</span><br><span class="line">        assert(<span class="built_in">strcmp</span>(buffer, expected[i]) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test_sprintf passed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    test_sprintf();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>klib.h</code>补充函数声明：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>Makefile中添加编译和运行<code>test_type3.c</code>的规则：</li>
</ol>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: test_type1 test_type2 test_type3</span></span><br><span class="line"></span><br><span class="line"><span class="section">test_type3: src/test_type3.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">run: test_type1 test_type2</span></span><br><span class="line">	./test_type1</span><br><span class="line">	./test_type2</span><br><span class="line">	./test_type3</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f test_type1 test_type2 test_type3</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><code>make</code>和<code>make run</code>:(成功！！)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">./test_type3</span><br><span class="line">Expected: 0, Got: 0</span><br><span class="line">Expected: 126322567, Got: 126322567</span><br><span class="line">Expected: 2147483647, Got: 2147483647</span><br><span class="line">Expected: -2147483648, Got: -2147483648</span><br><span class="line">Expected: -2147483647, Got: -2147483647</span><br><span class="line">Expected: 252645135, Got: 252645135</span><br><span class="line">Expected: 126322567, Got: 126322567</span><br><span class="line">Expected: -1, Got: -1</span><br><span class="line">test_sprintf passed.</span><br></pre></td></tr></table></figure>
<h2 id="Differential-Testing——强大的测试工具！"><a href="#Differential-Testing——强大的测试工具！" class="headerlink" title="Differential Testing——强大的测试工具！"></a>Differential Testing——强大的测试工具！</h2><ul>
<li>如果有一种方法能够表达指令的正确行为, 我们就可以基于这种方法来进行类似<code>assert()</code>的检查了——ISA手册。<ul>
<li>如果有一个ISA手册的参考实现就好了——我们用的<strong>真机</strong>。</li>
<li>我们让在NEMU中执行的每条指令也在真机中执行一次, 然后对比NEMU和真机的状态, 如果NEMU和真机的状态不一致, 我们就捕捉到error了</li>
</ul>
</li>
<li>这种方法在软件测试领域称为<strong>differential testing</strong>(后续简称<strong>DiffTest</strong>).<ul>
<li>进行DiffTest需要提供一个和<strong>DUT</strong>(Design Under Test, 测试对象) <strong>功能相同但实现方式不同</strong>的<strong>REF</strong>(Reference, 参考实现)</li>
<li>然后让它们接受<strong>相同的有定义的输入</strong>, 观测它们的<strong>行为是否相同</strong>.</li>
</ul>
</li>
<li>遗憾：真机上是运行了操作系统GNU&#x2F;Linux的, 我们无法在native中运行编译到<code>x86-nemu</code>的AM程序, 对于<code>mips32</code>和<code>riscv32</code>的程序, 真机更是无法直接运行. <ul>
<li>所以, 我们需要的不仅是一个ISA手册的正确实现, 而且<strong>需要在上面能正确运行$ISA-nemu的AM程序</strong>.</li>
</ul>
</li>
<li>因此, 为了通过DiffTest的方法测试NEMU实现的正确性, 我们让NEMU和另一个模拟器逐条指令地执行同一个客户程序. 双方每执行完一条指令, 就检查各自的寄存器和内存的状态, 如果发现状态不一致, 就马上报告错误, 停止客户程序的执行.</li>
</ul>
<ol>
<li>为了方便实现DiffTest, 我们在DUT和REF之间定义了如下的一组API:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在DUT host memory的`buf`和REF guest memory的`addr`之间拷贝`n`字节,</span></span><br><span class="line"><span class="comment">// `direction`指定拷贝的方向, `DIFFTEST_TO_DUT`表示往DUT拷贝, `DIFFTEST_TO_REF`表示往REF拷贝</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">difftest_memcpy</span><span class="params">(<span class="type">paddr_t</span> addr, <span class="type">void</span> *buf, <span class="type">size_t</span> n, <span class="type">bool</span> direction)</span>;</span><br><span class="line"><span class="comment">// `direction`为`DIFFTEST_TO_DUT`时, 获取REF的寄存器状态到`dut`;</span></span><br><span class="line"><span class="comment">// `direction`为`DIFFTEST_TO_REF`时, 设置REF的寄存器状态为`dut`;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">difftest_regcpy</span><span class="params">(<span class="type">void</span> *dut, <span class="type">bool</span> direction)</span>;</span><br><span class="line"><span class="comment">// 让REF执行`n`条指令</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">difftest_exec</span><span class="params">(<span class="type">uint64_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 初始化REF的DiffTest功能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">difftest_init</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中寄存器状态<code>dut</code>要求<strong>寄存器的成员按照某种顺序排列</strong>, 若未按要求顺序排列, difftest_regcpy()的行为是未定义的. <ul>
<li>REF需要实现这些API, DUT会使用这些API来进行DiffTest. 在这里, DUT和REF分别是NEMU和其它模拟器.</li>
</ul>
</li>
</ul>
<ol start="2">
<li>NEMU的框架代码已经准备好DiffTest的功能了, 在menuconfig中打开相应的选项:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Testing and Debugging</span><br><span class="line">  [*] Enable differential testing</span><br></pre></td></tr></table></figure>
<ul>
<li>然后重新编译NEMU并运行即可</li>
<li>riscv32: <strong>Spike</strong>. Spike是RISC-V社区的一款全系统模拟器, 它的工作原理与NEMU非常类似. 我们在Spike中增加了少量接口来实现DiffTest的API. 由于Spike包含较多源文件, 编译过程可能需要花费数分钟. 为了运行Spike, 你还需要安装另一个工具:</li>
<li><code>apt-get install device-tree-compiler</code></li>
</ul>
<ol start="3">
<li>由于不同ISA的寄存器有所不同, 框架代码把寄存器对比抽象成一个ISA相关的API, 即<code>isa_difftest_checkregs()</code>函数(在<code>nemu/src/isa/$ISA/difftest/dut.c</code>中定义). 你需要实现<code>isa_difftest_checkregs()</code>函数, 把通用寄存器和PC与从DUT中读出的寄存器的值进行比较. 若对比结果一致, 函数返回true; 如果发现值不一样, 函数返回false, 框架代码会自动停止客户程序的运行. 特别地, isa_difftest_checkregs()对比结果不一致时, 第二个参数pc应指向导致对比结果不一致的指令, 可用于打印提示信息.</li>
</ol>
<h4 id="选做：实现DiffTest"><a href="#选做：实现DiffTest" class="headerlink" title="选做：实现DiffTest"></a>选做：实现DiffTest</h4><ul>
<li>上文在介绍API约定的时候, 提到了寄存器状态r需要把寄存器按照某种顺序排列. 你首先需要RTFSC, 从中找出这一顺序, 并检查你的NEMU实现是否已经满足约束.</li>
<li>然后在isa_difftest_checkregs()中添加相应的代码, 实现DiffTest的核心功能. 实现正确后, 你将会得到一款无比强大的测试工具.</li>
<li>体会到DiffTest的强大之后, 不妨思考一下: 作为一种基础设施, DiffTest能帮助你节省多少调试的时间呢?</li>
</ul>
<ol>
<li>寄存器状态r需要把<strong>寄存器按照某种顺序排列</strong>. 你首先需要RTFSC, 从中找出这一顺序, 并检查你的NEMU实现是否已经满足约束.</li>
</ol>
<ul>
<li><code>nemu/tools/spike-diff/difftest.cc</code></li>
</ul>
<ol start="2">
<li>实现<code>isa_difftest_checkregs</code>:——将<code>ref_c</code>的寄存器与<code>dut_cpu</code>的寄存器逐一比较</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isa_difftest_checkregs</span><span class="params">(CPU_state *ref_r, <span class="type">vaddr_t</span> pc)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ARRLEN(cpu.gpr); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cpu.gpr[i]._32 != ref_r-&gt;gpr[i]._32) &#123;</span><br><span class="line">      Log(<span class="string">&quot;Mismatch at gpr[%d]: DUT = 0x%08x, REF = 0x%08x&quot;</span>, i, cpu.gpr[i]._32, ref_r-&gt;gpr[i]._32);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cpu.pc != ref_r-&gt;pc) &#123;</span><br><span class="line">    Log(<span class="string">&quot;Mismatch at pc: DUT = 0x%08x, REF = 0x%08x&quot;</span>, cpu.pc, ref_r-&gt;pc);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>make run</code>一下，发现NEMU成功编译和运行，启用了 DiffTest 功能，并且使用了 spike-diff 作为参考动态库。</li>
</ol>
<h4 id="思考：匪夷所思的QEMU行为-有点难度"><a href="#思考：匪夷所思的QEMU行为-有点难度" class="headerlink" title="思考：匪夷所思的QEMU行为 (有点难度)"></a>思考：匪夷所思的QEMU行为 (有点难度)</h4><ul>
<li>在一些旧版的mips32-QEMU中, 仅在上述指令的PC值后12位为0xffc时, 才会进行指令打包. 这个打包条件看上去非常奇怪, 你知道可能的原因是什么吗?</li>
</ul>
<ol>
<li>缓存行对齐</li>
</ol>
<ul>
<li>现代处理器通常使用缓存来提高内存访问速度。缓存行的大小通常是固定的，例如64字节或128字节。</li>
<li>如果PC值的后12位为0xffc，这意味着指令的地址接近一个缓存行的末尾。为了避免跨缓存行访问，QEMU可能会选择在这种情况下进行指令打包，以提高缓存命中率和指令执行效率。</li>
</ul>
<ol start="2">
<li>指令预取优化</li>
</ol>
<ul>
<li>指令预取是处理器在执行指令之前，从内存中预先读取指令的一种技术。预取的指令通常存储在指令缓存中。</li>
<li>当PC值的后12位为0xffc时，指令地址接近一个预取块的末尾。为了确保预取块中的指令能够连续执行，QEMU可能会选择在这种情况下进行指令打包，以优化指令预取的效果。</li>
</ul>
<ol start="3">
<li>特定硬件行为的模拟</li>
</ol>
<ul>
<li>QEMU作为一个模拟器，可能需要模拟特定硬件的行为。在某些硬件平台上，指令打包可能会在特定的地址范围内触发。</li>
<li>QEMU可能在PC值的后12位为0xffc时进行指令打包，以模拟这些硬件平台的行为，确保模拟器的行为与实际硬件一致。</li>
</ul>
<ol start="4">
<li>历史遗留问题</li>
</ol>
<h4 id="使用QEMU作为REF时-不要同时运行两份NEMU"><a href="#使用QEMU作为REF时-不要同时运行两份NEMU" class="headerlink" title="使用QEMU作为REF时, 不要同时运行两份NEMU"></a>使用QEMU作为REF时, 不要同时运行两份NEMU</h4><ul>
<li>DiffTest会通过一个固定的端口连接到QEMU, 同时运行两份打开DiffTest的NEMU会出现以下信息:<code>Failed to find an available port: Address already in use</code></li>
<li>如果你确信没有同时运行两份NEMU, 但仍然遇到上述信息, 可以通过执行以下命令把残留在后台的QEMU杀掉:<code>pkill -9 qemu</code></li>
</ul>
<h2 id="一键回归测试"><a href="#一键回归测试" class="headerlink" title="一键回归测试"></a>一键回归测试</h2><ul>
<li>以后你还需要在NEMU中加入新的功能, 为了保证加入的<strong>新功能</strong>没有影响到<strong>已有功能</strong>的实现, 你还需要<em>重新运行这些测试用例</em>. 在软件测试中, 这个过程称为<strong>回归测试</strong>.</li>
<li>为了提高效率, 我们为<code>cpu-tests</code>提供了一键回归测试的功能:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=$ISA-nemu run</span><br></pre></td></tr></table></figure>
<ul>
<li>即可自动批量运行cpu-tests中的所有测试, 并报告每个测试用例的运行结果.</li>
</ul>
<hr>
<ul>
<li>PA2.2结束！</li>
</ul>
<h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><h2 id="设备与CPU"><a href="#设备与CPU" class="headerlink" title="设备与CPU"></a>设备与CPU</h2><ul>
<li>除了纯粹的数据读写之外, 我们还需要对设备进行控制:</li>
<li>比如需要获取键盘控制器的状态, 查看当前是否有按键被按下;</li>
<li>或者是需要有方式可以查询或设置VGA控制器的分辨率.</li>
<li>所以, 在程序看来, <strong>访问设备 &#x3D; 读出数据 + 写入数据 + 控制状态</strong>.</li>
<li>既然设备也有寄存器, 一种最简单的方法就是把<strong>设备的寄存器</strong>作为<strong>接口</strong>, 让<strong>CPU</strong>来访问这些寄存器. <ol>
<li>比如CPU可以从&#x2F;往设备的<em>数据寄存器</em>中读出&#x2F;写入数据, 进行数据的输入输出;</li>
<li>可以从设备的<em>状态寄存器</em>中读出设备的状态, 询问设备是否忙碌;</li>
<li>或者往设备的<em>命令寄存器</em>中写入命令字, 来修改设备的状态.</li>
</ol>
</li>
<li>CPU如何访问设备寄存器：</li>
<li>给<strong>设备中允许CPU访问的寄存器逐一编号</strong>, 然后通过<strong>指令</strong>来<strong>引用这些编号</strong>.</li>
<li>设备中可能会有一些<strong>私有</strong>寄存器, 它们是由设备自己维护的, 它们没有这样的编号, CPU不能直接访问它们.</li>
<li>这就是所谓的<strong>I&#x2F;O编址方式</strong>, 因此这些<strong>编号</strong>也称为<strong>设备的地址</strong>.</li>
<li>常用的编址方式有两种：</li>
</ul>
<h3 id="端口I-O"><a href="#端口I-O" class="headerlink" title="端口I&#x2F;O"></a>端口I&#x2F;O</h3><ul>
<li>一种I&#x2F;O编址方式是<strong>端口映射I&#x2F;O(port-mapped I&#x2F;O)</strong>, CPU使用专门的I&#x2F;O指令对设备进行访问, 并把<strong>设备的地址</strong>称作<strong>端口号</strong>.<ul>
<li>有了端口号以后, 在<em>I&#x2F;O指令中给出端口号</em>, 就知道要访问哪一个设备寄存器了.</li>
</ul>
</li>
<li>端口映射I&#x2F;O<code>把端口号作为I/O指令的一部分</code>, 这种方法很简单, 但同时也是它最大的<code>缺点</code><ul>
<li>指令集为了兼容已经开发的程序, 是只能添加但不能修改的. 这意味着, 端口映射I&#x2F;O所能访问的I&#x2F;O地址空间的大小, 在设计I&#x2F;O指令的那一刻就已经决定下来了. 所谓I&#x2F;O地址空间, 其实就是所有能访问的设备的地址的集合.</li>
<li>随着设备越来越多, 功能也越来越复杂, I&#x2F;O地址空间有限的端口映射I&#x2F;O已经逐渐不能满足需求了.</li>
</ul>
</li>
</ul>
<h3 id="內存映射I-O"><a href="#內存映射I-O" class="headerlink" title="內存映射I&#x2F;O"></a>內存映射I&#x2F;O</h3><ul>
<li><strong>内存映射I&#x2F;O(memory-mapped I&#x2F;O, MMIO)</strong> ,是通过不同的<strong>物理内存地址</strong>给设备编址的</li>
<li>这种编址方式将一部分物理内存的访问”重定向”到I&#x2F;O地址空间中, CPU尝试访问这部分物理内存的时候, 实际上最终是访问了相应的I&#x2F;O设备. 这样以后, CPU就可以通过普通的访存指令来访问设备</li>
<li>好处: 物理内存的地址空间和CPU的位宽都会不断增长, 内存映射I&#x2F;O从来不需要担心I&#x2F;O地址空间耗尽的问题.</li>
</ul>
<h4 id="思考：理解volatile关键字"><a href="#思考：理解volatile关键字" class="headerlink" title="思考：理解volatile关键字"></a>思考：理解volatile关键字</h4><ul>
<li>也许你从来都没听说过C语言中有volatile这个关键字, 但它从C语言诞生开始就一直存在. volatile关键字的作用十分特别, 它的作用是避免编译器对相应代码进行优化. 你应该动手体会一下volatile的作用, 在GNU&#x2F;Linux下编写以下代码:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> _end;  <span class="comment">// _end是什么?</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> *p = &amp;_end;</span><br><span class="line">  *p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(*p != <span class="number">0xff</span>);</span><br><span class="line">  *p = <span class="number">0x33</span>;</span><br><span class="line">  *p = <span class="number">0x34</span>;</span><br><span class="line">  *p = <span class="number">0x86</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后使用<code>-O2</code>编译代码. 尝试去掉代码中的<code>volatile</code>关键字, 重新使用<code>-O2</code>编译, 并对比去掉<code>volatile</code>前后反汇编结果的不同.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -O2 -c fun.c -o fun.o</span><br><span class="line">objdump -d fun.o &gt; fun_with_volatile.s</span><br></pre></td></tr></table></figure>
<ul>
<li>你或许会感到疑惑, 代码优化不是一件好事情吗? 为什么会有volatile这种奇葩的存在? 思考一下, 如果代码中p指向的地址最终被映射到一个设备寄存器, 去掉volatile可能会带来什么问题?</li>
</ul>
<ol>
<li>使用volatile关键字的反汇编结果</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000 &lt;fun&gt;:</span><br><span class="line">   0:   c6 05 00 00 00 00 00    movb   $0x0,0x0(%rip)        # 0x6</span><br><span class="line">   7:   80 3d 00 00 00 00 ff    cmpb   $0xff,0x0(%rip)       # 0xe</span><br><span class="line">   e:   75 f7                   jne    7 &lt;fun+0x7&gt;</span><br><span class="line">  10:   c6 05 00 00 00 00 33    movb   $0x33,0x0(%rip)       # 0x17</span><br><span class="line">  17:   c6 05 00 00 00 00 34    movb   $0x34,0x0(%rip)       # 0x1e</span><br><span class="line">  1e:   c6 05 00 00 00 00 86    movb   $0x86,0x0(%rip)       # 0x25</span><br></pre></td></tr></table></figure>
<ul>
<li>编译器不会对变量p进行优化，每次访问*p时都会从内存中读取最新的值。</li>
<li>反汇编结果中保留了所有对*p的写操作。</li>
</ul>
<ol start="2">
<li>去掉volatile关键字的反汇编结果</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00000000 &lt;fun&gt;:</span><br><span class="line">   0:   c6 05 00 00 00 00 00    movb   $0x0,0x0(%rip)        # 0x6</span><br><span class="line">   7:   80 3d 00 00 00 00 ff    cmpb   $0xff,0x0(%rip)       # 0xe</span><br><span class="line">   e:   75 f7                   jne    7 &lt;fun+0x7&gt;</span><br><span class="line">  10:   c6 05 00 00 00 00 86    movb   $0x86,0x0(%rip)       # 0x17</span><br></pre></td></tr></table></figure>
<ul>
<li>编译器认为*p的值不会在循环中被改变，因此可能会对代码进行优化。</li>
<li>反汇编结果中，编译器优化掉了中间的写操作，只保留了最后一次写操作。</li>
</ul>
<ol start="3">
<li>为什么会有volatile关键字:</li>
</ol>
<ul>
<li>代码优化通常是一件好事，可以提高程序的执行效率。然而，在某些情况下，优化可能会导致程序行为不符合预期。特别是当<strong>变量的值可能在程序的其他部分或外部环境中被改变时，编译器的优化可能会忽略这些变化，从而导致错误的行为</strong>。</li>
</ul>
<ol start="4">
<li>如果代码中p指向的地址最终被映射到一个设备寄存器，去掉volatile可能会带来什么问题？</li>
<li>设备状态无法及时更新<br>- 设备寄存器的值可能会在程序执行过程中被设备硬件改变。如果编译器对访问设备寄存器的代码进行了优化，可能会导致程序无法及时读取到设备的最新状态。</li>
<li>指令被优化掉<br>- 编译器可能会优化掉一些关键的读写操作，导致设备无法正确接收命令或数据。例如，上述代码中的循环可能会被优化掉，导致程序无法正确等待设备状态的变化。</li>
<li>不可预测的行为<br>- 由于设备寄存器的值可能在程序执行过程中被外部硬件改变，去掉volatile关键字可能会导致程序行为不可预测，难以调试和维护。</li>
</ol>
<h3 id="状态机视角下的输入输出"><a href="#状态机视角下的输入输出" class="headerlink" title="状态机视角下的输入输出"></a>状态机视角下的输入输出</h3><ul>
<li>设备是连接计算机和物理世界的桥梁.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">状态机模型           |           状态机模型之外</span><br><span class="line">S = &lt;R, M&gt;         |        D</span><br><span class="line">计算机/程序  &lt;----I/O指令----&gt; 设备 &lt;----模拟电路----&gt; 物理世界</span><br><span class="line">                   |</span><br><span class="line">                   |</span><br></pre></td></tr></table></figure>
<ul>
<li>对状态机模型的行为进行扩展——&gt;对输入输出相关指令的行为进行建模:<ol>
<li>执行<strong>普通指令</strong>时, 状态机按照<strong>TRM的模型</strong>进行状态转移</li>
<li>执行<strong>设备输出</strong>相关的指令(如x86的out指令或者RISC架构的MMIO写指令)时, 状态机除了<strong>更新PC</strong>之外, 其它状态均保持<em>不变</em>, 但<em>设备的状态和物理世界</em>则会发生相应的变化</li>
<li>执行<strong>设备输入</strong>相关的指令(如x86的in指令或者RISC架构的MMIO读指令)时, 状态机的<em>转移将会”分叉”</em>: 状态机不再像TRM那样有唯一的新状态了, <strong>状态机具体会转移到哪一个新状态, 将取决于执行这条指令时设备的状态</strong></li>
</ol>
</li>
</ul>
<h2 id="NEMU中的输入输出"><a href="#NEMU中的输入输出" class="headerlink" title="NEMU中的输入输出"></a>NEMU中的输入输出</h2><ul>
<li>NEMU的框架代码已经在<code>nemu/src/device/</code>目录下提供了设备相关的代码,</li>
</ul>
<h3 id="映射和I-O方式"><a href="#映射和I-O方式" class="headerlink" title="映射和I&#x2F;O方式"></a>映射和I&#x2F;O方式</h3><ul>
<li>可以通过对<strong>映射</strong>的管理来将<code>端口映射I/O</code>和<code>内存映射I/O</code>两种I&#x2F;O编址方式<strong>统一</strong>起来</li>
</ul>
<ol>
<li>框架代码为映射定义了一个<em>结构体类型</em><strong>IOMap</strong>(在<code>nemu/include/device/map.h</code>中定义), 包括</li>
</ol>
<ul>
<li>名字</li>
<li>映射的起始地址和结束地址</li>
<li>映射的目标空间</li>
<li>一个回调函数.</li>
</ul>
<ol start="2">
<li>然后在<code>nemu/src/device/io/map.c</code>实现了<strong>映射的管理</strong>, 包括</li>
</ol>
<ul>
<li>I&#x2F;O空间的分配及其映射</li>
<li>映射的访问接口.</li>
<li>其中<code>map_read()</code>和<code>map_write()</code>用于将地址<code>addr</code>映射到<code>map</code>所指示的目标空间, 并进行访问. 访问时, 可能会触发相应的回调函数, 对设备和目标空间的状态进行更新. 由于NEMU是单线程程序, 因此只能串行模拟整个计算机系统的工作, 每次进行I&#x2F;O读写的时候, 才会调用设备提供的<strong>回调函数</strong>(callback). <ul>
<li>基于这两个API, 我们就可以很容易实现端口映射I&#x2F;O和内存映射I&#x2F;O的模拟了.</li>
</ul>
</li>
</ul>
<ol start="3">
<li><code>nemu/src/device/io/port-io.c</code>是对<strong>端口映射I&#x2F;O</strong>的模拟. </li>
<li><code>add_pio_map()</code>函数用于为<strong>设备的初始化</strong>来<strong>注册</strong>一个端口映射I&#x2F;O的<strong>映射关系</strong>.</li>
<li><code>pio_read()</code>和<code>pio_write()</code>是面向CPU的端口I&#x2F;O读写接口, 它们最终会调用map_read()和map_write(), 对通过add_pio_map()注册的I&#x2F;O空间进行访问.</li>
<li><strong>内存映射I&#x2F;O</strong>的模拟是类似的, <code>paddr_read()</code>和<code>paddr_write()</code>会判断地址addr落在物理内存空间还是设备空间,</li>
</ol>
<ul>
<li>若落在物理内存空间, 就会通过<code>pmem_read()</code>和<code>pmem_write()</code>来访问真正的物理内存;</li>
<li>若落在设备空间, 就通过<code>map_read()</code>和<code>map_write()</code>来访问相应的设备.</li>
<li>从这个角度来看, 内存和外设在CPU来看并没有什么不同, 只不过都是一个字节编址的对象而已.</li>
</ul>
<h3 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h3><ul>
<li>为了开启设备模拟的功能, 你需要在menuconfig选中相关选项:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[*] Devices  ---&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>重新编译后, 你会看到运行NEMU时会<strong>弹出一个新窗口</strong>, 用于<strong>显示VGA的输出</strong>(见下文). 需要注意的是, <strong>终端显示的提示符(nemu)仍然在等待用户输入</strong>, 此时窗口并未显示任何内容.</li>
<li>NEMU使用SDL库来实现设备的模拟, <code>nemu/src/device/device.c</code>含有和SDL库相关的代码.<ul>
<li><code>init_device()</code>函数主要进行以下工作:<ul>
<li>调用<code>init_map()</code>进行<strong>初始化</strong>.</li>
<li>对上述设备进行<strong>初始化</strong>, 其中在初始化<strong>VGA</strong>时还会进行一些和<strong>SDL相关的初始化</strong>工作, 包括<strong>创建窗口</strong>, <strong>设置显示模式</strong>等;</li>
<li>然后会进行<strong>定时器(alarm)相关的初始化工作</strong>. 定时器的功能在<em>PA4</em>最后才会用到, 目前可以忽略它.</li>
</ul>
</li>
</ul>
</li>
<li>另一方面, <code>cpu_exec()</code>在<strong>执行每条指令之后</strong>就会<strong>调用</strong><code>device_update()</code>函数, 这个函数首先会检查距离上次设备更新是否已经超过一定时间, 若是, 则会尝试刷新屏幕, 并进一步检查是否有按键按下&#x2F;释放, 以及是否点击了窗口的<code>X</code>按钮; 否则则直接返回, 避免检查过于频繁, 因为上述事件发生的频率是很低的.</li>
</ul>
<h2 id="将输入输出抽象成IOE"><a href="#将输入输出抽象成IOE" class="headerlink" title="将输入输出抽象成IOE"></a>将输入输出抽象成IOE</h2><ul>
<li>与TRM不同, 设备访问是为计算机提供输入输出的功能, 因此我们把它们划入一类新的API, 名字叫<strong>IOE(I&#x2F;O Extension)</strong>.</li>
<li>访问设备 &#x3D; 读&#x2F;写操作</li>
<li>IOE提供三个API:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ioe_init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ioe_read</span><span class="params">(<span class="type">int</span> reg, <span class="type">void</span> *buf)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ioe_write</span><span class="params">(<span class="type">int</span> reg, <span class="type">void</span> *buf)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个API用于进行IOE相关的<strong>初始化</strong>操作.</li>
<li>后两个API分别用于<strong>从编号为reg的寄存器中读出内容到缓冲区buf中</strong>, 以及<strong>往编号为reg寄存器中写入缓冲区buf中的内容</strong>.<ul>
<li>需要注意的是, 这里的reg寄存器<em>并不是上文讨论的设备寄存器</em>, 因为设备寄存器的编号是架构相关的. 在IOE中, 我们希望采用一种架构无关的”抽象寄存器”, <strong>这个reg其实是一个功能编号</strong>, 我们约定在不同的架构中, 同一个功能编号的含义也是相同的, 这样就实现了设备寄存器的抽象.</li>
</ul>
</li>
<li><code>abstract-machine/am/include/amdev.h</code>中定义了<strong>常见设备的”抽象寄存器”编号和相应的结构</strong>. <ul>
<li>这些定义是<strong>架构无关</strong>的, 每个架构在<strong>实现各自的IOE API</strong>时, 都需要<strong>遵循</strong>这些定义(约定).</li>
<li>为了方便地对这些抽象寄存器进行访问, <code>klib</code>中提供了<code>io_read()</code>和<code>io_write()</code>这两个<strong>宏</strong>, 它们分别对ioe_read()和ioe_write()这两个<strong>API</strong>进行了进一步的封装.</li>
</ul>
</li>
<li>特别地, NEMU作为一个平台, 设备的行为是与ISA无关的, 因此我们只需要在<code>abstract-machine/am/src/platform/nemu/ioe/</code>目录下<strong>实现一份IOE, 来供NEMU平台的架构共享</strong>. 其中, <code>abstract-machine/am/src/platform/nemu/ioe/ioe.c</code>中实现了上述的三个IOE API, ioe_read()和ioe_write()都是通过抽象寄存器的编号索引到一个处理函数, 然后调用它.</li>
<li>处理函数的具体功能和寄存器编号相关, 下面我们来逐一介绍NEMU中每个设备的功能.</li>
</ul>
<h3 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h3><ul>
<li>串口是最简单的<strong>输出</strong>设备. <code>nemu/src/device/serial.c</code>模拟了串口的功能</li>
</ul>
<h4 id="必做：运行Hello-World"><a href="#必做：运行Hello-World" class="headerlink" title="必做：运行Hello World"></a>必做：运行Hello World</h4><ul>
<li>如果你选择的是mips32和riscv32, 你不需要实现额外的代码, 因为NEMU的框架代码已经支持MMIO了.</li>
<li>实现后, <code>在am-kernels/kernels/hello/</code>目录下键入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=riscv32-nemu run</span><br></pre></td></tr></table></figure>
<ul>
<li>如果你的实现正确, 你将会看到程序往终端输出一些信息(请注意不要让输出淹没在调试信息中).</li>
<li>需要注意的是, 这个hello程序和我们在程序设计课上写的第一个hello程序所处的抽象层次是不一样的: 这个hello程序可以说是直接运行在裸机上, 可以在AM的抽象之上直接输出到设备(串口); 而我们在程序设计课上写的hello程序位于操作系统之上, 不能直接操作设备, 只能通过操作系统提供的服务进行输出, 输出的数据要经过很多层抽象才能到达设备层. 我们会在PA3中进一步体会操作系统的作用.</li>
</ul>
<ol>
<li><code>am-kernels/kernels/hello/hello.c</code>中代码：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;am.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;klib-macros.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *args)</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *fmt =</span><br><span class="line">    <span class="string">&quot;Hello, AbstractMachine!\n&quot;</span></span><br><span class="line">    <span class="string">&quot;mainargs = &#x27;%&#x27;.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span> *p = fmt; *p; p++) &#123;</span><br><span class="line">    (*p == <span class="string">&#x27;%&#x27;</span>) ? putstr(args) : putch(*p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>HIT GOOD TRAP at pc = 0x800000b0</code></li>
</ol>
<ul>
<li>输出<code>Hello, AbstractMachine!/n</code>和<code>mainargs = &#39;&#39;.\n</code></li>
<li>在AM中, main()函数允许带有一个字符串参数, 这一参数通过mainargs指定, 并由AM的运行时环境负责将它传给main()函数, 供AM程序使用. 具体的参数传递方式和架构相关.例如你可以在运行hello的时候给出一个字符串参数:<code>make ARCH=riscv32-nemu run mainargs=I-love-PA</code><ul>
<li>输出<code>Hello, AbstractMachine!/n</code>和<code>mainargs = &#39;I-love-PA&#39;.\n</code></li>
</ul>
</li>
</ul>
<h4 id="必做：实现printf"><a href="#必做：实现printf" class="headerlink" title="必做：实现printf"></a>必做：实现printf</h4><ul>
<li>有了<code>putch()</code>, 我们就可以在<code>klib</code>中实现<code>printf()</code>了.</li>
<li>你之前已经实现了<code>sprintf()</code>了, 它和<code>printf()</code>的功能非常相似, 这意味着它们之间会有不少重复的代码. 你已经见识到Copy-Paste编程习惯的坏处了, 思考一下, 如何简洁地实现它们呢?</li>
<li>实现了<code>printf()</code>之后, 你就可以在AM程序中使用输出调试法了.</li>
</ul>
<ol>
<li>在<code>ics2024/abstract-machine/klib/src/stdio.c</code>中：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">number</span><span class="params">(<span class="type">char</span> *str, <span class="type">unsigned</span> <span class="type">int</span> num, <span class="type">int</span> base, <span class="type">int</span> is_upper)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">  <span class="type">char</span> *p = buf + <span class="number">31</span>;</span><br><span class="line">  *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="type">int</span> digit = num % base;</span><br><span class="line">    *--p = (digit &lt; <span class="number">10</span>) ? <span class="string">&#x27;0&#x27;</span> + digit : (is_upper ? <span class="string">&#x27;A&#x27;</span> : <span class="string">&#x27;a&#x27;</span>) + digit - <span class="number">10</span>;</span><br><span class="line">    num /= base;</span><br><span class="line">  &#125; <span class="keyword">while</span> (num &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">    *str++ = *p++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">1024</span>]; <span class="comment">// 临时缓冲区</span></span><br><span class="line">  va_list args;</span><br><span class="line">  va_start(args, fmt);</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">vsprintf</span>(buf, fmt, args);</span><br><span class="line">  va_end(args);</span><br><span class="line">  <span class="type">char</span> *tmp = buf;</span><br><span class="line">  <span class="keyword">while</span> (*tmp != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    putch(*tmp++);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *out, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *str = out;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s;</span><br><span class="line">  <span class="type">int</span> base;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (; *fmt != <span class="string">&#x27;\0&#x27;</span>; ++fmt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">      *str++ = *fmt;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++fmt;</span><br><span class="line">    base = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (*fmt) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">        *str++ = (<span class="type">unsigned</span> <span class="type">char</span>) va_arg(ap, <span class="type">int</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">        s = va_arg(ap, <span class="type">char</span> *);</span><br><span class="line">        <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">          *str++ = *s++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">        num = va_arg(ap, <span class="type">int</span>);</span><br><span class="line">        str = number(str, num, base, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">        base = <span class="number">16</span>;</span><br><span class="line">        num = va_arg(ap, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">        str = number(str, num, base, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">        base = <span class="number">16</span>;</span><br><span class="line">        num = va_arg(ap, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">        str = number(str, num, base, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">        base = <span class="number">8</span>;</span><br><span class="line">        num = va_arg(ap, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">        str = number(str, num, base, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">        num = va_arg(ap, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">        str = number(str, num, base, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">        num = (<span class="type">unsigned</span> <span class="type">long</span>) va_arg(ap, <span class="type">void</span> *);</span><br><span class="line">        base = <span class="number">16</span>;</span><br><span class="line">        *str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        *str++ = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">        str = number(str, num, base, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">        *str++ = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        *str++ = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (*fmt) &#123;</span><br><span class="line">          *str++ = *fmt;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          --fmt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *str = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> str - out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="必做：运行alu-tests"><a href="#必做：运行alu-tests" class="headerlink" title="必做：运行alu-tests"></a>必做：运行alu-tests</h4><ul>
<li>我们在<code>am-kernels/tests/alu-tests/</code>目录下移植了一个专门测试各种C语言运算的程序, 实现<code>printf()</code>后你就可以运行它了. 编译过程可能需要花费1分钟.</li>
<li><code>make ARCH=riscv32-nemu run</code></li>
<li><code>HIT GOOD TRAP at pc = 0x800ebb34</code></li>
<li>但是没有printf输出，不知道为什么</li>
</ul>
<h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><h4 id="必做：实现IOE"><a href="#必做：实现IOE" class="headerlink" title="必做：实现IOE"></a>必做：实现IOE</h4><ul>
<li>在<code>abstract-machine/am/src/platform/nemu/ioe/timer.c</code>中实现AM_TIMER_UPTIME的功能. 在<code>abstract-machine/am/src/platform/nemu/include/nemu.h</code>和 <code>abstract-machine/am/src/$ISA/$ISA.h</code>中有一些输入输出相关的代码供你使用.</li>
<li>实现后, 在<code>$ISA-nemu</code>中运行<code>am-kernel/tests/am-tests</code>中的<code>real-time clock test</code>测试. 如果你的实现正确, 你将会看到<strong>程序每隔1秒往终端输出一行信息</strong>. 由于我们没有实现AM_TIMER_RTC, 测试总是输出1900年0月0日0时0分0秒, 这属于正常行为, 可以忽略.</li>
</ul>
<ol>
<li>实现：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __am_timer_uptime(AM_TIMER_UPTIME_T *uptime) &#123;</span><br><span class="line">  <span class="type">uint32_t</span> low = inl(RTC_ADDR);</span><br><span class="line">  <span class="type">uint32_t</span> high = inl(RTC_ADDR + <span class="number">4</span>);</span><br><span class="line">  uptime-&gt;us = ((<span class="type">uint64_t</span>)high &lt;&lt; <span class="number">32</span>) | low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不正确，之后有修改。修改后：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __am_timer_uptime(AM_TIMER_UPTIME_T *uptime) &#123;</span><br><span class="line">  <span class="type">uint32_t</span> high = inl(RTC_ADDR + <span class="number">4</span>);</span><br><span class="line">  <span class="type">uint32_t</span> low = inl(RTC_ADDR);</span><br><span class="line">  uptime-&gt;us = ((<span class="type">uint64_t</span>)high &lt;&lt; <span class="number">32</span>) | low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>要如何运行<code>real-time clock test</code>这个测试, 就交给你来RTFSC吧:</li>
</ol>
<ul>
<li>在<code>am-kernels/tests/am-tests/src/main.c</code>中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;amtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (*entry)() = <span class="literal">NULL</span>; <span class="comment">// mp entry</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *tests[<span class="number">256</span>] = &#123;</span><br><span class="line">  [<span class="string">&#x27;h&#x27;</span>] = <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">  [<span class="string">&#x27;H&#x27;</span>] = <span class="string">&quot;display this help message&quot;</span>,</span><br><span class="line">  [<span class="string">&#x27;i&#x27;</span>] = <span class="string">&quot;interrupt/yield test&quot;</span>,</span><br><span class="line">  [<span class="string">&#x27;d&#x27;</span>] = <span class="string">&quot;scan devices&quot;</span>,</span><br><span class="line">  [<span class="string">&#x27;m&#x27;</span>] = <span class="string">&quot;multiprocessor test&quot;</span>,</span><br><span class="line">  [<span class="string">&#x27;t&#x27;</span>] = <span class="string">&quot;real-time clock test&quot;</span>,</span><br><span class="line">  [<span class="string">&#x27;k&#x27;</span>] = <span class="string">&quot;readkey test&quot;</span>,</span><br><span class="line">  [<span class="string">&#x27;v&#x27;</span>] = <span class="string">&quot;display test&quot;</span>,</span><br><span class="line">  [<span class="string">&#x27;a&#x27;</span>] = <span class="string">&quot;audio test&quot;</span>,</span><br><span class="line">  [<span class="string">&#x27;p&#x27;</span>] = <span class="string">&quot;x86 virtual memory test&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *args)</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (args[<span class="number">0</span>]) &#123;</span><br><span class="line">    CASE(<span class="string">&#x27;h&#x27;</span>, hello);</span><br><span class="line">    CASE(<span class="string">&#x27;i&#x27;</span>, hello_intr, IOE, CTE(simple_trap));</span><br><span class="line">    CASE(<span class="string">&#x27;d&#x27;</span>, devscan, IOE);</span><br><span class="line">    CASE(<span class="string">&#x27;m&#x27;</span>, mp_print, MPE);</span><br><span class="line">    CASE(<span class="string">&#x27;t&#x27;</span>, rtc_test, IOE);</span><br><span class="line">    CASE(<span class="string">&#x27;k&#x27;</span>, keyboard_test, IOE);</span><br><span class="line">    CASE(<span class="string">&#x27;v&#x27;</span>, video_test, IOE);</span><br><span class="line">    CASE(<span class="string">&#x27;a&#x27;</span>, audio_test, IOE);</span><br><span class="line">    CASE(<span class="string">&#x27;p&#x27;</span>, vm_test, CTE(vm_handler), VME(simple_pgalloc, simple_pgfree));</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Usage: make run mainargs=*\n&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> ch = <span class="number">0</span>; ch &lt; <span class="number">256</span>; ch++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tests[ch]) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;  %c: %s\n&quot;</span>, ch, tests[ch]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>所以输入命令为<code>make ARCH=riscv32-nemu run mainargs=t</code></li>
</ul>
<ol start="3">
<li>成功,部分为：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1900-0-0 %02d:%02d:%02d GMT (1 second).</span><br><span class="line">1900-0-0 %02d:%02d:%02d GMT (2 seconds).</span><br><span class="line">1900-0-0 %02d:%02d:%02d GMT (3 seconds).</span><br><span class="line">1900-0-0 %02d:%02d:%02d GMT (4 seconds).</span><br><span class="line">1900-0-0 %02d:%02d:%02d GMT (5 seconds).</span><br><span class="line">1900-0-0 %02d:%02d:%02d GMT (6 seconds).</span><br><span class="line">1900-0-0 %02d:%02d:%02d GMT (7 seconds).</span><br><span class="line">1900-0-0 %02d:%02d:%02d GMT (8 seconds).</span><br><span class="line">1900-0-0 %02d:%02d:%02d GMT (9 seconds).</span><br></pre></td></tr></table></figure>
<h4 id="看看NEMU跑多快"><a href="#看看NEMU跑多快" class="headerlink" title="看看NEMU跑多快"></a>看看NEMU跑多快</h4><ul>
<li>有了时钟之后, 我们就可以测试一个程序跑多快, 从而测试计算机的性能. 尝试在NEMU中依次运行以下benchmark(已经按照程序的复杂度排序, 均在am-kernel&#x2F;benchmarks&#x2F;目录下; 另外跑分时请关闭NEMU的监视点, trace以及DiffTest, 同时取消menuconfig中的 Enable debug information并重新编译NEMU, 以获得较为真实的跑分):<ul>
<li>dhrystone</li>
<li>coremark</li>
<li>microbench</li>
</ul>
</li>
<li>成功运行后会输出跑分. 其中microbench跑分以i9-9900K @ 3.60GHz的处理器为参照, 100000分表示与参照机器性能相当, 100分表示性能为参照机器的千分之一. 除了和参照机器比较之外, 也可以和小伙伴进行比较. 如果把上述benchmark编译到native, 还可以比较native的性能.</li>
<li>另外, microbench提供了四个不同规模的测试集, 包括test, train, ref和huge. 你可以先运行test规模, 它可以较快地运行结束, 来检查NEMU实现的正确性, 然后再运行ref规模来测量性能. 具体的运行方法请阅读README.</li>
<li>此外, huge规模一般用于真机的测试, 在NEMU中需要运行很长时间, 我们不要求你运行它.</li>
</ul>
<ol>
<li>都报错</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make[1]: *** [/home/xiaoyao/ics2024/nemu/scripts/native.mk:38: run] 浮点异常 (核心已转储)</span><br><span class="line">make[1]: 离开目录“/home/xiaoyao/ics2024/nemu”</span><br><span class="line">make: *** [/home/xiaoyao/ics2024/abstract-machine/scripts/platform/nemu.mk:32：run] 错误 2</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>关于<code>AM_TIMER_UPTIME</code>的实现, 我们在框架代码中埋了一些小坑, 如果你没有修复相关的问题, 你可能会在运行<code>benchmark</code>的时候出现跑分不正确的现象. 这是为了强迫大家认真RTFSC了解程序运行过程中的一切细节:<code> benchmark</code>读取时钟信息的时候, 整个计算机系统究竟发生了什么? 只有这样你才能把时钟相关的bug调试正确.</li>
</ol>
<ul>
<li><code>am-kernels/benchmarks/dhrystone/dry.c</code>中944行有除0错误：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Dhrystone %s         %d Marks\n&quot;</span>, pass ? <span class="string">&quot;PASS&quot;</span> : <span class="string">&quot;FAIL&quot;</span>,</span><br><span class="line">      <span class="number">880900</span> / (<span class="type">int</span>)User_Time * NUMBER_OF_RUNS/ <span class="number">500000</span>);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>修改<code>time.c</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __am_timer_uptime(AM_TIMER_UPTIME_T *uptime) &#123;</span><br><span class="line">  <span class="type">uint32_t</span> high = inl(RTC_ADDR + <span class="number">4</span>);</span><br><span class="line">  <span class="type">uint32_t</span> low = inl(RTC_ADDR);</span><br><span class="line">  uptime-&gt;us = ((<span class="type">uint64_t</span>)high &lt;&lt; <span class="number">32</span>) | low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>Dhrystone:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Dhrystone Benchmark, Version C, Version 2.2</span><br><span class="line">Trying 500000 runs through Dhrystone.</span><br><span class="line">Finished in 16861 ms</span><br><span class="line">==================================================</span><br><span class="line">Dhrystone PASS         52 Marks</span><br><span class="line">                   vs. 100000 Marks (i7-7700K @ 4.20GHz)</span><br><span class="line">[src/cpu/cpu-exec.c:196 cpu_exec] nemu: HIT GOOD TRAP at pc = 0x80000d24</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>coremark:</li>
</ol>
<ul>
<li>报错！</li>
<li>查看<code>benchmarks/coremark/build/coremark-riscv32-nemu.txt</code></li>
<li><code>80000df4:	00178783          	lb	a5,1(a5)</code></li>
</ul>
<ol>
<li><code>  INSTPAT(&quot;??????? ????? ????? 000 ????? 00000 11&quot;, lb     , I, R(rd) = SEXT(Mr(src1 + imm, 1), 8));//lb,将src1+imm地址的值的低8位存入rd</code></li>
</ol>
<ul>
<li><code>80000968:	08046413          	ori	s0,s0,128</code></li>
</ul>
<ol start="2">
<li><code>INSTPAT(&quot;??????? ????? ????? 110 ????? 00100 11&quot;, ori    , I, R(rd) = src1 | imm); //ori，或立即数，将src1的值与imm进行或运算，结果存入rd</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CoreMark PASS       118 Marks</span><br><span class="line">                vs. 100000 Marks (i7-7700K @ 4.20GHz)</span><br><span class="line">[src/cpu/cpu-exec.c:196 cpu_exec] nemu: HIT GOOD TRAP at pc = 0x80002288</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>microbench</li>
</ol>
<ul>
<li>报错！</li>
<li>查看：<code>benchmarks/microbench/build/microbench-riscv32-nemu.txt</code></li>
<li><code>80004a54:	02f535b3          	mulhu	a1,a0,a5</code></li>
</ul>
<ol>
<li><code>  INSTPAT(&quot;0000001 ????? ????? 011 ????? 01100 11&quot;, mulhu  , R, R(rd) = ((uint64_t)src1 * (uint64_t)src2) &gt;&gt; 32);//mulhu</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MicroBench PASS        153 Marks</span><br><span class="line">                   vs. 100000 Marks (i9-9900K @ 3.60GHz)</span><br><span class="line">Scored time: 122518.853 ms</span><br><span class="line">Total  time: 141086.480 ms</span><br><span class="line">[src/cpu/cpu-exec.c:196 cpu_exec] nemu: HIT GOOD TRAP at pc = 0x80004e1c</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>正确实现时钟后, 你就可以在NEMU上运行一些具有展示性的程序了: 我们在<code>am-kernels/kernels/demo/</code>目录下移植了一些小型演示程序</li>
<li>为了运行它们, 你还需要实现<code>klib</code>中的<code>malloc()</code>和<code>free()</code>, 目前你可以实现一个简单的版本:<ul>
<li>在<code>malloc()</code>中维护一个上次分配内存位置的变量addr, 每次调用<code>malloc()</code>时, 就返回[addr, addr + size)这段空间. <code>addr</code>的初值设为<code>heap.start</code>, 表示从堆区开始分配. 你也可以参考<code>microbench</code>中的相关代码. 注意malloc()对<em>返回的地址有一定的要求</em>, 具体情况请RTFM.</li>
<li><code>free()</code>直接留空即可, 表示只分配不释放. 目前NEMU中的可用内存足够运行各种测试程序.</li>
</ul>
</li>
</ul>
<h4 id="选做："><a href="#选做：" class="headerlink" title="选做："></a>选做：</h4><h3 id="设备访问的踪迹-dtrace"><a href="#设备访问的踪迹-dtrace" class="headerlink" title="设备访问的踪迹 - dtrace"></a>设备访问的踪迹 - dtrace</h3><h4 id="必做：实现dtrace"><a href="#必做：实现dtrace" class="headerlink" title="必做：实现dtrace"></a>必做：实现dtrace</h4><ul>
<li>这个功能非常简单, 你可以自行定义<code>dtrace</code>输出的格式. 注意你可以通过<code>map-&gt;name</code>来<strong>获取一段设备地址空间的名字</strong>, 这样可以帮助你输出可读性较好的信息. 同样地, 你也可以为dtrace实现<strong>条件控制功能</strong>, 提升dtrace使用的灵活性.</li>
</ul>
<ol>
<li>在Kconfig中定义DTRACE，<code>nemu/Kconfig</code>:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">menu &quot;Tracing Options&quot;</span><br><span class="line">config DTRACE</span><br><span class="line">    bool &quot;Enable device trace&quot;</span><br><span class="line">    default n</span><br><span class="line">    help</span><br><span class="line">      Enable device trace to record device access behavior.</span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在 <code>map_read </code>和 <code>map_write </code>函数中添加 <code>dtrace</code> 功能:<code>nemu/src/device/io/map.c</code>:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">word_t</span> <span class="title function_">map_read</span><span class="params">(<span class="type">paddr_t</span> addr, <span class="type">int</span> len, IOMap *<span class="built_in">map</span>)</span> &#123;</span><br><span class="line">  assert(len &gt;= <span class="number">1</span> &amp;&amp; len &lt;= <span class="number">8</span>);</span><br><span class="line">  check_bound(<span class="built_in">map</span>, addr);</span><br><span class="line">  <span class="type">paddr_t</span> offset = addr - <span class="built_in">map</span>-&gt;low;</span><br><span class="line">  invoke_callback(<span class="built_in">map</span>-&gt;callback, offset, len, <span class="literal">false</span>); <span class="comment">// prepare data to read</span></span><br><span class="line">  <span class="type">word_t</span> ret = host_read(<span class="built_in">map</span>-&gt;space + offset, len);</span><br><span class="line">  IFDEF(CONFIG_DTRACE, Log(<span class="string">&quot;address = &quot;</span> FMT_PADDR <span class="string">&quot; read &quot;</span> FMT_PADDR <span class="string">&quot; at device = %s&quot;</span>, addr, ret, <span class="built_in">map</span>-&gt;name));</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">map_write</span><span class="params">(<span class="type">paddr_t</span> addr, <span class="type">int</span> len, <span class="type">word_t</span> data, IOMap *<span class="built_in">map</span>)</span> &#123;</span><br><span class="line">  assert(len &gt;= <span class="number">1</span> &amp;&amp; len &lt;= <span class="number">8</span>);</span><br><span class="line">  check_bound(<span class="built_in">map</span>, addr);</span><br><span class="line">  <span class="type">paddr_t</span> offset = addr - <span class="built_in">map</span>-&gt;low;</span><br><span class="line">  host_write(<span class="built_in">map</span>-&gt;space + offset, len, data);</span><br><span class="line">  invoke_callback(<span class="built_in">map</span>-&gt;callback, offset, len, <span class="literal">true</span>);</span><br><span class="line">  IFDEF(CONFIG_DTRACE, Log(<span class="string">&quot;address = &quot;</span> FMT_PADDR <span class="string">&quot; write &quot;</span> FMT_PADDR <span class="string">&quot; at device = %s&quot;</span>, addr, data, <span class="built_in">map</span>-&gt;name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>成功，片段如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[src/device/io/map.c:61 map_read] address = 0xa0000060 read 0x00000000 at device = keyboard</span><br></pre></td></tr></table></figure>
<h3 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h3><ul>
<li>一般键盘的工作方式如下: 当按下一个键的时候, 键盘将会发送该键的通码(make code); 当释放一个键的时候, 键盘将会发送该键的断码(break code).</li>
<li><code>nemu/src/device/keyboard.c</code></li>
<li>每当用户敲下&#x2F;释放按键时, 将会把相应的键盘码放入数据寄存器, CPU可以访问数据寄存器, 获得键盘码; 当无按键可获取时, 将会返回AM_KEY_NONE.</li>
<li><code>abstract-machine/am/include/amdev.h</code>中为键盘的功能定义了一个抽象寄存器:<ul>
<li><code>AM_INPUT_KEYBRD</code>, AM键盘控制器, 可读出按键信息. <code>keydown</code>为<code>true</code>时表示按下按键, 否则表示释放按键. <code>keycode</code>为按键的断码, 没有按键时, <code>keycode</code>为<code>AM_KEY_NONE</code>.</li>
</ul>
</li>
</ul>
<h4 id="必做：实现IOE-2"><a href="#必做：实现IOE-2" class="headerlink" title="必做：实现IOE(2)"></a>必做：实现IOE(2)</h4><ul>
<li>在<code>abstract-machine/am/src/platform/nemu/ioe/input.c</code>中实现<code>AM_INPUT_KEYBRD</code>的功能. 实现后, 在<code>$ISA-nemu</code>中运行<code>am-tests</code>中的<code>readkey test</code>测试. 如果你的实现正确, 在程序运行时弹出的新窗口中<strong>按下按键</strong>, 你将会看到<strong>程序输出相应的按键信息</strong>, 包括<strong>按键名, 键盘码, 以及按键状态</strong>.</li>
</ul>
<ol>
<li><code>am/src/platform/nemu/ioe/input.c</code>:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __am_input_keybrd(AM_INPUT_KEYBRD_T *kbd) &#123;</span><br><span class="line">  <span class="type">uint32_t</span> keycode = inl(KBD_ADDR);</span><br><span class="line">  <span class="keyword">if</span> (keycode == AM_KEY_NONE) &#123;</span><br><span class="line">    kbd-&gt;keydown = <span class="literal">false</span>;</span><br><span class="line">    kbd-&gt;keycode = AM_KEY_NONE;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    kbd-&gt;keydown =(keycode &amp; KEYDOWN_MASK ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">    kbd-&gt;keycode = keycode &amp; ~KEYDOWN_MASK;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>tests/am-tests/src/main.c</code>中：<code>[&#39;k&#39;] = &quot;readkey test&quot;</code></li>
</ol>
<ul>
<li><code>make ARCH=riscv32-nemu run mainargs=k</code></li>
</ul>
<ol start="3">
<li>成功：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Got  (kbd): Y (34) DOWN</span><br><span class="line">Got  (kbd): Y (34) UP</span><br><span class="line">Got  (kbd): O (37) DOWN</span><br><span class="line">Got  (kbd): O (37) UP</span><br><span class="line">Got  (kbd): U (35) DOWN</span><br><span class="line">Got  (kbd): U (35) UP</span><br></pre></td></tr></table></figure>
<h4 id="思考：如何检测多个键同时被按下"><a href="#思考：如何检测多个键同时被按下" class="headerlink" title="思考：如何检测多个键同时被按下?"></a>思考：如何检测多个键同时被按下?</h4><ul>
<li>在游戏中, 很多时候需要判断玩家是否同时按下了多个键, 例如RPG游戏中的八方向行走, 格斗游戏中的组合招式等等. 根据键盘码的特性, 你知道这些功能是如何实现的吗?</li>
<li>思路：<ol>
<li>使用数组或位图记录按键状态</li>
</ol>
<ul>
<li>使用一个数组或位图来记录每个按键的状态（按下或释放）。</li>
<li>当接收到按键事件时，更新相应的数组或位图。</li>
</ul>
<ol start="2">
<li>检测多个键同时按下</li>
</ol>
<ul>
<li>在游戏逻辑中，检查数组或位图中多个按键的状态，判断是否同时按下了这些按键。</li>
</ul>
</li>
</ul>
<h3 id="VGA"><a href="#VGA" class="headerlink" title="VGA"></a>VGA</h3><ul>
<li>VGA可以用于显示颜色像素, 是最常用的输出设备. <code>nemu/src/device/vga.c</code>模拟了VGA的功能</li>
</ul>
<h4 id="思考：神奇的调色板"><a href="#思考：神奇的调色板" class="headerlink" title="思考：神奇的调色板"></a>思考：神奇的调色板</h4><ul>
<li>现代的显示器一般都支持24位的颜色(R, G, B各占8个bit, 共有2^8<em>2^8</em>2^8约1600万种颜色), 为了让屏幕显示不同的颜色成为可能, 在8位颜色深度时会使用调色板的概念. 调色板是一个颜色信息的数组, 每一个元素占4个字节, 分别代表R(red), G(green), B(blue), A(alpha)的值. 引入了调色板的概念之后, 一个像素存储的就不再是颜色的信息, 而是一个调色板的索引: 具体来说, 要得到一个像素的颜色信息, 就要把它的值当作下标, 在调色板这个数组中做下标运算, 取出相应的颜色信息. 因此, 只要使用不同的调色板, 就可以在不同的时刻使用不同的256种颜色了.</li>
<li>在一些90年代的游戏中(比如仙剑奇侠传), 很多渐出渐入效果都是通过调色板实现的, 聪明的你知道其中的玄机吗?</li>
<li>可以通过<strong>动态修改调色板中的颜色信息</strong>来实现渐变效果。例如，可以逐步调整调色板中的颜色值，使得屏幕上的图像逐渐变暗或变亮。</li>
</ul>
<hr>
<ul>
<li>在AM中, 显示相关的设备叫GPU, GPU是一个专门用来进行图形渲染的设备. 在NEMU中, 我们并不支持一个完整GPU的功能, 而仅仅保留绘制像素的基本功能.</li>
<li><code>abstract-machine/am/include/amdev.h</code>中为GPU定义了五个抽象寄存器, 在NEMU中只会用到其中的两个:<ol>
<li><code>AM_GPU_CONFIG</code>, <strong>AM显示控制器信息</strong>, 可<code>读出</code><strong>屏幕大小信息width和height</strong>. 另外AM假设系统<em>在运行过程中</em>, 屏幕大小<em>不会发生变化</em>.</li>
<li><code>AM_GPU_FBDRAW</code>, <strong>AM帧缓冲控制器</strong>, 可<code>写入</code><strong>绘图信息</strong>, 向屏幕<code>(x, y)</code>坐标处绘制<strong>w*h的矩形图像</strong>. 图像像素按<strong>行优先</strong>方式存储在<code>pixels</code>中, 每个像素用<code>32位整数</code>以<code>00RRGGBB</code>的方式描述颜色. 若<code>sync</code>为<code>true</code>, 则马上将帧缓冲中的内容<strong>同步到屏幕上</strong>.</li>
</ol>
</li>
</ul>
<h4 id="必做：实现IOE-3"><a href="#必做：实现IOE-3" class="headerlink" title="必做：实现IOE(3)"></a>必做：实现IOE(3)</h4><ul>
<li>事实上, VGA设备还有两个寄存器: <strong>屏幕大小寄存器</strong>和<strong>同步寄存器</strong>. 我们在讲义中并未介绍它们, 我们把它们作为相应的练习留给大家. 具体地, 屏幕大小寄存器的硬件(NEMU)功能已经实现, 但软件(AM)还没有去使用它; 而对于同步寄存器则相反, 软件(AM)已经实现了同步屏幕的功能, 但硬件(NEMU)尚未添加相应的支持.</li>
<li>好了, 提示已经足够啦, 至于要在什么地方添加什么样的代码, 就由你来RTFSC吧. 这也是明白软硬件如何协同工作的很好的练习. 实现后, 向__am_gpu_init()中添加如下测试代码:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--- abstract-machine/am/src/platform/nemu/ioe/gpu.c</span><br><span class="line">+++ abstract-machine/am/src/platform/nemu/ioe/gpu.c</span><br><span class="line">@@ <span class="number">-6</span>,<span class="number">2</span> +<span class="number">6</span>,<span class="number">8</span> @@</span><br><span class="line"> <span class="type">void</span> __am_gpu_init() &#123;</span><br><span class="line">+  <span class="type">int</span> i;</span><br><span class="line">+  <span class="type">int</span> w = <span class="number">0</span>;  <span class="comment">// <span class="doctag">TODO:</span> get the correct width</span></span><br><span class="line">+  <span class="type">int</span> h = <span class="number">0</span>;  <span class="comment">// <span class="doctag">TODO:</span> get the correct height</span></span><br><span class="line">+  <span class="type">uint32_t</span> *fb = (<span class="type">uint32_t</span> *)(<span class="type">uintptr_t</span>)FB_ADDR;</span><br><span class="line">+  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; w * h; i ++) fb[i] = i;</span><br><span class="line">+  outl(SYNC_ADDR, <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中上述代码中的w和h并未设置正确的值, 你需要阅读am-tests中的display test测试, 理解它如何获取正确的屏幕大小, 然后修改上述代码的w和h. 你可能还需要对gpu.c中的代码进行一些修改. 修改后, 在$ISA-nemu中运行am-tests中的display test测试, 如果你的实现正确, 你会看到新窗口中输出了全屏的颜色信息.</li>
</ul>
<ol>
<li><code>nemu/src/device/vga.c</code>中<code>vga_update_screen()</code>,调用<code>update_screen</code>函数并将同步寄存器清零：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vga_update_screen</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> call `update_screen()` when the sync register is non-zero,</span></span><br><span class="line">  <span class="comment">// then zero out the sync register</span></span><br><span class="line">  <span class="keyword">if</span> (vgactl_port_base[<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">    update_screen();</span><br><span class="line">    vgactl_port_base[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>abstract-machine/am/src/platform/nemu/ioe/gpu.c</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __am_gpu_config(AM_GPU_CONFIG_T *cfg) &#123;</span><br><span class="line">  <span class="type">uint32_t</span> screen_data = inl(VGACTL_ADDR);</span><br><span class="line">  <span class="type">int</span> screen_width = (screen_data &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  <span class="type">int</span> screen_height = screen_data &amp; <span class="number">0xffff</span>;</span><br><span class="line">  <span class="type">int</span> screen_vmemsz = screen_width * screen_height * <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line"> </span><br><span class="line">  *cfg = (AM_GPU_CONFIG_T) &#123;</span><br><span class="line">    .present = <span class="literal">true</span>, .has_accel = <span class="literal">false</span>,</span><br><span class="line">    .width = screen_width, .height = screen_height,</span><br><span class="line">    .vmemsz = screen_vmemsz</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>abstract-machine/am/src/platform/nemu/ioe/gpu.c</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __am_gpu_init() &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> w=inl(VGACTL_ADDR) &gt;&gt; <span class="number">16</span>;<span class="comment">// <span class="doctag">TODO:</span> get the correct width</span></span><br><span class="line">  <span class="type">int</span> h=inl(VGACTL_ADDR)&amp; <span class="number">0x0000ffff</span>;<span class="comment">// <span class="doctag">TODO:</span> get the correct height</span></span><br><span class="line">  <span class="type">uint32_t</span> *fb = (<span class="type">uint32_t</span> *)(<span class="type">uintptr_t</span>)FB_ADDR;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; w * h; i ++) fb[i] = i;</span><br><span class="line">  outl(SYNC_ADDR, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>运行<code>  [&#39;v&#39;] = &quot;display test&quot;</code>:<code>make ARCH=riscv32-nemu run mainargs=v</code><br><img src="/2025/02/25/PA2%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-1.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<h4 id="必做：实现IOE-4"><a href="#必做：实现IOE-4" class="headerlink" title="必做：实现IOE(4)"></a>必做：实现IOE(4)</h4><ul>
<li>事实上, 刚才输出的颜色信息并不是display test期望输出的画面, 这是因为AM_GPU_FBDRAW的功能并未正确实现. 你需要正确地实现AM_GPU_FBDRAW的功能. 实现后, 重新运行display test. 如果你的实现正确, 你将会看到新窗口中输出了相应的动画效果.</li>
<li>实现正确后, 你就可以去掉上文添加的测试代码了.</li>
</ul>
<ol>
<li><code>abstract-machine/am/src/platform/nemu/ioe/gpu.c</code>:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __am_gpu_fbdraw(AM_GPU_FBDRAW_T *ctl) &#123;</span><br><span class="line">  <span class="type">int</span> x = ctl-&gt;x, y = ctl-&gt;y, w = ctl-&gt;w, h = ctl-&gt;h;</span><br><span class="line">  <span class="type">uint32_t</span> screen_data = inl(VGACTL_ADDR);</span><br><span class="line">  <span class="type">int</span> screen_width = (screen_data &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  <span class="type">int</span> screen_height = screen_data &amp; <span class="number">0xffff</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> *pixels = (<span class="type">uint32_t</span> *)ctl-&gt;pixels;</span><br><span class="line">  <span class="type">uint32_t</span> *fb = (<span class="type">uint32_t</span> *)(<span class="type">uintptr_t</span>)FB_ADDR;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; h &amp;&amp; j &lt; screen_height - y; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; w &amp;&amp; i &lt; screen_width - x; i++) &#123;</span><br><span class="line">      fb[(j + y) * screen_width + i + x] = pixels[j * w + i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctl-&gt;sync) &#123;</span><br><span class="line">    outl(SYNC_ADDR, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>去掉测试代码</li>
<li>运行<code>  [&#39;v&#39;] = &quot;display test&quot;</code>:<code>make ARCH=riscv32-nemu run mainargs=v</code><br><img src="/2025/02/25/PA2%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-2.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">3264: FPS = 2</span><br><span class="line">6388: FPS = 1</span><br><span class="line">8857: FPS = 1</span><br><span class="line">11971: FPS = 1</span><br><span class="line">15062: FPS = 1</span><br><span class="line">18262: FPS = 1</span><br><span class="line">21386: FPS = 1</span><br><span class="line">24425: FPS = 1</span><br><span class="line">27507: FPS = 1</span><br><span class="line">30531: FPS = 1</span><br><span class="line">33067: FPS = 1</span><br><span class="line">35720: FPS = 1</span><br></pre></td></tr></table></figure>
<h2 id="冯诺依曼计算机系统"><a href="#冯诺依曼计算机系统" class="headerlink" title="冯诺依曼计算机系统"></a>冯诺依曼计算机系统</h2><h4 id="展示你的计算机系统"><a href="#展示你的计算机系统" class="headerlink" title="展示你的计算机系统"></a>展示你的计算机系统</h4><ul>
<li>完整实现IOE后, 我们还可以运行一些酷炫的程序:</li>
</ul>
<ol>
<li>幻灯片播放(在<code>am-kernels/kernels/slider/</code>目录下). 程序将每隔5秒切换images&#x2F;目录下的图片.<br><img src="/2025/02/25/PA2%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-3.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>打字小游戏(在<code>am-kernels/kernels/typing-game/</code>目录下).</li>
</ol>
<ul>
<li><code>Hit: 4; Miss: 172; Wrong: 25</code>,好快哈哈哈<br><img src="/2025/02/25/PA2%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-4.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>(略)</li>
</ul>
<hr>
<ul>
<li>事实上, 游戏可以抽象成一个死循环:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  等待新的一帧();  <span class="comment">// AM_TIMER_UPTIME</span></span><br><span class="line">  处理用户按键();  <span class="comment">// AM_INPUT_KEYBRD</span></span><br><span class="line">  更新游戏逻辑();  <span class="comment">// TRM</span></span><br><span class="line">  绘制新的屏幕();  <span class="comment">// AM_GPU_FBDRAW</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们的计算机添加IOE之后, 完全可以通过AM的抽象支撑起循环体中的功能, 所以要在NEMU中运行这些酷炫的游戏, 并不是不可能的. 甚至我们也可以把刚才运行的am-tests测试中的死循环看成是一些简化的游戏. 你将要在PA3中运行的复杂游戏仙剑奇侠传, 背后也是这样的一个死循环.</li>
</ul>
<h4 id="必做：游戏是如何运行的"><a href="#必做：游戏是如何运行的" class="headerlink" title="必做：游戏是如何运行的"></a>必做：游戏是如何运行的</h4><ul>
<li>请你以打字小游戏为例, 结合”程序在计算机上运行”的两个视角, 来剖析打字小游戏究竟是如何在计算机上运行的. 具体地, 当你按下一个字母并命中的时候, 整个计算机系统(NEMU, ISA, AM, 运行时环境, 程序) 是如何协同工作, 从而让打字小游戏实现出”命中”的游戏效果?</li>
<li>打字小游戏只有不到200行的简单代码, 非常适合大家RTFSC. 如果你发现自己难以理解打字小游戏的具体行为, 你需要给自己敲响警钟了: 你在做PA的时候很有可能只关注怎么把必做内容的代码写对, 而不去思考这些代码和计算机系统的关系. 从ICS和PA的角度来说, 这种做法是不及格的, 而且很快你就会吃苦头了.</li>
</ul>
<ol>
<li>RTFSC-程序视角：</li>
<li>初始化：<br>- main() 函数首先调用 ioe_init() 和 video_init() 函数来初始化输入输出设备和视频显示。<br>- ioe_init() 初始化输入输出环境。<br>- video_init() 初始化屏幕宽度和高度，并设置字符纹理和背景颜色。</li>
<li>主循环：<br>- main() 函数进入一个无限循环，持续更新游戏逻辑和渲染屏幕。<br>- 在每一帧中，游戏逻辑通过 game_logic_update() 函数更新，处理字符的移动和状态。<br>- render() 函数负责将字符绘制到屏幕上，并显示命中、错过和错误的统计信息。</li>
<li>输入处理：<br>- 在每一帧中，游戏通过 io_read(AM_INPUT_KEYBRD) 函数读取键盘输入事件。<br>- 如果按下的键是 ESC，游戏调用 halt(0) 函数退出。<br>- 如果按下的键是字母键，游戏调用 check_hit() 函数检查是否命中字符。</li>
<li>命中处理：</li>
</ol>
<ul>
<li>check_hit() 函数遍历所有字符，检查按下的键是否与字符匹配，并且字符是否在屏幕上。</li>
<li>如果命中，更新命中统计信息，并将字符的速度设置为负值，使其向上移动。</li>
<li>如果未命中，更新错误统计信息。</li>
</ul>
<ol start="2">
<li>系统视角</li>
<li>NEMU：<br>- NEMU用于模拟计算机硬件环境。它执行打字小游戏的二进制代码，并模拟 CPU、内存和外设。<br>- 当游戏运行时，NEMU 负责解释和执行每一条指令，并处理硬件中断和设备 I&#x2F;O。</li>
<li>ISA：<br>- ISA 定义了 CPU 支持的指令集和寄存器。打字小游戏的二进制代码是基于特定 ISA 编译的。<br>- NEMU 根据 ISA 解释和执行指令，更新寄存器和内存状态。</li>
<li>AM：<br>- AM 提供了一组抽象的硬件接口，使得程序可以在不同的硬件平台上运行。<br>- 打字小游戏通过 AM 提供的接口（如 io_read() 和 io_write()）与硬件交互，而不需要关心底层硬件的具体实现。</li>
<li>运行时环境：<br>- 运行时环境包括操作系统和库函数，提供程序运行所需的基本服务。<br>- 打字小游戏依赖于运行时环境提供的输入输出、内存管理和中断处理等功能。</li>
<li>按下一个字母并命中的过程：</li>
<li>按下字母键：<br>- 用户按下一个字母键，键盘控制器生成一个键盘中断。<br>- NEMU 捕获键盘中断，并调用相应的中断处理程序。</li>
<li>处理键盘中断：<br>- 中断处理程序读取键盘输入，并将键码存储在输入缓冲区中。<br>- 游戏主循环调用 io_read(AM_INPUT_KEYBRD) 函数读取键盘输入事件。</li>
<li>检查命中：<br>- 游戏调用 check_hit() 函数，遍历所有字符，检查按下的键是否与字符匹配。<br>- 如果命中，更新命中统计信息，并将字符的速度设置为负值，使其向上移动。</li>
<li>更新屏幕：<br>- 游戏调用 render() 函数，将字符绘制到屏幕上，并显示命中、错过和错误的统计信息。<br>- NEMU 模拟 GPU，将绘制的内容显示在屏幕上。</li>
</ol>
<h3 id="必答题："><a href="#必答题：" class="headerlink" title="必答题："></a>必答题：</h3><h4 id="程序是个状态机"><a href="#程序是个状态机" class="headerlink" title="程序是个状态机"></a>程序是个状态机</h4><ul>
<li>已完成，在“不停计算的机器”</li>
</ul>
<h4 id="RTFSC-请整理一条指令在NEMU中的执行过程"><a href="#RTFSC-请整理一条指令在NEMU中的执行过程" class="headerlink" title="RTFSC 请整理一条指令在NEMU中的执行过程"></a>RTFSC 请整理一条指令在NEMU中的执行过程</h4><ul>
<li>已完成，在“RTFSC（2）”的“运行第一个C程序”中</li>
</ul>
<h4 id="程序如何运行-理解打字小游戏如何运行"><a href="#程序如何运行-理解打字小游戏如何运行" class="headerlink" title="程序如何运行 理解打字小游戏如何运行"></a>程序如何运行 理解打字小游戏如何运行</h4><ul>
<li>已完成，就在上面</li>
</ul>
<h4 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h4><ul>
<li>在<code>nemu/include/cpu/ifetch.h</code>中, 你会看到由<code>static inline</code>开头定义的<code>inst_fetch()</code>函数. 分别尝试去掉<code>static</code>, 去掉<code>inline</code>或去掉两者, 然后重新进行编译, 你可能会看到发生错误. 请分别解释为什么这些错误会发生&#x2F;不发生? 你有办法证明你的想法吗?</li>
</ul>
<ol>
<li>去掉<code>static</code>：</li>
</ol>
<ul>
<li>无错误</li>
<li>原因：去掉<code>static</code>后，函数<code>inst_fetch</code>仍然是<strong>内联函数</strong>。内联函数在编译时会<em>将函数体直接插入到调用点</em>，因此不会产生<em>多重定义</em>的问题。</li>
</ul>
<ol start="2">
<li>去掉<code>inline</code>：</li>
</ol>
<ul>
<li>无错误</li>
<li>原因：去掉<code>inline</code>后，函数<code>inst_fetch</code>仍然是<strong>静态函数</strong>。静态函数的<em>作用域仅限于定义它的文件</em>，因此不会产生<em>多重定义</em>的问题。</li>
</ul>
<ol start="3">
<li>去掉两者：</li>
</ol>
<ul>
<li>报错：</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: /home/xiaoyao/ics2024/nemu/build/obj-riscv32-nemu-interpreter/src/isa/riscv32/inst.o: in function `inst_fetch&#x27;:</span><br><span class="line">/home/xiaoyao/ics2024/nemu/include/cpu/ifetch.h:20: multiple definition of `inst_fetch&#x27;; /home/xiaoyao/ics2024/nemu/build/obj-riscv32-nemu-interpreter/src/engine/interpreter/hostcall.o:/home/xiaoyao/ics2024/nemu/include/cpu/ifetch.h:20: first defined here</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">make: *** [/home/xiaoyao/ics2024/nemu/scripts/build.mk:54：/home/xiaoyao/ics2024/nemu/build/riscv32-nemu-interpreter] 错误 1</span><br></pre></td></tr></table></figure>
<ul>
<li>原因：去掉<code>static</code>和<code>inline</code>后，函数<code>inst_fetch</code>变成了一个<strong>普通的全局函数</strong>。由于头文件<code>ifetch.h</code>会<strong>被多个源文件包含</strong>，因此会导致多个源文件中都定义了<code>inst_fetch</code>函数，从而在链接时产生<strong>多重定义</strong>错误。</li>
</ul>
<h4 id="编译与链接-1"><a href="#编译与链接-1" class="headerlink" title="编译与链接"></a>编译与链接</h4><ol>
<li>在<code>nemu/include/common.h</code>中添加一行<code>volatile static int dummy</code>; 然后重新编译NEMU. 请问重新编译后的NEMU含有多少个dummy变量的实体? 你是如何得到这个结果的?</li>
<li>一共有：37个</li>
<li>方法：每个包含<code>common.h</code>的源文件都会打印dummy变量的地址，从而确认dummy变量的数量(数出37个)</li>
</ol>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">static</span> <span class="type">int</span> dummy;</span><br><span class="line">__attribute__((constructor)) <span class="type">static</span> <span class="type">void</span> <span class="title function_">print_dummy_address</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Address of dummy: %p\n&quot;</span>, (<span class="type">void</span>*)&amp;dummy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>原因：<br>- 重新编译后的 NEMU 含有多个 dummy 变量的实体。每个包含 common.h 的源文件都会有一个独立的 dummy 变量。<br>- static 关键字使得 dummy 变量在每个源文件中都是局部的，因此每个包含 common.h 的源文件都会有一个独立的 dummy 变量。</li>
<li>添加上题中的代码后, 再在nemu&#x2F;include&#x2F;debug.h中添加一行<code>volatile static int dummy</code>; 然后重新编译NEMU. 请问此时的NEMU含有多少个dummy变量的实体? 与上题中dummy变量实体数目进行比较, 并解释本题的结果.</li>
<li>一共有：37个</li>
<li>方法：输出+数</li>
</ol>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//common.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">static</span> <span class="type">int</span> dummy_common;</span><br><span class="line">__attribute__((constructor)) <span class="type">static</span> <span class="type">void</span> <span class="title function_">print_dummy_address_common</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Address of dummy in common.h: %p\n&quot;</span>, (<span class="type">void</span>*)&amp;dummy_common);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//debug.h</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">static</span> <span class="type">int</span> dummy;</span><br><span class="line">__attribute__((constructor)) <span class="type">static</span> <span class="type">void</span> <span class="title function_">print_dummy_address_debug</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Address of dummy in debug.h: %p\n&quot;</span>, (<span class="type">void</span>*)&amp;dummy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>比较：结果<strong>相同</strong>。</li>
<li>原因：<br>- static 关键字使得 dummy 变量<strong>在每个源文件中都是局部的</strong>，即每个包含 common.h 和 debug.h 的源文件都会有一个<strong>独立的</strong> dummy 变量。<br>- volatile 关键字告诉编译器该变量可能会被外部因素修改，因此编译器不会对该变量进行优化。<br>- debug.h 包含了 common.h，因此每个包含 debug.h 的源文件中会有两个 dummy 变量，一个来自 common.h，一个来自 debug.h。</li>
<li>修改添加的代码, 为两处dummy变量进行初始化:volatile static int dummy &#x3D; 0; 然后重新编译NEMU. 你发现了什么问题? 为什么之前没有出现这样的问题? (回答完本题后可以删除添加的代码.)</li>
</ol>
<ul>
<li>报错，<strong>重复定义</strong></li>
<li>报错原因：<ul>
<li>static 关键字：<ul>
<li><strong>static</strong>关键字使得变量<strong>在每个源文件中都是局部的</strong>，即每个包含 common.h 和 debug.h 的源文件都会有一个独立的 dummy 变量。</li>
<li>但是，当在头文件中<strong>初始化</strong> static 变量时，编译器会尝试在每个包含该头文件的源文件中定义并初始化该变量。这会导致多个定义冲突。</li>
</ul>
</li>
</ul>
</li>
<li>之前没有出现这样的问题是因为：<ul>
<li>未初始化的 static 变量：<ul>
<li>当 static 变量<strong>未初始化时</strong>，编译器只会在每个包含该头文件的源文件中生成该变量的声明，而不会生成定义和初始化代码。</li>
<li>因此，每个源文件都会有一个独立的 dummy 变量，而不会导致多个定义冲突。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="了解Makefile"><a href="#了解Makefile" class="headerlink" title="了解Makefile"></a>了解Makefile</h4><ul>
<li>请描述你在<code>am-kernels/kernels/hello/</code>目录下敲入<code>make ARCH=$ISA-nemu</code> 后, make程序如何组织<code>.c</code>和<code>.h</code>文件, 最终生成可执行文件<code>am-kernels/kernels/hello/build/hello-$ISA-nemu.elf.</code> (这个问题包括两个方面:Makefile的工作方式和编译链接的过程.) 关于Makefile工作方式的提示:<ul>
<li>Makefile中使用了变量, 包含文件等特性</li>
<li>Makefile运用并重写了一些implicit rules</li>
<li>在man make中搜索-n选项, 也许会对你有帮助</li>
<li>RTFM</li>
</ul>
</li>
</ul>
<ol>
<li>Makefile 工作方式</li>
<li>变量和包含文件<br>- 在 <code>am-kernels/kernels/hello/Makefile</code> 中是以下内容：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME = hello</span><br><span class="line">SRCS = hello.c</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(AM_HOME)</span>/Makefile</span><br></pre></td></tr></table></figure><br>- <code>NAME</code> 变量定义了目标文件的名称。<br>- <code>SRCS</code> 变量定义了源文件。<br>- <code>include $(AM_HOME)/Makefile</code> 包含了 <code>$(AM_HOME)/Makefile</code> 文件中的内容</li>
<li>隐式规则和重写<br>- Makefile 使用了一些隐式规则和重写规则来简化编译和链接过程。隐式规则是 make 的默认规则，可以自动推断如何编译和链接文件。</li>
<li>编译链接过程</li>
<li>解析 Makefile<br>- 当你在 am-kernels&#x2F;kernels&#x2F;hello&#x2F; 目录下敲入 make ARCH&#x3D;$ISA-nemu 时，make 程序首先解析 Makefile。</li>
<li>包含 $(AM_HOME)&#x2F;Makefile<br>- make 程序解析 include $(AM_HOME)&#x2F;Makefile，将 $(AM_HOME)&#x2F;Makefile 文件的内容包含进来。假设 $(AM_HOME) 是 am-kernels&#x2F;abstract-machine 目录。</li>
<li>解析 $(AM_HOME)&#x2F;Makefile<br>- 在 $(AM_HOME)&#x2F;Makefile 中，定义了一些通用规则和变量，用于编译和链接不同的目标文件。</li>
<li>编译源文件<br>- make 程序根据隐式规则和重写规则，首先编译源文件 hello.c</li>
<li>链接目标文件<br>- 编译完成后，make 程序链接目标文件 hello.o，生成可执行文件 hello-$ISA-nemu.elf</li>
</ol>

</article>
    
    <div class="trm-reward">
        
            <span class="trm-reward-btn trm-glow" onclick='var qr = document.getElementById("qr"); qr.style.display = (qr.style.display === "none") ? "block" : "none";'>
                <i class="iconfont fas fa-hand-holding-usd"></i>
            </span>
        
        <p class="trm-reward-comment">If you like my blog, you can approve me by scanning the QR code below.</p>
        <div id="qr" style="display:none;">
            
                <div style="display:inline-block">
                    <a rel="noopener noreferrer" href='/assets/reward.jpg' target='_blank' >
                       <img src="/assets/reward.jpg" alt="微信" loading="lazy">
                    </a>
                    <p>微信</p>
                </div>
            
        </div>
    </div>

    

</div>
<div class="trm-post-next-prev row">
    <div class="col-lg-12">
        <!-- title -->
        <h5 class="trm-title-with-divider">
            Other Articles
            <span data-number="02"></span>
        </h5>
    </div>
    
        <div class="col-lg-6">
    <div class="trm-blog-card trm-scroll-animation">
        <a href="/2025/02/25/PA1%E5%AE%9E%E9%AA%8C%E5%BF%83%E5%BE%97/" class="trm-cover-frame trm-anima-link">
            
            
                <img alt="cover" class="no-fancybox" src="/img/block.jpg">
            
        </a>
        
        <div class="trm-card-descr">
            <div class="trm-label trm-category trm-mb-20">
                <a href=" /categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/">
                    计算机系统基础实验
                </a>
            </div>
            <h5>
                <a href="/2025/02/25/PA1%E5%AE%9E%E9%AA%8C%E5%BF%83%E5%BE%97/" class="trm-anima-link">
                    PA1实验记录
                </a>
            </h5>
            <div class="trm-divider trm-mb-20 trm-mt-20"></div>
            <ul class="trm-card-data trm-label">
                <li>25/02/25</li>
                <li>22:49</li>
                
                    <li>15k</li>
                
                
                    <li>58</li>
                
            </ul>
        </div>
    </div>
</div>
    
    
        <div class="col-lg-6">
    <div class="trm-blog-card trm-scroll-animation">
        <a href="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/" class="trm-cover-frame trm-anima-link">
            
            
                <img alt="cover" class="no-fancybox" src="/img/block.jpg">
            
        </a>
        
        <div class="trm-card-descr">
            <div class="trm-label trm-category trm-mb-20">
                <a href=" /categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/">
                    计算机系统基础实验
                </a>
            </div>
            <h5>
                <a href="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/" class="trm-anima-link">
                    PA3实验记录
                </a>
            </h5>
            <div class="trm-divider trm-mb-20 trm-mt-20"></div>
            <ul class="trm-card-data trm-label">
                <li>25/02/25</li>
                <li>22:46</li>
                
                    <li>23.9k</li>
                
                
                    <li>98</li>
                
            </ul>
        </div>
    </div>
</div>
    
</div>

    



                    <div class="trm-divider footer-divider"></div>

                    <!-- footer -->
                    <footer class="trm-footer-card trm-scroll-animation">

    

    

      

    
        <div class="trm-footer-item blog-run-long"></div>
     

    
        <div class="trm-footer-item">
            你走过的弯路，都是通向正轨的必经之路。
        </div>
     
</footer>
                    <!-- footer end -->

                </div>
            </div>
        </div>
    </div>
</div>
            <!-- body end -->

            

    <div id="post-toc" class="trm-post-toc">
      <div class="trm-post-toc-header">
        Article table of contents
				<span id="post-toc-top">
					TOP
				</span>
      </div>
      <div class="trm-post-toc-content">
        <ol class="trm-toc"><li class="trm-toc-item trm-toc-level-1" title="PA2 - 简单复杂的机器: 冯诺依曼计算机系统"><a rel="nofollow" class="trm-toc-link" href="#PA2-简单复杂的机器-冯诺依曼计算机系统"><span class="trm-toc-number">1.</span> <span class="trm-toc-text">PA2 - 简单复杂的机器: 冯诺依曼计算机系统</span></a></li><li class="trm-toc-item trm-toc-level-1" title="不停计算的机器"><a rel="nofollow" class="trm-toc-link" href="#不停计算的机器"><span class="trm-toc-number">2.</span> <span class="trm-toc-text">不停计算的机器</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="1.取指(instruction fetch, IF)"><a rel="nofollow" class="trm-toc-link" href="#1-取指-instruction-fetch-IF"><span class="trm-toc-number">2.0.1.</span> <span class="trm-toc-text">1.取指(instruction fetch, IF)</span></a></li><li class="trm-toc-item trm-toc-level-3" title="2.译码(instruction decode, ID)"><a rel="nofollow" class="trm-toc-link" href="#2-译码-instruction-decode-ID"><span class="trm-toc-number">2.0.2.</span> <span class="trm-toc-text">2.译码(instruction decode, ID)</span></a></li><li class="trm-toc-item trm-toc-level-3" title="3.执行(execute, EX)"><a rel="nofollow" class="trm-toc-link" href="#3-执行-execute-EX"><span class="trm-toc-number">2.0.3.</span> <span class="trm-toc-text">3.执行(execute, EX)</span></a></li><li class="trm-toc-item trm-toc-level-3" title="4.更新PC"><a rel="nofollow" class="trm-toc-link" href="#4-更新PC"><span class="trm-toc-number">2.0.4.</span> <span class="trm-toc-text">4.更新PC</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-2" title="YEMU: 一个简单的CPU模拟器"><a rel="nofollow" class="trm-toc-link" href="#YEMU-一个简单的CPU模拟器"><span class="trm-toc-number">2.1.</span> <span class="trm-toc-text">YEMU: 一个简单的CPU模拟器</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-1" title="RTFSC(2)"><a rel="nofollow" class="trm-toc-link" href="#RTFSC-2"><span class="trm-toc-number">3.</span> <span class="trm-toc-text">RTFSC(2)</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-2" title="RTFM"><a rel="nofollow" class="trm-toc-link" href="#RTFM"><span class="trm-toc-number">3.1.</span> <span class="trm-toc-text">RTFM</span></a></li><li class="trm-toc-item trm-toc-level-2" title="RTFSC(2)"><a rel="nofollow" class="trm-toc-link" href="#RTFSC-2-1"><span class="trm-toc-number">3.2.</span> <span class="trm-toc-text">RTFSC(2)</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="取指(instruction fetch, IF)"><a rel="nofollow" class="trm-toc-link" href="#取指-instruction-fetch-IF"><span class="trm-toc-number">3.2.1.</span> <span class="trm-toc-text">取指(instruction fetch, IF)</span></a></li><li class="trm-toc-item trm-toc-level-3" title="译码(instruction decode, ID)"><a rel="nofollow" class="trm-toc-link" href="#译码-instruction-decode-ID"><span class="trm-toc-number">3.2.2.</span> <span class="trm-toc-text">译码(instruction decode, ID)</span></a></li><li class="trm-toc-item trm-toc-level-3" title="执行(execute, EX)"><a rel="nofollow" class="trm-toc-link" href="#执行-execute-EX"><span class="trm-toc-number">3.2.3.</span> <span class="trm-toc-text">执行(execute, EX)</span></a></li><li class="trm-toc-item trm-toc-level-3" title="更新PC"><a rel="nofollow" class="trm-toc-link" href="#更新PC"><span class="trm-toc-number">3.2.4.</span> <span class="trm-toc-text">更新PC</span></a></li><li class="trm-toc-item trm-toc-level-3" title="结构化程序设计"><a rel="nofollow" class="trm-toc-link" href="#结构化程序设计"><span class="trm-toc-number">3.2.5.</span> <span class="trm-toc-text">结构化程序设计</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-2" title="运行第一个C程序"><a rel="nofollow" class="trm-toc-link" href="#运行第一个C程序"><span class="trm-toc-number">3.3.</span> <span class="trm-toc-text">运行第一个C程序</span></a></li><li class="trm-toc-item trm-toc-level-2" title="运行更多的程序"><a rel="nofollow" class="trm-toc-link" href="#运行更多的程序"><span class="trm-toc-number">3.4.</span> <span class="trm-toc-text">运行更多的程序</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="PA2.1结束"><a rel="nofollow" class="trm-toc-link" href="#PA2-1结束"><span class="trm-toc-number">3.4.1.</span> <span class="trm-toc-text">PA2.1结束</span></a></li></ol></li></ol></li><li class="trm-toc-item trm-toc-level-1" title="程序, 运行时环境与AM"><a rel="nofollow" class="trm-toc-link" href="#程序-运行时环境与AM"><span class="trm-toc-number">4.</span> <span class="trm-toc-text">程序, 运行时环境与AM</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-2" title="运行时环境"><a rel="nofollow" class="trm-toc-link" href="#运行时环境"><span class="trm-toc-number">4.1.</span> <span class="trm-toc-text">运行时环境</span></a></li><li class="trm-toc-item trm-toc-level-2" title="将运行时环境封装成库函数"><a rel="nofollow" class="trm-toc-link" href="#将运行时环境封装成库函数"><span class="trm-toc-number">4.2.</span> <span class="trm-toc-text">将运行时环境封装成库函数</span></a></li><li class="trm-toc-item trm-toc-level-2" title="AM - 裸机(bare-metal)运行时环境"><a rel="nofollow" class="trm-toc-link" href="#AM-裸机-bare-metal-运行时环境"><span class="trm-toc-number">4.3.</span> <span class="trm-toc-text">AM - 裸机(bare-metal)运行时环境</span></a></li><li class="trm-toc-item trm-toc-level-2" title="RTFSC(3)"><a rel="nofollow" class="trm-toc-link" href="#RTFSC-3"><span class="trm-toc-number">4.4.</span> <span class="trm-toc-text">RTFSC(3)</span></a></li><li class="trm-toc-item trm-toc-level-2" title="实现常用的库函数"><a rel="nofollow" class="trm-toc-link" href="#实现常用的库函数"><span class="trm-toc-number">4.5.</span> <span class="trm-toc-text">实现常用的库函数</span></a></li><li class="trm-toc-item trm-toc-level-2" title="重新认识计算机: 计算机是个抽象层"><a rel="nofollow" class="trm-toc-link" href="#重新认识计算机-计算机是个抽象层"><span class="trm-toc-number">4.6.</span> <span class="trm-toc-text">重新认识计算机: 计算机是个抽象层</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-1" title="基础设施（2）"><a rel="nofollow" class="trm-toc-link" href="#基础设施（2）"><span class="trm-toc-number">5.</span> <span class="trm-toc-text">基础设施（2）</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-2" title="bug诊断的利器 - 踪迹"><a rel="nofollow" class="trm-toc-link" href="#bug诊断的利器-踪迹"><span class="trm-toc-number">5.1.</span> <span class="trm-toc-text">bug诊断的利器 - 踪迹</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="指令执行的踪迹 - itrace"><a rel="nofollow" class="trm-toc-link" href="#指令执行的踪迹-itrace"><span class="trm-toc-number">5.1.1.</span> <span class="trm-toc-text">指令执行的踪迹 - itrace</span></a></li><li class="trm-toc-item trm-toc-level-3" title="指令环形缓冲区 - iringbuf"><a rel="nofollow" class="trm-toc-link" href="#指令环形缓冲区-iringbuf"><span class="trm-toc-number">5.1.2.</span> <span class="trm-toc-text">指令环形缓冲区 - iringbuf</span></a></li><li class="trm-toc-item trm-toc-level-3" title="内存访问的踪迹 - mtrace"><a rel="nofollow" class="trm-toc-link" href="#内存访问的踪迹-mtrace"><span class="trm-toc-number">5.1.3.</span> <span class="trm-toc-text">内存访问的踪迹 - mtrace</span></a></li><li class="trm-toc-item trm-toc-level-3" title="函数调用的踪迹 - ftrace"><a rel="nofollow" class="trm-toc-link" href="#函数调用的踪迹-ftrace"><span class="trm-toc-number">5.1.4.</span> <span class="trm-toc-text">函数调用的踪迹 - ftrace</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-2" title="AM作为基础设施"><a rel="nofollow" class="trm-toc-link" href="#AM作为基础设施"><span class="trm-toc-number">5.2.</span> <span class="trm-toc-text">AM作为基础设施</span></a></li><li class="trm-toc-item trm-toc-level-2" title="测试你的klib"><a rel="nofollow" class="trm-toc-link" href="#测试你的klib"><span class="trm-toc-number">5.3.</span> <span class="trm-toc-text">测试你的klib</span></a></li><li class="trm-toc-item trm-toc-level-2" title="Differential Testing——强大的测试工具！"><a rel="nofollow" class="trm-toc-link" href="#Differential-Testing——强大的测试工具！"><span class="trm-toc-number">5.4.</span> <span class="trm-toc-text">Differential Testing——强大的测试工具！</span></a></li><li class="trm-toc-item trm-toc-level-2" title="一键回归测试"><a rel="nofollow" class="trm-toc-link" href="#一键回归测试"><span class="trm-toc-number">5.5.</span> <span class="trm-toc-text">一键回归测试</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-1" title="输入输出"><a rel="nofollow" class="trm-toc-link" href="#输入输出"><span class="trm-toc-number">6.</span> <span class="trm-toc-text">输入输出</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-2" title="设备与CPU"><a rel="nofollow" class="trm-toc-link" href="#设备与CPU"><span class="trm-toc-number">6.1.</span> <span class="trm-toc-text">设备与CPU</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="端口I&#x2F;O"><a rel="nofollow" class="trm-toc-link" href="#端口I-O"><span class="trm-toc-number">6.1.1.</span> <span class="trm-toc-text">端口I&#x2F;O</span></a></li><li class="trm-toc-item trm-toc-level-3" title="內存映射I&#x2F;O"><a rel="nofollow" class="trm-toc-link" href="#內存映射I-O"><span class="trm-toc-number">6.1.2.</span> <span class="trm-toc-text">內存映射I&#x2F;O</span></a></li><li class="trm-toc-item trm-toc-level-3" title="状态机视角下的输入输出"><a rel="nofollow" class="trm-toc-link" href="#状态机视角下的输入输出"><span class="trm-toc-number">6.1.3.</span> <span class="trm-toc-text">状态机视角下的输入输出</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-2" title="NEMU中的输入输出"><a rel="nofollow" class="trm-toc-link" href="#NEMU中的输入输出"><span class="trm-toc-number">6.2.</span> <span class="trm-toc-text">NEMU中的输入输出</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="映射和I&#x2F;O方式"><a rel="nofollow" class="trm-toc-link" href="#映射和I-O方式"><span class="trm-toc-number">6.2.1.</span> <span class="trm-toc-text">映射和I&#x2F;O方式</span></a></li><li class="trm-toc-item trm-toc-level-3" title="设备"><a rel="nofollow" class="trm-toc-link" href="#设备"><span class="trm-toc-number">6.2.2.</span> <span class="trm-toc-text">设备</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-2" title="将输入输出抽象成IOE"><a rel="nofollow" class="trm-toc-link" href="#将输入输出抽象成IOE"><span class="trm-toc-number">6.3.</span> <span class="trm-toc-text">将输入输出抽象成IOE</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="串口"><a rel="nofollow" class="trm-toc-link" href="#串口"><span class="trm-toc-number">6.3.1.</span> <span class="trm-toc-text">串口</span></a></li><li class="trm-toc-item trm-toc-level-3" title="时钟"><a rel="nofollow" class="trm-toc-link" href="#时钟"><span class="trm-toc-number">6.3.2.</span> <span class="trm-toc-text">时钟</span></a></li><li class="trm-toc-item trm-toc-level-3" title="设备访问的踪迹 - dtrace"><a rel="nofollow" class="trm-toc-link" href="#设备访问的踪迹-dtrace"><span class="trm-toc-number">6.3.3.</span> <span class="trm-toc-text">设备访问的踪迹 - dtrace</span></a></li><li class="trm-toc-item trm-toc-level-3" title="键盘"><a rel="nofollow" class="trm-toc-link" href="#键盘"><span class="trm-toc-number">6.3.4.</span> <span class="trm-toc-text">键盘</span></a></li><li class="trm-toc-item trm-toc-level-3" title="VGA"><a rel="nofollow" class="trm-toc-link" href="#VGA"><span class="trm-toc-number">6.3.5.</span> <span class="trm-toc-text">VGA</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-2" title="冯诺依曼计算机系统"><a rel="nofollow" class="trm-toc-link" href="#冯诺依曼计算机系统"><span class="trm-toc-number">6.4.</span> <span class="trm-toc-text">冯诺依曼计算机系统</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="必答题："><a rel="nofollow" class="trm-toc-link" href="#必答题："><span class="trm-toc-number">6.4.1.</span> <span class="trm-toc-text">必答题：</span></a></li></ol></li></ol></li></ol>
      </div>
    </div>

            
<div class="trm-fixed-container">
    
        <div class="trm-fixed-btn post-toc-btn" data-title="Open toc">
            <i class="iconfont fas fa-th-list"></i>
        </div>
    
    
        <div class="trm-fixed-btn" data-title="Read Mode" onclick="asyncFun.switchReadMode()">
            <i class="iconfont fas fa-book-reader"></i>
        </div>
    
    
    <div id="trm-back-top" class="trm-fixed-btn" data-title="Back To Top">
        <i class="iconfont fas fa-arrow-up"></i>
    </div>
</div>
        </div>
      </div>
      <!-- scroll container end -->
  </div>
  <!-- app wrapper end -->

  
    <div class="trm-search-popup">
        <div class="trm-search-wrapper">
            <div class="form trm-search-form">
                <div class="trm-search-input-icon">
                    <i class="iconfont fas fa-search"></i>
                </div>
                <input class="trm-search-input" type="text" placeholder="Searching...">
                <div class="trm-search-btn-close">
                    <i class="iconfont fas fa-times"></i>
                </div>
            </div>
            <div class="trm-search-result-container">
                <div class="trm-search-empty">
                    Please enter keywords to search
                </div>
            </div>
            <div class="trm-search-footer">
                <div class="trm-search-stats"></div>
                <ul class="trm-search-commands">
                    <li>
                        <kbd class="command-palette-commands-key">
                            <svg width="15" height="15" aria-label="Escape key" role="img">
                                <g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"
                                    stroke-width="1.2">
                                    <path
                                        d="M13.6167 8.936c-.1065.3583-.6883.962-1.4875.962-.7993 0-1.653-.9165-1.653-2.1258v-.5678c0-1.2548.7896-2.1016 1.653-2.1016.8634 0 1.3601.4778 1.4875 1.0724M9 6c-.1352-.4735-.7506-.9219-1.46-.8972-.7092.0246-1.344.57-1.344 1.2166s.4198.8812 1.3445.9805C8.465 7.3992 8.968 7.9337 9 8.5c.032.5663-.454 1.398-1.4595 1.398C6.6593 9.898 6 9 5.963 8.4851m-1.4748.5368c-.2635.5941-.8099.876-1.5443.876s-1.7073-.6248-1.7073-2.204v-.4603c0-1.0416.721-2.131 1.7073-2.131.9864 0 1.6425 1.031 1.5443 2.2492h-2.956">
                                    </path>
                                </g>
                            </svg>
                        </kbd>
                        <span class="command-palette-Label">to close</span>
                    </li>
                </ul>
            </div>
        </div>
    </div>

  <!-- Plugin -->




    
    
<script src="https://unpkg.com/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script>

    

    

    
        
<script src="https://unpkg.com/hexo-generator-searchdb@1.4.0/dist/search.js"></script>

        <script src="/js/plugins/local_search.js?v=2.2.4"></script>
    

    <!-- 数学公式 -->
    

    <!-- 评论插件 -->
    
        

        
    

		




    <!-- Service Worker -->
    
    <!-- baidu push -->
    


<script id="async-script" src="/js/main.js?v=2.2.4"></script>

<!-- CDN -->


    

    

    



</body>

</html>