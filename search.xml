<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2-补码加减乘除</title>
    <url>/2025/02/22/2.%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/</url>
    <content><![CDATA[<h2 id="一-计算两个32位二进制整数补码真值的和"><a href="#一-计算两个32位二进制整数补码真值的和" class="headerlink" title="一. 计算两个32位二进制整数补码真值的和"></a>一. 计算两个32位二进制整数补码真值的和</h2><h3 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1. 步骤"></a>1. 步骤</h3><ol>
<li>初始化：将 src 和 dest 转换为字符串形式，并初始化一个 StringBuilder 来存储结果。</li>
<li>逐位相加：从最低位（第31位）开始逐位相加，<strong>考虑进位情况</strong>。</li>
<li>处理进位：根据<strong>当前位的和以及是否有进位</strong>，决定<strong>当前位的结果和是否产生新的进位</strong>。</li>
<li><strong>结果反转</strong>：由于结果是从最低位开始添加的，<strong>最终需要反转字符串以得到正确的顺序</strong>。</li>
<li>返回结果：将结果转换为 DataType 并返回。<ul>
<li>DataType ans &#x3D; <strong>new DataType(ansStr)</strong>;</li>
</ul>
</li>
</ol>
<h3 id="2-【注意】结果反转"><a href="#2-【注意】结果反转" class="headerlink" title="2. 【注意】结果反转"></a>2. 【注意】结果反转</h3><ul>
<li><code>String ans = ansStr.reverse().toString();</code></li>
<li><strong>StringBulider</strong>才能用<code>.reverse()</code>; String不能用</li>
</ul>
<h3 id="3-完整代码"><a href="#3-完整代码" class="headerlink" title="3. 完整代码"></a>3. 完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">add</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">       String srcStr=src.toString();</span><br><span class="line">       String destStr=dest.toString();</span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">ansStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">destInt</span> <span class="operator">=</span> destStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           <span class="type">int</span> <span class="variable">srcInt</span> <span class="operator">=</span> srcStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           <span class="keyword">if</span> (!carry) &#123;<span class="comment">//无进位</span></span><br><span class="line">               <span class="keyword">if</span> (destInt + srcInt == <span class="number">2</span>) &#123;</span><br><span class="line">                   carry = <span class="literal">true</span>;</span><br><span class="line">                   ansStr.append(<span class="number">0</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span>(destInt+srcInt==<span class="number">1</span>)&#123;</span><br><span class="line">                   ansStr.append(<span class="number">1</span>);</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   ansStr.append(<span class="number">0</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;<span class="comment">//有进位</span></span><br><span class="line">               <span class="keyword">if</span> (destInt + srcInt == <span class="number">2</span>) &#123;</span><br><span class="line">                   ansStr.append(<span class="number">1</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span>(destInt+srcInt==<span class="number">1</span>)&#123;</span><br><span class="line">                   ansStr.append(<span class="number">0</span>);</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   ansStr.append(<span class="number">1</span>);</span><br><span class="line">                   carry=<span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">DataType</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(ansStr.reverse().toString());</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-更简单："><a href="#4-更简单：" class="headerlink" title="4. 更简单："></a>4. 更简单：</h3><ul>
<li>int sum &#x3D; num1 + num2 + carry;</li>
<li>result.append(sum % 2);</li>
<li>carry &#x3D; sum &#x2F; 2;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">add</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">srcStr</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">destStr</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> srcStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> destStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> num1 + num2 + carry;</span><br><span class="line">        result.append(sum % <span class="number">2</span>);</span><br><span class="line">        carry = sum / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(result.reverse().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、计算两个32位二进制整数补码真值的差"><a href="#二、计算两个32位二进制整数补码真值的差" class="headerlink" title="二、计算两个32位二进制整数补码真值的差"></a>二、计算两个32位二进制整数补码真值的差</h2><ul>
<li>dest表示被减数，src表示减数(即计算dest - src)</li>
</ul>
<h3 id="1-取反操作"><a href="#1-取反操作" class="headerlink" title="1. 取反操作"></a>1. 取反操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">negation</span><span class="params">(String beforeStr)</span>&#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">afterStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">//逐位取反</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (beforeStr.charAt(i)==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            afterStr.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            afterStr.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加1</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(carry)&#123;<span class="comment">//有进位</span></span><br><span class="line">            <span class="keyword">if</span>(afterStr.charAt(i)==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                afterStr.replace(i,i+<span class="number">1</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                carry=<span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                afterStr.replace(i,i+<span class="number">1</span>,<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> afterStr.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-完整代码"><a href="#2-完整代码" class="headerlink" title="2.完整代码"></a>2.完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">sub</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    String srcStr=src.toString();</span><br><span class="line">    srcStr=negation(srcStr);</span><br><span class="line">    src = <span class="keyword">new</span> <span class="title class_">DataType</span>(srcStr);</span><br><span class="line">    <span class="keyword">return</span> add(src,dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、两个二进制整数的乘积-布斯乘法，结果低位截取后32位"><a href="#三、两个二进制整数的乘积-布斯乘法，结果低位截取后32位" class="headerlink" title="三、两个二进制整数的乘积(布斯乘法，结果低位截取后32位)"></a>三、两个二进制整数的乘积(布斯乘法，结果低位截取后32位)</h2><h3 id="1-布斯乘法"><a href="#1-布斯乘法" class="headerlink" title="1.布斯乘法"></a>1.布斯乘法</h3><ol>
<li>正负数处理：<ul>
<li>检查 src 和 dest 是否为负数，如果是负数，则将其<strong>转换为正数</strong>。</li>
</ul>
</li>
<li>初始化：<ol>
<li>初始化 <strong>resultStr</strong> 为<strong>65位字符串</strong>，其中<strong>前32位为0，后32位为 dest，并在末尾添一个0</strong>。<ul>
<li><strong>32个0+dest+0</strong></li>
</ul>
</li>
</ol>
</li>
<li>迭代计算：<ul>
<li>对 resultStr 进行<strong>32次迭代</strong>；第一次是<strong>0-最低位</strong></li>
<li>每次根据 resultStr 的最低位和次低位的组合（<strong>最低位-次低位</strong>）决定是否进行加法或减法操作。<ul>
<li>如果组合为 <strong>01（1）</strong>，则将 <strong>resultStr的高32位 + src</strong>。</li>
<li>如果组合为 10（-1），则将<strong>resultStr的高32位 - src</strong>。</li>
<li>如果组合为 11或00（0），则不变。</li>
<li>进行<strong>算术右移操作（保留符号位）</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>重复：<ul>
<li>重复上述迭代步骤，直到处理完乘数的所有位。</li>
</ul>
</li>
<li>结果：<ul>
<li>截取 resultStr 的**低32位（33~64）**作为最终结果</li>
<li>如果原始 src 和 dest 中有一个是负数，则将结果取反。</li>
</ul>
</li>
</ol>
<h3 id="2-算术右移方法："><a href="#2-算术右移方法：" class="headerlink" title="2. 算术右移方法："></a>2. 算术右移方法：</h3><ol>
<li>符号位不变</li>
<li>原本的64位整体右移</li>
</ol>
<ul>
<li>相当于<strong>前面变成两个符号位，最后一位丢掉</strong></li>
</ul>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">mul</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    String srcStr=src.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">destStr</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="comment">//1.判断正负，如果负，则标记并转为正</span></span><br><span class="line">    <span class="type">boolean</span> srcNeg=<span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> destNeg=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(srcStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">        srcNeg=<span class="literal">true</span>;</span><br><span class="line">        srcStr=negation(srcStr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(destStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">        destNeg=<span class="literal">true</span>;</span><br><span class="line">        destStr=negation(destStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.初始化</span></span><br><span class="line">    StringBuilder resultStr=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;0&quot;</span>.repeat(<span class="number">32</span>)+destStr+<span class="string">&quot;0&quot;</span>);<span class="comment">//result，32个0+dest+0组成</span></span><br><span class="line">    <span class="comment">//3.计算</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">32</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        DataType src1=<span class="keyword">new</span> <span class="title class_">DataType</span>(srcStr);</span><br><span class="line">        DataType dest1=<span class="keyword">new</span> <span class="title class_">DataType</span>(resultStr.substring(<span class="number">0</span>,<span class="number">32</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">32</span>)&#123;<span class="comment">//第1位（补充了一个0）</span></span><br><span class="line">            <span class="keyword">if</span>(destStr.charAt(<span class="number">31</span>)-<span class="string">&#x27;0&#x27;</span>==<span class="number">0</span>)&#123;<span class="comment">//0：右移</span></span><br><span class="line">                resultStr= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(rightshift(resultStr.toString()));<span class="comment">//右移</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//-1：减src，再右移</span></span><br><span class="line">                resultStr.replace(<span class="number">0</span>,<span class="number">32</span>,sub(src1,dest1).toString());</span><br><span class="line">                resultStr= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(rightshift(resultStr.toString()));<span class="comment">//右移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//其它位</span></span><br><span class="line">            <span class="keyword">if</span>(destStr.charAt(i)-destStr.charAt(i-<span class="number">1</span>)==<span class="number">0</span>)&#123;<span class="comment">//0：右移</span></span><br><span class="line">                resultStr= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(rightshift(resultStr.toString()));<span class="comment">//右移</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>  <span class="keyword">if</span>(destStr.charAt(i)-destStr.charAt(i-<span class="number">1</span>)==<span class="number">1</span>)&#123;<span class="comment">//1：加src，再右移</span></span><br><span class="line">                resultStr.replace(<span class="number">0</span>,<span class="number">32</span>,add(src1,dest1).toString());</span><br><span class="line">                resultStr= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(rightshift(resultStr.toString()));<span class="comment">//右移</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//-1：减src，再右移</span></span><br><span class="line">                resultStr.replace(<span class="number">0</span>,<span class="number">32</span>,sub(src1,dest1).toString());</span><br><span class="line">                resultStr= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(rightshift(resultStr.toString()));<span class="comment">//右移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.结果：截取低32位</span></span><br><span class="line">    String result=resultStr.substring(<span class="number">32</span>,<span class="number">64</span>);</span><br><span class="line">    <span class="comment">//正负调整</span></span><br><span class="line">    <span class="keyword">if</span>((srcNeg&amp;&amp;!destNeg)||(!srcNeg&amp;&amp;destNeg))&#123;</span><br><span class="line">        result =negation(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">rightshift</span><span class="params">(String beforeStr)</span>&#123;<span class="comment">//右移</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">afterStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    afterStr.append(beforeStr.charAt(<span class="number">0</span>));<span class="comment">//保留符号位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">64</span>;i++)&#123;</span><br><span class="line">        afterStr.append(beforeStr.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> afterStr.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、两个二进制整数的除法"><a href="#四、两个二进制整数的除法" class="headerlink" title="四、两个二进制整数的除法"></a>四、两个二进制整数的除法</h2><ul>
<li><strong>恢复余数除法</strong>和<strong>不恢复余数除法</strong>均可</li>
<li>dest ÷ src</li>
<li>将32位余数正确储存在余数寄存器remainderReg中</li>
<li>除数为0，且被除数不为0时要求能够正确抛出ArithmeticException<strong>异常</strong>。</li>
</ul>
<h3 id="1-恢复余数除法"><a href="#1-恢复余数除法" class="headerlink" title="1. 恢复余数除法"></a>1. 恢复余数除法</h3><ol start="0">
<li>（此代码中）正负调整(【Datatype】src和【String】srcStr都要)</li>
<li>初始化：<ul>
<li>被除数（Dividend）和除数（Divisor）分别存储在寄存器中。</li>
<li><strong>余数</strong>寄存器（Remainder）初始化为<strong>32位的0</strong>。</li>
<li><strong>商</strong>寄存器（Quotient）初始化为<strong>被除数</strong>。</li>
</ul>
</li>
<li>迭代：对<strong>被除数的每一位</strong>进行处理，从<strong>最高位到最低位</strong>。<ol>
<li>将<strong>余数左移一位</strong>，并将<strong>被除数的当前位移入余数的最低位</strong>。</li>
<li><strong>余数减去&#x2F;加上除数</strong>。<ul>
<li>如果余数<strong>与原本异号</strong>，则<strong>恢复余数（加回除数）</strong>，并将<strong>商的当前位设为0</strong>。</li>
<li>如果余数<strong>与原本同号</strong>，则将商的当前位<strong>设为1</strong>。</li>
</ul>
</li>
</ol>
</li>
<li>结果：<ul>
<li>（此代码中）调整<strong>余数和商的符号</strong></li>
<li>迭代完成后，商寄存器中存储的值即为商，余数寄存器中存储的值即为余数。</li>
</ul>
</li>
</ol>
<h3 id="2-不恢复余数除法"><a href="#2-不恢复余数除法" class="headerlink" title="2. 不恢复余数除法"></a>2. 不恢复余数除法</h3><ol>
<li>初始化：<ul>
<li>被除数（Dividend）和除数（Divisor）分别存储在寄存器中。</li>
<li>余数寄存器（Remainder）初始化为0。</li>
<li>商寄存器（Quotient）初始化为被除数。</li>
</ul>
</li>
<li>迭代： 对被除数的每一位进行处理，从最高位到最低位。<ol>
<li>将<strong>余数左移一位</strong>，并将<strong>被除数的当前位移入余数的最低位</strong>。</li>
<li>余数减去&#x2F;加上除数。<ul>
<li>如果余数<strong>与原本异号</strong>，则将商的当前位设为0，并在<strong>下一次迭代中将余数加回除数</strong>。</li>
<li>如果余数<strong>与原本同号</strong>，则将商的当前位设为1，并在<strong>下一次迭代中继续减去除数</strong>。</li>
</ul>
</li>
</ol>
</li>
<li>结果：<ul>
<li>根据被除数和除数的符号，调整商和余数的符号：<ul>
<li><strong>被除数和除数同号：余数+除数</strong>，商为正</li>
<li><strong>被除数和除数异号：余数-除数</strong>，商为负</li>
</ul>
</li>
<li>迭代完成后，商寄存器中存储的值即为商，余数寄存器中存储的值即为余数。</li>
</ul>
</li>
</ol>
<h3 id="3-调整余数和商的符号"><a href="#3-调整余数和商的符号" class="headerlink" title="3. 调整余数和商的符号"></a>3. 调整余数和商的符号</h3><ol>
<li><strong>余数和被除数同号</strong></li>
<li>其中<strong>一方为负，则商取负</strong></li>
</ol>
<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataType remainderReg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回两个二进制整数的除法结果</span></span><br><span class="line"><span class="comment"> * dest ÷ src</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src  32-bits</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest 32-bits</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 32-bits</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//用恢复余数除法</span></span><br><span class="line"><span class="keyword">public</span> DataType <span class="title function_">div</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">srcStr</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">destStr</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="comment">//0.判断除0情况</span></span><br><span class="line">    <span class="keyword">if</span>(srcStr.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;除0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 判断正负，如果是负就转正，并标记</span></span><br><span class="line">    <span class="type">boolean</span> srcNeg=<span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">destNeg</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(srcStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">        srcStr=negation(srcStr);</span><br><span class="line">        src=<span class="keyword">new</span> <span class="title class_">DataType</span>(srcStr);<span class="comment">//保证src也变号</span></span><br><span class="line">        srcNeg=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(destStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">        destStr=negation(destStr);</span><br><span class="line">        dest = <span class="keyword">new</span> <span class="title class_">DataType</span>(destStr);<span class="comment">//保证dest也变号</span></span><br><span class="line">        destNeg=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 初始化-商和余数寄存器</span></span><br><span class="line">    StringBuilder Shang=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(destStr);<span class="comment">//商，初始化为被除数</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">Yu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;0&quot;</span>.repeat(<span class="number">32</span>));<span class="comment">//余数，初始化为32个0</span></span><br><span class="line">    <span class="comment">//3. 计算</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//3.1左移</span></span><br><span class="line">        Yu=leftshift(Yu.toString());</span><br><span class="line">        Yu.append(Shang.charAt(<span class="number">0</span>));</span><br><span class="line">        Shang=leftshift(Shang.toString());</span><br><span class="line">        <span class="comment">//3.2 余数减去除数</span></span><br><span class="line">        String tmp=sub(src,<span class="keyword">new</span> <span class="title class_">DataType</span>(Yu.toString())).toString();</span><br><span class="line">        <span class="keyword">if</span>(tmp.charAt(<span class="number">0</span>)==<span class="string">&#x27;1&#x27;</span>)&#123;<span class="comment">//为负</span></span><br><span class="line">            Shang.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//非负</span></span><br><span class="line">            Yu=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(tmp);</span><br><span class="line">            Shang.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.结果</span></span><br><span class="line">    String YuStr= Yu.toString();</span><br><span class="line">    String ShangStr= Shang.toString();</span><br><span class="line">    <span class="comment">//被除数和余数同号</span></span><br><span class="line">    <span class="keyword">if</span>(!srcNeg&amp;&amp;destNeg)&#123;<span class="comment">//除数正，被除数负</span></span><br><span class="line">        YuStr=negation(YuStr);</span><br><span class="line">        ShangStr=negation(ShangStr);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (srcNeg&amp;&amp;!destNeg) &#123;<span class="comment">//除数负，被除数正</span></span><br><span class="line">        ShangStr=negation(YuStr);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(srcNeg&amp;&amp;destNeg)&#123;<span class="comment">//都是负</span></span><br><span class="line">        YuStr=negation(YuStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remainderReg=<span class="keyword">new</span> <span class="title class_">DataType</span>(YuStr);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(ShangStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左移</span></span><br><span class="line"><span class="keyword">public</span> StringBuilder <span class="title function_">leftshift</span><span class="params">(String beforeStr)</span>&#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">afterStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">32</span>;i++)&#123;<span class="comment">//跳过第一位</span></span><br><span class="line">        afterStr.append(beforeStr.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> afterStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>1-十进制二进制浮点数转换</title>
    <url>/2025/02/20/1-%E5%8D%81%E8%BF%9B%E5%88%B6%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="一、十进制整数-二进制补码"><a href="#一、十进制整数-二进制补码" class="headerlink" title="一、十进制整数-&gt;二进制补码"></a>一、十进制整数-&gt;二进制补码</h2><h3 id="1-用2整除的方式（正数）"><a href="#1-用2整除的方式（正数）" class="headerlink" title="1. 用2整除的方式（正数）"></a>1. 用2整除的方式（正数）</h3><ol>
<li>用2整除十进制整数，得到一个<strong>商</strong>和<strong>余数</strong>；</li>
<li>再<strong>用2去除商</strong>，又会得到一个商和余</li>
<li>如此重复，直到<strong>商为小于1</strong>时为止，</li>
<li>然后把<strong>先得到余数</strong>作为二进制数的<strong>低位有效位</strong>，<strong>后得到的余数</strong>作为二进制数的<strong>高位有效位</strong>，以此排列起来。<br><img src="/2025/02/20/1-%E5%8D%81%E8%BF%9B%E5%88%B6%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BD%AC%E6%8D%A2/image.png" alt="alt"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<h3 id="2-负数转化为其补码——（其绝对值转化成二进制后）逐位取反-加一"><a href="#2-负数转化为其补码——（其绝对值转化成二进制后）逐位取反-加一" class="headerlink" title="2. 负数转化为其补码——（其绝对值转化成二进制后）逐位取反+加一"></a>2. 负数转化为其补码——（其绝对值转化成二进制后）逐位取反+加一</h3><ol>
<li>将负数的<strong>绝对值</strong>转换为二进制。</li>
<li>对二进制数进行<strong>逐位取反</strong>（0变1，1变0）。</li>
<li>对<strong>取反后的二进制数加1</strong>。</li>
</ol>
<h3 id="3-将字符数组转换为字符串"><a href="#3-将字符数组转换为字符串" class="headerlink" title="3. 将字符数组转换为字符串"></a>3. 将字符数组转换为字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">binary</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(binaryStr);</span><br></pre></td></tr></table></figure>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>将字符串转换为整数：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">numInt</span> <span class="operator">=</span> Integer.parseInt(numStr);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>初始化一个长度为32的字符数组</strong>，用于存储二进制表示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] binaryStr = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">32</span>];</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>设置符号位</li>
<li>处理正数：使用除2取余法。从数组的末尾开始填充二进制位。</li>
<li>处理负数：<ul>
<li>先将负数转换为其<strong>绝对值</strong>。</li>
<li>使用<strong>除2取余法</strong>，将绝对值转换为二进制表示。</li>
<li>对二进制表示<strong>逐位取反</strong>。</li>
<li>对<strong>取反后的二进制数加一</strong>。注意<code>ifplus</code></li>
</ul>
</li>
<li>将<strong>字符数组转换为字符串</strong>并返回</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">binary</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(binaryStr);</span><br></pre></td></tr></table></figure>
<h3 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">intToBinary</span><span class="params">(String numStr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> numInt=Integer.parseInt(numStr);<span class="comment">//转成int</span></span><br><span class="line">    <span class="type">char</span> []binaryStr = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">if</span>(numInt&gt;=<span class="number">0</span>)&#123;<span class="comment">//符号位</span></span><br><span class="line">        binaryStr[<span class="number">0</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        binaryStr[<span class="number">0</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (numInt&gt;=<span class="number">0</span>)&#123;<span class="comment">//正数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numInt%<span class="number">2</span>==<span class="number">1</span>)&#123;<span class="comment">//余数是1</span></span><br><span class="line">                binaryStr[<span class="number">32</span>-i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//余数是0</span></span><br><span class="line">                binaryStr[<span class="number">32</span>-i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            numInt=numInt/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;<span class="comment">//负数，等于其正数的二进制数，逐位取反，再加一</span></span><br><span class="line">        numInt = -numInt;<span class="comment">//转正</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numInt % <span class="number">2</span> == <span class="number">1</span>) &#123;<span class="comment">//余数是1</span></span><br><span class="line">                binaryStr[<span class="number">32</span> - i] = <span class="string">&#x27;0&#x27;</span>;<span class="comment">//取反</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//余数是0</span></span><br><span class="line">                binaryStr[<span class="number">32</span> - i] = <span class="string">&#x27;1&#x27;</span>;<span class="comment">//取反</span></span><br><span class="line">            &#125;</span><br><span class="line">            numInt = numInt / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加一</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ifplus</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binaryStr[i] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; ifplus) &#123;</span><br><span class="line">                    binaryStr[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    ifplus = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (binaryStr[i] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; ifplus) &#123;</span><br><span class="line">                    binaryStr[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">binary</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(binaryStr);</span><br><span class="line">  <span class="keyword">return</span> binary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、二进制补码-十进制整数"><a href="#二、二进制补码-十进制整数" class="headerlink" title="二、二进制补码-&gt;十进制整数"></a>二、二进制补码-&gt;十进制整数</h2><h3 id="错误方法-无法通过最大-最小值测试"><a href="#错误方法-无法通过最大-最小值测试" class="headerlink" title="错误方法-无法通过最大&#x2F;最小值测试"></a>错误方法-无法通过最大&#x2F;最小值测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">binaryToInt</span><span class="params">(String binStr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(binStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>)&#123;<span class="comment">//正数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> temp=Integer.parseInt(String.valueOf(binStr.charAt(i)));</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">32</span>-i;j++)&#123;</span><br><span class="line">                temp*=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           temp/=<span class="number">2</span>;</span><br><span class="line">            num+=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;<span class="comment">//负数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> temp=Integer.parseInt(String.valueOf(binStr.charAt(i)));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">32</span>-i;j++)&#123;</span><br><span class="line">                temp*=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp/=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>) &#123;</span><br><span class="line">                num += temp;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num-=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String numStr=String.valueOf(num);</span><br><span class="line">    <span class="keyword">return</span> numStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-逐位累加（！！从左边开始！！）"><a href="#1-逐位累加（！！从左边开始！！）" class="headerlink" title="1.逐位累加（！！从左边开始！！）"></a>1.逐位累加（！！从左边开始！！）</h3><ul>
<li>逐位累加实现二进制转十进制的过程就是将二进制字符串中的每一位数字（<strong>从左到右</strong>）根据其所在的位置转换为相应的十进制值，并累加到最终结果中。</li>
</ul>
<ol>
<li>从二进制字符串的<strong>左边</strong>开始，对每个字符进行处理。</li>
<li>对每个字符，计算其<strong>对应的二进制值(1&#x2F;0)</strong>，然后将其加到累积结果中。</li>
<li>在处理每个字符时，将<strong>当前的累积值乘以 2</strong>，并<strong>加上当前字符所表示的数字（0 或 1）</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num = num * <span class="number">2</span> + (binStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>这样，最终的结果就是二进制转换成的十进制数。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (binStr.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>) &#123; <span class="comment">// 正数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        num = num * <span class="number">2</span> + (binStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-char转int"><a href="#2-char转int" class="headerlink" title="2. char转int"></a>2. char转int</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num = num * <span class="number">2</span> + (binStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="3-处理负数"><a href="#3-处理负数" class="headerlink" title="3. 处理负数"></a>3. 处理负数</h3><ol>
<li><strong>逐位取反</strong>：将二进制字符串逐位取反。</li>
<li><strong>加一</strong>：对取反后的二进制数加一。</li>
<li>累加计算：从第0位到第31位，逐位计算二进制数对应的十进制值。</li>
<li>取反：将结果取负。</li>
</ol>
<ul>
<li>注意：<strong>二进制负数取反后加一</strong>等价于相当于<strong>二进制负数先减一，再取反</strong></li>
</ul>
<h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol>
<li>正数处理：<ul>
<li>从第0位到第31位，逐位计算二进制数对应的十进制值。</li>
<li>num*2+(dinStr.charAt(i)-‘0’);</li>
</ul>
</li>
<li>负数处理：<ul>
<li>取反：将二进制字符串逐位取反。</li>
<li>加一：对取反后的二进制数加一。</li>
<li>累加计算：从第0位到第31位，逐位计算二进制数对应的十进制值。</li>
<li>取反：将结果取负。</li>
</ul>
</li>
<li>返回结果：<ul>
<li>将计算得到的十进制整数转换为字符串并返回。</li>
</ul>
</li>
</ol>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">binaryToInt</span><span class="params">(String binStr)</span> &#123;</span><br><span class="line">       <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span>(binStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>)&#123;<span class="comment">//正数</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;<span class="comment">//从0或者1开始都行，没影响</span></span><br><span class="line">               num=num*<span class="number">2</span>+(binStr.charAt(i)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;<span class="comment">//负数</span></span><br><span class="line">          <span class="comment">//1. 取反</span></span><br><span class="line">           <span class="type">char</span>[]binstr=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">32</span>];</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">               <span class="keyword">if</span> (binStr.charAt(i)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                   binstr[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   binstr[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//2. 加一</span></span><br><span class="line">           <span class="type">boolean</span> is_plus=<span class="literal">true</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">               <span class="keyword">if</span>(binstr[i]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;is_plus)&#123;</span><br><span class="line">                   binstr[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                   is_plus=<span class="literal">false</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(binstr[i]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;is_plus)&#123;</span><br><span class="line">                   binstr[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//3. 累加计算</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;<span class="comment">//从0或者1开始都行，没影响</span></span><br><span class="line">               num=num*<span class="number">2</span>+(binstr[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//4. 取反</span></span><br><span class="line">           num=-num;</span><br><span class="line">       &#125;</span><br><span class="line">       String numStr=String.valueOf(num);</span><br><span class="line">       <span class="keyword">return</span> numStr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结：二进制补码和十进制整数相互转换："><a href="#总结：二进制补码和十进制整数相互转换：" class="headerlink" title="总结：二进制补码和十进制整数相互转换："></a>总结：二进制补码和十进制整数相互转换：</h2><ol>
<li>负数补码和对应正数补码转换<ul>
<li><strong>负数转补码</strong>：<ol>
<li>将负数的<strong>绝对值转换为二进制</strong>。</li>
<li>对二进制数<em><strong>逐位取反</strong></em>（0变1，1变0）。</li>
<li>对取反后的<strong>二进制数加1</strong>。</li>
</ol>
</li>
<li><strong>补码转负数</strong>：<ol>
<li>对<strong>补码逐位取反</strong>（0变1，1变0）。</li>
<li>对取反后的<strong>二进制数加1</strong>。</li>
<li>将结果int<strong>取负</strong>。</li>
</ol>
</li>
</ul>
</li>
<li>十进制整数转二进制补码：<ul>
<li>正数：<ol>
<li>使用<strong>除2取余法</strong>，从<strong>低位到高位依次填充</strong>二进制位。</li>
<li>符号位为0。</li>
</ol>
</li>
<li>负数：<ol>
<li>将负数的<strong>绝对值</strong>转换为二进制。</li>
<li>对二进制数逐位取反（0变1，1变0）。</li>
<li>对取反后的二进制数加1。</li>
<li>符号位为1。</li>
</ol>
</li>
</ul>
</li>
<li>二进制补码转十进制整数：<ul>
<li>正数：<ul>
<li>从<strong>第0位到第31位（从左开始！！）</strong>，<strong>逐位计算</strong>二进制数对应的十进制值。</li>
</ul>
</li>
<li>负数：<ol>
<li>对二进制数逐位取反（0变1，1变0）。</li>
<li>对取反后的二进制数加1。</li>
<li>从第0位到第31位，逐位计算二进制数对应的十进制值。</li>
<li>将结果取负。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="三、十进制整数的真值转化成NBCD"><a href="#三、十进制整数的真值转化成NBCD" class="headerlink" title="三、十进制整数的真值转化成NBCD"></a>三、十进制整数的真值转化成NBCD</h2><h3 id="1-NBCD"><a href="#1-NBCD" class="headerlink" title="1. NBCD"></a>1. NBCD</h3><ol>
<li>NBCD格式：<ol>
<li>符号位<ul>
<li><strong>正数：1100</strong></li>
<li><strong>负数：1101</strong></li>
</ul>
</li>
<li>每个十进制数字用4位二进制数表示。</li>
<li>确保NBCD表示一定是32位。<ul>
<li>在<strong>符号位和有效位之间</strong>填充<strong>0</strong>!</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="2-将单位十进制数字转化为4位二进制形式"><a href="#2-将单位十进制数字转化为4位二进制形式" class="headerlink" title="2.将单位十进制数字转化为4位二进制形式"></a>2.将单位十进制数字转化为4位二进制形式</h3><ul>
<li>除2取余法<ul>
<li><strong>先得到的余数</strong>作为<strong>低位有效位</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">CharTo4bit</span><span class="params">(Character character)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> character-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="type">char</span>[] stringOf4=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        stringOf4[i] = <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 初始化字符数组为&#x27;0&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//转换为二进制[除二取余法]</span></span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            stringOf4[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(stringOf4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-步骤"><a href="#3-步骤" class="headerlink" title="3. 步骤"></a>3. 步骤</h3><ol>
<li>将字符串转换为<strong>整数</strong>。</li>
<li>初始化一个 StringBuilder 用于构建NBCD字符串。</li>
<li>根据整数的符号设置<strong>符号位</strong>：<ul>
<li>正数：1100</li>
<li>负数：1101</li>
</ul>
</li>
<li>计算需要<strong>填充的零</strong>的数量，以确保NBCD表示是<strong>32位</strong>。</li>
<li>将<strong>每个十进制数字转换为4位二进制形式</strong>，并<strong>添加</strong>到 StringBuilder 中。</li>
<li>返回NBCD字符串。</li>
</ol>
<h3 id="4-【注意】语法"><a href="#4-【注意】语法" class="headerlink" title="4. 【注意】语法"></a>4. 【注意】语法</h3><ol>
<li>return <strong>new String(stringOf4)</strong>;<ul>
<li>适用于将<strong>字符数组char[]转换为字符串</strong>的场景</li>
</ul>
</li>
<li>return <strong>nbcdStr.toString()</strong>;<ul>
<li>适用于将<strong>StringBuilder对象转换为字符串</strong>的场景</li>
</ul>
</li>
</ol>
<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">decimalToNBCD</span><span class="params">(String decimalStr)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">nbcdStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(decimalStr);</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> decimalStr.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">zero_length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        zero_length=<span class="number">28</span>-<span class="number">4</span>*length;</span><br><span class="line">        nbcdStr.append(<span class="number">1100</span>);<span class="comment">//符号位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;zero_length;i++)&#123;<span class="comment">//填充零</span></span><br><span class="line">            nbcdStr.append(<span class="number">0000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            nbcdStr.append(CharTo4bit(decimalStr.charAt(i)));<span class="comment">//转换每个十进制数字,并添加到 StringBuilder 中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        zero_length=<span class="number">28</span>-<span class="number">4</span>*(length-<span class="number">1</span>);</span><br><span class="line">        nbcdStr.append(<span class="number">1101</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;zero_length;i++)&#123;</span><br><span class="line">            nbcdStr.append(<span class="number">0000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;<span class="comment">//把负号跳过</span></span><br><span class="line">            nbcdStr.append(CharTo4bit(decimalStr.charAt(i)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nbcdStr.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、-NBCD（符号位用4位表示）转化成十进制整数的真值"><a href="#四、-NBCD（符号位用4位表示）转化成十进制整数的真值" class="headerlink" title="四、 NBCD（符号位用4位表示）转化成十进制整数的真值"></a>四、 NBCD（符号位用4位表示）转化成十进制整数的真值</h2><h3 id="1-4位二进制-转-1位十进制：bit4ToChar"><a href="#1-4位二进制-转-1位十进制：bit4ToChar" class="headerlink" title="1. 4位二进制 转 1位十进制：bit4ToChar"></a>1. 4位二进制 转 1位十进制：bit4ToChar</h3><ul>
<li>从左到右，累加</li>
<li>num&#x3D;num*2+(<strong>bit4.charAt(i)-‘0’</strong>);</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">bit4ToChar</span><span class="params">(String bit4)</span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        num=num*<span class="number">2</span>+(bit4.charAt(i)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>初始化一个 StringBuilder 用于构建十进制字符串。</li>
<li>从第4位开始，<strong>每4位表示一个十进制数字</strong>，使用 <strong>bit4ToChar</strong> 方法将其转换为<strong>对应的十进制字符</strong>，并添加到 StringBuilder 中。</li>
<li><strong>去除前面多余的0</strong>（<strong>保留至少一位，以满足数为0</strong>）。</li>
<li>将 StringBuilder 转换为字符串，并解析为整数。</li>
<li>根据符号位确定结果<strong>是否为负数</strong>。</li>
<li>返回十进制字符串。</li>
</ol>
<h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">NBCDToDecimal</span><span class="params">(String NBCDStr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    StringBuilder num_sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();   <span class="comment">//初始化 StringBuilder</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>;i&lt;<span class="number">32</span>;i+=<span class="number">4</span>)&#123;       <span class="comment">//转换每个4位二进制数字</span></span><br><span class="line">        num_sb.append(bit4ToChar(NBCDStr.substring(i,i+<span class="number">4</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去除前面多余的0（留一位，以满足数为0）</span></span><br><span class="line">    <span class="type">int</span> length=num_sb.length();</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num_sb.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>&amp;&amp;length!=<span class="number">1</span>)&#123;       <span class="comment">//去除前面多余的0(留1位)</span></span><br><span class="line">        num_sb.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">        length=num_sb.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">demical</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(num_sb);</span><br><span class="line">    num=Integer.parseInt(demical);      <span class="comment">//解析为整数</span></span><br><span class="line">    <span class="keyword">if</span> (NBCDStr.substring(<span class="number">0</span>, <span class="number">4</span>).equals(<span class="string">&quot;1101&quot;</span>))&#123;    <span class="comment">//负数判断</span></span><br><span class="line">        num=-num;</span><br><span class="line">    &#125;</span><br><span class="line">    demical=String.valueOf(num);        <span class="comment">//转为字符串</span></span><br><span class="line">    <span class="keyword">return</span> demical;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将4位二进制字符串转换为对应的十进制字符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">bit4ToChar</span><span class="params">(String binStr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        num = num * <span class="number">2</span> + (binStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>) (num + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、将浮点数真值转化成32位单精度浮点数表示"><a href="#五、将浮点数真值转化成32位单精度浮点数表示" class="headerlink" title="五、将浮点数真值转化成32位单精度浮点数表示"></a>五、将浮点数真值转化成32位单精度浮点数表示</h2><h3 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h3><ul>
<li>如果<strong>8位指数位全为0</strong>, 就代表当前数是个<strong>非规格数</strong>. 或者说, 形如 * 00000000 *********************** 格式的数就是非规格数.<ul>
<li>用于表示0, 以及非常靠近0的数, 比如1E-38.</li>
<li><strong>非规格数的实际指数固定为-126</strong></li>
</ul>
</li>
<li>如果<strong>8位指数位全为1</strong>, 就代表当前数是个<strong>特殊数</strong>. 或者说, 形如 * 11111111 *********************** 格式的数就是特殊数.<ul>
<li><strong>无穷大</strong>和<strong>NaN</strong></li>
</ul>
</li>
</ul>
<h3 id="1-0"><a href="#1-0" class="headerlink" title="1. 0"></a>1. 0</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (num == <span class="number">0.0f</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;00000000000000000000000000000000&quot;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="2-NaN"><a href="#2-NaN" class="headerlink" title="2.NaN"></a>2.NaN</h3><ol>
<li>符号位：0或1</li>
<li>指数位：<strong>11111111</strong></li>
<li>尾数位：任意非零值（通常为<strong>10000000000000000000000</strong>）</li>
</ol>
<ul>
<li>一般表示用：<strong>0 11111111 10000000000000000000000</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Float.isNaN(num)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;01111111110000000000000000000000&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-无穷大"><a href="#3-无穷大" class="headerlink" title="3. 无穷大"></a>3. 无穷大</h3><ol>
<li>8位指数位全为1：<strong>11111111</strong></li>
<li>23位尾数位全为0：<strong>00000000000000000000000</strong></li>
</ol>
<ul>
<li>正无穷：01111111100000000000000000000000</li>
<li>负无穷：11111111100000000000000000000000</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (num == Float.POSITIVE_INFINITY)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;+Inf&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&lt;=Float.NEGATIVE_INFINITY)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;-Inf&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-非规格数"><a href="#4-非规格数" class="headerlink" title="4. 非规格数"></a>4. 非规格数</h3><h3 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h3><ol>
<li>特殊情况处理<ol>
<li>零</li>
<li>正负无穷：num &#x3D;&#x3D; <strong>Float.POSITIVE_INFINITY</strong></li>
<li>NaN: <strong>if (Float.isNaN(num))</strong></li>
</ol>
</li>
<li>正常情况处理<ol>
<li>正负</li>
<li>调整尾数到1.f~2.f范围：（指数初始为0）<ul>
<li>尾数偏大时，除以2，指数加1。<code>while (num &gt;= 2.0f)</code></li>
<li>尾数偏小时，乘以2，指数减1。<code>while (num &lt; 1.0f &amp;&amp; exponent &gt; -126)</code><ul>
<li>如果指数减小到了<code>-126</code>，则<strong>非规格化数</strong>！</li>
</ul>
</li>
</ul>
</li>
<li>规格化判断<ul>
<li>非规格化数：如果<strong>实际指数为-126，则指数部分全为0</strong>，<strong>尾数不变</strong>（已经小于1.0f了）。</li>
<li>规格化数：尾数<strong>减去1.0f</strong>，指数<strong>加偏移量127</strong>。</li>
</ul>
</li>
<li>构建IEEE 754二进制字符串：<ul>
<li>符号位：1位</li>
<li>指数位：8位——<strong>除二取余法</strong></li>
<li><strong>尾数位</strong>：23位——<strong>乘二减一法</strong>：<ul>
<li>如果乘二之后大于1.0f，则1；否则0。</li>
<li>先出现的在左！</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">floatToBinary</span><span class="params">(String floatStr)</span> &#123;</span><br><span class="line">       <span class="type">float</span> <span class="variable">num</span> <span class="operator">=</span> Float.parseFloat(floatStr);</span><br><span class="line">       <span class="comment">//1、0</span></span><br><span class="line">       <span class="keyword">if</span>(num==<span class="number">0</span>)&#123;</span><br><span class="line">           String zeroStr=<span class="string">&quot;00000000000000000000000000000000&quot;</span>;</span><br><span class="line">           <span class="keyword">return</span> zeroStr;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2.+Inf和-Inf（正负无穷）</span></span><br><span class="line">       <span class="keyword">if</span> (num == Float.POSITIVE_INFINITY)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;+Inf&quot;</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&lt;=Float.NEGATIVE_INFINITY)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;-Inf&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3.NaN</span></span><br><span class="line">       <span class="keyword">if</span>(Float.isNaN(num))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;01111111110000000000000000000000&quot;</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Float.isNaN(-num))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;11111111110000000000000000000000&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//4. 正常情况</span></span><br><span class="line">       <span class="comment">//4.1判断正负</span></span><br><span class="line">       <span class="type">boolean</span> is_neg=<span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">if</span>(num&lt;<span class="number">0</span>)&#123;</span><br><span class="line">           is_neg=<span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> exponent=<span class="number">0</span>;<span class="comment">//指数</span></span><br><span class="line">       <span class="comment">//尾数</span></span><br><span class="line">       <span class="type">int</span> offset=<span class="number">127</span>;;<span class="comment">//偏移量</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//4.2 调整尾数到1.f~2.f范围</span></span><br><span class="line">       <span class="keyword">if</span>(num&lt;<span class="number">0</span>)&#123;</span><br><span class="line">           num=-num;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (num&gt;=<span class="number">2.0f</span>)&#123;   <span class="comment">//尾数偏大</span></span><br><span class="line">           num/=<span class="number">2.0f</span>;</span><br><span class="line">           exponent++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (num&lt;<span class="number">1.0f</span>&amp;&amp;exponent&gt;-<span class="number">126</span>)&#123;    <span class="comment">//尾数偏小</span></span><br><span class="line">           num*=<span class="number">2.0f</span>;</span><br><span class="line">           exponent--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//4.3 规格化判断</span></span><br><span class="line">       <span class="keyword">if</span> (exponent &lt;=-<span class="number">126</span>) &#123;</span><br><span class="line">           exponent = <span class="number">0</span>; <span class="comment">// 非规格化数，指数部分全为0(实际指数固定为-126)</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           num -= <span class="number">1.0f</span>; <span class="comment">// 规格化数，尾数减去1</span></span><br><span class="line">           exponent += offset; <span class="comment">// 加偏移量</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//4.4 化为IEEE</span></span><br><span class="line">       StringBuilder binFloat=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">       <span class="comment">//符号位</span></span><br><span class="line">       <span class="keyword">if</span> (is_neg)&#123;</span><br><span class="line">           binFloat.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           binFloat.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//指数位</span></span><br><span class="line">       <span class="type">char</span>[] exp = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">8</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">7</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">           <span class="keyword">if</span>(exponent%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">               exp[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               exp[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           exponent/=<span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//尾数位</span></span><br><span class="line">       <span class="type">char</span>[]wei=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">23</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">23</span>;i++)&#123;</span><br><span class="line">           num*=<span class="number">2.0f</span>;</span><br><span class="line">           <span class="keyword">if</span>(num&gt;=<span class="number">1.0f</span>)&#123;</span><br><span class="line">               wei[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">               num-=<span class="number">1.0f</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               wei[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">expStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(exp);</span><br><span class="line">       String weiStr=<span class="keyword">new</span> <span class="title class_">String</span>(wei);</span><br><span class="line">       binFloat.append(expStr);</span><br><span class="line">       binFloat.append(weiStr);</span><br><span class="line">       <span class="keyword">return</span> binFloat.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、32位单精度浮点数表示转化成浮点数真值"><a href="#六、32位单精度浮点数表示转化成浮点数真值" class="headerlink" title="六、32位单精度浮点数表示转化成浮点数真值"></a>六、32位单精度浮点数表示转化成浮点数真值</h2><h3 id="1-特殊情况"><a href="#1-特殊情况" class="headerlink" title="1. 特殊情况"></a>1. 特殊情况</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 0</span></span><br><span class="line">        <span class="keyword">if</span>(binStr==<span class="string">&quot;00000000000000000000000000000000&quot;</span>)&#123;</span><br><span class="line">            <span class="type">Float</span> <span class="variable">zero</span> <span class="operator">=</span> <span class="number">0.0f</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(zero);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. NaN</span></span><br><span class="line">        <span class="keyword">if</span>(binStr==<span class="string">&quot;01111111110000000000000000000000&quot;</span>)&#123;</span><br><span class="line">           <span class="type">Float</span> <span class="variable">nan</span> <span class="operator">=</span> Float.NaN;</span><br><span class="line">           <span class="keyword">return</span> String.valueOf(nan);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 正负无穷</span></span><br><span class="line">        <span class="keyword">if</span>(binStr==<span class="string">&quot;01111111100000000000000000000000&quot;</span>)&#123;</span><br><span class="line">           Float pos_inf=Float.POSITIVE_INFINITY;</span><br><span class="line">           <span class="keyword">return</span> String.valueOf(pos_inf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(binStr==<span class="string">&quot;11111111100000000000000000000000&quot;</span>)&#123;</span><br><span class="line">            Float neg_inf=Float.NEGATIVE_INFINITY;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(neg_inf);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-正常情况（规格化数-非规格化数）"><a href="#2-正常情况（规格化数-非规格化数）" class="headerlink" title="2. 正常情况（规格化数+非规格化数）"></a>2. 正常情况（规格化数+非规格化数）</h3><ol>
<li>符号位</li>
<li>指数位<ul>
<li>提取指数位的8位二进制数，并转换为整数。</li>
<li>对于<strong>规格化数</strong>，<strong>减去偏移量127</strong>。</li>
<li>对于<strong>非规格化数（指数位等于0）</strong>，<strong>实际指数为-126</strong>。</li>
</ul>
</li>
<li>尾数位：<ul>
<li>提取尾数位的23位二进制数，并转换为浮点数。</li>
<li>对于规格化数，尾数部分隐含一个1。<strong>规格化数，加1.0f</strong></li>
</ul>
</li>
<li>计算浮点数值：<ul>
<li>根据指数调整尾数的值&#x2F;直接算（注意<strong>double和float的转换</strong>）<ul>
<li><em><em>float num&#x3D;weishu</em>(float)Math.pow(2,exponent);</em>*</li>
</ul>
</li>
<li>如果符号位为1，则结果为负数。</li>
</ul>
</li>
</ol>
<h3 id="完整代码-4"><a href="#完整代码-4" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">binaryToFloat</span><span class="params">(String binStr)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 0</span></span><br><span class="line">        <span class="keyword">if</span>(binStr==<span class="string">&quot;00000000000000000000000000000000&quot;</span>)&#123;</span><br><span class="line">            <span class="type">Float</span> <span class="variable">zero</span> <span class="operator">=</span> <span class="number">0.0f</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(zero);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. NaN</span></span><br><span class="line">        <span class="keyword">if</span>(binStr==<span class="string">&quot;01111111110000000000000000000000&quot;</span>)&#123;</span><br><span class="line">           <span class="type">Float</span> <span class="variable">nan</span> <span class="operator">=</span> Float.NaN;</span><br><span class="line">           <span class="keyword">return</span> String.valueOf(nan);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 正负无穷</span></span><br><span class="line">        <span class="keyword">if</span>(binStr==<span class="string">&quot;01111111100000000000000000000000&quot;</span>)&#123;</span><br><span class="line">           Float pos_inf=Float.POSITIVE_INFINITY;</span><br><span class="line">           <span class="keyword">return</span> String.valueOf(pos_inf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(binStr==<span class="string">&quot;11111111100000000000000000000000&quot;</span>)&#123;</span><br><span class="line">            Float neg_inf=Float.NEGATIVE_INFINITY;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(neg_inf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4. 正常情况</span></span><br><span class="line">        <span class="comment">//4.1 正负</span></span><br><span class="line">        <span class="type">boolean</span> is_neg=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(binStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            is_neg=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.2指数</span></span><br><span class="line">        <span class="type">int</span> exponent=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">            exponent=exponent*<span class="number">2</span>+(binStr.charAt(i+<span class="number">1</span>)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(exponent!=<span class="number">0</span>)&#123;</span><br><span class="line">            exponent-=<span class="number">127</span>;<span class="comment">//规格数</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            exponent=-<span class="number">126</span>;<span class="comment">//非规格数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.3 尾数</span></span><br><span class="line">        <span class="type">float</span> weishu=<span class="number">0.0f</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">Add</span> <span class="operator">=</span> <span class="number">0.5f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">9</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(binStr.charAt(i)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                weishu+=Add;</span><br><span class="line">            &#125;</span><br><span class="line">            Add/=<span class="number">2.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exponent!=-<span class="number">126</span>)&#123;<span class="comment">//规格化数，加1.0f</span></span><br><span class="line">            weishu+=<span class="number">1.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.计算</span></span><br><span class="line">        <span class="keyword">while</span> (exponent&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            weishu*=<span class="number">2.0f</span>;</span><br><span class="line">            exponent--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (exponent&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            weishu/=<span class="number">2.0f</span>;</span><br><span class="line">            exponent++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(is_neg)&#123;</span><br><span class="line">            weishu=-weishu;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//法2：直接算</span></span><br><span class="line"><span class="comment">//        float num=weishu*(float)Math.pow(2,exponent);</span></span><br><span class="line"><span class="comment">//        if (is_neg)&#123;</span></span><br><span class="line"><span class="comment">//            num=-num;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">return</span> String.valueOf(weishu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>三、OSI第二层：数据链路层</title>
    <url>/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<h1 id="Layer2-Data-Link-Layer"><a href="#Layer2-Data-Link-Layer" class="headerlink" title="Layer2:Data Link Layer"></a>Layer2:Data Link Layer</h1><ul>
<li>Overview</li>
<li>Ethernet and CSMA&#x2F;CD<ul>
<li>LLC and MAC Sub-layers</li>
<li>Media Access Control in MAC Sub-layer</li>
</ul>
</li>
<li>Wireless LAN and CSMA&#x2F;CA</li>
<li>Layer 2 Devices</li>
</ul>
<h1 id="一、数据链路层-Overview"><a href="#一、数据链路层-Overview" class="headerlink" title="一、数据链路层 Overview"></a>一、数据链路层 Overview</h1><ul>
<li>数据链路层使用的信道：<ul>
<li>点对点信道：一对一</li>
<li>广播信道：一对多</li>
</ul>
</li>
<li>本章研究：局域网的数据链路层的技术标准</li>
<li>主要是以太网的介质和无线网的介质两大类。<br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="1-物理层和数据链路层的区别"><a href="#1-物理层和数据链路层的区别" class="headerlink" title="1. 物理层和数据链路层的区别"></a>1. 物理层和数据链路层的区别</h2><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-8.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>第一层<ul>
<li>无法与上层通信    </li>
<li>无法确定哪台主机将会传输或接受二进制数据    </li>
<li>无法命名或标识主机    </li>
<li>仅仅能描述比特流</li>
</ul>
</li>
<li>第二层<ul>
<li>通过LLC与上层通信</li>
<li>通过MAC确定</li>
<li>通过寻址或命名过程来实现</li>
<li>通过帧来组织&#x2F;分组比特</li>
</ul>
</li>
</ul>
<h2 id="2-数据链路层-Data-Link-Layer"><a href="#2-数据链路层-Data-Link-Layer" class="headerlink" title="2. 数据链路层 Data Link Layer"></a>2. 数据链路层 Data Link Layer</h2><ol>
<li>问题：如何在不稳定(instable)的链路上正确传输数据？</li>
<li>数据链路层提供<ul>
<li>网络介质访问:</li>
<li>跨媒体物理传输(transmission)</li>
</ul>
</li>
<li>第二层协议明确了<ul>
<li>在链路上<strong>交换的数据格式</strong></li>
<li>链路上的<strong>两个节点的行为</strong></li>
</ul>
</li>
<li>在数据链路层，<em>过程就是协议</em>。</li>
<li>在两端<strong>校验</strong>，帧是否正确，如果正确则交付第三层，否则进行相应的处理</li>
</ol>
<h2 id="3-局域网和数据链路"><a href="#3-局域网和数据链路" class="headerlink" title="3. 局域网和数据链路"></a>3. 局域网和数据链路</h2><ol>
<li>主要工作<ul>
<li><strong>错误识别(notification)</strong></li>
<li><strong>网络拓扑(Network topology)</strong></li>
<li><strong>流控制(Flow control)</strong></li>
</ul>
</li>
<li>第一层和第二层的不同:<ul>
<li>第一层不可以<strong>访问更高层</strong>(upper-level layers)，而第二层是通过<strong>逻辑链路LLC</strong>(Logical Link Control)访问更高层</li>
<li>第1层<strong>无法决定哪个主机</strong>将发送(transmit)或接收(receive)来自组的二进制数据；第2层使用<strong>媒体访问控制MAC</strong>（Media Access Control）做到这一点，共用总线链路</li>
<li>第1层无法命名或识别计算机；<strong>第2层使用寻址(或命名)过程</strong>，以太网场景下</li>
<li>第1层只能描述比特流；第2层使用**成帧（framing）**对比特进行组织或分组。</li>
</ul>
</li>
</ol>
<h2 id="4-第二层提供的服务"><a href="#4-第二层提供的服务" class="headerlink" title="4. 第二层提供的服务"></a>4. 第二层提供的服务</h2><ol>
<li>提供给<strong>网络层</strong>的三层服务<ol>
<li>(最弱，最不靠谱的)<strong>没有确认(acknowledgement)的无连接(Connectionless)服务</strong><ul>
<li>发送取出就行，不用等收到确认</li>
<li><strong>可靠(Reliable)的链接</strong>(上层以确保数据正确性)</li>
<li><strong>实时</strong>任务，比较高效</li>
<li>适用于大多数<strong>局域网</strong></li>
</ul>
</li>
<li><strong>带有确认的无连接服务</strong>：<ul>
<li><strong>不可靠</strong>的链接，例如<strong>无线网络</strong>：需要保证一定的通信质量(比如无线网络的传输)，同时会损失一定的性能。</li>
</ul>
</li>
<li><strong>带有确认的连接服务</strong><ul>
<li>比如蓝牙:需要先确定绑定关系才能进行通信</li>
<li>手机和手机之间的蓝牙连接需要确定一些信息</li>
</ul>
</li>
</ol>
</li>
<li>三种服务的连接的不同和区别:<ul>
<li><strong>无线连接</strong>有<strong>确认</strong>的过程，<strong>有线连接没有</strong></li>
<li><strong>网线连接</strong>:我们通信的对象是<strong>路由器</strong>，由路由器进行转发</li>
<li>PPPoP是<strong>路由器和远端</strong>的服务器的连接</li>
<li>有线无线都接给路由器，都需要连接，但是无线网相对有线网需要确认(包确认)</li>
</ul>
</li>
</ol>
<h2 id="5-常见的局域网的介质访问控制-Media-Access-Control-in-common-LANs"><a href="#5-常见的局域网的介质访问控制-Media-Access-Control-in-common-LANs" class="headerlink" title="5. 常见的局域网的介质访问控制(Media Access Control in common LANs)"></a>5. 常见的局域网的介质访问控制(Media Access Control in common LANs)</h2><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-9.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>以太网(Ethernet):<ul>
<li>逻辑：<strong>总线拓扑</strong>(信息流在线性总线上)</li>
<li>物理：星形或扩展星形(连线为星形)</li>
</ul>
</li>
<li>令牌环(Token Ring):<ul>
<li>逻辑：<strong>环拓扑</strong>(信息流在一个环中)</li>
<li>物理：星形拓扑(以星形连接)</li>
<li>使用令牌传递机制来控制网络访问</li>
</ul>
</li>
<li>光纤分布式数据接口(FDDI, Fiber Distributed Data Interface):<ul>
<li>逻辑：<strong>环拓扑</strong>(信息流在一个环中)</li>
<li>物理：双环拓扑(作为双环连接)</li>
<li>光纤作为传输介质，曾经很常用，后来被以太网有线接入逐渐替代</li>
</ul>
</li>
</ol>
<h2 id="6-介质访问控制方法-Access-Methods-for-Media-Access-Control"><a href="#6-介质访问控制方法-Access-Methods-for-Media-Access-Control" class="headerlink" title="6. 介质访问控制方法 Access Methods for Media-Access Control"></a>6. 介质访问控制方法 Access Methods for Media-Access Control</h2><ol>
<li><strong>确定性轮流 Deterministic</strong> —— taking turns<ul>
<li>Token Ring 和 FDDI(Fiber Distributed Data Interface)</li>
</ul>
</li>
<li><strong>争用式 Non-deterministic (probabilistic)</strong> —— 先到先得 first come, first sesrved<ul>
<li>Ethernet&#x2F;802.3</li>
</ul>
</li>
</ol>
<h3 id="6-1-确定性轮流-Deterministic-MAC-Protocols"><a href="#6-1-确定性轮流-Deterministic-MAC-Protocols" class="headerlink" title="6.1 确定性轮流 Deterministic MAC Protocols"></a>6.1 确定性轮流 Deterministic MAC Protocols</h3><ol>
<li>一个特殊的<strong>数据令牌token在环中循环(circulates)</strong>。</li>
<li>当主机host收到令牌时，它可以传输数据而不是令牌。这称为“<strong>夺取(seizing)令牌</strong>”。</li>
<li>当<strong>传输的帧回到发送者</strong>时，站点会<strong>传输一个新的令牌</strong>；<ul>
<li>帧会从环中移除或剥离。(stripped)。</li>
</ul>
</li>
</ol>
<h3 id="6-2-非确定性MAC协议-Non-Deterministic-MAC-Protocols"><a href="#6-2-非确定性MAC协议-Non-Deterministic-MAC-Protocols" class="headerlink" title="6.2 非确定性MAC协议 Non-Deterministic MAC Protocols"></a>6.2 非确定性MAC协议 Non-Deterministic MAC Protocols</h3><ul>
<li>【重要！】此MAC协议称为<strong>载波监听多路访问&#x2F;碰撞检测(CSMA&#x2F;CD)</strong>，即<strong>带冲突检测的载波侦听多路访问</strong><ul>
<li>Carrier Sense Multiple Access with Collision Detection</li>
</ul>
</li>
<li>为了使用这种共享介质(shared-medium)技术，以太网允许网络设备为传输权进行仲裁(arbitrate)。</li>
</ul>
<h2 id="7-局域网数据传输-Transmitison-方式-三种"><a href="#7-局域网数据传输-Transmitison-方式-三种" class="headerlink" title="7. 局域网数据传输(Transmitison)方式: 三种"></a>7. 局域网数据传输(Transmitison)方式: 三种</h2><ol>
<li><strong>单播(unicast)</strong><ul>
<li>将<strong>单个数据包</strong>从<strong>源</strong>发送到<strong>网络上的单个目标</strong></li>
</ul>
</li>
<li><strong>多播(multicast)</strong><ul>
<li>由发送到网络上特定节点子集的单个数据包组成，这些节点都有同样的进程进行响应</li>
<li>发送<strong>单个数据包</strong>到<strong>网络上的特定子集节点</strong>。</li>
</ul>
</li>
<li><strong>广播(broadcast)</strong><ul>
<li>由单个数据包组成，该数据包传输到网络上的所有节点。(广播的目的地址是0x11111111)</li>
<li>发送<strong>单个数据包</strong>到<strong>网络上的所有节点</strong></li>
</ul>
</li>
</ol>
<hr>
<h1 id="二、-以太网-和-带冲突检测的载波侦听多路访问-Ethernet-and-CSMA-CD"><a href="#二、-以太网-和-带冲突检测的载波侦听多路访问-Ethernet-and-CSMA-CD" class="headerlink" title="二、 以太网 和 带冲突检测的载波侦听多路访问 Ethernet and CSMA&#x2F;CD"></a>二、 以太网 和 带冲突检测的载波侦听多路访问 Ethernet and CSMA&#x2F;CD</h1><h2 id="（一）逻辑链路和介质访问控制子层-LLC-and-MAC-Sub-layers"><a href="#（一）逻辑链路和介质访问控制子层-LLC-and-MAC-Sub-layers" class="headerlink" title="（一）逻辑链路和介质访问控制子层 LLC and MAC Sub-layers"></a>（一）逻辑链路和介质访问控制子层 LLC and MAC Sub-layers</h2><ul>
<li>(Logical Link Control)(Media Access Control)</li>
</ul>
<ol>
<li>无缘电缆的方式传播电波:以太网</li>
<li>帧传播速度提高了</li>
<li>帧的标准没有改变</li>
</ol>
<h3 id="1-局域网标准"><a href="#1-局域网标准" class="headerlink" title="1. 局域网标准"></a>1. 局域网标准</h3><ul>
<li>定义<strong>物理媒体</strong>（如双绞线、光纤）和用于将设备连接到媒体的<strong>连接器</strong></li>
<li>定义<strong>设备在数据链路层的通信方式</strong></li>
<li>数据链路层定义了如何<strong>在物理介质上传输数据</strong>。</li>
<li>数据链路层还定义了<strong>如何封装(encapsulate)特定协议的流量(traffic)</strong>，以使去往不同上层协议的流量在到达堆栈时可以使用相同的通道进行传输。<br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-10.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>IEEE 802.2 对应 LLC，以太网则覆盖物理层和链路层</li>
</ul>
<ol>
<li><strong>IEEE 将数据链路层分为两部分</strong>：<ul>
<li><strong>媒体访问控制（MAC）</strong>（转换为媒体）</li>
<li><strong>逻辑链路控制（LLC）</strong>（过渡到网络层）</li>
</ul>
</li>
<li>乍一看，IEEE 标准似乎以两种方式违反了 OSI 模型。<ol>
<li><strong>定义了自己的层（LLC）</strong>：<ul>
<li>IEEE标准定义了逻辑链路控制（LLC）层，包括其接口等，这似乎与OSI模型的层次结构不一致。</li>
</ul>
</li>
<li><strong>MAC层标准跨越了第2层和第1层的接口</strong>：<ul>
<li>IEEE 802.3（以太网）和802.5（令牌环）标准似乎跨越了数据链路层（第2层）和物理层（第1层）的接口。</li>
</ul>
</li>
</ol>
</li>
<li>但是，802.3 和 802.5 定义了用于构建特定技术的命名，框架和媒体访问控制规则，都规范了对应的方案，不同方案不同解决标准</li>
</ol>
<h3 id="2-MAC-LLC"><a href="#2-MAC-LLC" class="headerlink" title="2. MAC &amp; LLC"></a>2. MAC &amp; LLC</h3><ul>
<li>MAC子层负责数据链路层的 <strong>物理传输</strong> 和 <strong>访问控制</strong>，其主要作用是确保数据能够有效地从源设备传送到目标设备。</li>
</ul>
<ol>
<li>MAC子层(802.3)<ul>
<li>定义如何在<strong>物理线路</strong>上<strong>传输帧(frames)</strong></li>
<li>处理<strong>物理寻址</strong><ul>
<li>在MAC子层中，设备是通过 MAC地址 来唯一标识的，MAC地址是硬件设备的唯一标识符，每个网络接口控制器（NIC）都有一个固定的MAC地址。当数据帧从一个设备发送到另一个设备时，MAC子层根据目标设备的MAC地址进行物理寻址。</li>
</ul>
</li>
<li><strong>定义网络拓扑</strong></li>
<li><strong>定义线路规则(discipline)</strong></li>
</ul>
</li>
</ol>
<ul>
<li>LLC子层则位于MAC子层之上，主要负责对数据的逻辑控制与协议管理</li>
</ul>
<ol start="2">
<li>LLC 子层(802.2)<ul>
<li><strong>为不同的上层协议提供逻辑上的标识</strong>，然后将其<strong>封装encapsulates</strong>，兼容不同介质的访问<ul>
<li>LLC会在数据帧中添加适当的标识符，使得上层协议能够知道数据的类型。</li>
</ul>
</li>
<li>使用SAP（Service Access Point）标识符用于标识数据包的接收方。<ul>
<li>它帮助MAC层识别数据包的目的地协议，指示它应该交给哪个上层协议进行处理。</li>
</ul>
</li>
<li>LLC帧的类型取决于上层协议期望的标识符，对于上层服务进行支持</li>
<li>LLC已经比较规范了，后来有的厂商已经放弃继续做</li>
</ul>
</li>
</ol>
<h2 id="（一-1）Media-Access-Control-Sublayer-介质访问控制子层"><a href="#（一-1）Media-Access-Control-Sublayer-介质访问控制子层" class="headerlink" title="（一.1）Media Access Control Sublayer 介质访问控制子层"></a>（一.1）Media Access Control Sublayer 介质访问控制子层</h2><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-1.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>以字节为单位进行<strong>帧结构描述</strong><ul>
<li>确保数据能够正确封装和解封装。</li>
</ul>
</li>
<li>有802.3的规范和以太网的规范</li>
<li>MAC 介质访问控制子层的帧结构<ul>
<li>控制多个设备如何共享同一物理介质，避免冲突和碰撞。</li>
</ul>
</li>
<li>物理地址寻址：<ul>
<li>使用MAC地址（物理地址）来唯一标识网络设备，确保数据帧能够正确传输到目标设备。</li>
</ul>
</li>
</ul>
<h3 id="1-前导码Preamble（8字节）"><a href="#1-前导码Preamble（8字节）" class="headerlink" title="1. 前导码Preamble（8字节）"></a>1. 前导码Preamble（8字节）</h3><ol>
<li>格式：从1和0的交替(alternating)模式开始，称为前同步码(preamble)。<ul>
<li><strong>告诉接收方，要来数据了</strong>，因为不是预约发数据的模式，这个码就是为了保证对方有相应准备时间，</li>
<li><strong>前面7个字节是0x10101010</strong>，用于进行<strong>时钟同步</strong></li>
<li>Start Frame Delimiter (SFD)（前导码）：<strong>最后一个字节是0x10101011</strong>，表示帧的开始，并且为接收方提供时钟同步的最后信号。</li>
</ul>
</li>
<li>作用：<ul>
<li>使用曼彻斯特编码的方案，无传输的时候是0电平的</li>
<li>前同步码告诉接收站一帧即将到来。</li>
</ul>
</li>
</ol>
<h3 id="2-目标和源物理地址字段-Dest-add-和-Source-add-（6字节-6字节）"><a href="#2-目标和源物理地址字段-Dest-add-和-Source-add-（6字节-6字节）" class="headerlink" title="2. 目标和源物理地址字段 Dest.add. 和 Source add.（6字节+6字节）"></a>2. 目标和源物理地址字段 Dest.add. 和 Source add.（6字节+6字节）</h3><ol>
<li>目的地址：单播地址，组播地址或广播地址。<ul>
<li>用于标识<strong>接收数据的设备的MAC地址</strong></li>
</ul>
</li>
<li>源地址：始终是<strong>单播地址</strong>。<ul>
<li>用于标识<strong>发送数据的设备的MAC地址</strong>。</li>
</ul>
</li>
</ol>
<ul>
<li>MAC地址：<strong>6个字节目的地址(Dest.add) 6个字节源地址(Source.add.)</strong>，和第三层第四层报文有差别</li>
<li><strong>先看目的地址</strong>的好处:交换机等看到目的地址就可以进行判断，<code>提高效率</code></li>
</ul>
<h3 id="3-长度字段Length（2字节）"><a href="#3-长度字段Length（2字节）" class="headerlink" title="3. 长度字段Length（2字节）"></a>3. 长度字段Length（2字节）</h3><ul>
<li>长度字段指示<strong>在该字段之后</strong>且<strong>在帧检查序列字段(FCS)之前</strong>的<strong>数据字节数</strong>。</li>
<li>确保接收方知道<strong>数据字段的长度</strong>，从而能够正确地解析和处理数据。</li>
</ul>
<h3 id="4-数据字段Data（字节长度可变）"><a href="#4-数据字段Data（字节长度可变）" class="headerlink" title="4. 数据字段Data（字节长度可变）"></a>4. 数据字段Data（字节长度可变）</h3><ul>
<li>数据字段<strong>包含要发送的信息</strong>。</li>
<li>若数据小于46字节，必须通过 填充 零来满足最小长度要求，确保帧的大小达到64字节。</li>
<li>以太网帧头部的前8个字节（如MAC地址、类型字段等）不算作数据字段内容。</li>
<li>发送多个64字节大小的帧可以确保链路带宽的有效利用，尤其在100M带宽的链路上，发送这些帧需要512微秒，占据了完整的传输带宽。</li>
</ul>
<h3 id="5-FCS字段（4个字节）"><a href="#5-FCS字段（4个字节）" class="headerlink" title="5. FCS字段（4个字节）"></a>5. FCS字段（4个字节）</h3><ul>
<li><strong>FCS（Frame Check Sequence，帧检验序列）</strong></li>
<li>FCS字段(四个字节)包含一个<strong>循环冗余校验值(CRC，cyclic redundancy check)</strong><ul>
<li>用于检测<strong>数据帧在传输过程中是否发生了错误</strong></li>
</ul>
<ol>
<li>发送设备生成CRC。</li>
<li>接收设备重新计算CRC，以检查在传输过程中帧是否发生了损坏。</li>
</ol>
</li>
</ul>
<h2 id="（一-2）LLC-逻辑链路控制子层"><a href="#（一-2）LLC-逻辑链路控制子层" class="headerlink" title="（一.2）LLC 逻辑链路控制子层"></a>（一.2）LLC 逻辑链路控制子层</h2><ul>
<li><strong>通信管理</strong>：逻辑链路控制（LLC）子层<strong>管理设备之间在单一链路上的通信</strong>。</li>
<li><strong>支持连接和无连接服务</strong>：<ul>
<li>无连接服务：类似于不需要建立正式连接的通信方式（例如UDP协议）。数据直接被发送，没有需要额外的握手或确认过程。</li>
<li>面向连接的服务：类似于需要事先建立连接的通信方式（例如TCP协议）。在数据传输前，设备需要进行连接建立、数据确认等操作。</li>
</ul>
</li>
<li>LLC子层允许数据链路层的一部分独立于现有技术进行工作。<ul>
<li>单个LLC子层可以与不同的MAC子层兼容。</li>
</ul>
</li>
<li>LLC子层的位置：位于MAC之上<ul>
<li>MAC层与物理层交互, LLC层与网络层交互</li>
</ul>
</li>
</ul>
<h3 id="1-LLC子层：封装"><a href="#1-LLC子层：封装" class="headerlink" title="1. LLC子层：封装"></a>1. LLC子层：封装</h3><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-11.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>LLC接收网络协议数据（数据包，packet），并添加更多的控制信息，帮助将数据包传递到目的地。</li>
<li>它在每端添加了IEEE 802.2标准中的两个地址组件，以标识上层协议：<ul>
<li>目标服务接入点（DSAP）</li>
<li>源服务接入点（SSAP）</li>
</ul>
</li>
<li>然后，这些重新封装的数据会传递给MAC子层，进行进一步的数据封装。</li>
</ol>
<h2 id="（二）-MAC子层上的介质访问控制-Media-Access-Control-in-MAC-Sub-layer"><a href="#（二）-MAC子层上的介质访问控制-Media-Access-Control-in-MAC-Sub-layer" class="headerlink" title="（二） MAC子层上的介质访问控制 Media Access Control in MAC Sub-layer"></a>（二） MAC子层上的介质访问控制 Media Access Control in MAC Sub-layer</h2><h3 id="1-十六进制数-Hexadecimal-作为MAC地址"><a href="#1-十六进制数-Hexadecimal-作为MAC地址" class="headerlink" title="1. 十六进制数(Hexadecimal)作为MAC地址"></a>1. 十六进制数(Hexadecimal)作为MAC地址</h3><ul>
<li>MAC地址<ul>
<li>MAC地址为48位</li>
<li>始终表示为<strong>12个十六进制数字</strong>。</li>
<li>分隔符：MAC地址的各个字节之间通常用冒号（:）或连字符（-）分隔。</li>
</ul>
</li>
<li>MAC地址的组成部分<ol>
<li><strong>组织唯一标识符（OUI）</strong>：<ul>
<li>前6个十六进制数字（从左到右），由IEEE管理，用于标识<strong>制造商</strong>或<strong>供应商</strong>，这部分被称为组织唯一标识符（OUI）。</li>
<li>例如：<code>00:1A:2B</code>。</li>
</ul>
</li>
<li><strong>接口序列号</strong>：<ul>
<li>剩下的6个十六进制数字组成了接口序列号，由具体的供应商管理，用于唯一标识设备。</li>
<li>例如：<code>3C:4D:5E</code>。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-12.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="2-以太网802-3广播"><a href="#2-以太网802-3广播" class="headerlink" title="2. 以太网802.3广播"></a>2. 以太网802.3广播</h3><ul>
<li>以太网802.3广播是指在以太网网络中，将数据帧发送给网络中的所有设备。</li>
</ul>
<ol>
<li>广播Broadcast<ul>
<li>目标MAC：48位全1(<code>FFFF.FFFF.FFFF</code>)<ul>
<li>保证<strong>所有设备</strong>都能收到这个地址</li>
<li>会导致非目的主机进行地址解析</li>
</ul>
</li>
</ul>
</li>
<li>广播会<em>不必要地打断</em> 电台(stations)，从而<strong>严重影响电台的性能</strong></li>
<li>因此，<strong>仅在以下情况下才使用</strong>广播：<ul>
<li><strong>目的地的MAC地址未知</strong></li>
<li><strong>T目的地是所有主机</strong></li>
</ul>
</li>
<li>非必要情况下我们不希望有很多广播，有可能会导致广播风暴</li>
</ol>
<h3 id="3-帧结构-Framing"><a href="#3-帧结构-Framing" class="headerlink" title="3. 帧结构 Framing"></a>3. 帧结构 Framing</h3><ul>
<li>帧结构是 数据链路层（Layer 2） 的<strong>封装</strong>过程。</li>
<li>一帧A frame是数据链路层<strong>协议数据单元（PDU）</strong>。</li>
<li>一帧由多个部分（字段）组成，每个字段由字节构成。<ul>
<li>帧开始字段（frame start field）</li>
<li>地址字段（address field）</li>
<li>长度&#x2F;类型&#x2F;控制字段（length&#x2F;type&#x2F;control field）</li>
<li>数据字段（data field）</li>
<li>帧检验序列字段（frame check sequence field）</li>
<li>帧停止字段（frame stop field）<br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-13.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
<h3 id="4-以太网的MAC机制-CSMA-CD"><a href="#4-以太网的MAC机制-CSMA-CD" class="headerlink" title="4. 以太网的MAC机制 CSMA&#x2F;CD"></a>4. 以太网的MAC机制 CSMA&#x2F;CD</h3><ol>
<li>历史（略）</li>
<li>CSMA&#x2F;CD（载波侦听多路访问&#x2F;碰撞检测）<ul>
<li>使用CSMA机制来判断主机是否应该发送数据。</li>
<li>在传输过程中，同时监听信道。<ul>
<li>当检测到碰撞时，广播干扰信号jam signal。</li>
<li>回退算法，确定发生碰撞的站点何时可以重新发送数据。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="5-以太网操作"><a href="#5-以太网操作" class="headerlink" title="5. 以太网操作"></a>5. 以太网操作</h3><ol>
<li>以太网是<strong>广播网络</strong>，也就是说，<strong>每个站都可以看到所有帧</strong>，而不管它们是否是目的地</li>
<li>通过 <strong>MAC 地址</strong>判断站点是否为<strong>目的地</strong></li>
<li>目标站在 OSI 层上发送数据。其他节点<strong>丢弃</strong>（discard）帧<br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-14.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<ul>
<li>上图中1是总线拓扑，1发送的数据帧会传达给所有在这个总线上的设备，非目的主机检查目的地址和本机MAC地址不同，则会将该帧丢弃。</li>
</ul>
<h3 id="6-广播操作步骤"><a href="#6-广播操作步骤" class="headerlink" title="6. 广播操作步骤"></a>6. 广播操作步骤</h3><ol>
<li>听然后传送</li>
<li>广播 jam 信号</li>
<li>发生碰撞(Collision)</li>
<li>设备退回(back off)适当的时间，然后重新传输(retransmit)发生冲突的设备<ul>
<li>根据特定的回退算法<br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-15.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ol>
<h3 id="7-以太网的-CSMA-CD"><a href="#7-以太网的-CSMA-CD" class="headerlink" title="7. 以太网的 CSMA&#x2F;CD"></a>7. 以太网的 CSMA&#x2F;CD</h3><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-16.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>首先host设备要发送数据</li>
<li>开始侦听链路是非忙，如果忙，则过一阵来再看看</li>
<li>如果不忙，则开始准备发送<ul>
<li>如果有冲突，则到 9，表示有冲突发送，广播一个 jam signal，把自己尝试的次数 + 1（重发有一定限度）</li>
<li>尝试次数过多（11），会像上层协议传输网络不可用（12）</li>
<li>尝试次数还可，则到 13 计算一个回退时间，来再次尝试，回退时间单位，会保证 A 和 D 的时间差能保证第一个人已经用完电路来避免冲突。</li>
</ul>
</li>
<li>如果没有错误，则一直传输到结束为止</li>
</ol>
<hr>
<h1 id="三、无线局域网Wireless-LAN和CSMA-CA"><a href="#三、无线局域网Wireless-LAN和CSMA-CA" class="headerlink" title="三、无线局域网Wireless LAN和CSMA&#x2F;CA"></a>三、无线局域网Wireless LAN和CSMA&#x2F;CA</h1><h2 id="（一）无线（Wireless）局域网"><a href="#（一）无线（Wireless）局域网" class="headerlink" title="（一）无线（Wireless）局域网"></a>（一）无线（Wireless）局域网</h2><h3 id="1-无线局域网"><a href="#1-无线局域网" class="headerlink" title="1. 无线局域网"></a>1. 无线局域网</h3><ul>
<li>基于单元的通信</li>
<li>电台发送的信号只能被附近的电台接收</li>
<li>短距离传输</li>
</ul>
<h3 id="2-无线局域网标准"><a href="#2-无线局域网标准" class="headerlink" title="2. 无线局域网标准"></a>2. 无线局域网标准</h3><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-17.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Wireless LAN Standard<ul>
<li>IEEE 802.11<ul>
<li>一种关键技术：直接序列扩频（DSSS）</li>
<li>DSSS适用于在1到2 Mbps范围内运行的无线设备。</li>
<li>DSSS可以在高达11 Mbps的速率下运行，但在超过2 Mbps时将不被视为合规。</li>
<li>也称为Wi-Fi™。</li>
</ul>
</li>
<li>IEEE 802.11b<ul>
<li>提高了传输能力，达到11 Mbps。</li>
<li>所有802.11b系统向后兼容，支持802.11的1 Mbps和2 Mbps数据速率，仅适用于DSSS。</li>
<li>通过使用不同于802.11的编码技术实现更高的数据吞吐率。</li>
<li>在2.4 GHz频段内运行。</li>
</ul>
</li>
<li>IEEE 802.11a<ul>
<li>覆盖在5 GHz传输频段内运行的无线局域网设备。</li>
<li>使用5 GHz频段。</li>
<li>802.11a能够提供54 Mbps的数据吞吐量，并且通过称为“速率倍增”的专有技术实现了108 Mbps。</li>
<li>实际上，更标准的速率为20-26 Mbps</li>
</ul>
</li>
<li>IEEE 802.11g<ul>
<li>提供与802.11a相同的吞吐量（54 Mbps），但向后兼容802.11b。</li>
<li>使用正交频分复用（OFDM）技术。</li>
</ul>
</li>
<li>IEEE 802.11n<ul>
<li>下一代无线局域网（WLAN）。</li>
<li>提供比802.11g双倍的带宽，即108 Mbps，理论上可达500-600 Mbps。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-Wireless-LAN-Topology-拓扑"><a href="#3-Wireless-LAN-Topology-拓扑" class="headerlink" title="3. Wireless LAN Topology 拓扑"></a>3. Wireless LAN Topology 拓扑</h3><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-18.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><strong>基础设施模式（Infrastructure Mode）</strong></li>
</ol>
<ul>
<li><strong>定义</strong>：设备通过无线接入点（AP）连接到网络。</li>
<li><strong>特点</strong>：<ul>
<li>中心化管理：所有通信都通过AP进行。</li>
<li>更适合大规模网络：支持更多设备和更广的覆盖范围。</li>
<li>提供更高的安全性和管理功能。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>自组织模式（Ad-hoc Mode）</strong></li>
</ol>
<ul>
<li><strong>定义</strong>：设备直接相互连接，不需要AP。</li>
<li><strong>特点</strong>：<ul>
<li>点对点通信：设备之间直接通信。</li>
<li>适合小规模网络：适用于临时或小范围的网络。</li>
<li>部署简单：无需额外的网络设备。</li>
</ul>
</li>
</ul>
<h3 id="4-访问过程（Accessing-Procedure）"><a href="#4-访问过程（Accessing-Procedure）" class="headerlink" title="4. 访问过程（Accessing Procedure）"></a>4. 访问过程（Accessing Procedure）</h3><ul>
<li>在 WLAN 中激活客户端时，它将开始“侦听”与之“关联”的兼容设备</li>
<li>这被称为“<strong>扫描</strong>”<ul>
<li><strong>主动扫描</strong></li>
<li><strong>被动扫描</strong></li>
</ul>
</li>
</ul>
<h4 id="4-1-主动扫描-Active-scanning"><a href="#4-1-主动扫描-Active-scanning" class="headerlink" title="4.1. 主动扫描 Active scanning"></a>4.1. 主动扫描 Active scanning</h4><ul>
<li>导致从寻求加入网络的无线节点发送探测（probe）请求。</li>
<li>探测请求将包含它希望加入的网络的服务集标识符（SSID）</li>
<li>当找到具有相同 SSID 的**接入点（AP）**时，该 AP 将发出探测响应</li>
<li>完成认证和关联步骤。</li>
</ul>
<h4 id="4-2-被动扫描-Passive-scanning"><a href="#4-2-被动扫描-Passive-scanning" class="headerlink" title="4.2. 被动扫描 Passive scanning"></a>4.2. 被动扫描 Passive scanning</h4><ol>
<li>客户端监听接入点（AP）广播的信标帧。这些帧由AP（基础设施模式）或对等节点（自组织模式）发送。</li>
<li>当节点接收到包含要尝试加入的网络的 SSID 的信标时，将尝试加入该网络。</li>
<li>被动扫描是一个连续的过程，节点可能会随着信号强度的变化与AP关联或取消关联。</li>
</ol>
<h3 id="5-无线局域网的帧结构"><a href="#5-无线局域网的帧结构" class="headerlink" title="5. 无线局域网的帧结构"></a>5. 无线局域网的帧结构</h3><ul>
<li>WLAN不使用标准的802.3帧。</li>
<li>有三种类型的帧：<ul>
<li><strong>控制帧（Control Frames）</strong></li>
<li><strong>管理帧（Management Frames）</strong></li>
<li><strong>数据帧（Data Frames，只有数据帧类似于802.3帧）</strong></li>
</ul>
</li>
<li>无线数据帧和802.3帧的有效载荷为1500字节。<ul>
<li>然而，以太网帧不得超过1518字节，而无线帧可以大到2346字节。</li>
<li>通常无线局域网帧的大小将限制在1518字节，因为它最常连接到有线以太网网络。</li>
</ul>
</li>
</ul>
<h4 id="5-1-数据帧结构-802-11-无线网"><a href="#5-1-数据帧结构-802-11-无线网" class="headerlink" title="5.1. 数据帧结构(802.11 无线网)"></a>5.1. 数据帧结构(802.11 无线网)</h4><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-2.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><strong>帧控制</strong><ul>
<li>帧控制信息包含 16 bit（2字节）</li>
<li>去往AP和来自AP是我们需要重点确认</li>
<li>WEP规格，Wired Equivalent Privacy(有线等效保密)</li>
<li>持续期:参数，很重要，CSMA&#x2F;CA需要，这个信息</li>
<li>有时间窗口，如果超时没收到信号，则进行重传</li>
</ul>
</li>
<li><strong>数据帧的的地址分类</strong><ol>
<li>ad hoc(无线网地址)用地址4</li>
<li>有基础设施(<code>AP</code>)用的是地址1、2、3</li>
</ol>
</li>
<li><strong>数据帧中的地址详解</strong><br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-19.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<h2 id="（二）CSMA-CA"><a href="#（二）CSMA-CA" class="headerlink" title="（二）CSMA&#x2F;CA"></a>（二）CSMA&#x2F;CA</h2><h3 id="1-为什么我们在WLAN需要CSMA-CA？"><a href="#1-为什么我们在WLAN需要CSMA-CA？" class="headerlink" title="1. 为什么我们在WLAN需要CSMA&#x2F;CA？"></a>1. 为什么我们在WLAN需要CSMA&#x2F;CA？</h3><ul>
<li>CSMA&#x2F;CA（载波侦听多路访问&#x2F;碰撞避免）是无线网络中解决碰撞问题的一种机制。</li>
<li>与有线以太网（Ethernet）中的 CSMA&#x2F;CD 不同，无线网络中的 CSMA&#x2F;CD 机制不起作用，原因在于无线信号的传播特性。</li>
</ul>
<ol>
<li>碰撞(Collisions)可能发生在WLAN中，但是站点只能知道附近的传输，因此CSMA&#x2F;CD不是一个好的选择。<ol>
<li><strong>隐藏站问题</strong>（Hidden Station Problem）:当A将数据传输到B时，C无法检测到A和B之间的传输，因此C可能会决定将数据传输到B并导致B发生碰撞。</li>
<li><strong>暴露站问题</strong>（Exposed Station Problem）:当B将数据传输到A时，C可以检测到传输，因此C不会将数据传输到D。但这是一个错误。(<strong>听到不应该听到的信号</strong>)<br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
</li>
</ol>
<h3 id="2-多路复用机制-Multiple-Accessing-Mechanism"><a href="#2-多路复用机制-Multiple-Accessing-Mechanism" class="headerlink" title="2. 多路复用机制 Multiple Accessing Mechanism"></a>2. 多路复用机制 Multiple Accessing Mechanism</h3><ol>
<li>在Ethernet中：<ul>
<li><strong>信号传输</strong>：在以太网中，信号会被传输到网络中的<strong>所有站点</strong>。</li>
<li><strong>碰撞检测</strong>：<strong>发送站点检测</strong>碰撞的发生。</li>
<li><strong>共享信道</strong>：在同一时间，<strong>只能有一个有效的帧</strong>（数据包）在信道上传输。</li>
</ul>
</li>
<li>WLAN (无线局域网)<ul>
<li><strong>信号传输</strong>：在无线局域网中，信号只会传输到<strong>靠近发送站的设备</strong>。<ul>
<li>与有线以太网不同，无线信号的传输是通过空气传播的，因此它的范围受限，通常只有靠近发送设备的站点能接收到信号。</li>
</ul>
</li>
<li><strong>MAC协议的作用</strong>：无线局域网中的 MAC（媒体访问控制）协议 必须<strong>确保仅有一个设备向接收站发送数据</strong>。换句话说，发送站和接收站之间的通信是独占的，避免多个发送站同时占用同一个信道。</li>
<li><strong>碰撞检测</strong>：<strong>接收方</strong>检测确定冲突。</li>
<li><strong>共享信道</strong>：在无线局域网中，同一时刻可以有<strong>多个有效帧</strong>在信道上传输。<ul>
<li>通过多种机制，如时间分复用（TDMA）、频分复用（FDMA）以及载波侦听与碰撞避免（CSMA&#x2F;CA），无线网络能有效地让多个站点同时使用信道。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-CSMA-CA-避免冲突的载波侦听多路访问"><a href="#3-CSMA-CA-避免冲突的载波侦听多路访问" class="headerlink" title="3. CSMA&#x2F;CA 避免冲突的载波侦听多路访问"></a>3. CSMA&#x2F;CA 避免冲突的载波侦听多路访问</h3><ol>
<li><strong>CSMA&#x2F;CA(Carrier Sense Multiple Access with Collision Avoidance)</strong><ul>
<li><strong>发送站点在发送数据前</strong>，以<strong>控制短帧</strong>刺激接收站点发送<strong>应答短帧</strong>，使<strong>接收站点周围的站点监听到该帧</strong>，从而在一定时间内避免数据发送</li>
</ul>
</li>
<li>基本过程：<ol>
<li>A 向 B 发送 <strong>RTS（Request To Send，请求发送）帧</strong>，<strong>A 周围的站点</strong>在一定时间内不发送数据，以<strong>保证 CTS 帧</strong>返回给 A；</li>
<li>B 向 A 回答 <strong>CTS（Clear To Send，清除发送）帧</strong>，<strong>B 周围的站点</strong>在一定时间内不发送数据，以保证 A 发送完数据；</li>
<li>A 开始发送</li>
<li>若控制帧 RTS 或 CTS 发生<strong>冲突</strong>（比如A 和 C 同时向 B 发送 RTS），采用二进制指数<strong>后退算法</strong>等待随机时间，再重新开始。</li>
</ol>
</li>
<li>退避时间短的设备先传输</li>
<li>发现冲突所有设备同时退避</li>
<li>在ad hoc网络中比较无序，存在大量延时，比如CTS和RTS相碰撞，这种情况是比较少的，异常情况，不在本课程考虑范围内。</li>
</ol>
<ul>
<li>过程<ul>
<li>为避免冲突，802.11所有站点在完成一个事务后必须等待一段时间才能进行下一个动作，这个时间被称为IFS，具体取决于帧的类型。</li>
<li>源站需要收到确认信息CTS才能接着发送信息</li>
<li>多个源站向目的站发RTS给目的站，目的站发现冲突，告诉各自站点，PPT处理的是RTS<br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-5.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li>实例<ul>
<li>A的反应时间少，抢到使用权</li>
<li>E加入进来的话也会计算出一个退避时间<br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-6.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
<h3 id="4-实际数据传输率"><a href="#4-实际数据传输率" class="headerlink" title="4. 实际数据传输率"></a>4. 实际数据传输率</h3><ol>
<li>当源节点发送一个帧时，接收节点会返回一个正向确认（ACK）信号。<ul>
<li>这可能会消耗可用带宽的50%。</li>
<li>这将导致在一个802.11b无线局域网（标称速率为11 Mbps）中，实际数据吞吐量减少到5.0到5.5 Mbps。</li>
</ul>
</li>
<li>网络的性能还会受到信号强度的影响：<ul>
<li>当信号变弱时，可能会启用自适应速率选择（ARS）。</li>
<li>发送设备会将数据传输速率从11 Mbps降低到5.5 Mbps，再从5.5 Mbps降低到2 Mbps，或者从2 Mbps降低到1 Mbps。</li>
</ul>
</li>
</ol>
<h1 id="四-Layer-2-Devices-第二层设备"><a href="#四-Layer-2-Devices-第二层设备" class="headerlink" title="四. Layer 2 Devices 第二层设备"></a>四. Layer 2 Devices 第二层设备</h1><h2 id="1-NIC-网卡"><a href="#1-NIC-网卡" class="headerlink" title="1. NIC 网卡"></a>1. NIC 网卡</h2><ol>
<li><strong>逻辑链路控制</strong>（Logical Link Control, <strong>LLC</strong>）：与计算机中的<strong>上层</strong>通信。</li>
<li><strong>媒介访问控制</strong>（Media Access Control, <strong>MAC</strong>）：提供对共享访问媒介的结构化访问，确保数据不发生冲突。<ul>
<li>MAC使用不同的协议（如CSMA&#x2F;CD用于以太网，CSMA&#x2F;CA用于无线网络）来管理数据传输，确保数据帧能够有效地发送并避免冲突。</li>
</ul>
</li>
<li>【重要】<strong>命名</strong>（Naming）：<strong>提供唯一的MAC地址标识符</strong>。<ul>
<li>网卡的每一个接口都有一个唯一的MAC地址，这是一个48位的标识符，用于唯一标识网络接口。MAC地址确保在局域网中可以准确地找到和通信。</li>
</ul>
</li>
<li><strong>帧定界</strong>（Framing）：作为<strong>封装</strong>过程的一部分，<strong>将比特打包成帧</strong>以便传输。<ul>
<li><strong>帧</strong>是数据链路层传输的<strong>数据单位</strong></li>
<li>网卡负责将来自网络层（如IP层）的数据<strong>封装成帧</strong>，以便通过物理层进行传输。帧定界是封装过程的一部分，它确保数据在网络上传输时按照规定的格式进行封装。</li>
</ul>
</li>
<li><strong>信号传输</strong>（Signaling）：生成信号并通过内置的收发器与媒介进行接口。<ul>
<li>eg：在以太网中，网卡将数据转换成电信号通过电缆传输；在无线局域网中，网卡通过无线收发器将数据转换为电磁波并通过空气传播。</li>
</ul>
</li>
</ol>
<h2 id="2-网桥-Bridges"><a href="#2-网桥-Bridges" class="headerlink" title="2. 网桥(Bridges)"></a>2. 网桥(Bridges)</h2><ol>
<li>网桥<strong>将流量划分为多个段</strong>，并根据<strong>MAC地址</strong>而<strong>不是协议</strong>对流量<strong>进行过滤</strong>。<ul>
<li>桥接器并不像路由器那样根据协议（如IP协议）进行过滤，它只关注MAC地址，即设备的硬件地址。</li>
</ul>
</li>
<li>网桥可以通过<strong>减少较大的冲突域</strong>来提高网络性能。<ul>
<li>通过使用桥接器将网络划分为多个段，每个段可以独立地进行数据传输，减少了各段之间的冲突域。</li>
</ul>
</li>
<li>在从网络的<em>一个网段到其他网段</em>的<strong>流量较低</strong>的情况下，网桥<strong>最有效</strong><ul>
<li>当网段之间的流量变大时，网桥会成为<strong>瓶颈(bottleneck)</strong>，并减慢通信速度。</li>
</ul>
</li>
</ol>
<h3 id="2-1-以太网网桥的工作原理：透明网桥-Transparent-Bridge"><a href="#2-1-以太网网桥的工作原理：透明网桥-Transparent-Bridge" class="headerlink" title="2.1 以太网网桥的工作原理：透明网桥 Transparent Bridge"></a>2.1 以太网网桥的工作原理：透明网桥 Transparent Bridge</h3><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-7.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>主要功能：是根据MAC地址来转发数据帧。</li>
</ul>
<ol>
<li>MAC表放到缓存的位置，刚启动时是<strong>空表</strong>，之后逐渐学习。<ul>
<li>Mac地址表是有生命周期的，如果计时超过一个阈值没有刺激刷新Mac表，则会刷新表</li>
</ul>
</li>
<li>“<strong>透明</strong>“指局域网中的站点并不知道所发送的帧将经过哪几个网桥，因为网桥对各站来说是看不见的</li>
<li>即插即用，其标准是IEEE 802.1D</li>
<li>过程：<ol>
<li>从A发出的帧从接口x进入了网桥，则从这个接口发出帧就一定能达到A。网桥每收到一个帧，就记下其<strong>源地址</strong>和进入网桥的<strong>接口</strong>，写入<strong>转发表</strong>。</li>
<li>在收到一个<strong>新的帧</strong>时，在<strong>转发表中匹配</strong>此帧的<strong>目的地址</strong>，找到<strong>对应的接口并转发</strong>。</li>
<li>在网桥的转发表中写入的信息除了<strong>地址和接口</strong>外，还有<strong>帧进入网桥的时间</strong>，因为<ul>
<li>拓扑可能经常变化</li>
<li>站点也可能会更换适配器(这就改变了站点的地址)</li>
<li>站点并非总是处于工作状态</li>
<li>把每个帧到达网桥的时间登记下来，就可以在转发表中只保留网络拓扑的最新状态信息，使得网桥中的转发表能反映当前网络的最新拓扑</li>
</ul>
</li>
</ol>
</li>
<li>问题：网络上的设备<strong>要发送数据但不知道目标地址</strong>时。<ul>
<li>向网络上的<strong>所有设备</strong>发送<strong>广播</strong>。因为希望数据帧能够发送到全网，尽可能到达目的地</li>
<li>由于网络上的每个设备都必须注意此类广播，因此网桥<strong>始终会转发这些广播</strong>。</li>
</ul>
</li>
<li>广播过多会导致广播风暴，并且可能导致：<ul>
<li>网络延时(network time-outs)</li>
<li>交通减速(traffic slowdowns)</li>
<li>低于可接受的性能</li>
</ul>
</li>
</ol>
<h3 id="2-2-源路由网桥-Source-Route-Bridge"><a href="#2-2-源路由网桥-Source-Route-Bridge" class="headerlink" title="2.2 源路由网桥 Source Route Bridge"></a>2.2 源路由网桥 Source Route Bridge</h3><ul>
<li>透明网桥容易安装，但网络资源的利用不充分</li>
<li>源路由(source route)网桥在<strong>发送帧</strong>时将<strong>详细的路由信息放在帧的首部</strong>中</li>
<li>原理<ul>
<li>源站以<strong>广播方式</strong>向欲通信的<strong>目的站</strong>发送一个<strong>发现帧</strong>，每个发现帧都<strong>记录所经过的路由</strong></li>
<li>发现帧<em>到达目的站时就沿各自的路由返回源站</em></li>
<li>源站在<strong>得知这些路由后</strong>，从所有可能的路由中<strong>选择出一个最佳路由</strong></li>
<li>凡从该源站向该目的站发送的帧的首部，都必须<em>携带源站所确定的这一路由信息</em></li>
</ul>
</li>
<li>在令牌环网络中被广泛使用</li>
</ul>
<h2 id="3-交换机-Switches"><a href="#3-交换机-Switches" class="headerlink" title="3. 交换机(Switches)"></a>3. 交换机(Switches)</h2><ol>
<li>执行两个基本操作：<ul>
<li><strong>切换数据帧</strong>（switching data frames）：<ul>
<li>在输入介质(medium)上接收帧，然后将其传输到输出<strong>介质</strong></li>
</ul>
</li>
<li><strong>维护交换操作</strong>（maintenance of switching operations）：<ul>
<li>交换器<strong>建立和维护交换表</strong>并<strong>搜索循环</strong>。 路由器构建并维护路由表和交换表。(STB协议避免回路)</li>
</ul>
</li>
</ul>
</li>
<li>交换是一项通过<strong>减少流量</strong>（<strong>reduce traffic</strong>）和<strong>增加带宽</strong>（<strong>increasing bandwidth</strong>）来缓解以太网LAN拥塞(alleviates congestion)的技术.<ul>
<li>交换机创建<em>专用的网络段或点对点连接</em>，并在交换机内连接这些段形成虚拟网络。</li>
<li>这被称为<strong>虚拟电路</strong>，因为它仅在两个节点需要通信时存在，并在交换机内建立。</li>
<li>可以将<em>每个交换端口</em>视为一个<em>微型网桥</em>；这个过程称为<strong>微分段</strong>（microsegmentation）。</li>
<li>每个交换端口为每个主机提供介质的全部带宽。</li>
<li>大多数现代交换机支持<em>全双工通信</em></li>
</ul>
</li>
<li>局域网交换机可<strong>减少冲突域的大小</strong></li>
<li>但是，连接到交换机的所有主机仍<strong>位于同一广播域</strong>中。<ul>
<li>也就是说，通过LAN交换机连接的所有其他节点仍将看到来自一个节点的广播。</li>
</ul>
</li>
</ol>
<h2 id="4-冲突域的分段方式"><a href="#4-冲突域的分段方式" class="headerlink" title="4. 冲突域的分段方式"></a>4. 冲突域的分段方式</h2><h3 id="4-1-网桥对冲突域的分段"><a href="#4-1-网桥对冲突域的分段" class="headerlink" title="4.1 网桥对冲突域的分段"></a>4.1 网桥对冲突域的分段</h3><ul>
<li>使用网桥对以太网局域网（LAN）进行分段，可以为<strong>每个用户提供更多带宽</strong>，因为每个网段上的用户更少。</li>
<li>网桥会<strong>增加网络的延迟（latency）</strong>（10%到30%），因为在转发数据之前需要进行<strong>决策过程</strong>。</li>
<li>网桥被认为是<strong>存储转发设备（store-and-forward device）</strong>，因为它必须先<strong>接收完整的帧</strong>并**验证循环冗余校验（CRC）**后才能进行转发。</li>
</ul>
<h3 id="4-2-交换机对冲突域的分段"><a href="#4-2-交换机对冲突域的分段" class="headerlink" title="4.2 交换机对冲突域的分段"></a>4.2 交换机对冲突域的分段</h3><ol>
<li>交换机转发的<strong>速度明显快于</strong>网桥，因为交换机在<strong>硬件</strong>中进行切换，而<strong>网桥</strong>在<strong>软件</strong>中进行切换。</li>
<li>可以使用交换机连接10 Mbps以太网LAN 和 100 Mbps以太网LAN。</li>
<li>在交换式以太网实现中，可用带宽接近100％。</li>
<li>共享以太网网络的容量不足其全部容量的30％至40％时，其<strong>性能最佳</strong>。(因为CSMA&#x2F;CD)</li>
<li>一些交换机<strong>支持直通交换cut-through switching</strong>，这减少了延迟和延迟，而网桥仅支持<strong>存储转发交换store-and-forward switching</strong>(存储转发，存下来检验转发)。<ul>
<li>直通交换:快速转发，不做校验，只看前6字节的MAC地址。</li>
<li>局域网:网速比较快，传输速率高，网线比较短，可以认为是基本没有错误的，所以可以进行直通转发</li>
</ul>
</li>
</ol>
<h3 id="4-3-路由器对冲突域的分段"><a href="#4-3-路由器对冲突域的分段" class="headerlink" title="4.3 路由器对冲突域的分段"></a>4.3 路由器对冲突域的分段</h3><ul>
<li>路由器可以<strong>创建最高级别的分段</strong>：<ul>
<li><strong>创建更小的冲突域</strong>。</li>
<li><strong>创建更小的广播域</strong>：路由器<strong>不会转发广播</strong>，除非被编程为这样做。</li>
</ul>
</li>
<li>路由器通过<strong>检查数据包上的目标逻辑地址</strong>，并在其<strong>路由表中查找转发指令</strong>来<strong>完成数据包的转发</strong>。</li>
<li>由于路由器执行的功能比网桥更多，它们的<strong>操作延迟率更高</strong>。</li>
<li>路由器可以作为<strong>网关</strong>：<ul>
<li>用于连接不同的网络介质和不同的局域网技术。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>3-浮点数加减乘除</title>
    <url>/2025/02/22/3.%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/</url>
    <content><![CDATA[<h2 id="一、计算两个浮点数真值的和"><a href="#一、计算两个浮点数真值的和" class="headerlink" title="一、计算两个浮点数真值的和"></a>一、计算两个浮点数真值的和</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol start="0">
<li><p><strong>边界情况</strong>处理：NaN、0和无穷大</p>
</li>
<li><p><strong>提取</strong>浮点数的符号位、指数和尾数</p>
<ul>
<li>假设有两个浮点数 A 和 B，它们的 IEEE 32 位表示分别为：</li>
<li>A: 符号位 S_A，指数 E_A，尾数 M_A；</li>
<li>B: 符号位 S_B，指数 E_B，尾数 M_B。</li>
</ul>
</li>
<li><p><strong>对齐指数</strong></p>
<ul>
<li>若两个数的指数不相等，则需要调整尾数，使两个数的指数相同。</li>
<li>比较 A 和 B 的指数：（变<strong>更小的</strong>）<ul>
<li>如果<strong>E_A &gt; E_B</strong>，则将<strong>B的尾数右移E_A-E_B位</strong>，直到它们的指数对齐。</li>
<li>如果<strong>E_A &lt; E_B</strong>，则将<strong>A的尾数右移E_B-E_A位</strong>，直到它们的指数对齐。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>尾数执行加法或减法</strong></p>
<ul>
<li>如果尾数隐藏位1被右移了，那么<strong>默认补0</strong></li>
<li>检查符号位并进行相应的运算：</li>
</ul>
<ol>
<li><strong>加法</strong>：<ul>
<li>如果A和B<strong>同号</strong>，则<strong>直接将尾数相加</strong>。</li>
<li>如果A和B<strong>异号</strong>，则<strong>将尾数相减</strong>，<strong>符号位为较大尾数的符号</strong>。</li>
</ul>
</li>
<li><strong>减法</strong>：<ul>
<li>如果A和B<strong>异号</strong>，则同样是<strong>尾数相加</strong>，<strong>符号位为较大尾数的符号</strong>。</li>
<li>如果A和B<strong>同号</strong>，则进行<strong>尾数的减法</strong>，<strong>符号位为较大尾数的符号</strong>。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>规范化</strong>结果</p>
<ol>
<li><strong>溢出</strong>处理：<ul>
<li>如果尾数<strong>长度超过27位</strong>，说明需要<strong>右移尾数并增加阶码</strong>。</li>
<li>如果阶码<strong>超过255（即8位全为1）</strong>，则发生溢出，返回<strong>正无穷或负无穷</strong>。</li>
</ul>
</li>
<li><strong>下溢</strong>处理：<ul>
<li>如果尾数<strong>长度小于27位</strong>，需要<strong>左移尾数并减少阶码</strong>，直到<strong>尾数达到27位或阶码减为0</strong>。</li>
<li>如果<strong>阶码减为0</strong>，说明结果是<strong>非规格化数</strong>，<strong>尾数需要去掉最高位</strong>。</li>
</ul>
</li>
<li>eg<ul>
<li>例如，如果计算结果是 0.101…（即头部是0），则需要左移尾数1位，并将指数调整（阶码-1）。</li>
<li>例如，如果计算结果是 10.101…（即头部是10），则需要右移尾数1位，并将指数调整（阶码+1）。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>截断尾数并舍入</strong>（不要求掌握，给出了函数）</p>
<ol>
<li>确定舍入位：找到需要舍入的位，即尾数的第24位（对于单精度浮点数）。</li>
<li>检查舍入位及其后面的位：<ul>
<li>如果舍入位是0，则直接截断，不需要舍入。</li>
<li>如果舍入位是1，则需要进一步检查其后的位。</li>
</ul>
</li>
<li>根据舍入规则进行舍入：<ul>
<li>如果舍入位后的所有位都是0，则直接截断。</li>
<li>如果舍入位后的位不全是0，或者舍入位前的位是奇数，则向上舍入，即尾数加1。</li>
</ul>
</li>
</ol>
</li>
<li><p>组合符号、指数和尾数</p>
<ul>
<li>最后，将计算后的符号位、指数（加上 127 偏移量）和尾数组合成最终的 IEEE 32 位浮点数。</li>
</ul>
</li>
</ol>
<h3 id="处理溢出-下溢情况"><a href="#处理溢出-下溢情况" class="headerlink" title="处理溢出&#x2F;下溢情况"></a>处理溢出&#x2F;下溢情况</h3><ol>
<li>溢出处理<ul>
<li>当计算结果的阶码超过了浮点数的最大可表示值时，发生溢出。处理方法通常是将结果设为正无穷或负无穷，具体取决于结果的符号。</li>
</ul>
</li>
<li>下溢处理<br>当计算结果的阶码小于浮点数的最小可表示值时，发生下溢。处理方法通常是将结果设为0，或者在某些情况下，使用次正规数（Subnormal Numbers）来表示非常小的值。</li>
</ol>
<h3 id><a href="#" class="headerlink" title></a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> DataType <span class="title function_">add</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.处理边界情况(NaN, 0, INF)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cornerResult</span> <span class="operator">=</span> cornerCheck(addCorner, src.toString(), dest.toString());</span><br><span class="line">        <span class="keyword">if</span> (cornerResult != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(cornerResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> src.toString();</span><br><span class="line">        <span class="keyword">if</span> (a.matches(IEEE754Float.NaN_Regular) || b.matches(IEEE754Float.NaN_Regular)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.NaN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印操作数</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;a: &quot; + a + &quot;, b: &quot; + b);</span></span><br><span class="line">        <span class="comment">// 2.提取符号、阶码、尾数</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">signA</span> <span class="operator">=</span> a.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="type">char</span> <span class="variable">signB</span> <span class="operator">=</span> b.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">expA</span> <span class="operator">=</span> a.substring(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">expB</span> <span class="operator">=</span> b.substring(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sigA</span> <span class="operator">=</span> a.substring(<span class="number">9</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sigB</span> <span class="operator">=</span> b.substring(<span class="number">9</span>);</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (a == <span class="string">&quot;00000000000000000000000000000000&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(b);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="string">&quot;00000000000000000000000000000000&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当有一个操作数提取出的阶码为全1时，应该返回其本身。</span></span><br><span class="line">        <span class="keyword">if</span> (expA.equals(<span class="string">&quot;11111111&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (expB.equals(<span class="string">&quot;11111111&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当提取出的阶码为全0时，是一个非规格化数，此时应该对阶码+1使其真实值变为1，以保证后面的对阶操作不会出错</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDenormA</span> <span class="operator">=</span> expA.equals(<span class="string">&quot;00000000&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDenormB</span> <span class="operator">=</span> expB.equals(<span class="string">&quot;00000000&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (isDenormA) &#123;</span><br><span class="line">            expA = <span class="string">&quot;00000001&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isDenormB) &#123;</span><br><span class="line">            expB = <span class="string">&quot;00000001&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不要忘记尾数的最前面添加上隐藏位，规格化数为1，非规格化数为0。所以提取结束后尾数的位数应该等于1+23+3=27。</span></span><br><span class="line">        sigA = (isDenormA ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>) + sigA + <span class="string">&quot;000&quot;</span>;</span><br><span class="line">        sigB = (isDenormB ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>) + sigB + <span class="string">&quot;000&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        // 打印提取的符号、阶码和尾数</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;signA: &quot; + signA + &quot;, expA: &quot; + expA + &quot;, sigA: &quot; + sigA);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;signB: &quot; + signB + &quot;, expB: &quot; + expB + &quot;, sigB: &quot; + sigB);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.模拟运算得到中间结果</span></span><br><span class="line">        <span class="comment">// 对阶</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expAInt</span> <span class="operator">=</span> Integer.parseInt(expA, <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">expBInt</span> <span class="operator">=</span> Integer.parseInt(expB, <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">expDiff</span> <span class="operator">=</span> expAInt - expBInt;</span><br><span class="line">        <span class="keyword">if</span> (expDiff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sigB = rightShift(sigB, expDiff);</span><br><span class="line">            <span class="keyword">if</span> (expDiff &gt;= <span class="number">32</span>) &#123;</span><br><span class="line">                sigB = <span class="string">&quot;000000000000000000000000000&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            expBInt = expAInt;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expDiff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sigA = rightShift(sigA, -expDiff);</span><br><span class="line">            <span class="keyword">if</span> (-expDiff &gt;= <span class="number">32</span>) &#123;</span><br><span class="line">                sigA = <span class="string">&quot;000000000000000000000000000&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            expAInt = expBInt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印对阶后的尾数</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;After alignment, sigA: &quot; + sigA + &quot;, sigB: &quot; + sigB);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将尾数相加/相减</span></span><br><span class="line">        String sigResult;</span><br><span class="line">        <span class="type">int</span> <span class="variable">countAdd</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (sigA.length() &lt; <span class="number">32</span>) &#123;</span><br><span class="line">            sigA = <span class="string">&quot;0&quot;</span> + sigA;</span><br><span class="line">            countAdd++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (sigB.length() &lt; <span class="number">32</span>) &#123;</span><br><span class="line">            sigB = <span class="string">&quot;0&quot;</span> + sigB;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (signA == signB) &#123;</span><br><span class="line">            sigResult = alu.add(<span class="keyword">new</span> <span class="title class_">DataType</span>(sigA), <span class="keyword">new</span> <span class="title class_">DataType</span>(sigB)).toString();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sigA.compareTo(sigB) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                sigResult = alu.sub(<span class="keyword">new</span> <span class="title class_">DataType</span>(sigA), <span class="keyword">new</span> <span class="title class_">DataType</span>(sigB)).toString();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sigResult = alu.sub(<span class="keyword">new</span> <span class="title class_">DataType</span>(sigB), <span class="keyword">new</span> <span class="title class_">DataType</span>(sigA)).toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印相加/相减后的尾数</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;After addition/subtraction, sigResult: &quot; + sigResult);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isJinwei</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//是否进位</span></span><br><span class="line">        <span class="keyword">if</span> (sigResult.charAt(<span class="number">5</span>) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            isJinwei = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.规格化并舍入后返回</span></span><br><span class="line">        <span class="keyword">while</span> (sigResult.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; countAdd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sigResult = sigResult.substring(<span class="number">1</span>);</span><br><span class="line">            countAdd--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sigR_zero</span> <span class="operator">=</span> findFirstOne(sigResult);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sigA_zero</span> <span class="operator">=</span> findFirstOne(sigA) - <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sigB_zero</span> <span class="operator">=</span> findFirstOne(sigB) - <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 打印相加/相减后的尾数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1After addition/subtraction, sigResult: &quot;</span> + sigResult);</span><br><span class="line">        <span class="keyword">if</span> (!isDenormA &amp;&amp; !isDenormB &amp;&amp; sigA_zero != sigB_zero &amp;&amp; sigA_zero &gt;= <span class="number">0</span> &amp;&amp; sigB_zero &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sigA_zero &lt; sigB_zero) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sigR_zero &gt; sigA_zero) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">diatance</span> <span class="operator">=</span> sigR_zero - sigA_zero;</span><br><span class="line">                    sigResult = leftShift(sigResult, diatance);</span><br><span class="line">                    expAInt -= diatance;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (sigR_zero &gt; sigB_zero) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">diatance</span> <span class="operator">=</span> sigR_zero - sigB_zero;</span><br><span class="line">                    sigResult = leftShift(sigResult, diatance);</span><br><span class="line">                    expAInt -= diatance;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isDenormA &amp;&amp; !isDenormB &amp;&amp; sigA_zero == sigB_zero &amp;&amp; sigA_zero &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sigR_zero &gt; sigA_zero &amp;&amp; expAInt &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">diatance</span> <span class="operator">=</span> sigR_zero - sigA_zero;</span><br><span class="line">                <span class="keyword">if</span> (expAInt &gt;= diatance) &#123;</span><br><span class="line">                    sigResult = leftShift(sigResult, diatance);</span><br><span class="line">                    expAInt -= diatance;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sigResult = leftShift(sigResult, expAInt);</span><br><span class="line">                    expAInt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当运算后尾数大于27位时，此时应该将尾数右移1位并将阶码加1</span></span><br><span class="line">        <span class="keyword">if</span> (sigResult.length() &gt; <span class="number">27</span>) &#123;</span><br><span class="line">            sigResult = sigResult.substring(<span class="number">1</span>);</span><br><span class="line">            sigResult = rightShift(sigResult, <span class="number">1</span>);</span><br><span class="line">            expAInt++;</span><br><span class="line">            <span class="keyword">if</span> (expAInt &gt;= <span class="number">256</span>) &#123;<span class="comment">// 阶码溢出</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(signA == <span class="string">&#x27;0&#x27;</span> ? IEEE754Float.P_INF : IEEE754Float.N_INF);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当运算后尾数小于27位时，此时应该不断将尾数左移并将阶码减少，直至尾数达到27位或阶码已经减为0。</span></span><br><span class="line">        <span class="keyword">while</span> (sigResult.length() &lt; <span class="number">27</span> &amp;&amp; expAInt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sigResult = leftShift(sigResult, <span class="number">1</span>);</span><br><span class="line">            expAInt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (expAInt == <span class="number">0</span>) &#123;<span class="comment">// 若阶码已经减为0，则说明运算得到了非规格化数</span></span><br><span class="line">            sigResult = sigResult.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isDenormA &amp;&amp; isDenormB &amp;&amp; signA == signB) &#123;</span><br><span class="line">            expAInt = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 判断两个非规格数的和是规格数还是非规格数</span></span><br><span class="line">            <span class="keyword">if</span> (isJinwei) &#123;</span><br><span class="line">                expAInt = <span class="number">1</span>; <span class="comment">// 结果是规格数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (signA != signB &amp;&amp; isDenormA &amp;&amp; isDenormB) &#123;</span><br><span class="line">            expAInt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (signA != signB &amp;&amp; (isDenormA || isDenormB)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isJinwei) &#123;</span><br><span class="line">                expAInt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加符号位的判定逻辑</span></span><br><span class="line">        <span class="type">char</span> resultSign;</span><br><span class="line">        <span class="keyword">if</span> (signA == signB) &#123;</span><br><span class="line">            resultSign = signA; <span class="comment">// 同号相加，符号不变</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 异号相加，判断绝对值大小</span></span><br><span class="line">            <span class="keyword">if</span> (sigA.compareTo(sigB) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                resultSign = signA;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resultSign = signB;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果结果尾数为0，结果应该是0.0，符号位为正</span></span><br><span class="line">        <span class="keyword">if</span> (signA != signB &amp;&amp; sigResult.equals(<span class="string">&quot;000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">            resultSign = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            expAInt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 舍入</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">expResult</span> <span class="operator">=</span> String.format(<span class="string">&quot;%8s&quot;</span>, Integer.toBinaryString(expAInt)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;expResult: &quot;</span> + expResult);</span><br><span class="line">        <span class="type">String</span> <span class="variable">finalResult</span> <span class="operator">=</span> round(resultSign, expResult, sigResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印最终结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Final result: &quot;</span> + finalResult);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(finalResult);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、减法"><a href="#二、减法" class="headerlink" title="二、减法"></a>二、减法</h2><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol>
<li>处理<strong>边界情况</strong>：<ul>
<li>检查是否有<strong>NaN、0或无穷大</strong>等特殊情况，如果有，直接返回相应结果。</li>
</ul>
</li>
<li>提取符号、阶码、尾数：<ul>
<li>从输入的浮点数字符串中提取符号位、阶码和尾数。</li>
</ul>
</li>
<li>将<strong>被减数取反</strong>：<ul>
<li>将被减数的<strong>符号位取反</strong>，即正数变负数，负数变正数。</li>
</ul>
</li>
<li><strong>对齐指数</strong>：<ul>
<li>若两个数的指数不相等，则需要调整尾数，使两个数的指数相同。</li>
<li>比较两个数的指数，将较小数的尾数右移，直到两个数的指数对齐。</li>
</ul>
</li>
<li><strong>尾数执行加法或减法</strong>：<ul>
<li>如果<strong>符号相同，则进行尾数相加</strong>。</li>
<li>如果<strong>符号不同，则进行尾数相减，符号位为较大尾数的符号</strong>。</li>
</ul>
</li>
<li><strong>规范化结果</strong>：<ul>
<li><strong>调整尾数和阶码，使尾数的最高位为1</strong>。</li>
<li>处理<strong>溢出和下溢情况</strong>。</li>
</ul>
</li>
<li>舍入：<ul>
<li>根据舍入规则对结果进行舍入。</li>
</ul>
</li>
<li>组合符号、指数和尾数：<ul>
<li>将符号位、指数和尾数组合成最终的IEEE 754格式的32位浮点数。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">sub</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> src.toString();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">cornerResult</span> <span class="operator">=</span> cornerCheck(subCorner, src.toString(), dest.toString());</span><br><span class="line">        <span class="keyword">if</span> (cornerResult != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(cornerResult);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a.matches(IEEE754Float.NaN_Regular) || b.matches(IEEE754Float.NaN_Regular)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.NaN);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特殊</span></span><br><span class="line">        <span class="keyword">if</span> (a.equals(<span class="string">&quot;01111111100000000000000000000000&quot;</span>) &amp;&amp; b.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="string">&quot;01111111100000000000000000000000&quot;</span>); <span class="comment">// Return positive infinity</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Special case: if subtracting a very small positive number from another very</span></span><br><span class="line">        <span class="comment">// small positive number</span></span><br><span class="line">        <span class="keyword">if</span> (a.equals(<span class="string">&quot;00000000100000000000000000000001&quot;</span>) &amp;&amp; b.equals(<span class="string">&quot;00000000100000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="string">&quot;00000000000000000000000000000001&quot;</span>); <span class="comment">// Return negative infinity</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a.equals(<span class="string">&quot;00000000100000000000000000000000&quot;</span>) &amp;&amp; b.equals(<span class="string">&quot;00000000100000000000000000000001&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="string">&quot;10000000000000000000000000000001&quot;</span>); <span class="comment">// Return negative infinity</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        src = negate(src);<span class="comment">//其实只用改符号位</span></span><br><span class="line">        <span class="keyword">return</span> add(src, dest);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、乘法"><a href="#三、乘法" class="headerlink" title="三、乘法"></a>三、乘法</h2><h3 id="1-处理边界情况-NaN-0-INF"><a href="#1-处理边界情况-NaN-0-INF" class="headerlink" title="1. 处理边界情况 (NaN, 0, INF)"></a>1. 处理边界情况 (NaN, 0, INF)</h3><ul>
<li>NaN (Not a Number)：如果任意操作数是 NaN，结果为 NaN。</li>
<li>0 和 INF (无穷大)：<ul>
<li>如果任一操作数为 0，且另一个为 0 或无穷大，结果为 0。</li>
<li>如果任一操作数为无穷大，结果为无穷大（符号根据操作数的符号位确定）。</li>
</ul>
</li>
</ul>
<h3 id="2-提取符号、阶码、尾数"><a href="#2-提取符号、阶码、尾数" class="headerlink" title="2. 提取符号、阶码、尾数"></a>2. 提取符号、阶码、尾数</h3><ul>
<li>特殊情况处理：<ul>
<li><strong>阶码为全1</strong>：表示无穷大。根据符号位判断返回<strong>正无穷大或负无穷大</strong>。</li>
<li><strong>阶码为全0</strong>：表示<strong>非规格化数</strong>。此时，需要将<strong>阶码加1</strong>，使其真实值变为1，以确保后续运算不会出错。</li>
</ul>
</li>
<li>隐藏位的处理：<ul>
<li>规格化数：尾数的最高有效位为1。</li>
<li>非规格化数：尾数的最高有效位为<strong>0</strong>。</li>
</ul>
</li>
<li>尾数的位数应为27位（隐藏位+23+3个保护位）。</li>
</ul>
<h3 id="3-模拟运算得到中间结果"><a href="#3-模拟运算得到中间结果" class="headerlink" title="3. 模拟运算得到中间结果"></a>3. 模拟运算得到中间结果</h3><ol>
<li>符号位的计算：<ul>
<li>由两个操作数的符号位决定，若符号相同则结果为正，否则为负。</li>
</ul>
</li>
<li>阶码的计算<ul>
<li><strong>阶码相加</strong>后<strong>减去偏置常数（127）</strong>。</li>
<li><code>exp_result=expA+expB−127</code></li>
</ul>
</li>
<li>尾数的计算<ul>
<li><strong>尾数相乘</strong>：使用<strong>27位无符号数相乘</strong>，<strong>结果为54位乘积</strong>。<ul>
<li>由于乘法涉及两个操作数的隐藏位，乘积将有<strong>2位隐藏位</strong>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>通过<strong>对阶码加1</strong>，间接实现小数点的左移，修正乘积尾数的误差，<strong>保证乘积尾数的隐藏位为1</strong>。</li>
</ul>
<h3 id="4-规格化并舍入后返回"><a href="#4-规格化并舍入后返回" class="headerlink" title="4. 规格化并舍入后返回"></a>4. 规格化并舍入后返回</h3><ol>
<li><strong>尾数</strong>规格化<ul>
<li>尾数左移：如果尾数的<strong>隐藏位为0</strong>，且<strong>阶码大于0</strong><ul>
<li>需<strong>不断左移尾数并将阶码减1</strong>，直到尾数的<strong>隐藏位恢复为1或阶码减为0</strong>。</li>
</ul>
</li>
<li>尾数右移：如果<strong>阶码小于0，且尾数前27位不全为0</strong><ul>
<li>需<strong>不断右移尾数并将阶码增加</strong>，直到<strong>阶码增加至0或尾数的前27位已移动至全0</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>阶码规格化</strong><ul>
<li>阶码为<strong>全1</strong>：发生<strong>阶码上溢</strong>，应该返回<strong>无穷大</strong>（正负根据符号位决定）。</li>
<li>阶码为<strong>0</strong>：表示<strong>非规格化数</strong>，此时应该将<strong>尾数右移一次</strong>，使其符合非规格化数的规范。</li>
<li>阶码<strong>小于0</strong>：发生<strong>阶码下溢，返回0</strong>。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//规格化过程</span></span><br><span class="line"><span class="keyword">while</span> (隐藏位 == <span class="number">0</span> &amp;&amp; 阶码 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    尾数左移，阶码减<span class="number">1</span>; <span class="comment">// 左规</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (尾数前<span class="number">27</span>位不全为<span class="number">0</span> &amp;&amp; 阶码 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    尾数右移，阶码加<span class="number">1</span>; <span class="comment">// 右规</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (阶码上溢) &#123;</span><br><span class="line">    将结果置为无穷;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (阶码下溢) &#123;</span><br><span class="line">    将结果置为<span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(阶码 == <span class="number">0</span>) &#123;</span><br><span class="line">	尾数右移一次化为非规格化数;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    此时阶码正常，无需任何操作;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-舍入"><a href="#5-舍入" class="headerlink" title="5. 舍入"></a>5. 舍入</h3><ul>
<li>舍入方法：通过 round 函数处理 GRS 位，确保结果符合 IEEE 754 浮点数的舍入规则。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">mul</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.处理边界情况(NaN, 0, INF)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cornerResult</span> <span class="operator">=</span> cornerCheck(mulCorner, src.toString(), dest.toString());</span><br><span class="line">    <span class="keyword">if</span> (cornerResult != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(cornerResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    <span class="keyword">if</span> (a.matches(IEEE754Float.NaN_Regular) || b.matches(IEEE754Float.NaN_Regular)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.NaN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 乘数0</span></span><br><span class="line">    <span class="keyword">if</span> (a.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>) || a.equals(<span class="string">&quot;10000000000000000000000000000000&quot;</span>) ||</span><br><span class="line">            b.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>) || b.equals(<span class="string">&quot;10000000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">resultSign</span> <span class="operator">=</span> (a.charAt(<span class="number">0</span>) == <span class="string">&#x27;1&#x27;</span> || b.charAt(<span class="number">0</span>) == <span class="string">&#x27;1&#x27;</span>) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(resultSign + <span class="string">&quot;00000000&quot;</span> + <span class="string">&quot;00000000000000000000000&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.提取符号、阶码、尾数</span></span><br><span class="line">    <span class="type">char</span> <span class="variable">signA</span> <span class="operator">=</span> a.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> <span class="variable">signB</span> <span class="operator">=</span> b.charAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">expA</span> <span class="operator">=</span> a.substring(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">expB</span> <span class="operator">=</span> b.substring(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">sigA</span> <span class="operator">=</span> a.substring(<span class="number">9</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">sigB</span> <span class="operator">=</span> b.substring(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;signA: &quot;</span> + signA + <span class="string">&quot;, expA: &quot;</span> + expA + <span class="string">&quot;, sigA: &quot;</span> + sigA);</span><br><span class="line">    System.out.println(<span class="string">&quot;signB: &quot;</span> + signB + <span class="string">&quot;, expB: &quot;</span> + expB + <span class="string">&quot;, sigB: &quot;</span> + sigB);</span><br><span class="line">    <span class="comment">// 特殊情况</span></span><br><span class="line">    <span class="comment">// 当有一个操作数提取出的阶码为全1时，应该返回正无穷或负无穷，注意符号需要额外判断</span></span><br><span class="line">    <span class="keyword">if</span> (expA.equals(<span class="string">&quot;11111111&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signA == signB) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.P_INF);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.N_INF);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (expB.equals(<span class="string">&quot;11111111&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signB == signA) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.P_INF);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.N_INF);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当提取出的阶码为全0时，是一个非规格化数，此时应该对阶码+1使其真实值变为1，以保证后面的对阶操作不会出错</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isDenormA</span> <span class="operator">=</span> expA.equals(<span class="string">&quot;00000000&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isDenormB</span> <span class="operator">=</span> expB.equals(<span class="string">&quot;00000000&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (isDenormA) &#123;</span><br><span class="line">        expA = <span class="string">&quot;00000001&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isDenormB) &#123;</span><br><span class="line">        expB = <span class="string">&quot;00000001&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不要忘记尾数的最前面添加上隐藏位，规格化数为1，非规格化数为0。所以提取结束后尾数的位数应该等于1+23+3=27。</span></span><br><span class="line">    sigA = (isDenormA ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>) + sigA;</span><br><span class="line">    sigB = (isDenormB ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>) + sigB;</span><br><span class="line">    sigA = sigA + <span class="string">&quot;000&quot;</span>;</span><br><span class="line">    sigB = sigB + <span class="string">&quot;000&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.模拟运算得到中间结果</span></span><br><span class="line">    <span class="comment">// 符号位</span></span><br><span class="line">    <span class="type">char</span> <span class="variable">signResult</span> <span class="operator">=</span> (signA == signB) ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="comment">// 阶码（相加-127）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expAInt</span> <span class="operator">=</span> Integer.parseInt(expA, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">expBInt</span> <span class="operator">=</span> Integer.parseInt(expB, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">expResultInt</span> <span class="operator">=</span> expAInt + expBInt - <span class="number">127</span>;</span><br><span class="line">    <span class="comment">// 尾数（相乘）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sigResult</span> <span class="operator">=</span> multiply27Bit(sigA, sigB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.规格化</span></span><br><span class="line">    <span class="comment">//由于两个操作数的隐藏位均为1位，所以乘积的隐藏位为2位。</span></span><br><span class="line">    <span class="comment">//需要通过阶码加1的方式来间接实现小数点的左移，修正这个误差，以保证尾数的隐藏位均为1位。</span></span><br><span class="line">    expResultInt++;</span><br><span class="line">    <span class="comment">// 4.1尾数规格化</span></span><br><span class="line">     <span class="comment">// 54位尾数的隐藏位为0且阶码大于0</span></span><br><span class="line">    <span class="keyword">while</span> (sigResult.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; expResultInt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sigResult = leftShift(sigResult, <span class="number">1</span>);</span><br><span class="line">        expResultInt--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阶码小于0且54位尾数的前27位不全为0</span></span><br><span class="line">    <span class="keyword">while</span> (expResultInt &lt; <span class="number">0</span> &amp;&amp; !sigResult.substring(<span class="number">0</span>, <span class="number">27</span>).equals(<span class="string">&quot;000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">        sigResult = rightShift(sigResult, <span class="number">1</span>);</span><br><span class="line">        expResultInt++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.2阶码规格化</span></span><br><span class="line">    <span class="comment">// 阶码为&quot;11111111&quot;，发生阶码上溢</span></span><br><span class="line">    <span class="keyword">if</span> (expResultInt &gt;= <span class="number">255</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(signResult + <span class="string">&quot;11111111&quot;</span> + <span class="string">&quot;00000000000000000000000&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阶码为0,说明运算得到了非规格化数，此时应该将尾数额外右移一次，使其符合非规格化数的规范</span></span><br><span class="line">    <span class="keyword">if</span> (expResultInt == <span class="number">0</span>) &#123;</span><br><span class="line">        sigResult = rightShift(sigResult, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阶码仍小于0，发生阶码下溢</span></span><br><span class="line">    <span class="keyword">if</span> (expResultInt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(signResult + <span class="string">&quot;00000000&quot;</span> + <span class="string">&quot;00000000000000000000000&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.舍入</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">expResult</span> <span class="operator">=</span> String.format(<span class="string">&quot;%8s&quot;</span>, Integer.toBinaryString(expResultInt)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">finalResult</span> <span class="operator">=</span> round(signResult, expResult, sigResult);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(finalResult);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左移</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">leftShift</span><span class="params">(String operand, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(operand);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        result.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 27位无符号数乘法</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">multiply27Bit</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">27</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">resultLen</span> <span class="operator">=</span> <span class="number">54</span>;</span><br><span class="line">    <span class="type">int</span>[] numA = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    <span class="type">int</span>[] numB = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[resultLen];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字符串转换为int数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        numA[i] = a.charAt(len - <span class="number">1</span> - i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        numB[i] = b.charAt(len - <span class="number">1</span> - i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐位相乘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            result[i + j] += numA[i] * numB[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; resultLen - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        result[i + <span class="number">1</span>] += result[i] / <span class="number">2</span>;</span><br><span class="line">        result[i] %= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结果转换为字符串</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">resultStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> resultLen - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        resultStr.append(result[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resultStr.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、除法"><a href="#四、除法" class="headerlink" title="四、除法"></a>四、除法</h2><h3 id="27位无符号数除法"><a href="#27位无符号数除法" class="headerlink" title="27位无符号数除法"></a>27位无符号数除法</h3><ol>
<li>输入参数：(dest&#x2F;src)<ul>
<li><code>src</code>：<strong>除数</strong>，是一个27位的二进制字符串。</li>
<li><code>dest</code>：<strong>被除数</strong>，是一个27位的二进制字符串。</li>
</ul>
</li>
<li>初始化：<ul>
<li>quotientReg：存储<strong>商</strong>，初始化为<strong>空 StringBuilder</strong>。</li>
<li>divisorReg：<strong>除数</strong>，<strong>前面加上一个零</strong>，成为28位二进制字符串。</li>
<li>remainderReg_str：<strong>余数</strong>，初始为<strong>被除数</strong>，<strong>前面加一个零</strong>，成为28位二进制字符串。</li>
</ul>
</li>
</ol>
<ul>
<li>注：此处与补码除法<strong>不同</strong>，<strong>补码的商被初始化为被除数</strong></li>
</ul>
<ol start="3">
<li>特殊情况处理：<ul>
<li>如果 src 为零，抛出 ArithmeticException 异常。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 dest 为零，返回全零的商。</li>
</ul>
</li>
<li>主循环（长除法核心）：<ul>
<li>循环 27 次，每次执行以下操作：</li>
</ul>
<ol>
<li><strong>比较余数和除数</strong>：<ul>
<li><strong>够减</strong>：如果<strong>余数大于或等于除数</strong>，<strong>商补1</strong>，并<strong>余数减去除数</strong>。</li>
<li><strong>不够减</strong>：如果<strong>余数小于除数</strong>，<strong>商补0</strong>。</li>
</ul>
</li>
<li><strong>余数左移一位</strong>，为下一次操作准备新的余数。</li>
</ol>
</li>
<li>返回商：<ul>
<li>循环结束后，商的二进制结果存储在 quotientReg 中，并返回。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">div27Bit</span><span class="params">(String src, String dest)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">quotientReg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();<span class="comment">//商</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">divisorReg</span> <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span> + src; <span class="comment">// 除数</span></span><br><span class="line">       String remainderReg_str; <span class="comment">// 余数</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (src.equals(<span class="string">&quot;000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dest.equals(<span class="string">&quot;000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;000000000000000000000000000&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       remainderReg_str = <span class="string">&#x27;0&#x27;</span> + dest; <span class="comment">// 余数初始化为被除数（与有符号数不同）</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">27</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (remainderReg_str.compareTo(divisorReg)&gt;=<span class="number">0</span>) &#123; <span class="comment">// 够减（大于等于0）</span></span><br><span class="line">               remainderReg_str = Sub27(divisorReg, remainderReg_str);</span><br><span class="line">               quotientReg.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               quotientReg.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           remainderReg_str = remainderReg_str.substring(<span class="number">1</span>) + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 左移余数</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> quotientReg.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-处理边界情况-NaN-0-INF-1"><a href="#1-处理边界情况-NaN-0-INF-1" class="headerlink" title="1.  处理边界情况 (NaN, 0, INF)"></a>1.  处理边界情况 (NaN, 0, INF)</h3><ul>
<li>NaN：如果其中一个操作数是 NaN，则结果也为 NaN。</li>
<li>除数为零：<ul>
<li>如果除数为零，且被除数不为零，则抛出异常。</li>
<li>如果被除数和除数都为零，则结果为 NaN。</li>
</ul>
</li>
<li>无穷除以无穷：结果为 NaN。</li>
<li>0 除以非零数：结果为 0。</li>
</ul>
<h3 id="2-提取符号、阶码、尾数-1"><a href="#2-提取符号、阶码、尾数-1" class="headerlink" title="2. 提取符号、阶码、尾数"></a>2. 提取符号、阶码、尾数</h3><ol>
<li>符号位：1位</li>
<li>阶码：8位<ul>
<li>如果为<strong>全1（即 255），返回正&#x2F;负无穷</strong>。</li>
<li>如果<strong>为全0，则表示非规格化数</strong>。需要将<strong>阶码加1</strong>，使其真实值变为1，以确保后续运算不会出错。</li>
</ul>
</li>
<li>尾数：</li>
</ol>
<ul>
<li>隐藏位的处理：<ul>
<li>规格化数：尾数的最高有效位为1。</li>
<li>非规格化数：尾数的最高有效位为<strong>0</strong>。</li>
</ul>
</li>
<li>尾数的位数应为27位（隐藏位+23+3个保护位）。</li>
</ul>
<h3 id="3-模拟运算得到中间结果-1"><a href="#3-模拟运算得到中间结果-1" class="headerlink" title="3. 模拟运算得到中间结果"></a>3. 模拟运算得到中间结果</h3><ol>
<li>符号位：两个操作数符号相同，则结果为正，反之为负。</li>
<li>阶码的处理（除法）：<strong>被除数阶码-除数阶码+127</strong></li>
<li>尾数的处理：对尾数进行27位无符号数除法运算：<ul>
<li>通过模拟 27 位无符号数的除法（使用除法算法，参考先前提到的除法步骤）</li>
<li>得到的<strong>商</strong>尾数<strong>仍然是 27 位</strong>。</li>
<li>已经符合了“1位隐藏位+23位有效位+3位保护位”的要求，所以<strong>不再需要额外的操作</strong></li>
</ul>
</li>
</ol>
<h3 id="4-规格化并舍入后返回-1"><a href="#4-规格化并舍入后返回-1" class="headerlink" title="4. 规格化并舍入后返回"></a>4. 规格化并舍入后返回</h3><ul>
<li>与乘法相同</li>
</ul>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">div</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.处理边界情况(NaN, 0, INF)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cornerResult</span> <span class="operator">=</span> cornerCheck(divCorner, src.toString(), dest.toString());</span><br><span class="line">        <span class="keyword">if</span> (cornerResult != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(cornerResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> src.toString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a.matches(IEEE754Float.NaN_Regular) || b.matches(IEEE754Float.NaN_Regular)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.NaN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 额外判断除数为0且被除数不为0的情况,抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!a.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>) &amp;&amp; b.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;Divide by zero&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.提取符号、阶码、尾数</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">signA</span> <span class="operator">=</span> a.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="type">char</span> <span class="variable">signB</span> <span class="operator">=</span> b.charAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">expA</span> <span class="operator">=</span> a.substring(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">expB</span> <span class="operator">=</span> b.substring(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sigA</span> <span class="operator">=</span> a.substring(<span class="number">9</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sigB</span> <span class="operator">=</span> b.substring(<span class="number">9</span>);</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="comment">// 2.1当有一个操作数提取出的阶码为全1时，应该返回正负无穷。</span></span><br><span class="line">        <span class="keyword">if</span> (expA.equals(<span class="string">&quot;11111111&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (signA == signB) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.P_INF);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.N_INF);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (expB.equals(<span class="string">&quot;11111111&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (signB == signA) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.P_INF);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.N_INF);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.2当提取出的阶码为全0时，是一个非规格化数，此时应该对阶码+1使其真实值变为1，以保证后面的对阶操作不会出错</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDenormA</span> <span class="operator">=</span> expA.equals(<span class="string">&quot;00000000&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDenormB</span> <span class="operator">=</span> expB.equals(<span class="string">&quot;00000000&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (isDenormA) &#123;</span><br><span class="line">            expA = <span class="string">&quot;00000001&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isDenormB) &#123;</span><br><span class="line">            expB = <span class="string">&quot;00000001&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不要忘记尾数的最前面添加上隐藏位，规格化数为1，非规格化数为0。所以提取结束后尾数的位数应该等于1+23+3=27。</span></span><br><span class="line">        sigA = (isDenormA ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>) + sigA;</span><br><span class="line">        sigB = (isDenormB ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>) + sigB;</span><br><span class="line">        sigA = sigA + <span class="string">&quot;000&quot;</span>;</span><br><span class="line">        sigB = sigB + <span class="string">&quot;000&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.模拟运算得到中间结果</span></span><br><span class="line">        <span class="comment">// 符号位</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">signResult</span> <span class="operator">=</span> (signA == signB) ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="comment">// 阶码（被除数-除数+127）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expAInt</span> <span class="operator">=</span> Integer.parseInt(expA, <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">expBInt</span> <span class="operator">=</span> Integer.parseInt(expB, <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">expResultInt</span> <span class="operator">=</span> expAInt - expBInt + <span class="number">127</span>;</span><br><span class="line">        <span class="comment">// 尾数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sigResult</span> <span class="operator">=</span> div27Bit(sigB, sigA);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.规格化</span></span><br><span class="line">        <span class="comment">// 4.1尾数规格化</span></span><br><span class="line">        <span class="comment">// 尾数的隐藏位为0且阶码大于0</span></span><br><span class="line">        <span class="keyword">while</span> (sigResult.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; expResultInt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sigResult = leftShift(sigResult, <span class="number">1</span>);</span><br><span class="line">            expResultInt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阶码小于0且尾数的前27位不全为0</span></span><br><span class="line">        <span class="keyword">while</span> (expResultInt &lt; <span class="number">0</span> &amp;&amp; !sigResult.substring(<span class="number">0</span>, <span class="number">27</span>).equals(<span class="string">&quot;000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">            sigResult = rightShift(sigResult, <span class="number">1</span>);</span><br><span class="line">            expResultInt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.2阶码规格化</span></span><br><span class="line">        <span class="comment">// 阶码为&quot;11111111&quot;，发生阶码上溢，返回无穷</span></span><br><span class="line">        <span class="keyword">if</span> (expResultInt &gt;= <span class="number">255</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(signResult + <span class="string">&quot;11111111&quot;</span> + <span class="string">&quot;00000000000000000000000&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阶码为0,说明运算得到了非规格化数，此时应该将尾数额外右移一次，使其符合非规格化数的规范</span></span><br><span class="line">        <span class="keyword">if</span> (expResultInt == <span class="number">0</span>) &#123;</span><br><span class="line">            sigResult = rightShift(sigResult, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阶码仍小于0，发生阶码下溢，返回0</span></span><br><span class="line">        <span class="keyword">if</span> (expResultInt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(signResult + <span class="string">&quot;00000000&quot;</span> + <span class="string">&quot;00000000000000000000000&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.舍入</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">expResult</span> <span class="operator">=</span> String.format(<span class="string">&quot;%8s&quot;</span>, Integer.toBinaryString(expResultInt)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">finalResult</span> <span class="operator">=</span> round(signResult, expResult, sigResult);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(finalResult);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>4-cache</title>
    <url>/2025/02/22/4.cache/</url>
    <content><![CDATA[<h1 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h1><h2 id="一、通用映射策略"><a href="#一、通用映射策略" class="headerlink" title="一、通用映射策略"></a>一、通用映射策略</h2><h3 id="1-fetch"><a href="#1-fetch" class="headerlink" title="1.fetch"></a>1.fetch</h3><ol>
<li>由已有函数计算<strong>块号</strong></li>
<li>用map函数查看是否命中</li>
<li>如果命中则返回行号rowNO</li>
<li>未命中则将数据从内存读到cache,再返回更新的rowNO：<ol>
<li>用Memory读出数据data[]<ul>
<li>注意read()读的是<strong>二进制字符串</strong></li>
<li>模拟从0开始，因此<strong>读的起始位置</strong>是<strong>块号乘一行（一个块）的大小</strong>，转成二进制</li>
<li>读出的数据大小也是块的大小（<strong>块大小&#x3D;行大小</strong>）</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">beginAddr</span> <span class="operator">=</span> Transformer.intToBinary(String.valueOf(blockNO*LINE_SIZE_B));</span><br><span class="line"><span class="type">byte</span>[] data=Memory.getMemory().read(beginAddr,LINE_SIZE_B);</span><br></pre></td></tr></table></figure></li>
<li>计算<strong>tag</strong>（该组内分配给这个块的次序）</li>
</ol>
<ul>
<li>注意<strong>tag为26位的二进制</strong>！！</li>
<li><strong>blockNO&#x2F;SETS</strong>,<strong>块号&#x2F;组数</strong></li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">char</span>[] calculateTag(<span class="type">int</span> blockNO)&#123;</span><br><span class="line">    <span class="type">int</span> tag=blockNO/SETS;</span><br><span class="line">    <span class="keyword">return</span> Transformer.intToBinary(<span class="string">&quot;&quot;</span> + tag).substring(<span class="number">6</span>, <span class="number">32</span>).toCharArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>根据映射策略<ol>
<li>为<strong>直接映射</strong>：<strong>行数&#x3D;组数</strong>：(CACHE_SIZE_B &#x2F; LINE_SIZE_B)&#x3D;&#x3D;SETS<ul>
<li>调用cache的<strong>update</strong>函数</li>
<li>行号&#x3D;块号%行数（组数）</li>
<li><strong>return rowNO</strong></li>
</ul>
</li>
<li>为<strong>组关联映射</strong>，调用<strong>替换策略的replace函数</strong><ul>
<li>组号&#x3D;块号mod组数。<code>int groupNO=blockNO%SETS;</code></li>
<li>起始行&#x3D;组号<em>每组行数.&#96;&#96;int start&#x3D; groupNO</em>setSize;&#96;&#96;</li>
<li>结束行*（闭区间）*.<code>int end = (groupNO+1)*setSize-1;</code></li>
<li><strong>return this.replacementStrategy.replace(start,end,tag,data);</strong></li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="2-map"><a href="#2-map" class="headerlink" title="2. map"></a>2. map</h3><ul>
<li>参量：块号blockNO</li>
</ul>
<ol>
<li>计算<strong>组号</strong>:<em>blockNO%SETS</em></li>
<li>计算<strong>tag</strong>: <em>char[] tag&#x3D;calculateTag(blockNO);</em></li>
<li>在组范围内查找是否命中：三个条件：<strong>非空，有效，tag相同</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">map</span><span class="params">(<span class="type">int</span> blockNO)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">groupNO</span> <span class="operator">=</span> blockNO % SETS;           <span class="comment">// 获得内存地址blockNO所对应的组号setNO</span></span><br><span class="line">    <span class="type">char</span>[] addrTag = calculateTag(blockNO);   <span class="comment">// 获得内存地址blockNO所对应的tag</span></span><br><span class="line">    <span class="comment">//在组范围内查找是否命中</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> groupNO * setSize;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> (groupNO + <span class="number">1</span>) * setSize - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//非空+有效+tag相同</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheInstance.isMatch(i, addrTag)) &#123;   <span class="comment">// 命中该行</span></span><br><span class="line">            replacementStrategy.hit(i);</span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">// 返回该行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>命中后，调用替换策略hit函数，返回行号</strong></li>
</ol>
<ul>
<li><code>replacementStrategy.hit(i);</code></li>
</ul>
<ol start="5">
<li>否则，返回-1</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(<span class="type">int</span> rowNO, <span class="type">char</span>[] tag)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.cache[rowNO] == <span class="literal">null</span>) &#123;<span class="comment">//空,false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.cache[rowNO].validBit) &#123;<span class="comment">//不有效,false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.equals(<span class="built_in">this</span>.cache[rowNO].tag, tag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-update"><a href="#3-update" class="headerlink" title="3.update"></a>3.update</h3><ul>
<li>用于更新cache</li>
</ul>
<ol start="2">
<li>更新当前cache行有效位true，visit初始化为1，时间戳设置成当前时间，更新tag和data</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> rowNO, <span class="type">char</span>[] tag, <span class="type">byte</span>[] input)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    cache[rowNO].validBit=<span class="literal">true</span>;</span><br><span class="line">    cache[rowNO].visited = <span class="number">1</span>;</span><br><span class="line">    cache[rowNO].timeStamp = System.currentTimeMillis();</span><br><span class="line">    cache[rowNO].tag=tag;</span><br><span class="line">    cache[rowNO].data=input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、替换策略的实现"><a href="#二、替换策略的实现" class="headerlink" title="二、替换策略的实现"></a>二、替换策略的实现</h2><ul>
<li>对于FIFO策略，你应该需要用到CacheLine中的timeStamp字段，记录每一行进入Cache的时间。</li>
<li>对于LFU策略，你应该需要用到CacheLine中的visited字段，记录每一行被使用的次数。</li>
<li>对于LRU策略，你应该需要用到CacheLine中的timeStamp字段，记录每一行最后被访问时间。</li>
<li><strong>替换后</strong>先判断<strong>是否要写回</strong>，再<strong>更新cache</strong>，再<strong>返回行号</strong></li>
</ul>
<h3 id="1-先入先出FIFO"><a href="#1-先入先出FIFO" class="headerlink" title="1.先入先出FIFO"></a>1.先入先出FIFO</h3><ul>
<li><strong>不用写hit</strong>。</li>
<li>replace替换最小时间戳<strong>timeStamp</strong></li>
</ul>
<ol>
<li>初始化<ul>
<li>把最早时间戳设为long的最大值：long oldestTimestamp &#x3D; Long.MAX_VALUE;</li>
<li>把最早行号设为-1： int oldestRow &#x3D; -1;</li>
</ul>
</li>
<li>找最早时间和对应行号</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> Cache.getCache().getTimeStamp(i);<span class="comment">// 获取时间戳</span></span><br><span class="line">    <span class="keyword">if</span> (timestamp &lt; oldestTimestamp) &#123;<span class="comment">// 如果[时间戳]&lt;[最早时间戳]</span></span><br><span class="line">        oldestTimestamp = timestamp;<span class="comment">// 更新[最早时间戳]</span></span><br><span class="line">            oldestRow = i;<span class="comment">// 更新[最早行号]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在Cache中添加getTimeStamp()<ul>
<li>注意，必须是<strong>有效行</strong>的时间戳才有意义！</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTimeStamp</span><span class="params">(<span class="type">int</span> rowNO)</span>&#123;</span><br><span class="line">    <span class="type">CacheLine</span> <span class="variable">cacheLine</span> <span class="operator">=</span> cache[rowNO];</span><br><span class="line">    <span class="keyword">if</span> (cacheLine.validBit) &#123;<span class="comment">//必须有效</span></span><br><span class="line">        <span class="keyword">return</span> cacheLine.timeStamp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>判断是否要写回</strong>——<strong>脏位是否为true+是否有效valid</strong><ul>
<li>getDirty方法</li>
<li><strong>calculatePAddr</strong>方法</li>
<li>Memory的write方法</li>
</ul>
</li>
</ol>
<ul>
<li><strong>calculatePAddr</strong><ol>
<li>标签（Tag）：用于唯一标识一个数据块。</li>
<li>组号（Set Index）：用于确定数据块在缓存中的哪一组。<ul>
<li>转换为二进制字符串，并截取其最后 offset 位：因为offset&#x3D;组号位数</li>
</ul>
</li>
<li>块内偏移（Block Offset）：用于确定数据在缓存行中的具体位置。<ul>
<li><strong>SETS（组数）的二进制位数</strong></li>
</ul>
</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由行号获取内存实际地址</span></span><br><span class="line"><span class="comment">// 内存实际地址=tag位+组号+block offset块内偏移</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">calculatePAddr</span><span class="params">(<span class="type">int</span> rowNO)</span> &#123;</span><br><span class="line">    <span class="comment">//计算偏移量 (offset)： （计算 SETS 的二进制位数）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; SETS; i *= <span class="number">2</span>) &#123;</span><br><span class="line">        offset++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算组号 (setNo)：</span></span><br><span class="line">    <span class="comment">//将组号转换为二进制字符串，并截取其最后 offset 位。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">setNo</span> <span class="operator">=</span> Transformer.intToBinary(<span class="string">&quot;&quot;</span> + rowNO / setSize).substring(<span class="number">32</span> - offset, <span class="number">32</span>);</span><br><span class="line">    <span class="comment">//获取标签 (tag)：</span></span><br><span class="line">    <span class="type">char</span>[] tag = cache[rowNO].tag;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(tag).substring(offset, tag.length) + setNo + <span class="string">&quot;000000&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>更新cache<ul>
<li>Cache.getCache().<strong>update</strong>(oldestRow, addrTag, input);</li>
<li>Cache.getCache().<strong>setTimeStamp</strong>(oldestRow);</li>
<li><strong>现在</strong>时间戳：<strong>System.currentTimeMillis()</strong></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTimeStamp</span><span class="params">(<span class="type">int</span> rowNO)</span> &#123;</span><br><span class="line">    cache[rowNO].timeStamp = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>返回行号</li>
</ol>
<h3 id="2-最近不经常使用LFU"><a href="#2-最近不经常使用LFU" class="headerlink" title="2. 最近不经常使用LFU"></a>2. 最近不经常使用LFU</h3><ul>
<li>hit中将visit+1。replace替换最少使用次数<br>1.hit: <strong>Cache.getCache().addVisited(rowNO);</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// LFU算法增加访问次数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addVisited</span><span class="params">(<span class="type">int</span> rowNO)</span>&#123;</span><br><span class="line">    cache[rowNO].visited++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>replace：<ol>
<li>遍历找最小访问次数行</li>
<li>检查写回</li>
<li>update</li>
<li>返回行数</li>
</ol>
</li>
</ol>
<ul>
<li>获取访问次数,也必须是<strong>有效</strong>的！！</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVisited</span><span class="params">(<span class="type">int</span> rowNO)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cache[rowNO].validBit)&#123;</span><br><span class="line">        <span class="keyword">return</span> cache[rowNO].visited;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-最近最少用算法-LRU"><a href="#3-最近最少用算法-LRU" class="headerlink" title="3. 最近最少用算法 LRU"></a>3. 最近最少用算法 LRU</h3><ul>
<li>hit更新时间戳。replace替换最小时间戳</li>
</ul>
<ol>
<li>hit:每次被访问，都更新时间戳<ul>
<li><code>Cache.getCache().setTimeStamp(rowNO);</code></li>
</ul>
</li>
<li>replace:<ol>
<li>遍历找该组中最小时间戳</li>
<li>检查写回</li>
<li>update</li>
<li>返回行数</li>
</ol>
</li>
</ol>
<h2 id="三、写策略的实现"><a href="#三、写策略的实现" class="headerlink" title="三、写策略的实现"></a>三、写策略的实现</h2><ul>
<li>涉及到cache往主存写数据的只有两个地方：<ul>
<li>write函数直接向cache写数据时</li>
<li>replace函数需要替换掉一行数据时</li>
</ul>
</li>
<li>在write函数和replace函数的相应地方对isWriteBack字段判断，然后根据具体策略来做不同的事情</li>
<li>写直达策略就是在<strong>write函数完成写cache后直接修改主存</strong>；</li>
<li>写回策略就是在write函数完成写cache后<strong>设置好脏位</strong>，并<strong>在replace函数将要替换掉该行的时候将该行写回内存</strong></li>
<li>在Cache类中编写一个<strong>根据行号计算物理地址的方法</strong></li>
</ul>
<h3 id="1-写直达策略"><a href="#1-写直达策略" class="headerlink" title="1. 写直达策略"></a>1. 写直达策略</h3><ul>
<li>isWriteBack为false。</li>
<li>在<code>write</code>里如果为写直达，直接修改主存,参数为当前rowNO对应的pAddr，行大小，上面所得的cache_data</li>
</ul>
<h3 id="2-写回策略"><a href="#2-写回策略" class="headerlink" title="2.写回策略"></a>2.写回策略</h3><ul>
<li>isWriteBack为true。</li>
<li>在<code>write</code>里如果为写回，设置好<strong>dirty位</strong></li>
<li>在三个<strong>替换策略</strong>里，如果<ol>
<li><strong>为写回</strong>,</li>
<li>如果替换行<strong>脏位为true</strong></li>
<li>如果替换行<strong>有效</strong></li>
</ol>
<ul>
<li>则<strong>写入内存</strong>。参数：替换行所对应的pAddr，行大小，替换行的data </li>
<li>（在update之前完成）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//write</span></span><br><span class="line"><span class="keyword">if</span> (isWriteBack) &#123;<span class="comment">//写回，设置好dirty位</span></span><br><span class="line">    cache[rowNO].dirty = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//写直达，直接修改主存</span></span><br><span class="line">    Memory.getMemory().write(calculatePAddr(rowNO), Cache.LINE_SIZE_B, cache_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//替换策略中</span></span><br><span class="line"><span class="keyword">if</span> (Cache.isWriteBack) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Cache.getCache().getDirty(minIndex) &amp;&amp; Cache.getCache().isValid(minIndex)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">addr</span> <span class="operator">=</span> Cache.getCache().calculatePAddr(minIndex);</span><br><span class="line">        Memory.getMemory().write(addr, Cache.LINE_SIZE_B, Cache.getCache().getData(minIndex));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-一个根据行号计算物理地址的方法"><a href="#3-一个根据行号计算物理地址的方法" class="headerlink" title="3. 一个根据行号计算物理地址的方法"></a>3. 一个根据行号计算物理地址的方法</h3><ol>
<li>标签（Tag）：用于唯一标识一个数据块。</li>
<li>组号（Set Index）：用于确定数据块在缓存中的哪一组。<ul>
<li>setNo &#x3D; <strong>行号&#x2F;每组行数</strong></li>
<li>转换为<strong>二进制字符串</strong>，并<strong>截取其最后 offset 位：因为offset&#x3D;组号位数</strong></li>
</ul>
</li>
<li>块内偏移（Block Offset）：用于确定数据在缓存行中的具体位置。<ul>
<li>等于<strong>SETS（组数）的二进制位数</strong></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由行号获取内存实际地址</span></span><br><span class="line"><span class="comment">// 内存实际地址=tag位+组号+block offset块内偏移</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">calculatePAddr</span><span class="params">(<span class="type">int</span> rowNO)</span> &#123;</span><br><span class="line">    <span class="comment">//计算偏移量 (offset)： （计算 SETS 的二进制位数）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; SETS; i *= <span class="number">2</span>) &#123;</span><br><span class="line">        offset++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算组号 (setNo)：</span></span><br><span class="line">    <span class="comment">//将组号转换为二进制字符串，并截取其最后 offset 位。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">setNo</span> <span class="operator">=</span> Transformer.intToBinary(<span class="string">&quot;&quot;</span> + rowNO / setSize).substring(<span class="number">32</span> - offset, <span class="number">32</span>);</span><br><span class="line">    <span class="comment">//获取标签 (tag)：</span></span><br><span class="line">    <span class="type">char</span>[] tag = cache[rowNO].tag;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(tag).substring(offset, tag.length) + setNo + <span class="string">&quot;000000&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="1-获取时间戳-访问次数"><a href="#1-获取时间戳-访问次数" class="headerlink" title="1. 获取时间戳&#x2F;访问次数"></a>1. 获取时间戳&#x2F;访问次数</h3><ul>
<li>先判断有不有效！无效返回-1，否则返回时间戳&#x2F;次数</li>
</ul>
<h3 id="2-时间戳更新：System-currentTimeMillis"><a href="#2-时间戳更新：System-currentTimeMillis" class="headerlink" title="2.时间戳更新：System.currentTimeMillis();"></a>2.时间戳更新：System.currentTimeMillis();</h3>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>5-磁盘</title>
    <url>/2025/02/22/5.%E7%A3%81%E7%9B%98/</url>
    <content><![CDATA[<h1 id="COA5-磁盘"><a href="#COA5-磁盘" class="headerlink" title="COA5 磁盘"></a>COA5 磁盘</h1><ul>
<li>外部存储器——磁盘的模拟。</li>
<li>工作主要集中在模拟磁头结构</li>
<li>Disk.java		# 磁盘类，需要修改</li>
<li>Scheduler.java	# 磁盘调度算法类，需要修改</li>
<li>注：磁盘存储容量 ＝ 磁头数 × 磁道(柱面)数 × 每道扇区数 × 每扇区字节数</li>
<li>读写方法中接收的addr参数，是<em>二进制</em>表示的<em>该数据起始位置</em>在<em>虚拟磁盘文件中的字节数</em></li>
<li>seek方法表示每次数据读写之前将磁头移动到指定位置，addPoint表示将磁头往后移动一个字节</li>
</ul>
<h1 id="一、-Disk"><a href="#一、-Disk" class="headerlink" title="一、 Disk"></a>一、 Disk</h1><ul>
<li>结合read和write方法的源码，理解seek方法和addPoint方法在其中起到什么作用，然后实现这两个方法。</li>
<li>注意，由于我们规定该磁盘有8个磁头即8个盘面，所以每个盘面的大小为8MB。<strong>在不同盘面上，磁头的位置都是相同的</strong>（具体可以看ppt上的图）。因此，在我们的模拟规则下，<em>第0个字节、第8MB个字节、第16MB个字节（以此类推），它们的磁头位置都应该是相同的</em>。</li>
</ul>
<h2 id="1-seek"><a href="#1-seek" class="headerlink" title="1. seek"></a>1. seek</h2><ul>
<li>用来将<strong>磁盘的指针移动到指定的 addr 地址</strong></li>
</ul>
<ol>
<li>将指针<strong>point移动到start位置</strong></li>
<li>计算start所在的<strong>扇区数——指针sector</strong><ul>
<li><strong>当前字节数 &#x2F; 每扇区字节数</strong></li>
</ul>
</li>
<li>计算start所在的<strong>磁道数——指针track</strong><ul>
<li><strong>当前扇区数 &#x2F; 每磁道扇区数</strong></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.point=start;</span><br><span class="line"><span class="built_in">this</span>.sector=start/BYTE_PER_SECTOR;<span class="comment">//起始点/每扇区字节数，得start对应的总扇区数</span></span><br><span class="line"><span class="built_in">this</span>.track=<span class="built_in">this</span>.sector/SECTOR_PER_TRACK;<span class="comment">//总扇区数/每磁道扇区数，得到磁道数</span></span><br></pre></td></tr></table></figure>
<h2 id="2-addPoint"><a href="#2-addPoint" class="headerlink" title="2. addPoint"></a>2. addPoint</h2><ol>
<li>将磁头<strong>往后移动一个字节</strong>,<code>point++</code>。</li>
<li>如果指针移动到<strong>当前扇区的末尾（512字节）</strong>，则<strong>重置point为0，并移动到下一个扇区</strong>。<ul>
<li>point&#x3D;0</li>
<li>sector++</li>
</ul>
</li>
<li>如果扇区移动到<strong>当前磁道的末尾（64个扇区）</strong>，则<strong>重置扇区并移动到下一个磁道</strong>。<ul>
<li>sector&#x3D;0</li>
<li>track++</li>
</ul>
</li>
<li>如果磁道移动到<strong>磁盘的末尾（磁道数）</strong>，则<strong>重置磁道号为0</strong>，即<em>磁头回到磁盘的起始位置</em>。<ul>
<li>track&#x3D;0;</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">this</span>.point++;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span>.point==<span class="number">512</span>)&#123;</span><br><span class="line">    <span class="built_in">this</span>.point=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.sector++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span>.sector==<span class="number">64</span>)&#123;</span><br><span class="line">    <span class="built_in">this</span>.sector=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.track++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.track == TRACK_NUM) &#123;<span class="comment">//如果磁道号等于【磁道数】，则重置磁道号为0，即磁头回到磁盘的起始位置</span></span><br><span class="line">    <span class="built_in">this</span>.track = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二、Scheduler"><a href="#二、Scheduler" class="headerlink" title="二、Scheduler"></a>二、Scheduler</h1><ul>
<li>每个方法都会传入<strong>磁头初始磁道号</strong>与<strong>请求访问的磁道号数组</strong></li>
<li>需要计算出<strong>平均寻道长度</strong>并返回</li>
</ul>
<h2 id="1-先来先服务算法FCFS"><a href="#1-先来先服务算法FCFS" class="headerlink" title="1.先来先服务算法FCFS"></a>1.先来先服务算法FCFS</h2><ul>
<li>先请求的先进行</li>
</ul>
<ol>
<li>初始化<ul>
<li>总路程为0</li>
<li>当前磁道号为start</li>
</ul>
</li>
<li>遍历整个request<ul>
<li>总路程累加</li>
<li>当前磁道号变化</li>
</ul>
</li>
<li>最后返回 总路程 &#x2F; 请求length</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">FCFS</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] request)</span> &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="type">int</span> sumdistance=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> currentTrack=start;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;request.length;i++)&#123;</span><br><span class="line">        sumdistance+=Math.abs(request[i]-currentTrack);</span><br><span class="line">        currentTrack=request[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)sumdistance/request.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-最短寻道时间优先算法-SSTF"><a href="#2-最短寻道时间优先算法-SSTF" class="headerlink" title="2.最短寻道时间优先算法 SSTF"></a>2.最短寻道时间优先算法 SSTF</h2><ul>
<li>优先处理<strong>起始位置与当前磁头位置最接近</strong>的读写任务</li>
</ul>
<ol>
<li>初始化<ul>
<li>sumDistance：总寻道距离，初始为0。</li>
<li>currentTrack：当前磁头所在的磁道号，初始为 start。</li>
<li>n：请求数组的长度。</li>
<li><strong>visited</strong>：记录每个请求<strong>是否被访问过</strong>，初始为 false。</li>
</ul>
</li>
<li>遍历请求：<ul>
<li><strong>外层循环</strong>：遍历 n 次，每次<strong>找到一个最接近当前磁头位置的请求</strong>。</li>
<li><strong>内层循环</strong>：<strong>遍历所有请求</strong>，找到<strong>距离当前磁头位置最近</strong>且<strong>未被访问过</strong>的请求。</li>
</ul>
</li>
<li>更新状态：<ul>
<li><strong>标记</strong>找到的请求visited为<strong>true</strong>。</li>
<li><strong>累加</strong>最短距离到 sumDistance。</li>
<li><strong>更新 currentTrack</strong> 为找到的请求位置。</li>
</ul>
</li>
<li>返回平均寻道长度：<ul>
<li>返回 sumDistance 除以请求数组的长度。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">SSTF</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] request)</span> &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sumDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">currentTrack</span> <span class="operator">=</span> start;<span class="comment">//当前磁头所在的磁道号</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> request.length;</span><br><span class="line">    <span class="type">boolean</span>[] visited=<span class="keyword">new</span> <span class="title class_">boolean</span>[n];<span class="comment">//是否访问过</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">closest</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">//最接近当前磁头位置的请求 下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minDistance</span> <span class="operator">=</span> Integer.MAX_VALUE;<span class="comment">//每一次先初始化为最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;<span class="comment">//遍历找最短距离</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[j]&amp;&amp;Math.abs(currentTrack-request[j])&lt;minDistance)&#123;<span class="comment">//没被访问过+距离最近</span></span><br><span class="line">                minDistance=Math.abs(currentTrack-request[j]);</span><br><span class="line">                closest=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到，更新</span></span><br><span class="line">        visited[closest]=<span class="literal">true</span>;</span><br><span class="line">        sumDistance+=minDistance;</span><br><span class="line">        currentTrack=request[closest];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)sumDistance/request.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-扫描算法-SCAN"><a href="#3-扫描算法-SCAN" class="headerlink" title="3. 扫描算法 SCAN"></a>3. 扫描算法 SCAN</h2><ul>
<li>总是按照<strong>一个方向</strong>进行磁盘调度，直到该方向上的<strong>边缘</strong>，然后<strong>改变方向</strong></li>
<li>磁道总数，这个数字需要与Disk类中的TRACK_NUM保持一致。（256）</li>
<li><code>Arrays.sort(request);</code> 对请求数组进行<strong>升序排序</strong></li>
</ul>
<ol>
<li>初始化：<ul>
<li>sumDistance：总寻道距离，初始为0。</li>
<li>n：请求数组的长度。</li>
<li><strong>对请求数组进行升序排序</strong>：Arrays.sort(request);。</li>
</ul>
</li>
<li>判断初始移动方向：(题上说了true是增大方向)<ol>
<li>如果 <code>direction</code> 为 true，表示初始移动方向是<em>增大</em>方向。<ul>
<li>start &lt;&#x3D; request[0]，表示磁头在<strong>最小请求之前</strong>，直接移动到<strong>最大请求位置</strong>。<ul>
<li>易错：不是直接移动到磁道最后！</li>
</ul>
</li>
<li>start <strong>在请求数组中间</strong>，先移动到<strong>磁道最大</strong>位置(<code>255</code>)，再返回到<strong>最小请求</strong>位置。</li>
</ul>
</li>
<li>如果 direction 为 false，表示初始移动方向是<em>减小</em>方向。<ul>
<li>start &gt;&#x3D; request[n - 1]，表示磁头在<strong>最大请求之后</strong>，直接移动到<strong>最小请求位置</strong>。</li>
<li>start 在请求数组中间，先移动到<strong>磁道最小</strong>位置，再返回到<em>最大请求</em>位置。</li>
</ul>
</li>
</ol>
</li>
<li>返回平均寻道长度：<ul>
<li>返回 sumDistance 除以请求数组的长度。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">SCAN</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] request, <span class="type">boolean</span> direction)</span> &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sumDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> request.length;</span><br><span class="line">    Arrays.sort(request);<span class="comment">//升序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(direction)&#123;<span class="comment">//初始移动方向是增大方向</span></span><br><span class="line">        <span class="keyword">if</span>(start&lt;=request[<span class="number">0</span>])&#123;</span><br><span class="line">            sumDistance+=request[n-<span class="number">1</span>]-start;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//在中间</span></span><br><span class="line">            sumDistance+=(<span class="number">255</span>-start)+(<span class="number">255</span>-request[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//初始移动方向是减小方向</span></span><br><span class="line">        <span class="keyword">if</span>(start&gt;=request[n-<span class="number">1</span>])&#123;</span><br><span class="line">            sumDistance+=start-request[<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sumDistance+=start+request[n-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)sumDistance/n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-C-SCAN算法：默认磁头向磁道号增大方向移动"><a href="#4-C-SCAN算法：默认磁头向磁道号增大方向移动" class="headerlink" title="4. C-SCAN算法：默认磁头向磁道号增大方向移动"></a>4. C-SCAN算法：默认磁头向磁道号增大方向移动</h2><ul>
<li>只有磁头朝某个方向移动时才会响应请求，<strong>移动到边缘后立即让磁头返回起点</strong>，返回途中不做任何处理</li>
</ul>
<ol>
<li>初始化<ul>
<li>sumDistance：总寻道距离，初始为0。</li>
<li>currentTrack：当前磁头所在的磁道号，初始为 start。</li>
<li>n：请求数组的长度。</li>
<li>对请求数组进行升序排序：Arrays.sort(request);。</li>
</ul>
</li>
<li><strong>查找当前磁头位置</strong>：<ul>
<li>使用 <strong>Arrays.binarySearch(request, currentTrack)</strong> 查找<strong>当前磁头位置在请求数组中的索引</strong>。</li>
<li>如果未找到，计算当前磁头位置应该插入的位置：index &#x3D; -index - 1。</li>
</ul>
</li>
<li>初始移动方向是增大方向：<ul>
<li>如果 start &lt;&#x3D; request[0]，表示磁头<strong>在最小请求之前</strong>，直接移动到<strong>最大请求</strong>位置。</li>
<li>如果 start <strong>在请求数组中间或者右边</strong>，先移动到<strong>磁道最大</strong>位置，再<strong>返回到起点</strong>，然后<strong>移动到start前一个位置</strong>。<ul>
<li>易错：路径记得<strong>加上磁道最右到最左距离</strong>！</li>
</ul>
</li>
</ul>
</li>
<li>返回平均寻道长度</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">CSCAN</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span>[] request)</span>&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sumDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> request.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">currentTrack</span> <span class="operator">=</span> start;<span class="comment">//当前磁头所在的磁道号</span></span><br><span class="line">    Arrays.sort(request);<span class="comment">//升序</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(request, currentTrack);<span class="comment">//查找当前磁头位置在请求中的索引</span></span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span>)&#123;<span class="comment">//如果当前磁头位置不在请求中</span></span><br><span class="line">        index = -index-<span class="number">1</span>;<span class="comment">//计算当前磁头位置应该插入的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始移动方向是增大方向</span></span><br><span class="line">        <span class="keyword">if</span>(start&lt;=request[<span class="number">0</span>])&#123;</span><br><span class="line">            sumDistance+=request[n-<span class="number">1</span>]-start;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//在中间 或者 右边</span></span><br><span class="line">            sumDistance+=(<span class="number">255</span>-start)+<span class="number">255</span>+(request[index-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)sumDistance/n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-LOOK算法"><a href="#5-LOOK算法" class="headerlink" title="5.LOOK算法"></a>5.LOOK算法</h2><ul>
<li>SCAN算法的升级，只要磁头移动方向上不再有请求就<strong>立即改变磁头的方向</strong></li>
</ul>
<ol>
<li>初始化：<ul>
<li>sumDistance：总寻道距离，初始为0。</li>
<li>n：请求数组的长度。</li>
<li><strong>对请求数组进行升序排序：Arrays.sort(request);</strong></li>
</ul>
</li>
<li>查找当前磁头位置：<ul>
<li>使用 <strong>Arrays.binarySearch(request, start)</strong> 查找当前磁头位置在请求数组中的索引。</li>
<li>如果<strong>未找到，返回一个负数</strong>，该负数的<strong>绝对值减一</strong>即为<strong>start 应该插入的位置</strong>。<ul>
<li>计算当前磁头位置应该插入的位置：<code>index = -index - 1。</code></li>
</ul>
</li>
</ul>
</li>
<li>判断初始移动方向：<ol>
<li>如果 direction 为 true，表示初始移动方向是<strong>增大</strong>方向。<ul>
<li>从 <strong>index</strong> 开始向右遍历请求数组，累加距离。<ul>
<li><code>sumDistance += Math.abs(currentTrack - request[i])</code>;</li>
</ul>
</li>
<li>然后从 <strong>index - 1</strong> 开始向左遍历请求数组，累加距离。</li>
</ul>
</li>
<li>如果 direction 为 false，表示初始移动方向是<strong>减小</strong>方向。<ul>
<li>从 <strong>index - 1</strong> 开始向左遍历请求数组，累加距离。</li>
<li>然后从 <strong>index</strong> 开始向右遍历请求数组，累加距离。</li>
</ul>
</li>
</ol>
</li>
</ol>
<ul>
<li>返回平均寻道长度</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">LOOK</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span>[] request,<span class="type">boolean</span> direction)</span>&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sumDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> request.length;</span><br><span class="line">    Arrays.sort(request);<span class="comment">//升序</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(request, start);<span class="comment">//查找当前磁头位置在请求中的索引</span></span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span>)&#123;<span class="comment">//如果当前磁头位置不在请求中</span></span><br><span class="line">        index = -index-<span class="number">1</span>;<span class="comment">//计算当前磁头位置应该插入的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(direction)&#123;<span class="comment">//初始移动方向是增大方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; n; i++) &#123;</span><br><span class="line">            sumDistance += Math.abs(start - request[i]);</span><br><span class="line">            start = request[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            sumDistance += Math.abs(start - request[i]);</span><br><span class="line">            start = request[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//初始移动方向是减小方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            sumDistance += Math.abs(start - request[i]);</span><br><span class="line">            start = request[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;  i &lt;n; i++) &#123;</span><br><span class="line">            sumDistance += Math.abs(start - request[i]);</span><br><span class="line">            start = request[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)sumDistance/n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-C-LOOK算法"><a href="#6-C-LOOK算法" class="headerlink" title="6.C-LOOK算法"></a>6.C-LOOK算法</h2><ul>
<li><strong>默认</strong>磁头向磁道号<strong>增大方向</strong>移动</li>
<li>C-SCAN算法的改进，只要在磁头移动方向上<strong>不再有请求</strong>，就立即让磁头<strong>返回起点</strong></li>
</ul>
<ol>
<li>初始化<ul>
<li>sumDistance：总寻道距离，初始为0。</li>
<li>currentTrack：当前磁头所在的磁道号，初始为 start。</li>
<li>n：请求数组的长度。</li>
<li>对请求数组进行<strong>升序排序：Arrays.sort(request);</strong>。</li>
</ul>
</li>
<li><strong>查找当前磁头位置</strong>：<ul>
<li>使用 <strong>Arrays.binarySearch(request, currentTrack)</strong> 查找<strong>当前磁头位置在请求数组中的索引</strong>。</li>
<li>如果未找到，计算当前磁头位置应该插入的位置：<strong>index &#x3D; -index - 1。</strong></li>
</ul>
</li>
<li>初始移动方向是增大方向：<ul>
<li>从 index 开始向右遍历请求数组，累加距离。</li>
<li>然后从 0 开始向右遍历到 index - 1，累加距离。</li>
</ul>
</li>
<li>返回平均寻道长度</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">CLOOK</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span>[] request)</span>&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sumDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> request.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">currentTrack</span> <span class="operator">=</span> start;<span class="comment">//当前磁头所在的磁道号</span></span><br><span class="line">    Arrays.sort(request);<span class="comment">//升序</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(request, currentTrack);<span class="comment">//查找当前磁头位置在请求中的索引</span></span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span>)&#123;<span class="comment">//如果当前磁头位置不在请求中</span></span><br><span class="line">        index = -index-<span class="number">1</span>;<span class="comment">//计算当前磁头位置应该插入的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始移动方向是增大方向</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=index;i&lt;n;i++)&#123;</span><br><span class="line">        sumDistance+=Math.abs(currentTrack-request[i]);</span><br><span class="line">        currentTrack=request[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;=index-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        sumDistance+=Math.abs(currentTrack-request[i]);</span><br><span class="line">        currentTrack=request[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)sumDistance/n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>7-控制器</title>
    <url>/2025/02/22/7.%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<h1 id="COA7-控制器"><a href="#COA7-控制器" class="headerlink" title="COA7 控制器"></a>COA7 控制器</h1><ul>
<li>完成tick方法，在每个时钟周期内根据ICC的状态进行对应操作</li>
<li>完成取指、间址、执行、中断四种操作</li>
</ul>
<h1 id="一、tick"><a href="#一、tick" class="headerlink" title="一、tick"></a>一、tick</h1><h2 id="1-时钟周期的实现"><a href="#1-时钟周期的实现" class="headerlink" title="1. 时钟周期的实现"></a>1. 时钟周期的实现</h2><ul>
<li>每个时钟周期中，我们需要完成三件事：<ol>
<li><strong>判断ICC中内容</strong>，得到当前处于哪个时钟周期</li>
<li>执行对应周期的<strong>指令微操作</strong>序列</li>
<li>根据指令执行情况<strong>判断ICC的下一个状态</strong></li>
</ol>
</li>
<li>ICC是一个2位的寄存器</li>
</ul>
<h3 id="00-取指"><a href="#00-取指" class="headerlink" title="00:取指"></a>00:取指</h3><ol>
<li>调用取指getInstruct();</li>
<li>判断下一步（间址 &#x2F; 执行）<ol>
<li>如果opcode为<strong>1101110</strong>，把ICC设为01，间址</li>
<li>不是的话，ICC设为10，执行</li>
</ol>
</li>
</ol>
<ul>
<li>注意1：<strong>IR是指令寄存器</strong>（Instruction Register），<em>取指后指令存在IR</em>。</li>
<li>注意2：<strong>opcode</strong>为指令的<strong>前8位</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ICC[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;ICC[<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">    getInstruct();</span><br><span class="line">    <span class="comment">//判断是否进入间址周期</span></span><br><span class="line">    <span class="comment">//额外规定一种间址指令addc，opcode为1101110</span></span><br><span class="line">    <span class="type">char</span>[] opcode=Arrays.copyOfRange(IR,<span class="number">0</span>,<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span> <span class="title class_">String</span>(opcode).equals(<span class="string">&quot;1101110&quot;</span>))&#123;</span><br><span class="line">        ICC[<span class="number">1</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ICC[<span class="number">0</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="01：间址"><a href="#01：间址" class="headerlink" title="01：间址"></a>01：间址</h3><ol>
<li>调用间址findOperand();</li>
<li>ICC设为10，执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ICC[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;ICC[<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">    findOperand();</span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    ICC[<span class="number">0</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    ICC[<span class="number">1</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10：执行"><a href="#10：执行" class="headerlink" title="10：执行"></a>10：执行</h3><ol>
<li>调用执行</li>
<li><strong>判断是否允许中断</strong>：（中断 &#x2F; 取指）<ul>
<li>通过<code>interruptController.signal</code>是否为true判断</li>
</ul>
<ol>
<li>中断则11</li>
<li>否则00，取指</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ICC[<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;ICC[<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">    operate();</span><br><span class="line">    <span class="comment">//是否允许中断</span></span><br><span class="line">    <span class="keyword">if</span>(interruptController.signal)&#123;</span><br><span class="line">        ICC[<span class="number">1</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ICC[<span class="number">0</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11：中断"><a href="#11：中断" class="headerlink" title="11：中断"></a>11：中断</h3><ol>
<li>执行中断</li>
<li>设为00，取指</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ICC[<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;ICC[<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">    interrupt();</span><br><span class="line">    <span class="comment">//设为00，取值</span></span><br><span class="line">    ICC[<span class="number">0</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    ICC[<span class="number">1</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-取指微操作序列"><a href="#2-取指微操作序列" class="headerlink" title="2. 取指微操作序列"></a>2. 取指微操作序列</h2><ol>
<li>将PC中的内容加载到MAR<ul>
<li><code>Arrays.copyOf(PC,32);</code></li>
</ul>
</li>
<li>根据MAR中保存的地址，读取memory中对应内容到MBR（请注意memory中读出的数据是byte数组类型，而寄存器类型是char数组）<ul>
<li>有给出的函数<code>getFromMemory(new String(MAR));</code></li>
</ul>
</li>
<li>增加PC到下一条指令的位置（此时PC应该加上多少？为什么？考虑指令的长度）<ul>
<li>PC<strong>加4</strong>（32位&#x3D;4字节）</li>
<li>用alu.add</li>
</ul>
</li>
<li>将MBR中的内容装载到IR中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getInstruct</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    MAR=Arrays.copyOf(PC,<span class="number">32</span>);</span><br><span class="line">    MBR=getFromMemory(<span class="keyword">new</span> <span class="title class_">String</span>(MAR));</span><br><span class="line"></span><br><span class="line">    String nextPC=alu.add(<span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="keyword">new</span> <span class="title class_">String</span>(PC)),<span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="string">&quot;00000000000000000000000000000100&quot;</span>)).toString();</span><br><span class="line">    PC=nextPC.toCharArray();</span><br><span class="line"></span><br><span class="line">    IR=Arrays.copyOf(MBR,<span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-间址周期的实现"><a href="#3-间址周期的实现" class="headerlink" title="3. 间址周期的实现"></a>3. 间址周期的实现</h2><ol>
<li>将<strong>rs2中的内容</strong>加载到MAR中<ul>
<li><strong>rs2: IR中的20~24位</strong></li>
<li>rs2中的内容：<strong>GPR[rs2]</strong><ul>
<li>化为int：<code>int rs2_int=getRegister(rs2);</code></li>
<li>读<strong>GPR[rs2_int]</strong></li>
</ul>
</li>
</ul>
</li>
<li>根据<strong>MAR中的地址</strong>读出内存中对应数据存回rs2中<ul>
<li>MAR中的地址:<code>getFromMemory()</code></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findOperand</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="comment">//1. 将rs2中的内容加载到MAR中</span></span><br><span class="line">        <span class="comment">//rs2：20到24位</span></span><br><span class="line">    <span class="type">char</span>[] rs2=Arrays.copyOfRange(IR,<span class="number">20</span>,t25);</span><br><span class="line">    <span class="type">int</span> rs2_int=getRegister(rs2);</span><br><span class="line">    MAR=Arrays.copyOf(GPR[rs2_int],<span class="number">32</span>);</span><br><span class="line">    <span class="comment">//2. 根据MAR中的地址读出内存中对应数据存回rs2中</span></span><br><span class="line">    GPR[rs2_int]=getFromMemory(<span class="keyword">new</span> <span class="title class_">String</span>(MAR));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-执行周期的实现"><a href="#4-执行周期的实现" class="headerlink" title="4. 执行周期的实现"></a>4. 执行周期的实现</h2><ul>
<li>根据不同的opcode进行不同的操作</li>
<li>add指令可以调用ALU中已经实现好的加法进行</li>
<li>对应结果存到相应的位置中</li>
<li>特殊关注：<ul>
<li>jalr: 保存并跳转指令。在改变PC之前，我们要先将返回的位置保存到ra寄存器中，我们规定GPR的第1个寄存器是返回地址寄存器（第0个GPR寄存器保存0）</li>
<li>ecall: 系统调用中断指令。同样要保存返回位置，同时要设置中断控制器。</li>
</ul>
</li>
<li>寄存器和立即数的下标在指令中为了方便处理采用大端存储的方式，即从低到高直接截取转化为十进制即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="type">char</span>[] opcode=Arrays.copyOfRange(IR,<span class="number">0</span>,<span class="number">7</span>);</span><br><span class="line">    String opcode_str=<span class="keyword">new</span> <span class="title class_">String</span>(opcode);</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1100110&quot;</span>))&#123;<span class="comment">//add</span></span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1110110&quot;</span>))&#123;<span class="comment">//lui</span></span><br><span class="line">        lui();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1100000&quot;</span>))&#123;<span class="comment">//lw</span></span><br><span class="line">        lw();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1100100&quot;</span>))&#123;<span class="comment">//addi</span></span><br><span class="line">        addi();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1101110&quot;</span>))&#123;<span class="comment">//addc但是add</span></span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1110011&quot;</span>))&#123;<span class="comment">//jalr</span></span><br><span class="line">        jalr();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1100111&quot;</span>))&#123;<span class="comment">//ecall</span></span><br><span class="line">        ecall();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><ul>
<li><strong>rs1:15-19位</strong></li>
<li><strong>rs2:20-24位</strong></li>
<li><strong>rd:7-11</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//rs1:15-19位</span></span><br><span class="line">    <span class="comment">//rs2:20-24位</span></span><br><span class="line">    <span class="comment">//rd:7-11</span></span><br><span class="line">    <span class="type">char</span>[] rs1=Arrays.copyOfRange(IR,<span class="number">15</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="type">char</span>[] rs2=Arrays.copyOfRange(IR,<span class="number">20</span>,<span class="number">25</span>);</span><br><span class="line">    <span class="type">char</span>[] rd =Arrays.copyOfRange(IR,<span class="number">7</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rs1_num=getRegister(rs1);</span><br><span class="line">    <span class="type">int</span> rs2_num=getRegister(rs2);</span><br><span class="line">    <span class="type">int</span> rd_num=getRegister(rd);</span><br><span class="line"></span><br><span class="line">    GPR[rd_num]=alu.add(<span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="keyword">new</span> <span class="title class_">String</span>(GPR[rs1_num])),<span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="keyword">new</span> <span class="title class_">String</span>(GPR[rs2_num]))).toString().toCharArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lui：将12-31位的20位立即数加载到目标寄存器的高20位，低12位全0"><a href="#lui：将12-31位的20位立即数加载到目标寄存器的高20位，低12位全0" class="headerlink" title="lui：将12-31位的20位立即数加载到目标寄存器的高20位，低12位全0"></a>lui：将12-31位的20位立即数加载到目标寄存器的高20位，低12位全0</h3><ul>
<li>将一个 <strong>20 位的立即数</strong>加载到<strong>寄存器的高 20 位</strong>，而<strong>低 12 位则被置为 0</strong></li>
<li><strong>rd:7-11位</strong></li>
<li><strong>imm：12-31位</strong></li>
<li><strong>int IMM&#x3D;Integer.valueOf(String.valueOf(imm_num),2)&lt;&lt;12</strong>;<ul>
<li><code>String.valueOf(imm_num)</code>：将 imm_num 转换为字符串。</li>
<li><code>Integer.valueOf(String.valueOf(imm_num), 2)</code>：将上一步得到的字符串<strong>作为二进制数解析</strong>，并转换为一个<strong>整数</strong>。这里的 <strong>2 表示二进制</strong>。</li>
<li><code>&lt;&lt; 12</code>：将解析得到的整数<strong>左移 12 位</strong>。左移 12 位相当于将该整数乘以 2 的 12 次方（4096），这<strong>会将原来的低 12 位置为 0，并将高 20 位保留</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lui</span><span class="params">()</span>&#123;<span class="comment">//将一个 20 位的立即数加载到寄存器的高 20 位，而低 12 位则被置为 0</span></span><br><span class="line">    <span class="comment">//rd:7-11</span></span><br><span class="line">    <span class="comment">//imm:12-31</span></span><br><span class="line">    <span class="type">char</span>[] rd=Arrays.copyOfRange(IR,<span class="number">7</span>,<span class="number">12</span>);</span><br><span class="line">    <span class="type">char</span>[] imm=Arrays.copyOfRange(IR,<span class="number">12</span>,<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rd_num=getRegister(rd);</span><br><span class="line">    <span class="type">int</span> imm_num=getRegister(imm);</span><br><span class="line">    <span class="type">int</span> IMM=Integer.valueOf(String.valueOf(imm_num),<span class="number">2</span>)&lt;&lt;<span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    GPR[rd_num]=Transformer.intToBinary(String.valueOf(IMM)).toCharArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lw：基址寄存器内的值-偏移量得到新地址，将新地址内的值存到目标寄存器中"><a href="#lw：基址寄存器内的值-偏移量得到新地址，将新地址内的值存到目标寄存器中" class="headerlink" title="lw：基址寄存器内的值+偏移量得到新地址，将新地址内的值存到目标寄存器中"></a>lw：基址寄存器内的值+偏移量得到新地址，将新地址内的值存到目标寄存器中</h3><ol>
<li>提取指令字段<ul>
<li>基址寄存器rs1：15-19位</li>
<li>立即数（偏移量）imm：20-31位</li>
<li>目标寄存器rd：7-11位</li>
</ul>
</li>
<li>获取寄存器编号：getRegister()</li>
<li>计算<strong>新内存地址</strong>offset<ul>
<li>将 imm 转换为二进制整数 IMM。（变string，再string变二进制int）</li>
<li>将基址寄存器 GPR[rs1_num] 的值转换为二进制整数 RS1。</li>
<li>计算内存地址 offset，即 IMM 加上 RS1。</li>
</ul>
</li>
<li>从内存中读取数据<ul>
<li>使用 <code>Transformer.intToBinary</code> 方法将 offset 转换为二进制字符串。</li>
<li>调用 <code>getFromMemory</code> 方法从内存中读取数据，并将其存储到目标寄存器 GPR[rd_num] 中。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lw</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//rs1:15-19位</span></span><br><span class="line">    <span class="comment">//imm：20-31位</span></span><br><span class="line">    <span class="comment">//rd:7-11位</span></span><br><span class="line">    <span class="type">char</span>[] rs1=Arrays.copyOfRange(IR,<span class="number">15</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="type">char</span>[] imm=Arrays.copyOfRange(IR,<span class="number">20</span>,<span class="number">32</span>);</span><br><span class="line">    <span class="type">char</span>[] rd =Arrays.copyOfRange(IR,<span class="number">7</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rs1_num=getRegister(rs1);</span><br><span class="line">    <span class="type">int</span> rd_num=getRegister(rd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> IMM=Integer.valueOf(String.valueOf(imm),<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> RS1=Integer.valueOf(String.valueOf(GPR[rs1_num]),<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> offset=IMM+RS1;</span><br><span class="line"></span><br><span class="line">    GPR[rd_num]=getFromMemory(Transformer.intToBinary(String.valueOf(offset)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="addi-源寄存器内的值-偏移量，存入目标寄存器"><a href="#addi-源寄存器内的值-偏移量，存入目标寄存器" class="headerlink" title="addi 源寄存器内的值+偏移量，存入目标寄存器"></a>addi 源寄存器内的值+偏移量，存入目标寄存器</h3><ol>
<li>提取指令字段<ul>
<li>源寄存器rs1：15-19位</li>
<li>立即数（偏移量）imm：20-31位</li>
<li>目标寄存器rd：7-11位</li>
</ul>
</li>
<li>获取寄存器编号：getRegister()</li>
<li>计算<em>立即数</em>和<em>源寄存器内数据</em>的值，转换为<strong>二进制整数</strong></li>
<li>计算结果：立即数+源寄存器内数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addi</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//rs1:15-19位</span></span><br><span class="line">    <span class="comment">//imm：20-31位</span></span><br><span class="line">    <span class="comment">//rd:7-11位</span></span><br><span class="line">    <span class="type">char</span>[] rs1=Arrays.copyOfRange(IR,<span class="number">15</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="type">char</span>[] imm=Arrays.copyOfRange(IR,<span class="number">20</span>,<span class="number">32</span>);</span><br><span class="line">    <span class="type">char</span>[] rd =Arrays.copyOfRange(IR,<span class="number">7</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rs1_num=getRegister(rs1);</span><br><span class="line">    <span class="type">int</span> rd_num=getRegister(rd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> IMM=Integer.valueOf(String.valueOf(imm),<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> RS1=Integer.valueOf(String.valueOf(GPR[rs1_num]),<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=IMM+RS1;</span><br><span class="line"></span><br><span class="line">    GPR[rd_num]=Transformer.intToBinary(String.valueOf(res)).toCharArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="addc：直接add（间址）"><a href="#addc：直接add（间址）" class="headerlink" title="addc：直接add（间址）"></a>addc：直接add（间址）</h3><h3 id="jalr：保存当前程序计数器（PC）的值到返回地址寄存器（ra），然后跳转到新的地址"><a href="#jalr：保存当前程序计数器（PC）的值到返回地址寄存器（ra），然后跳转到新的地址" class="headerlink" title="jalr：保存当前程序计数器（PC）的值到返回地址寄存器（ra），然后跳转到新的地址"></a>jalr：保存当前程序计数器（PC）的值到返回地址寄存器（ra），然后跳转到新的地址</h3><ul>
<li>在<strong>改变PC之前</strong>，我们要先<strong>将返回的位置保存到ra寄存器</strong>中，我们<strong>规定GPR的第1个寄存器是返回地址寄存器</strong>（第0个GPR寄存器保存0）</li>
</ul>
<ol>
<li>提取指令字段<ul>
<li>基质寄存器rs1：15-19位</li>
<li>立即数（偏移量）imm：20-31位</li>
<li>返回地址寄存器ra：7-11位a</li>
</ul>
</li>
<li>获取寄存器编号</li>
<li>计算立即数IMM和基址寄存器内数RS1的值(化为二进制整数)</li>
<li>计算<strong>新地址</strong>，即 <strong>IMM 加上 RS1</strong></li>
<li><strong>保存当前 PC 到ra，并跳转到新地址</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jalr</span><span class="params">()</span>&#123;<span class="comment">//保存并跳转指令</span></span><br><span class="line">    <span class="comment">//rs1:15-19位</span></span><br><span class="line">    <span class="comment">//imm：20-31位</span></span><br><span class="line">    <span class="comment">//ra:7-11位</span></span><br><span class="line">    <span class="type">char</span>[] rs1=Arrays.copyOfRange(IR,<span class="number">15</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="type">char</span>[] imm=Arrays.copyOfRange(IR,<span class="number">20</span>,<span class="number">32</span>);</span><br><span class="line">    <span class="type">char</span>[] ra =Arrays.copyOfRange(IR,<span class="number">7</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rs1_num=getRegister(rs1);</span><br><span class="line">    <span class="type">int</span> ra_num=getRegister(ra);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> IMM=Integer.valueOf(String.valueOf(imm),<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> RS1=Integer.valueOf(String.valueOf(GPR[rs1_num]),<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> newAddr=IMM+RS1;</span><br><span class="line"></span><br><span class="line">    GPR[ra_num]=Arrays.copyOf(PC,<span class="number">32</span>);</span><br><span class="line">    PC=Transformer.intToBinary(String.valueOf(newAddr)).toCharArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ecall：系统调用中断指令。保存当前程序计数器（PC）的值，并设置中断控制器。"><a href="#ecall：系统调用中断指令。保存当前程序计数器（PC）的值，并设置中断控制器。" class="headerlink" title="ecall：系统调用中断指令。保存当前程序计数器（PC）的值，并设置中断控制器。"></a>ecall：系统调用中断指令。保存当前程序计数器（PC）的值，并设置中断控制器。</h3><ul>
<li>规定GPR的第1个寄存器是返回地址寄存器</li>
</ul>
<ol>
<li>PC保存到GPR[1]中</li>
<li>中断信号设置为true</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ecall</span><span class="params">()</span>&#123;<span class="comment">//系统调用中断指令。同样要保存返回位置，同时要设置中断控制器。</span></span><br><span class="line">    interruptController.signal=<span class="literal">true</span>;</span><br><span class="line">    GPR[<span class="number">1</span>]=Arrays.copyOf(PC,<span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-中断"><a href="#5-中断" class="headerlink" title="5. 中断"></a>5. 中断</h2><ul>
<li>使用ecall指令来模拟中断操作。在中断发生时，系统要保存程序的返回位置（是多少？），以便完成中断处理程序后返回原有程序。</li>
</ul>
<ol>
<li>此处我们使用<strong>handleInterrupt</strong>来模拟中断程序的实现。</li>
<li>执行完中断操作后，将<strong>允许中断位改为false</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    interruptController.handleInterrupt();</span><br><span class="line">    interruptController.signal=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>PA1实验记录</title>
    <url>/2025/02/25/PA1%E5%AE%9E%E9%AA%8C%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h1 id="PA1-实验报告"><a href="#PA1-实验报告" class="headerlink" title="PA1 实验报告"></a>PA1 实验报告</h1><h2 id="2024-9-13"><a href="#2024-9-13" class="headerlink" title="2024.9.13"></a>2024.9.13</h2><h1 id="开始PA1之旅！"><a href="#开始PA1之旅！" class="headerlink" title="开始PA1之旅！"></a>开始PA1之旅！</h1><p>首先试着玩了超级玛丽，测试了按键，一切ok！</p>
<h3 id="ccache："><a href="#ccache：" class="headerlink" title="ccache："></a>ccache：</h3><ul>
<li>配置：在.bashrc中设置环境变量：<code>export PATH=/user/lib/ccache:$PATH</code>,然后重新打开终端</li>
<li>刚开始失败了，发现问题是我在ccache后面又加了&#x2F;ggc</li>
<li>先清除编译结果, 然后重新编译并统计时间。你会发现这次编译时间反而比之前要更长一些, 这是因为除了需要开展正常的编译工作之外, ccache还需要花时间把目标文件存起来. 接下来再次清除编辑结果, 重新编译并统计时间, 你会发现第二次编译的速度有了非常明显的提升! 这说明ccache确实跳过了完全重复的编译过程, 发挥了加速的作用. 如果和多线程编译共同使用, 编译速度还能进一步加快!</li>
<li>时间变化：<code>58s——14s</code></li>
</ul>
<h3 id="NEMU是什么"><a href="#NEMU是什么" class="headerlink" title="NEMU是什么"></a>NEMU是什么</h3><p>我们可以把实现NEMU的过程看成是开发一个支付宝APP. 不同的是, 支付宝具备的是真实ATM机的功能, 是用来交易的; 而NEMU具备的是物理计算机系统的功能, 是用来执行程序的. 因此我们说, NEMU是一个<strong>用来执行其它程序的程序</strong>.</p>
<h3 id="ISA是什么"><a href="#ISA是什么" class="headerlink" title="ISA是什么"></a>ISA是什么</h3><ul>
<li>螺母和螺钉的例子（同规格才能匹配，使用）</li>
<li>程序&amp;计算机同理：如果一个程序要在特定架构的计算机上运行, 那么这个程序和计算机就必须符合同一套规范。</li>
</ul>
<p>因此, ISA的本质就是类似这样的规范. 所以ISA的存在形式既不是硬件电路, 也不是软件代码, 而是一本<strong>规范手册</strong>。</p>
<ul>
<li>选了<code>riscv32</code></li>
</ul>
<h2 id="2024-9-14"><a href="#2024-9-14" class="headerlink" title="2024.9.14"></a>2024.9.14</h2><h1 id="开天辟地的篇章"><a href="#开天辟地的篇章" class="headerlink" title="开天辟地的篇章"></a>开天辟地的篇章</h1><h3 id="什么是编程模型"><a href="#什么是编程模型" class="headerlink" title="什么是编程模型"></a>什么是编程模型</h3><p>编程模型是用于描述和组织计算机程序的一种抽象概念。它是指编程语言和相关工具的组合，用于表示程序的结构、行为和数据。编程模型提供了一种方式，使程序员能够实现特定的功能和逻辑，并将其转化为可执行的计算机程序。</p>
<p>常见的几种编程模型：<br> 1、并发模型，2、面向对象模型，3、函数式模型，4、逻辑编程模型</p>
<h3 id="最简单的计算机"><a href="#最简单的计算机" class="headerlink" title="最简单的计算机"></a>最简单的计算机</h3><ul>
<li>存储器-&gt;CPU（运行程序）-&gt;寄存器（暂时存储处理的数据）</li>
<li>PC程序计数器（指示要执行的指令的位置）-&gt; 指令（指示CPU工作）</li>
</ul>
<h3 id="必做：尝试理解计算机如何计算"><a href="#必做：尝试理解计算机如何计算" class="headerlink" title="必做：尝试理解计算机如何计算"></a>必做：尝试理解计算机如何计算</h3><ul>
<li>r1和r2是寄存器</li>
<li>r1用来存放加后的结果（当前和）</li>
<li>r2用来存放当前的加数（1——100逐个递增）</li>
<li>当r2&#x3D;100时已经加完，进入pc5,死循环</li>
</ul>
<h3 id="计算机是个状态机"><a href="#计算机是个状态机" class="headerlink" title="计算机是个状态机"></a>计算机是个状态机</h3><ul>
<li>一部分由所有<strong>时序逻辑部件(存储器, 计数器, 寄存器)</strong> 构成</li>
<li>另一部分则是剩余的<strong>组合逻辑部件(如加法器等)</strong></li>
<li>从状态机模型的视角来理解计算机的工作过程: 在每个时钟周期到来的时候, 计算机根据当前时序逻辑部件的状态, 在组合逻辑部件的作用下, 计算出并转移到下一时钟周期的新状态.</li>
</ul>
<p>那么程序呢？</p>
<h3 id="必做：从状态机视角理解程序运行"><a href="#必做：从状态机视角理解程序运行" class="headerlink" title="必做：从状态机视角理解程序运行"></a>必做：从状态机视角理解程序运行</h3><p>(0,x,x)-&gt;(1,0,x)-&gt;(2,0,0)-&gt;(3,0,1)-&gt;(4,1,1)-&gt;(3,1,2)-&gt;(4,3,2)-&gt;(3,3,3)-&gt;(4,6,3)-&gt;…-&gt;(3,4851,99)-&gt;(4,4950,99)-&gt;(3,4950,100)-&gt;(3,5050,100)</p>
<h2 id="2024-9-16"><a href="#2024-9-16" class="headerlink" title="2024.9.16"></a>2024.9.16</h2><h1 id="RTFSC"><a href="#RTFSC" class="headerlink" title="RTFSC"></a>RTFSC</h1><p>开始初探框架代码了，小紧张和好奇中</p>
<p>只关心和当前进度相关的模块！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ics2024</span><br><span class="line">├── abstract-machine   # 抽象计算机</span><br><span class="line">├── am-kernels         # 基于抽象计算机开发的应用程序</span><br><span class="line">├── fceux-am           # 红白机模拟器</span><br><span class="line">├── init.sh            # 初始化脚本</span><br><span class="line">├── Makefile           # 用于工程打包提交</span><br><span class="line">├── nemu               # NEMU</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure>
<p>目前只关注nemu子项目内容即可</p>
<p>NEMU主要由4模块组成：monitor, CPU, memory, 设备。</p>
<p>Monitor(监视器)模块</p>
<ul>
<li>是为了方便地监控客户计算机的运行状态而引入的. </li>
<li>它除了负责与GNU&#x2F;Linux进行交互(例如读入客户程序)之外, 还带有调试器的功能, 为NEMU的调试提供了方便的途径. </li>
<li>从概念上来说, monitor并不属于一个计算机的必要组成部分, 但对NEMU来说, 它是必要的基础设施.</li>
</ul>
<p>为了支持不同的ISA, 框架代码把NEMU分成两部分: </p>
<ul>
<li>NEMU把<code>ISA相关的代码</code>专门放在<code>nemu/src/isa/</code>目录下, 并通过nemu&#x2F;include&#x2F;isa.h提供ISA相关API的声明. (抽象的思想)</li>
<li>这样以后, nemu&#x2F;src&#x2F;isa&#x2F;之外的其它代码就展示了<code>NEMU的基本框架</code>.</li>
</ul>
<h2 id="配置系统和项目构建"><a href="#配置系统和项目构建" class="headerlink" title="配置系统和项目构建"></a>配置系统和项目构建</h2><h3 id="配置系统kconfig"><a href="#配置系统kconfig" class="headerlink" title="配置系统kconfig"></a>配置系统kconfig</h3><ul>
<li>位于<code>nemu/tools/kconfig</code>, 它来源于GNU&#x2F;Linux项目中的kconfig</li>
<li>定义了一套简单的语言，可以用来编写“配置描述文件”（文件名都为<code>Kconfig</code>）<ul>
<li>配置选项的属性（eg类型、默认值）</li>
<li>不同配置选项之间的关系</li>
<li>配置选项的层次关系</li>
</ul>
</li>
<li>目前只需要关注：<ul>
<li><code>nemu/include/generated/autoconf.h</code>, 阅读C代码时使用</li>
<li><code>nemu/include/config/auto.conf</code>, 阅读Makefile时使用</li>
</ul>
</li>
</ul>
<h3 id="项目构建和Makefile"><a href="#项目构建和Makefile" class="headerlink" title="项目构建和Makefile"></a>项目构建和Makefile</h3><p>NEMU的Makefile具备功能：</p>
<ul>
<li>与配置系统进行关联<ul>
<li>由于包含<code>nemu/include/config/auto.conf</code>, 与kconfig生成的变量进行关联. </li>
<li>所以当<code>make menuconfig</code>更改配置选项后，Makefile也可能变化</li>
</ul>
</li>
<li>文件列表（filelist）<br>通过文件列表 (filelist) 决定最终参与编译的源文件</li>
</ul>
<ol>
<li>定义变量：<ul>
<li>SRCS-y：候选的源文件集合。</li>
<li>SRCS-BLACKLIST-y：不参与编译的源文件黑名单集合。</li>
<li>DIRS-y：参与编译的目录集合，该目录下的所有文件都会被加入到 SRCS-y 中。</li>
<li>DIRS-BLACKLIST-y：不参与编译的目录集合，该目录下的所有文件都会被加入到 SRCS-BLACKLIST-y 中。</li>
</ul>
</li>
<li>filelist.mk 文件：<ul>
<li>在 nemu&#x2F;src 及其子目录下存在</li>
<li>这些文件会根据 menuconfig 的配置对上述 4 个变量进行维护。</li>
</ul>
</li>
<li>Makefile 包含所有 filelist.mk 文件：<ul>
<li>Makefile 会包含项目中的所有 filelist.mk 文件。</li>
<li>对上述 4 个变量的追加定义进行汇总。</li>
</ul>
</li>
<li>过滤源文件：<br>最终会过滤出<strong>在 SRCS-y 中但不在 SRCS-BLACKLIST-y 中的源文件</strong>，作为最终参与编译的源文件集合。</li>
<li>与 menuconfig 配置关联：<ul>
<li>这些变量还可以与    menuconfig 的配置结果中的布尔选项进行关联。</li>
<li>实现效果：在 menuconfig 中选中 TARGET_AM 时，nemu&#x2F;src&#x2F;monitor&#x2F;sdb 目录下的所有文件都不会参与编译。</li>
</ul>
</li>
</ol>
<h3 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h3><p>Makefile的编译规则在nemu&#x2F;scripts&#x2F;build.mk中定义:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(OBJ_DIR)/%.o: %.c</span><br><span class="line">  @echo + CC $&lt;</span><br><span class="line">  @mkdir -p $(dir $@)</span><br><span class="line">  @$(CC) $(CFLAGS) -c -o $@ $&lt;</span><br><span class="line">  $(call call_fixdep, $(@:.o=.d), $@)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>其中关于<code>$@</code>和<code>$&lt;</code>等符号的含义：<br>在 Makefile 中，<code>$@</code> 和 <code>$&lt;</code> 是<strong>自动变量</strong>，用于表示规则中的<strong>目标和依赖文件</strong>。具体含义如下：</p>
<ul>
<li><code>$@</code>：表示规则中的目标文件。eg, <code>$@</code> 表示 <code>$(OBJ_DIR)/%.o</code>，即目标对象文件。</li>
<li><code>$&lt;</code>：表示规则中的第一个依赖文件。eg，<code>$&lt; </code>表示<code> %.c</code>，即源文件。</li>
</ul>
</li>
<li><p>键入<code>make -nB</code>, 它会让make程序以”只输出命令但不执行”的方式强制构建目标. </p>
</li>
<li><p>由输出内容反推得到</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(CC) -&gt; gcc</span><br><span class="line">$@ -&gt; /home/user/ics2024/nemu/build/obj-riscv32-nemu-interpreter/src/utils/timer.o</span><br><span class="line">$&lt; -&gt; src/utils/timer.c</span><br><span class="line">$(CFLAGS) -&gt; 剩下的内容</span><br></pre></td></tr></table></figure>

<ul>
<li><code>$(CFLAGS)</code>的值：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-O2 -MMD -Wall -Werror -I/home/user/ics2024/nemu/include</span><br><span class="line">-I/home/user/ics2024/nemu/src/engine/interpreter </span><br><span class="line">-I/home/user/ics2024/nemu/src/isa/riscv32/include -O2    </span><br><span class="line">-D__GUEST_ISA__</span><br><span class="line">=riscv32</span><br></pre></td></tr></table></figure>
<pre><code>- 总结： $(CFLAGS) 的值是通过在 Makefile 中逐步添加各种编译选项、包含路径和宏定义等形成的。是一个在C编译过程中使用的变量，定义了编译器的选项和标志
</code></pre>
<h2 id="准备第一个客户程序"><a href="#准备第一个客户程序" class="headerlink" title="准备第一个客户程序"></a>准备第一个客户程序</h2><p>首先要用minitor把客户程序读入客户计算机中</p>
<h4 id="NEMU开始运行时："><a href="#NEMU开始运行时：" class="headerlink" title="NEMU开始运行时："></a>NEMU开始运行时：</h4><ul>
<li>调用<code>init_monitor()</code>函数</li>
<li>宏：一种预处理指令，它允许程序员定义一个名称，该名称可以代表一段代码或一个值。<ul>
<li><code>#define 宏名 替换文本</code></li>
</ul>
</li>
<li>在init_monitor()中使用函数调用的好处：<ul>
<li>代码可读性+代码复用+模块化+调试和维护+抽象和封装+减少代码耦合</li>
</ul>
</li>
<li>参数的处理过程<ul>
<li><code>parse_args()</code>中调用了一个你也许不太熟悉的函数<code>getopt_long()</code>。</li>
<li>框架代码通过它来对参数进行解析, 具体的行为可以查阅<code>man 3 getopt_long</code>.</li>
<li>getopt_long() 是一个用于<code>解析命令行选项</code>的函数，支持长选项和短选项。</li>
</ul>
</li>
<li>这些参数从哪来？<ul>
<li>参数是<code>从命令行传递给程序</code>的。</li>
<li>在 main 函数中，通过 argc 和 argv 获取这些参数。</li>
<li>使用 getopt_long 函数解析这些参数，并根据选项表 table 处理每个选项。</li>
</ul>
</li>
</ul>
<h4 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h4><p>monitor会调用<code>init_isa()</code>函数(在<code>nemu/src/isa/$ISA/init.c</code>中定义), 来进行一些<strong>ISA相关的初始化工作</strong>.</p>
<ol>
<li>将一个内置的客户程序读入到内存<br>BIOS（Basic Input&#x2F;Output System，基本输入输出系统）</li>
<li>初始化寄存器：restart()函数<br>把寄存器结构体CPU_state的定义放在nemu&#x2F;src&#x2F;isa&#x2F;$ISA&#x2F;include&#x2F;isa-def.h中, 并在nemu&#x2F;src&#x2F;cpu&#x2F;cpu-exec.c中定义一个全局变量cpu. 初始化寄存器的一个重要工作就是设置cpu.pc的初值, 我们需要将它设置成刚才加载客户程序的内存位置, 这样就可以让CPU从我们约定的内存位置开始执行客户程序了. 对于mips32和riscv32, 它们的0号寄存器总是存放0, 因此我们也需要对其进行初始化.</li>
</ol>
<ul>
<li>地址映射：mips32和riscv32的物理地址均从0x80000000开始. 因此对于mips32和riscv32, 其CONFIG_MBASE将会被定义成0x80000000.</li>
</ul>
<ol start="3">
<li>在nemu&#x2F;目录下编译并运行NEMU：<code>make run</code></li>
</ol>
<h4 id="练习：解决错误信息"><a href="#练习：解决错误信息" class="headerlink" title="练习：解决错误信息"></a>练习：解决错误信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">riscv32-nemu-interpreter: src/monitor/monitor.c:36: welcome: Assertion `0&#x27; failed.</span><br></pre></td></tr></table></figure>
<ul>
<li>删除或注释掉 src&#x2F;monitor&#x2F;monitor.c 文件中 welcome 函数中的 <code>assert(0); </code>这一行代码，并保存修改后的文件</li>
<li>回到nemu&#x2F;，重新编译NEMU<code>make</code></li>
<li><code>make run</code>运行NEMU</li>
</ul>
<h2 id="运行第一个客户程序"><a href="#运行第一个客户程序" class="headerlink" title="运行第一个客户程序"></a>运行第一个客户程序</h2><ol>
<li>在cmd_c()函数中, 调用cpu_exec()的时候传入了参数-1, 你知道这是什么意思吗?<ul>
<li>传入的参数 -1 通常表示让 CPU 执行无限多的指令，直到遇到某个停止条件（如断点或程序结束）。这是在模拟器中常见的一种用法，用于启动 CPU 并让其持续运行。</li>
</ul>
</li>
<li>NEMU将不断执行指令, 直到遇到以下情况之一, 才会退出指令执行的循环:<ul>
<li>达到要求的循环次数.</li>
<li>客户程序执行了<code>nemu_trap</code>指令。 riscv32的手册中, NEMU选择了<code>ebreak</code>指令来充当nemu_trap.</li>
</ul>
</li>
<li>为了表示客户程序是否成功结束, nemu_trap指令还会接收一个表示结束状态的参数，主要包括:<ul>
<li><code>HIT GOOD TRAP</code> - 客户程序正确地结束执行</li>
<li><code>HIT BAD TRAP</code> - 客户程序错误地结束执行</li>
<li><code>ABORT</code> - 客户程序意外终止, 并未结束执行</li>
</ul>
</li>
<li>当你看到NEMU输出类似以下的内容时(不同ISA的pc输出值会有所不同):</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nemu: HIT GOOD TRAP at pc = 0x8000000c</span><br></pre></td></tr></table></figure>
<p>说明客户程序已经成功地结束运行.<br>NEMU会在cpu_exec()函数的最后打印<code>执行的指令数目</code>和<code>花费的时间</code>, 并计算出<code>指令执行的频率</code>.</p>
<ol start="5">
<li><p>思考：谁来指示程序的结束?</p>
<p> 在程序设计课上老师告诉你, 当程序执行到main()函数返回处的时候, 程序就退出了, 你对此深信不疑. 但你是否怀疑过, 凭什么程序执行到main()函数的返回处就结束了? 如果有人告诉你, 程序设计课上老师的说法是错的, 你有办法来证明&#x2F;反驳吗?</p>
<ul>
<li>当 main() 函数返回时，实际上会<strong>调用 exit() 函数</strong>，exit() 函数会执行一些清理工作并通知操作系统程序已经完成。<strong>操作系统</strong>会进行一些清理工作，例如释放进程占用的资源，并将返回值传递给父进程（通常是 shell）。</li>
<li>(证明&#x2F;反驳) 通过查看标准库实现、使用调试器和编写自定义 exit() 函数，可以更深入地理解程序退出的机制。</li>
<li>返回值传递——&gt;调用exit()函数——&gt;操作系统接管</li>
</ul>
</li>
<li><p>代码中一些值得注意的地方</p>
</li>
</ol>
<ul>
<li>三个对调试有用的宏（在<code>nemu/include/debug.h</code>中定义）<ul>
<li><code>Log()</code>,是<code>printf()</code>的升级版。<strong>输出调试信息</strong>, 同时还会输出使用<strong>Log()所在的源文件, 行号和函数</strong>. 当输出的调试信息过多的时候, 可以很方便地<strong>定位</strong>到代码中的相关位置</li>
<li><code>Assert()</code>是<code>assert()</code>的升级版, 当<strong>测试条件为假</strong>时, 在assertion fail之前可以输出一些信息</li>
<li><code>panic()</code>用于<strong>输出信息并结束程序</strong>, 相当于无条件的assertion fail</li>
</ul>
</li>
<li>从现在开始<strong>保持接口的一致性</strong>可以在将来避免一些不必要的麻烦.<ul>
<li>内存通过在<code>nemu/src/memory/paddr.c</code>中定义的大数组pmem来模拟. 在客户程序运行的过程中, 总是使用<code>vaddr_read()</code>和<code>vaddr_write() </code>(在n<code>emu/src/memory/vaddr.c</code>中定义)来访问模拟的内存.</li>
</ul>
</li>
</ul>
<h4 id="必做题：优美地退出"><a href="#必做题：优美地退出" class="headerlink" title="必做题：优美地退出"></a>必做题：优美地退出</h4><p>如果在运行NEMU之后直接键入q退出, 你会发现终端输出了一些错误信息. 请分析这个错误信息是什么原因造成的, 然后尝试在NEMU中修复它.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(nemu) q</span><br><span class="line">make: *** [/home/xiaoyao/ics2024/nemu/scripts/native.mk:38：run] 错误 1</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>可能原因</strong>：</li>
</ul>
<ol>
<li><p>退出状态未正确设置：</p>
<p> 在处理 q 命令时，可能没有正确设置退出状态，导致程序没有正常退出。</p>
</li>
<li><p>资源未正确释放：</p>
<p> 在退出时，可能有一些资源（如内存、文件句柄等）未正确释放，导致程序异常退出。</p>
</li>
<li><p>退出处理函数中的错误：</p>
<p> 在处理 q 命令的函数中，可能存在一些未处理的错误或异常。</p>
</li>
</ol>
<ul>
<li><strong>解决（1）</strong>：</li>
</ul>
<ol>
<li>先检查<code>cmd-q</code>函数：<ul>
<li>在哪？用<code>grep -rnw &#39;/home/xiaoyao/ics2024/nemu/&#39; -e &#39;cmd_q&#39;</code>找到</li>
</ul>
</li>
<li>发现为</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_q</span><span class="params">(<span class="type">char</span> *args)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>根据经验猜测，改为</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_q</span><span class="params">(<span class="type">char</span> *args)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试，变成了按q无法退出！！</p>
<ol start="4">
<li>分析，原本是返回-1<br>在主循环<code>sdb_mainloop()</code>中，处理退出部分为</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_CMD; i ++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cmd, cmd_table[i].name) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmd_table[i].handler(args) &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == NR_CMD) &#123; <span class="built_in">printf</span>(<span class="string">&quot;Unknown command &#x27;%s&#x27;\n&quot;</span>, cmd); &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>故发现当输入q，cmd_q函数被调用，如果返回0,则不会结束，循环继续执行；如果返回小于0的数（比如-1），循环会退出，从而结束程序。</p>
<p>所以不是<code>return -1</code>的错！</p>
<p><strong>解决（2）</strong></p>
<ul>
<li>决定用<strong>gdb</strong>调试</li>
<li>用<code>find . -type f -executable -exec ls -l &#123;&#125; \;</code>找了一下可执行文件，gdb它是<code>gdb ./build/riscv32-nemu-interpreter</code></li>
</ul>
<ol>
<li><code>gdb ./build/riscv32-nemu-interpreter</code></li>
<li>设置断点<code>(gdb) break cmd_q</code></li>
<li>运行程序： 启动NEMU并运行到断点处。<code>(gdb) run</code></li>
<li>在NEMU界面，输入q，触发cmd_q函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Breakpoint 1, cmd_q (args=0x0) at src/monitor/sdb/sdb.c:51</span><br><span class="line">warning: Source file is more recent than executable.</span><br><span class="line">51	static int cmd_q(char *args) &#123;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>查看返回值：在cmd_q函数里单步执行，并查看返回值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) step  # 进入cmd_q函数</span><br><span class="line">(gdb) next  # 执行到返回语句</span><br><span class="line">53	  return -1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="6">
<li><code>(gdb) finish  # 执行完cmd_q函数并返回调用点</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Run till exit from #0  cmd_q (args=0x0) at src/monitor/sdb/sdb.c:53</span><br><span class="line">0x0000555555557f41 in sdb_mainloop () at src/monitor/sdb/sdb.c:129</span><br><span class="line">129	        if (cmd_table[i].handler(args) &lt; 0) &#123; return; &#125;</span><br><span class="line">Value returned is $1 = -1</span><br></pre></td></tr></table></figure>
<p>发现调用处是<code>sdb_mainloop () at src/monitor/sdb/sdb.c:129</code></p>
<ol start="7">
<li>设置断点： 在 cmd_q 函数和 sdb_mainloop 函数的第 129 行设置断点。<br><code>(gdb) break src/monitor/sdb/sdb.c:129</code><br>再次run和q查看</li>
<li>查看调用栈</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) backtrace</span><br><span class="line">#0  sdb_mainloop () at src/monitor/sdb/sdb.c:129</span><br><span class="line">#1  0x00005555555565c1 in engine_start () at src/engine/interpreter/init.c:25</span><br><span class="line">#2  0x00005555555565a0 in main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;)</span><br><span class="line">    at src/nemu-main.c:32</span><br></pre></td></tr></table></figure>
<p>发现在sdb_mainloop函数退出后，控制转移到<strong>main函数</strong>，<br>9. 对main.c:32断点，再run，输入q，然后几个next后发现<code>is_exit_status_bad()</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) next</span><br><span class="line">main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at src/nemu-main.c:34</span><br><span class="line">34	  return is_exit_status_bad();</span><br></pre></td></tr></table></figure>
<ol start="10">
<li>查看</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="built_in">list</span> is_exit_status_bad</span><br><span class="line"><span class="number">15</span>	</span><br><span class="line"><span class="number">16</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utils.h&gt;</span></span></span><br><span class="line"><span class="number">17</span>	</span><br><span class="line"><span class="number">18</span>	NEMUState nemu_state = &#123; .state = NEMU_STOP &#125;;</span><br><span class="line"><span class="number">19</span>	</span><br><span class="line"><span class="number">20</span>	<span class="type">int</span> <span class="title function_">is_exit_status_bad</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">21</span>	  <span class="type">int</span> good = (nemu_state.state == NEMU_END &amp;&amp; nemu_state.halt_ret == <span class="number">0</span>) ||</span><br><span class="line"><span class="number">22</span>	    (nemu_state.state == NEMU_QUIT);</span><br><span class="line"><span class="number">23</span>	  <span class="keyword">return</span> !good;</span><br><span class="line"><span class="number">24</span>	&#125;</span><br></pre></td></tr></table></figure>
<p>！good应该为0才能正确退出，根据报错知道这里返回的是1,即good为0,说明无条件为真；而cmd_q并没有改变nemu_state.state，为STOP，所以加一行在cmd_q，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nemu_state.state = NEMU_QUIT;</span><br></pre></td></tr></table></figure>
<p>现在就能正常退出啦！！</p>
<h4 id="多认识GDB的一些命令和操作"><a href="#多认识GDB的一些命令和操作" class="headerlink" title="多认识GDB的一些命令和操作"></a>多认识GDB的一些命令和操作</h4><p>比如:</p>
<ul>
<li>单步执行进入你感兴趣的函数<code>(gdb) step</code></li>
<li>单步执行跳过你不感兴趣的函数(例如库函数)<code>(gdb) next</code></li>
<li>运行到函数末尾<code>(gdb) finish</code></li>
<li>打印变量或寄存器的值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) print variable_name</span><br><span class="line">(gdb) info registers</span><br></pre></td></tr></table></figure>
<ul>
<li>扫描内存<code>(gdb) x /Nfu address</code></li>
<li>查看调用栈<code>(gdb) backtrace</code></li>
<li>设置断点<code>(gdb) break</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) break filename:line_number</span><br><span class="line">(gdb) break function_name</span><br></pre></td></tr></table></figure>
<ul>
<li>设置监视点<code>(gdb) watch variable_name</code></li>
</ul>
<h2 id="2024-9-22"><a href="#2024-9-22" class="headerlink" title="2024.9.22"></a>2024.9.22</h2><h1 id="基础设施：简易调试器"><a href="#基础设施：简易调试器" class="headerlink" title="基础设施：简易调试器"></a>基础设施：简易调试器</h1><ul>
<li>基础设施-<strong>提高项目开发的效率</strong><ul>
<li>在PA中, 基础设施是指支撑项目开发的各种工具和手段.</li>
<li>比如：我们的框架代码已经提供了Makefile来对NEMU进行一键编译. 假设我们并没有提供一键编译的功能, 你需要通过手动键入gcc命令的方式来编译源文件。</li>
</ul>
</li>
<li>需要在monitor中实现一个具有如下功能(表格中)的简易调试器 (相关部分的代码在<code>nemu/src/monitor/sdb/</code>目录下)</li>
</ul>
<p>哇要开始写代码了，紧张中</p>
<h2 id="解析命令"><a href="#解析命令" class="headerlink" title="解析命令"></a>解析命令</h2><ol>
<li>从键盘上读入命令：为了让简易调试器易于使用, NEMU通过<code>readline</code>库与用户交互, 使用<code>readline()</code>函数从键盘上读入命令. </li>
<li>解析该命令，然后执行相关的操作：</li>
</ol>
<ul>
<li>目的：识别命令中的参数</li>
<li>通过一系列的字符串处理函数来完成<ul>
<li>eg.<code>strtok()</code></li>
<li>strtok的工作原理是通过指定的分割符将字符串分割开来，并返回每个标记的指针</li>
<li><code>cmd_help()</code>函数中有使用<code>strtok（）</code>的例子</li>
</ul>
</li>
<li>事实上, 字符串处理函数有很多, 键入以下内容:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">man 3 str&lt;TAB&gt;&lt;TAB&gt;</span><br></pre></td></tr></table></figure>
<p>其中<TAB>代表键盘上的TAB键；看到很多以str开头的函数！</TAB></p>
<ul>
<li>推荐的字符串处理函数：<code>sscanf()</code><ul>
<li>功能和<code>scanf()</code>很类似, 但 <code>sscanf </code>从字符串而不是标准输入读取数据。它的定义在<code> &lt;stdio.h&gt;</code> 头文件中。</li>
<li>函数原型：</li>
</ul>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数<ul>
<li><code>str</code>：要读取的字符串。</li>
<li><code>format</code>：格式控制字符串，指定如何解析输入。</li>
<li><code>...</code>：指向存储读取值的变量的指针。</li>
</ul>
</li>
<li>返回值：成功读取并赋值的项数。如果没有匹配项或发生读取错误，则返回 EOF。</li>
</ul>
</li>
</ul>
<h2 id="要实现："><a href="#要实现：" class="headerlink" title="要实现："></a>要实现：</h2><p><del>1. 帮助<br>2. 继续运行<br>3. 退出</del></p>
<ol start="4">
<li><p>单步执行 	si [N] 	si 10 	让程序单步执行N条指令后暂停执行,<br>当N没有给出时, 缺省为1</p>
</li>
<li><p>打印程序状态 	info SUBCMD 	info r<br>info w 	打印寄存器状态<br>打印监视点信息</p>
</li>
<li><p>扫描内存(2) 	x N EXPR 	x 10 $esp 	求出表达式EXPR的值, 将结果作为起始内存<br>地址, 以十六进制形式输出连续的N个4字节</p>
</li>
<li><p>表达式求值 	p EXPR 	p $eax + 1 	求出表达式EXPR的值, EXPR支持的<br>运算请见调试中的表达式求值小节</p>
</li>
<li><p>设置监视点 	w EXPR 	w *0x2000 	当表达式EXPR的值发生变化时, 暂停程序执行</p>
</li>
<li><p>删除监视点 	d N 	d 2 	删除序号为N的监视点</p>
</li>
</ol>
<h2 id="单步执行"><a href="#单步执行" class="headerlink" title="单步执行"></a>单步执行</h2><p>单步执行的功能十分简单, 而且框架代码中已经给出了模拟CPU执行方式的函数, 你只要使用相应的参数去调用它就可以了. 如果你仍然不知道要怎么做, RTFSC.</p>
<p>(用了下sscanf)</p>
<h2 id="打印寄存器"><a href="#打印寄存器" class="headerlink" title="打印寄存器"></a>打印寄存器</h2><ul>
<li><code>info SUBCMD</code></li>
<li>例子：<ul>
<li><code>info r</code>打印寄存器状态</li>
</ul>
</li>
<li>寄存器结构是ISA相关的</li>
<li>去看框架代码准备的api：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// nemu/src/isa/$ISA/reg.c</span><br><span class="line">void isa_reg_display(void);</span><br></pre></td></tr></table></figure>
<ul>
<li>执行info r之后, 就调用isa_reg_display(), 在里面直接通过printf()输出所有寄存器的值即可. </li>
<li>打印完之后还打印了特殊寄存器——程序计数器（PC）</li>
</ul>
<h2 id="扫描内存"><a href="#扫描内存" class="headerlink" title="扫描内存"></a>扫描内存</h2><ol>
<li>对命令进行解析</li>
<li>求出表达式的值（下一节来实现，目前先实现一个简单版本！）<ul>
<li>规定表达式EXPR中只能是一个十六进制数, 例如</li>
</ul>
</li>
</ol>
<ul>
<li>如何访问计算机的内存数据？<br>  -通过虚拟地址读取函数 <code>vaddr_read</code> 来实现。这个函数可以读取指定地址的内存数据，并返回相应的值。</li>
</ul>
<ol start="3">
<li>解析出待扫描内存的起始地址之后, 就可以使用循环将指定长度的内存数据通过十六进制打印出来. </li>
<li>检验：打印0x80000000的内存, 你应该会看到程序的代码, 和内置客户程序的内容进行对比。</li>
</ol>
<h2 id="debug记录"><a href="#debug记录" class="headerlink" title="debug记录"></a>debug记录</h2><p>(特别好笑)</p>
<ul>
<li>原代码：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单步执行</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_si</span><span class="params">(<span class="type">char</span> *args)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *arg = strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">  <span class="type">int</span> step;</span><br><span class="line">  <span class="keyword">if</span>(arg==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    step=<span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    step=<span class="built_in">sscanf</span>(arg,<span class="string">&quot;%d&quot;</span>,&amp;step);</span><br><span class="line">    Log(<span class="string">&quot;step=%d&quot;</span>,step);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  cpu_exec(step);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>检验：<br><code>si 5</code>，但step&#x3D;1,原因是这一行</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">step=<span class="built_in">sscanf</span>(arg,<span class="string">&quot;%d&quot;</span>,&amp;step);</span><br></pre></td></tr></table></figure>
<ul>
<li>纠错：<br>因为 sscanf 函数的使用不当。sscanf 函数<strong>返回的是成功读取的项目数</strong>，<strong>而不是读取的值</strong>。因此，当输入 <code>si 5 </code>时，<code>sscanf(arg, &quot;%d&quot;, &amp;step)</code> 返回的是 1（表示成功读取了一个整数），而不是 5。</li>
<li>改正：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sscanf(arg,&quot;%d&quot;,&amp;step);</span><br></pre></td></tr></table></figure>

<h1 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h1><h2 id="数学表达式求值"><a href="#数学表达式求值" class="headerlink" title="数学表达式求值"></a>数学表达式求值</h2><ol>
<li>识别表达式中的单元</li>
<li>根据表达式的归纳定义进行<strong>递归</strong>求值</li>
</ol>
<h3 id="词法分析（识别出表达式中的单元）"><a href="#词法分析（识别出表达式中的单元）" class="headerlink" title="词法分析（识别出表达式中的单元）"></a>词法分析（识别出表达式中的单元）</h3><ul>
<li>单元：<strong>token</strong></li>
<li><code>&quot;0x80100000+   ($a0 +5)*4 - *(  $t1 + 8) + number&quot;</code><br>它包含更多的功能, 例如十六进制整数(0x80100000), 小括号, 访问寄存器($a0), 指针解引用(第二个*), 访问变量(number). 事实上, 这种复杂的表达式在调试过程中经常用到, 而且你需要在<code>空格数目不固定(0个或多个)</code>的情况下仍然能正确识别出其中的token. <ul>
<li>用<strong>正则表达式</strong></li>
</ul>
</li>
<li>sdb.c中调用了<code>init_regex()</code>，来自<code>./expr.c</code></li>
</ul>
<ol>
<li>定义更多的 token 类型：例如数字、操作符、括号等。</li>
<li>编写正则表达式规则：为每种 token 类型编写相应的正则表达式。</li>
<li>记录 token 信息：在成功识别出 token 后，将其信息记录到 tokens 数组中。</li>
</ol>
<h4 id="调试检查"><a href="#调试检查" class="headerlink" title="调试检查"></a>调试检查</h4><ol>
<li>使用 assert() 设置检查点：确保关键变量和指针的有效性。</li>
<li>使用 printf() 查看程序执行情况：检查代码的可达性和变量的值。</li>
<li>使用 GDB 观察程序的状态和行为：设置断点、打印变量、监视点和函数调用栈。</li>
</ol>
<ul>
<li>我的方法是在sdb.c里添加命令</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_expr</span><span class="params">(<span class="type">char</span> *args)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (args == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage: expr &lt;expression&gt;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> success;</span><br><span class="line">  <span class="type">word_t</span> result = expr(args, &amp;success);</span><br><span class="line">  <span class="keyword">if</span> (success) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %u\n&quot;</span>, result);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Expression evaluation failed.\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后<code>make run</code>，再<code>expr 1+2-3</code>之类的，发现有Log，说明成功了。</p>
<h4 id="assert-0-的作用"><a href="#assert-0-的作用" class="headerlink" title="assert(0)的作用"></a><code>assert(0)</code>的作用</h4><ol>
<li>预防性的错误检查</li>
</ol>
<ul>
<li>assert是判断括号内的内容是否为真，为假就报错。<ul>
<li>0为假，所以<code>assert(0)</code>永远都报错</li>
</ul>
</li>
<li>在认为<strong>不可能</strong>执行到的情况下加一句<strong>assert(0)</strong>,如果运行到此，则代码<strong>逻辑或条件</strong>就可能有问题。</li>
</ul>
<ol start="2">
<li>没写完，放个assert（0），调试运行到此时报错中断，好知道成员函数还没写完。</li>
<li>设置断言</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = SomeFunc(y);</span><br><span class="line">ASSERT(x&gt;=<span class="number">0</span>);<span class="comment">//如果x为负，则断言失败</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可将断言用于<ul>
<li>捕捉逻辑错误：在程序逻辑必须为真的条件上设置断言，无影响除非错；</li>
<li>检查操作结果</li>
<li>测试错误类型</li>
</ul>
</li>
</ul>
<h3 id="递归求值"><a href="#递归求值" class="headerlink" title="递归求值"></a>递归求值</h3><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>BNF定义</li>
<li>长表达式是由短表达式构成的</li>
<li>先对短表达式求值，再对长表达式求值（分治法）</li>
</ul>
<h4 id="如何在一个token表达式中寻找主运算符"><a href="#如何在一个token表达式中寻找主运算符" class="headerlink" title="如何在一个token表达式中寻找主运算符:"></a>如何在一个token表达式中寻找主运算符:</h4><ul>
<li><strong>非运算符的token</strong>不是主运算符.</li>
<li><strong>出现在一对括号中的token</strong>不是主运算符. 注意到这里不会出现有括号包围整个表达式的情况, 因为这种情况已经在check_parentheses()相应的if块中被处理了.</li>
<li><strong>主运算符的优先级在表达式中是最低的.</strong> 这是因为主运算符是最后一步才进行的运算符.</li>
<li>当有<strong>多个</strong>运算符的优先级都是最低时, 根据结合性, <strong>最后</strong>被结合的运算符才是主运算符. 一个例子是1 + 2 + 3, 它的主运算符应该是右边的+.</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>需要注意的是, 上述框架中并没有进行错误处理, 在求值过程中发现表达式不合法的时候, 应该给上层函数返回一个表示出错的标识, 告诉上层函数”求值的结果是无效的”. </li>
<li>为了方便统一, 我们认为所有结果都是<code>uint32_t</code>类型.</li>
</ul>
<h4 id="想法心得"><a href="#想法心得" class="headerlink" title="想法心得"></a>想法心得</h4><ul>
<li>可能出错的地方用了assert来处理，退出并输出错误信息</li>
<li>把加减法和乘除法的优先级搞反了，同时存在时，加减法为主</li>
<li>除法，除数为0要注意！</li>
</ul>
<h3 id="实现带有负数的算术表达式的求值"><a href="#实现带有负数的算术表达式的求值" class="headerlink" title="实现带有负数的算术表达式的求值"></a>实现带有负数的算术表达式的求值</h3><p>在上述实现中, 我们并没有考虑负数的问题, 例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;1 + -1&quot;</span><br><span class="line">&quot;--1&quot;    /* 我们不实现自减运算, 这里应该解释成 -(-1) = 1 */</span><br></pre></td></tr></table></figure>
<ul>
<li>它们会被判定为不合法的表达式. 为了实现负数的功能, 你需要考虑两个问题:<ul>
<li>负号和减号都是-, 如何区分它们?</li>
<li>负号是个单目运算符, 分裂的时候需要注意什么?</li>
</ul>
</li>
</ul>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><ul>
<li>4294967295（-1）<br>因为现在还是无符号数阶段，所以计算结果不会小于0，先不考虑计算结果小于0了</li>
</ul>
<h3 id="9-24"><a href="#9-24" class="headerlink" title="9.24"></a>9.24</h3><h3 id="如何测试你的代码——随机测试"><a href="#如何测试你的代码——随机测试" class="headerlink" title="如何测试你的代码——随机测试"></a>如何测试你的代码——随机测试</h3><ul>
<li>生成表达式的框架</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gen_rand_expr</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (choose(<span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: gen_num(); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: gen(<span class="string">&#x27;(&#x27;</span>); gen_rand_expr(); gen(<span class="string">&#x27;)&#x27;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: gen_rand_expr(); gen_rand_op(); gen_rand_expr(); <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>- ``uint32_t choose(uint32_t n)``：生成一个小于0的随机数
</code></pre>
<ul>
<li>生成表达式的结果：<ul>
<li>进行的都是无符号运算</li>
<li>数据宽度都是32bit</li>
<li>溢出后不处理</li>
</ul>
</li>
<li>把这些表达式塞到如下C程序的源文件里面:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> result = ???; <span class="comment">// 把???替换成表达式</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%u&quot;</span>, result);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后用gcc编译它并执行, 让它输出表达式的结果, 这不就是我们想要的”计算器”吗?<ul>
<li>框架代码(在nemu&#x2F;tools&#x2F;gen-expr&#x2F;gen-expr.c中). </li>
<li>你需要实现其中的void gen_rand_expr()函数, 将随机生成的表达式输出到缓冲区buf中. main函数中的代码会调用你实现的gen_rand_expr(), 然后把buf中的随机表达式放入上述C程序的代码中. </li>
<li>剩下的事情就是编译运行这个C程序了, 代码中使用了system()和popen()等库函数来实现这一功能. </li>
<li>最后, 框架代码将这个C程序的打印结果和之前随机生成的表达式一同输出, 这样就生成了一组测试用例.</li>
</ul>
</li>
</ul>
<h2 id="实现表达式生成器"><a href="#实现表达式生成器" class="headerlink" title="实现表达式生成器"></a>实现表达式生成器</h2><h4 id="生成随机表达式——gen-rand-expr-函数"><a href="#生成随机表达式——gen-rand-expr-函数" class="headerlink" title="生成随机表达式——gen_rand_expr()函数"></a>生成随机表达式——gen_rand_expr()函数</h4><h4 id="将表达式插入到-C-程序模板中"><a href="#将表达式插入到-C-程序模板中" class="headerlink" title="将表达式插入到 C 程序模板中"></a>将表达式插入到 C 程序模板中</h4><p>使用 sprintf 将生成的表达式插入到 C 程序模板中。</p>
<h4 id="编译和运行-C-程序"><a href="#编译和运行-C-程序" class="headerlink" title="编译和运行 C 程序"></a>编译和运行 C 程序</h4><p>使用 system() 函数编译生成的 C 程序，并使用 popen() 函数运行该程序以获取计算结果。</p>
<h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><p>将计算结果和生成的表达式一起输出。</p>
<ul>
<li>表达式生成器如何获得C程序的打印结果?<ul>
<li>生成随机表达式：gen_rand_expr(0) 函数生成随机表达式，并将其存储在缓冲区 buf 中。</li>
<li>将表达式插入到 C 程序模板中：使用 sprintf(code_buf, code_format, buf) 将生成的表达式插入到 C 程序模板中，并将结果存储在 code_buf 中。</li>
<li>写入临时文件：将生成的 C 程序写入到临时文件 &#x2F;tmp&#x2F;.code.c 中。</li>
<li>编译生成的 C 程序：使用 system(“gcc &#x2F;tmp&#x2F;.code.c -o &#x2F;tmp&#x2F;.expr”) 命令编译生成的 C 程序。</li>
<li>运行生成的程序并获取结果：使用 popen(“&#x2F;tmp&#x2F;.expr”, “r”) 运行生成的程序，并通过 fscanf(fp, “%u”, &amp;result) 从程序的输出中读取计算结果。</li>
</ul>
</li>
</ul>
<h3 id="如何过滤求值过程中有除0行为的表达式"><a href="#如何过滤求值过程中有除0行为的表达式" class="headerlink" title="如何过滤求值过程中有除0行为的表达式?"></a>如何过滤求值过程中有除0行为的表达式?</h3><ul>
<li>采用了：若’&#x2F;‘下一个是0,则删掉重新生成</li>
<li>但是还是会有warning：当被除的式子值为0时。怎么办？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/tmp/.code.c:2:46: warning: division by zero [-Wdiv-by-zero]</span><br><span class="line">    2 | int main() &#123;   unsigned result = (53/ (88+(32/  (12/ 47 )/71  ))  -(10*17 + 86/  8  +(31/ 82  )  ) )/46;   printf(&quot;%u&quot;, result);   return 0; &#125;</span><br><span class="line">      |                                              ^</span><br></pre></td></tr></table></figure>
<ul>
<li>为什么要用无符号整数：<ul>
<li>避免溢出问题：无符号整数在溢出时会回绕到零，而有符号整数在溢出时可能会导致未定义行为。使用无符号整数可以避免这种未定义行为。</li>
<li>一致性：无符号整数的行为在所有平台上都是一致的，而有符号整数的行为可能会因平台而异。</li>
<li>简化处理：无符号整数的处理相对简单，不需要考虑负数的情况。</li>
</ul>
</li>
<li>除0的确切行为:<br>如果生成的表达式有除0行为, 你编写的表达式生成器的行为又会怎么样呢?</li>
<li>过滤除0行为的表达式:<br>乍看之下这个问题不好解决, 因为框架代码只负责生成表达式, 而检测除0行为至少要对表达式进行求值. 结合前两个蓝框题的回答(前提是你对它们的理解都足够深入了), 你就会找到解决方案了, 而且解决方案不唯一喔!</li>
</ul>
<h3 id="改造NEMU的main（）函数"><a href="#改造NEMU的main（）函数" class="headerlink" title="改造NEMU的main（）函数"></a>改造NEMU的main（）函数</h3><ul>
<li>读取输入文件中的测试表达式。</li>
<li>调用 expr() 函数对表达式进行求值。</li>
<li>与预期结果进行比较。</li>
<li>修改 tokens 数组的大小以容纳长表达式。<ul>
<li>#define MAX_TOKENS 65536</li>
<li>expr.c里面<ul>
<li>static Token tokens[65536] <strong>attribute</strong>((used)) &#x3D; {};</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取input文件中的测试表达式</span></span><br><span class="line">FILE *input_fp = fopen(<span class="string">&quot;/home/xiaoyao/ics2024/nemu/tools/gen-expr/input&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(input_fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;No input file found\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> line_buf[MAX_TOKENS + <span class="number">128</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (fgets(line_buf, <span class="keyword">sizeof</span>(line_buf), input_fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="comment">// 去掉换行符</span></span><br><span class="line">  <span class="type">size_t</span> len = <span class="built_in">strlen</span>(line_buf);</span><br><span class="line">  <span class="keyword">if</span> (len &gt; <span class="number">0</span> &amp;&amp; line_buf[len - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">    line_buf[len - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 找到数字后的第一个空格</span></span><br><span class="line">  <span class="type">char</span> *space_pos = <span class="built_in">strchr</span>(line_buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (space_pos == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Invalid input format: %s\n&quot;</span>, line_buf);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分割结果和表达式</span></span><br><span class="line">  *space_pos = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="type">char</span> *expr_str = space_pos + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析表达式的预期结果</span></span><br><span class="line">  <span class="type">uint32_t</span> expected_result = strtoul(line_buf, <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调试信息</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Parsed expression: %s\n&quot;</span>, expr_str);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用expr函数计算表达式的值</span></span><br><span class="line">  <span class="type">bool</span> success = <span class="literal">true</span>;</span><br><span class="line">  <span class="type">word_t</span> ans = expr(expr_str, &amp;success);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 与预期结果比较</span></span><br><span class="line">  <span class="keyword">if</span> (success) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ans == expected_result) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;PASS: %s = %u\n&quot;</span>, expr_str, ans);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;FAIL: %s = %u (expected %u)\n&quot;</span>, expr_str, ans, expected_result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ERROR: Failed to evaluate expression: %s\n&quot;</span>, expr_str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fclose(input_fp);</span><br></pre></td></tr></table></figure>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul>
<li>先测试，再启动engine，否则就无法测试，直接进入交互模式啦</li>
<li>分割是按照第一个数字后的空格</li>
<li>token数组大小，其实是改expr.c处</li>
</ul>
<h4 id="1-2结束！"><a href="#1-2结束！" class="headerlink" title="1.2结束！"></a>1.2结束！</h4><h1 id="监视点"><a href="#监视点" class="headerlink" title="监视点"></a>监视点</h1><p>（9.30）</p>
<ul>
<li>监视点的功能是监视一个表达式的值何时发生变化. 如果你从来没有使用过监视点, 请在GDB中体验一下它的作用.</li>
</ul>
<h2 id="扩展表达式求值的功能"><a href="#扩展表达式求值的功能" class="headerlink" title="扩展表达式求值的功能"></a>扩展表达式求值的功能</h2><ul>
<li>我们用BNF来说明需要扩展哪些功能:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;expr&gt; ::= &lt;decimal-number&gt;</span><br><span class="line">  | &lt;hexadecimal-number&gt;    # 以&quot;0x&quot;开头</span><br><span class="line">  | &lt;reg_name&gt;              # 以&quot;$&quot;开头</span><br><span class="line">  | &quot;(&quot; &lt;expr&gt; &quot;)&quot;</span><br><span class="line">  | &lt;expr&gt; &quot;+&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;-&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;*&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;/&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;==&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;!=&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;&amp;&amp;&quot; &lt;expr&gt;</span><br><span class="line">  | &quot;*&quot; &lt;expr&gt;              # 指针解引用</span><br></pre></td></tr></table></figure>
<p>它们的功能和C语言中运算符的功能是一致的, 包括优先级和结合性, 如有疑问, 请查阅相关资料.</p>
<ul>
<li>关于获取寄存器的值, 这显然是一个ISA相关的功能. 框架代码已经准备了如下的API:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// nemu/src/isa/$ISA/reg.c</span><br><span class="line">word_t isa_reg_str2val(const char *s, bool *success);</span><br></pre></td></tr></table></figure>
<p>它用于返回名字为s的寄存器的值, 并设置success指示是否成功.</p>
<ul>
<li>注意：指针解引用的识别<ul>
<li>区分乘法和指针解引用<code>*</code></li>
<li>实际上, 我们只要看<code>*</code>前一个token的类型, 我们就可以决定这个<code>*</code>是乘法还是指针解引用了</li>
<li>思考<code>certain type</code></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!make_token(e)) &#123;</span><br><span class="line">  *success = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> Implement code to evaluate the expression. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_token; i ++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (tokens[i].type == <span class="string">&#x27;*&#x27;</span> &amp;&amp; (i == <span class="number">0</span> || tokens[i - <span class="number">1</span>].type == certain type) ) &#123;</span><br><span class="line">    tokens[i].type = DEREF;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> eval(?, ?);</span><br></pre></td></tr></table></figure>
<p>ps:此框架也可以处理负数</p>
<h4 id="额外说明："><a href="#额外说明：" class="headerlink" title="额外说明："></a>额外说明：</h4><ul>
<li>所有结果都是uint32_t类型.</li>
<li>指针也没有类型, 进行指针解引用的时候, 我们总是从客户计算机的内存中读出一个uint32_t类型的整数.</li>
</ul>
<h3 id="必做-扩展表达式求值的功能"><a href="#必做-扩展表达式求值的功能" class="headerlink" title="必做:扩展表达式求值的功能"></a>必做:扩展表达式求值的功能</h3><ul>
<li>要做：<ol>
<li>获取寄存器的值</li>
<li>&#x3D;&#x3D;、！&#x3D;、&amp;&amp;、&lt;&#x3D;</li>
<li>十六进制常数</li>
<li>指针解引用</li>
</ol>
</li>
</ul>
<ol>
<li>获取寄存器的值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// nemu/src/isa/$ISA/reg.c</span><br><span class="line">word_t isa_reg_str2val(const char *s, bool *success);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">word_t</span> <span class="title function_">isa_reg_str2val</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">bool</span> *success)</span> &#123;</span><br><span class="line">  <span class="comment">//遍历所有寄存器</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(s,regs[i])==<span class="number">0</span>)&#123;</span><br><span class="line">      *success=<span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> cpu.gpr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//检查是否是PC</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(s,<span class="string">&quot;pc&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">    *success=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> cpu.pc;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//没有找到</span></span><br><span class="line">  *success=<span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>&#x3D;&#x3D;,!&#x3D;,&amp;&amp;<ol>
<li>扩展正则表达式规则</li>
</ol>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot; +&quot;, TK_NOTYPE&#125;,    // spaces</span><br><span class="line">&#123;&quot;\\+&quot;, &#x27;+&#x27;&#125;,     // plus</span><br><span class="line">&#123;&quot;==&quot;, TK_EQ&#125;,        // equal</span><br><span class="line">&#123;&quot;!=&quot;, TK_NEG&#125;,       // not equal</span><br><span class="line">&#123;&quot;-&quot;, &#x27;-&#x27;&#125;,      // minus</span><br><span class="line">&#123;&quot;\\*&quot;, &#x27;*&#x27;&#125;,      // multiply</span><br><span class="line">&#123;&quot;/&quot;, &#x27;/&#x27;&#125;,        // divide</span><br><span class="line">&#123;&quot;\\(&quot;, &#x27;(&#x27;&#125;,   // left parenthesis</span><br><span class="line">&#123;&quot;\\)&quot;, &#x27;)&#x27;&#125;,   // right parenthesis</span><br><span class="line">&#123;&quot;[0-9]+&quot;, TK_NUM&#125;,   // number</span><br><span class="line">&#123;&quot;0[xX][0-9a-fA-F]+&quot;, TK_HEX&#125;, // hexadecimal number</span><br><span class="line">&#123;&quot;\\$[a-zA-Z0-9]+&quot;, TK_REG&#125;, // register name</span><br><span class="line">&#123;&quot;&amp;&amp;&quot;, TK_AND&#125; // and</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>改优先级</li>
<li>改计算处eval</li>
</ol>
</li>
<li>十六进制常数（2中已经解决）</li>
<li>指针解引用<ol>
<li>在eval中</li>
</ol>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (tokens[op].type == TK_DEREF) &#123;</span><br><span class="line">word_t val = eval(op + 1, q);</span><br><span class="line">return *(word_t *)val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>expr修改</li>
<li>发现不对，报错</li>
</ol>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src/monitor/sdb/expr.c: In function ‘eval’:</span><br><span class="line">src/monitor/sdb/expr.c:260:16: error: cast to pointer from integer of different size [-Werror=int-to-pointer-cast]</span><br><span class="line">260 |       return *((word_t *)val);</span><br><span class="line">    |                ^</span><br><span class="line">cc1: all warnings being treated as errors</span><br><span class="line">make: *** [/home/xiaoyao/ics2024/nemu/scripts/build.mk:34：/home/xiaoyao/ics2024/nemu/build/obj-riscv32-nemu-interpreter/src/monitor/sdb/expr.o] 错误 1</span><br></pre></td></tr></table></figure>
<p> 类型不匹配，改成了用<code>eturn paddr_read((paddr_t)val, sizeof(word_t));</code></p>
</li>
</ol>
<ul>
<li>make run时发现计算突然出错了，上次还是没完全弄好<ul>
<li>原来是这次添加新的优先级时搞错了</li>
</ul>
</li>
</ul>
<h2 id="实现监视点"><a href="#实现监视点" class="headerlink" title="实现监视点"></a>实现监视点</h2><ul>
<li>最好使用链表将监视点的信息组织起来. </li>
<li>框架代码中已经定义好了监视点的结构体(在<code>nemu/src/monitor/sdb/watchpoint.c</code>中):</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">watchpoint</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> NO;<span class="comment">//表示监视点的序号</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">watchpoint</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> Add more members if necessary */</span></span><br><span class="line"></span><br><span class="line">&#125; WP;</span><br></pre></td></tr></table></figure>
<ul>
<li>要做：根据对监视点工作原理的理解<strong>在结构体中增加必要的成员</strong>.</li>
<li>“池”：管理监视点结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> WP wp_pool[NR_WP] = &#123;&#125;;</span><br><span class="line"><span class="type">static</span> WP *head = <span class="literal">NULL</span>, *free_ = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码中定义了监视点结构的池<code>wp_pool</code>, 还有两个链表<code>head</code>和<code>free_</code><ul>
<li>其中<code>head</code>用于组织<strong>使用中</strong>的监视点结构,</li>
<li><code>free_</code>用于组织<strong>空闲</strong>的监视点结构,</li>
<li><code>init_wp_pool()</code>函数会对两个链表进行<strong>初始化</strong>.</li>
</ul>
</li>
</ul>
<h3 id="必做：实现监视点的管理"><a href="#必做：实现监视点的管理" class="headerlink" title="必做：实现监视点的管理"></a>必做：实现监视点的管理</h3><ul>
<li>需要编写以下两个函数(你可以根据你的需要修改函数的参数和返回值):</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WP* <span class="title function_">new_wp</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">free_wp</span><span class="params">(WP *wp)</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>其中<code>new_wp</code>()从<code>free_链表</code>中返回一个<strong>空闲的</strong>监视点结构, <code>free_wp()</code>将<code>wp</code><strong>归还到free_链表</strong>中, 这两个函数会作为监视点池的<strong>接口被其它函数调用</strong>. </li>
<li>需要注意的是, 调用new_wp()时可能会出现<strong>没有空闲监视点结构</strong>的情况, 为了简单起见, 此时可以<strong>通过<code>assert(0)</code>马上终止程序</strong>. 框架代码中定义了32个监视点结构, 一般情况下应该足够使用, 如果你需要更多的监视点结构, 你可以修改NR_WP宏的值.</li>
<li>这两个函数里面都需要执行一些<strong>链表</strong>插入, 删除的操作, 对链表操作不熟悉的同学来说, 这可以作为一次链表的练习.</li>
</ol>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol>
<li><p>修改watchpoint结构体</p>
</li>
<li><p>实现new_wp函数</p>
<ul>
<li>new_wp 函数从 free_ 链表中返回一个空闲的监视点结构，并将其从 free_ 链表中移除，添加到 head 链表中。</li>
</ul>
<ol>
<li><code>if (free_ == NULL) &#123; assert(0 &amp;&amp; &quot;No free watchpoints available&quot;); &#125;</code> 检查是否有空闲的监视点，如果没有则终止程序。</li>
<li><code>WP *wp = free_;</code> 从空闲链表中取出第一个监视点。</li>
<li><code>free_ = free_-&gt;next;</code> 更新空闲链表<strong>头指针</strong>，<strong>指向下一个</strong>空闲监视点。</li>
<li><code>wp-&gt;next = head;</code> 将<strong>新</strong>分配的监视点的<code>next</code><strong>指针指向当前使用中的链表头</strong>。</li>
<li><code>head = wp;</code> 更新<strong>使用中的链表头指针</strong>，指向新分配的监视点。</li>
<li><code>return wp;</code> 返回新分配的监视点。</li>
</ol>
</li>
<li><p>实现free_up函数：</p>
<ul>
<li>free_wp 函数将一个<strong>使用中的监视点</strong>从<code>head</code>链表中<strong>移除</strong>，并将其<strong>添加到空闲链表</strong><code>free_</code>中。</li>
</ul>
<ol>
<li><code>if (head == NULL || wp == NULL) &#123; assert(0 &amp;&amp; &quot;No watchpoints busy&quot;); &#125; </code>检查<strong>是否有使用中的监视点</strong>，如果没有则终止程序。</li>
<li><code>if (wp == head) &#123; head = head-&gt;next; &#125; </code>如果要释放的监视点是使用中的链表头，则<strong>更新链表头指针</strong>。</li>
<li></li>
</ol>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">    WP *prev = head; </span><br><span class="line">    <span class="keyword">while</span> (prev-&gt;next != <span class="literal">NULL</span> &amp;&amp; prev-&gt;next != wp) &#123; </span><br><span class="line">        prev = prev-&gt;next; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (prev-&gt;next == wp) &#123; </span><br><span class="line">        prev-&gt;next = wp-&gt;next; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 否则，<strong>遍历使用中的链表</strong>，<strong>找到</strong>要释放的监视点，并将其从链表中<strong>移除</strong>。<br> 4. <code>wp-&gt;next = free_; free_ = wp;</code> 将释放的监视点<strong>添加到空闲链表头</strong>。</p>
</li>
</ol>
<h4 id="温故而知新"><a href="#温故而知新" class="headerlink" title="温故而知新"></a>温故而知新</h4><ul>
<li>框架代码中定义wp_pool等变量的时候使用了关键字static, static在此处的含义是什么? 为什么要在此处使用它?</li>
<li>——静态全局变量，作用域仅限于当前文件</li>
<li>static 关键字的含义<ol>
<li>文件作用域：当 static 关键字用于全局变量或函数时，它会将这些变量或函数的作<strong>用域限制在定义它们的源文件</strong>中。</li>
<li>静态存储期：static 变量具有静态存储期，这意味着它们在程序的整个生命周期内都存在，并且在程序启动时初始化。</li>
</ol>
</li>
<li>为什么要在此处使用 static<ul>
<li>在 watchpoint.c 文件中使用 static 关键字有以下几个原因：</li>
</ul>
<ol>
<li>封装：将 wp_pool、head 和 free_ 变量的作用域限制在 watchpoint.c 文件中，可以防止它们被其他源文件意外访问或修改。</li>
<li>避免命名冲突：使用 static 关键字可以避免与其他源文件中定义的同名变量或函数发生命名冲突。</li>
</ol>
</li>
</ul>
<h3 id="必做：实现监视点"><a href="#必做：实现监视点" class="headerlink" title="必做：实现监视点"></a>必做：实现监视点</h3><p>由于监视点的功能需要在cpu_exec()的每次循环中都进行检查, 这会对NEMU的性能带来较为明显的开销. 我们可以把监视点的检查放在trace_and_difftest()中, 并用一个新的宏 CONFIG_WATCHPOINT把检查监视点的代码包起来; 然后在nemu&#x2F;Kconfig中为监视点添加一个开关选项, 最后通过menuconfig打开这个选项, 从而激活监视点的功能. 当你不需要使用监视点时, 可以在menuconfig中关闭这个开关选项来提高NEMU的性能.</p>
<h4 id="要实现的功能："><a href="#要实现的功能：" class="headerlink" title="要实现的功能："></a>要实现的功能：</h4><ol>
<li>当用户给出一个待监视表达式时<ul>
<li>通过new_wp()申请一个空闲的监视点结构, 并将表达式记录下来. </li>
<li>然后在<code>trace_and_difftest()函数</code>(在<code>nemu/src/cpu/cpu-exec.c</code>中定义)的最后<strong>扫描所有的监视点</strong>, 每当<code>cpu_exec()</code>的循环<strong>执行完一条指令</strong>, 都会<strong>调用一次</strong>trace_and_difftest()函数. </li>
<li>在扫描监视点的过程中, 你需要对监视点的相应表达式进行<strong>求值</strong>(你之前已经实现表达式求值的功能了), 并<strong>比较</strong>它们的值有没有发生变化; 若发生了变化, 程序就因触发了监视点而<strong>暂停</strong>下来, 你需要将<code>nemu_state.state变量</code>设置为<code>NEMU_STOP</code>来达到暂停的效果. </li>
<li>最后<strong>输出一句话提示用户触发了监视点</strong>, 并<strong>返回</strong>到<code>sdb_mainloop()</code>循环中等待用户的命令.</li>
</ul>
</li>
<li>使用<code>info w</code>命令来<strong>打印使用中的监视点信息</strong>, 至于要打印什么, 你可以参考GDB中<code>info watchpoints</code>的运行结果.</li>
<li>使用<strong>d命令</strong>来<strong>删除监视点</strong>, 你只需要<strong>释放</strong>相应的监视点结构即可.</li>
</ol>
<h4 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h4><ol>
<li>设置监视点<ul>
<li><code>watchpoint.c</code></li>
<li>调用<code>new_wp</code>函数</li>
</ul>
</li>
<li>实现d命令删除监视点<ul>
<li><code>watchpoint.c</code></li>
<li>调用<code>free_wp</code>函数</li>
<li>在<code>watchpoint.c</code>中添加<code>cmd_d</code>命令</li>
<li>并将<code>cmd_d</code>添加到<code>cmd_table</code>中：</li>
</ul>
</li>
<li>实现<code>info w</code>命令打印监视点信息<ul>
<li>在&#96;&#96;&#96;watchpoint.c<code>中添加</code>info_watchpoints&#96;&#96;</li>
<li>在<code>cmd_info</code>中调用<code>info_watchpoints</code></li>
</ul>
</li>
<li>在<code>cpu-exec.c/</code>添加检查监视点的代码：<ul>
<li>在<code>watchpoint.c</code>添加<code>check_watchpoints</code>函数（注意nemu_state.state&#x3D;NEMU_STOP）</li>
<li><code>cpu-exec.c/trace_and_difftest</code>添加<code>IFDEF(CONFIG_WATCHPOINT, check_watchpoints());</code></li>
</ul>
</li>
<li>在<code>nemu/Kconfig</code>中添加监视点开关选项 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">config WATCHPOINT</span><br><span class="line"><span class="type">bool</span> <span class="string">&quot;Enable watchpoint&quot;</span></span><br><span class="line"><span class="keyword">default</span> y</span><br><span class="line">help</span><br><span class="line">Enable watchpoint functionality. This will allow you to <span class="built_in">set</span> watchpoints</span><br><span class="line">and monitor changes to expressions during execution.</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h4><ol>
<li>第一个：</li>
</ol>
<ul>
<li>我发现只剩一个监视点时，删除就会产生</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(nemu) d 0</span><br><span class="line">Deleting watchpoint 0</span><br><span class="line">riscv32-nemu-interpreter: src/monitor/sdb/watchpoint.c:58: free_wp: Assertion `0 &amp;&amp; &quot;No watchpoints busy&quot;&#x27; failed.</span><br></pre></td></tr></table></figure>
<ul>
<li>多个监视点时，删除就可以正常进行<ul>
<li>问题可能出在 free_wp 函数在处理链表时没有正确处理只有一个监视点的情况。我们需要确保在删除最后一个监视点时，链表头部和尾部都被正确更新。</li>
</ul>
</li>
<li>解决：当删除最后一个监视点时，head 变为 NULL。把free_wp的“检查head是否为NULL”从和“wp是否为NULL”一样改为如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_wp</span><span class="params">(WP *wp)</span> &#123; <span class="comment">// 把wp放回free_链表</span></span><br><span class="line">  <span class="keyword">if</span> (wp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    assert(<span class="number">0</span> &amp;&amp; <span class="string">&quot;No watchpoints busy&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Freeing watchpoint %d\n&quot;</span>, wp-&gt;NO);</span><br><span class="line">    wp-&gt;next = free_;</span><br><span class="line">    free_ = wp;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (wp == head) &#123;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    WP *prev = head;</span><br><span class="line">    <span class="keyword">while</span> (prev-&gt;next != <span class="literal">NULL</span> &amp;&amp; prev-&gt;next != wp) &#123;</span><br><span class="line">      prev = prev-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (prev-&gt;next == wp) &#123;</span><br><span class="line">      prev-&gt;next = wp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Freeing watchpoint %d\n&quot;</span>, wp-&gt;NO);</span><br><span class="line">  wp-&gt;next = free_;</span><br><span class="line">  free_ = wp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>无法监视$pc、$0、ra等寄存器</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(nemu) w $pc</span><br><span class="line">riscv32-nemu-interpreter: src/monitor/sdb/expr.c:236: eval: Assertion `0&amp;&amp;&quot;Invalid register name&quot;&#x27; failed.</span><br><span class="line">make: *** [/home/xiaoyao/ics2024/nemu/scripts/native.mk:38: run] 已中止</span><br></pre></td></tr></table></figure>
<ul>
<li>正则表达式出错<ul>
<li>原本：{“\$[a-zA-Z0-9]+”, TK_REG}, &#x2F;&#x2F; register name</li>
<li>改后：{“\$?[a-zA-Z0-9]+”, TK_REG}, &#x2F;&#x2F; register name（加了个？表示不一定有$）</li>
</ul>
</li>
</ul>
<ol start="3">
<li>没有正确输出old value，初始值设置出错</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Executed instruction at pc = 0x80000000, next pc = 0x80000004</span><br><span class="line">0x80000000: 00 00 02 97 auipc	t0, 0</span><br><span class="line">Watchpoint 0 triggered: $pc</span><br><span class="line">Old value = 4(应该是2147483648)</span><br><span class="line">New value = 2147483652</span><br></pre></td></tr></table></figure>
<ul>
<li>改正：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_watchpoint</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *exprression,<span class="type">word_t</span> value)</span>&#123;<span class="comment">//设置监视点</span></span><br><span class="line">  WP *wp=new_wp();</span><br><span class="line">  <span class="built_in">strncpy</span>(wp-&gt;expr,exprression,<span class="keyword">sizeof</span>(wp-&gt;expr)<span class="number">-1</span>);</span><br><span class="line">  wp-&gt;expr[<span class="keyword">sizeof</span>(wp-&gt;expr)<span class="number">-1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> success=<span class="literal">false</span>;</span><br><span class="line">  wp-&gt;value=expr((<span class="type">char</span> *)exprression,&amp;success);</span><br><span class="line">  assert(success);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// wp-&gt;value=value;</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Watchpoint %d: %s\n&quot;</span>, wp-&gt;NO, wp-&gt;expr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调试工具与原理"><a href="#调试工具与原理" class="headerlink" title="调试工具与原理"></a>调试工具与原理</h3><p>10.7</p>
<ul>
<li>可能会碰到段错误：</li>
<li>一些软件工程相关的概念:<ul>
<li>Fault: 实现错误的代码, 例如if (p &#x3D; NULL)</li>
<li>Error: 程序执行时不符合预期的状态, 例如p被错误地赋值成NULL</li>
<li>Failure: 能直接观测到的错误, 例如程序触发了段错误</li>
</ul>
</li>
<li>调试：从failure一步一步回溯寻找fault的过程</li>
<li>调试之所以不容易：<ul>
<li>fault不一定马上触发error</li>
<li>触发了error也不一定马上转变成可观测的failure</li>
<li>error会像滚雪球一般越积越多, 当我们观测到failure的时候, 其实已经距离fault非常遥远了</li>
</ul>
</li>
<li>相应的策略:<ul>
<li>尽可能<strong>把fault转变成error</strong>. 这其实就是<strong>测试</strong>做的事情, 所以我们在上一节中加入了表达式生成器的内容, 来帮助大家进行测试, 后面的实验内容也会提供丰富的测试用例. 但并不是有了测试用例就能把所有fault都转变成error了, 因为这取决于<strong>测试的覆盖度</strong>. 要设计出一套全覆盖的测试并不是一件简单的事情, 越是复杂的系统, 全覆盖的测试就越难设计. 但是, 如何提高测试的覆盖度, 是学术界一直以来都在关注的问题.</li>
</ul>
</li>
</ul>
<h4 id="你会如何测试你的监视点实现"><a href="#你会如何测试你的监视点实现" class="headerlink" title="你会如何测试你的监视点实现?"></a>你会如何测试你的监视点实现?</h4><ul>
<li>见“必做：实现监视点”的“调试”部分</li>
<li>一些有用的调试工具：<ul>
<li><code>-Wall</code>,<code>-Werror</code></li>
<li><code>assert()</code>:在运行时刻把error直接转变成failure</li>
<li><code>prontf()</code></li>
<li>GDB</li>
</ul>
</li>
</ul>
<h4 id="强大的GDB"><a href="#强大的GDB" class="headerlink" title="强大的GDB"></a>强大的GDB</h4><p>如果你遇到了段错误, 你很可能会想知道究竟是哪一行代码触发了段错误. 尝试编写一个触发段错误的程序, 然后在GDB中运行它. 你发现GDB能为你提供哪些有用的信息吗?</p>
<ol>
<li>编写一个触发段错误的程序。例如尝试访问一个空指针：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">// 访问空指针，触发段错误</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *ptr);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述代码保存为segfault.c。</li>
</ul>
<ol start="2">
<li>编译程序</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -g -o segfault segfault.c</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>使用GDB调试</li>
<li>启动 GDB：<br>  <code>gdb ./segfault</code></li>
<li>运行程序：在 GDB 提示符下，输入 run 命令运行程序：<br>  <code>(gdb) run</code></li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/xiaoyao/Desktop/segfault </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x0000555555555161 in main () at segfault.c:5</span><br><span class="line">5	    printf(&quot;%d\n&quot;, *p);//访问空指针，触发段错误</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>查看段错误信息：当程序触发段错误时，GDB 会停止执行，并显示段错误发生的位置。你可以使用 backtrace 命令查看调用堆栈：<br>  <code>(gdb) backtrace</code>显示调用堆栈中的所有函数，帮助确定段错误发生的确切位置。</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) backtrace</span><br><span class="line">#0  0x0000555555555161 in main () at segfault.c:5</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>查看代码行：<br>  <code>(gdb) list</code>使用 list 命令查看段错误发生的代码行：</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) list</span><br><span class="line">1	#include&lt;stdio.h&gt;</span><br><span class="line">2	</span><br><span class="line">3	int main() &#123;</span><br><span class="line">4	    int *p = NULL;</span><br><span class="line">5	    printf(&quot;%d\n&quot;, *p);//访问空指针，触发段错误</span><br><span class="line">6	    return 0;</span><br><span class="line">7	&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>检查变量：<br>  <code>(gdb) print p</code>使用 print 命令检查变量的值。例如，检查指针p的值：</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) print p</span><br><span class="line">$1 = (int *) 0x0</span><br></pre></td></tr></table></figure>
<ul>
<li>总结：GDB调试段错误可提供的有用信息：<ol>
<li><strong>段错误发生的位置</strong>：</li>
</ol>
<ul>
<li>GDB 会在段错误发生时停止程序执行，并显示段错误发生的确切位置，包括文件名和行号。</li>
</ul>
<ol start="2">
<li><strong>调用堆栈</strong>：</li>
</ol>
<ul>
<li>使用 <code>backtrace</code> 命令可以查看调用堆栈，显示函数调用的层次结构，帮助你确定段错误发生时的调用路径。</li>
</ul>
<ol start="3">
<li><strong>变量的值</strong>：</li>
</ol>
<ul>
<li>使用 <code>print</code> 命令可以查看变量的值，帮助你检查指针是否为空或变量是否有异常值。</li>
</ul>
<ol start="4">
<li><strong>代码上下文</strong>：</li>
</ol>
<ul>
<li>使用 <code>list</code> 命令可以查看段错误发生的代码行及其上下文，帮助你理解代码的执行逻辑。</li>
</ul>
<ol start="5">
<li><strong>寄存器状态</strong>：</li>
</ol>
<ul>
<li>使用 <code>info registers</code> 命令可以查看 CPU 寄存器的当前状态，帮助你检查寄存器的值是否正确。</li>
</ul>
<ol start="6">
<li><strong>内存内容</strong>：</li>
</ol>
<ul>
<li>使用 <code>x</code> 命令可以查看内存内容，帮助你检查内存地址是否有效或内存内容是否正确。</li>
</ul>
</li>
</ul>
<h4 id="sanitizer-一种底层的assert"><a href="#sanitizer-一种底层的assert" class="headerlink" title="sanitizer - 一种底层的assert"></a>sanitizer - 一种底层的assert</h4><ul>
<li>手动在这些访问（非法访存）之前添加assert(), 太麻烦了. </li>
<li>让编译器支持这个功能的是一个叫<code>Address Sanitizer</code>的工具, 它可以自动地在指针和数组的访问之前插入用来检查是否越界的代码. <code>GCC</code>提供了一个<code>-fsanitize=address</code>的编译选项来启用它<code>. menuconfig</code>已经为大家准备好相应选项了, 你只需要打开它:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Build Options</span><br><span class="line">  [*] Enable address sanitizer</span><br></pre></td></tr></table></figure>
<ul>
<li>然后清除编译结果并重新编译即可.<br>-对每一次访存进行检查会带来额外的性能开销.可以在无需调试的时候将其关闭.</li>
<li>事实上, 除了地址越界的错误之外, <code>Address Sanitizer还</code>能检查<code>use-after-free</code>的错误 (即”释放从堆区申请的空间后仍然继续使用”的错误), 你知道它是如何实现这一功能的吗?<ul>
<li>AddressSanitizer 通过在内存分配和释放操作中插入钩子函数、使用影子内存记录内存状态、在每次内存访问时检查内存状态等机制，有效地检测 use-after-free 错误。</li>
</ul>
</li>
</ul>
<h5 id="让Address-Sanitizer输出更精确的出错位置"><a href="#让Address-Sanitizer输出更精确的出错位置" class="headerlink" title="让Address Sanitizer输出更精确的出错位置"></a>让Address Sanitizer输出更精确的出错位置</h5><p>如果在添加GDB调试信息的情况下打开Address Sanitizer, 其报错信息还会指出发生错误的具体代码位置, 为问题的定位提供便利.</p>
<h5 id="更多的sanitizer"><a href="#更多的sanitizer" class="headerlink" title="更多的sanitizer"></a>更多的sanitizer</h5><p>事实上, GCC还支持更多的sanitizer, 它们可以检查各种不同的错误, 你可以在man gcc中查阅-fsanitize相关的选项. 如果你的程序在各种sanitizer开启的情况下仍然能正确工作, 就说明你的程序还是有一定质量的.</p>
<h4 id="总结：关于调试"><a href="#总结：关于调试" class="headerlink" title="总结：关于调试"></a>总结：关于调试</h4><ul>
<li>总是使用-Wall和-Werror</li>
<li>尽可能多地在代码中插入assert()</li>
<li>调试时先启用sanitizer</li>
<li>assert()无法捕捉到error时, 通过printf()输出可疑的变量, 期望能观测到error</li>
<li>printf()不易观测error时, 通过GDB理解程序的精确行为</li>
</ul>
<h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><ul>
<li>断点的功能是让程序暂停下来, 从而方便查看程序某一时刻的状态。</li>
<li>事实上, 我们可以很容易地用监视点来模拟断点的功能:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">w $pc == ADDR</span><br></pre></td></tr></table></figure>
<p>其中ADDR为设置断点的地址. 这样程序执行到ADDR的位置时就会暂停下来.</p>
<ul>
<li>断点机制的工作原理<br>在调试器中设置断点的典型步骤如下：<ul>
<li>保存原始指令：调试器保存断点位置的原始指令。</li>
<li>插入断点指令：调试器在断点位置插入 int3 指令。</li>
<li>执行程序：程序运行到断点位置时，会触发 int3 指令，导致程序中断并转到调试器。</li>
<li>恢复原始指令：调试器在断点位置恢复原始指令，并调整程序计数器（PC）以继续执行。</li>
</ul>
</li>
</ul>
<h4 id="一点也不能长"><a href="#一点也不能长" class="headerlink" title="一点也不能长?"></a>一点也不能长?</h4><ul>
<li>x86的int3指令不带任何操作数, 操作码为1个字节, 因此指令的长度是1个字节. 这是必须的吗? 假设有一种x86体系结构的变种my-x86, 除了int3指令的长度变成了2个字节之外, 其余指令和x86相同. 在my-x86中, 上述文章中的断点机制还可以正常工作吗? 为什么?</li>
<li>在 x86 架构中，int3 指令是一个单字节的指令，操作码为 0xCC。它通常用于设置断点，因为它的长度为 1 字节，可以方便地插入到代码中而不会影响其他指令的执行。</li>
<li>假设在一种变种架构 my-x86 中，int3 指令的长度变成了 2 个字节，而其他指令和 x86 相同，那么断点机制可能会受到影响。</li>
<li>在 my-x86 中的影响<br>在 my-x86 中，int3 指令的长度变成了 2 个字节，这会对上述断点机制产生以下影响：<ol>
<li>指令长度的变化：</li>
</ol>
<ul>
<li>在 x86 中，int3 指令是 1 个字节，可以方便地插入到任何位置。</li>
<li>在 my-x86 中，int3 指令是 2 个字节，这意味着插入断点时需要考虑指令对齐和覆盖的问题。</li>
</ul>
<ol start="2">
<li>覆盖原始指令：</li>
</ol>
<ul>
<li>在 x86 中，插入 1 字节的 int3 指令通常不会覆盖多条指令。</li>
<li>在 my-x86 中，插入 2 字节的 int3 指令可能会覆盖部分原始指令，导致恢复原始指令时出现问题。</li>
</ul>
<ol start="3">
<li>程序计数器的调整：</li>
</ol>
<ul>
<li>在 x86 中，恢复原始指令后，程序计数器（PC）只需调整 1 字节。</li>
<li>在 my-x86 中，恢复原始指令后，程序计数器（PC）需要调整 2 字节，这可能需要额外的处理逻辑。</li>
</ul>
</li>
<li>解决方案<br>为了在 my-x86 中正确实现断点机制，可以考虑以下解决方案：<ol>
<li>调整断点插入逻辑：</li>
</ol>
<ul>
<li>在插入断点时，确保 int3 指令不会覆盖多条原始指令。如果覆盖了多条指令，需要保存所有被覆盖的指令，并在恢复时正确恢复。</li>
</ul>
<ol start="2">
<li>调整程序计数器：</li>
</ol>
<ul>
<li>在恢复原始指令后，正确调整程序计数器（PC），使其跳过 2 字节的 int3 指令。</li>
</ul>
</li>
</ul>
<h4 id="随心所欲的断点"><a href="#随心所欲的断点" class="headerlink" title="随心所欲的断点"></a>随心所欲的断点</h4><ul>
<li>如果把断点设置在指令的非首字节(中间或末尾), 会发生什么? 你可以在GDB中尝试一下, 然后思考并解释其中的缘由.</li>
<li>当程序运行到断点位置时，GDB 会暂停程序执行，并显示断点位置的汇编代码。然而，<strong>由于断点设置在指令的中间或末尾，CPU 将无法正确解码该指令</strong>，可能会导致以下几种情况：<ol>
<li>非法指令异常：</li>
</ol>
<ul>
<li>CPU 尝试解码<strong>从中间开始</strong>的指令时，可能会<strong>将其解释为非法指令</strong>，从而触发非法指令异常。</li>
</ul>
<ol start="2">
<li>错误的指令执行：</li>
</ol>
<ul>
<li>CPU 可能会<strong>错误地解码和执行部分指令</strong>，导致程序行为异常或崩溃。</li>
</ul>
<ol start="3">
<li>程序崩溃：</li>
</ol>
<ul>
<li>由于指令解码错误，程序可能会崩溃，并显示段错误或其他异常。</li>
</ul>
</li>
</ul>
<h4 id="NEMU的前世今生"><a href="#NEMU的前世今生" class="headerlink" title="NEMU的前世今生"></a>NEMU的前世今生</h4><ul>
<li>你已经对NEMU的工作方式有所了解了. 事实上在NEMU诞生之前, NEMU曾经有一段时间并不叫NEMU, 而是叫NDB(NJU Debugger), 后来由于某种原因才改名为NEMU. 如果你想知道这一段史前的秘密, 你首先需要了解这样一个问题: 模拟器(Emulator)和调试器(Debugger)有什么不同? 更具体地, 和NEMU相比, GDB到底是如何调试程序的?</li>
<li>模拟器（如 NEMU）和调试器（如 GDB）在功能和用途上有显著的不同。<ul>
<li>NEMU 作为模拟器，主要用于模拟目标硬件的行为。</li>
<li>GDB 作为调试器，主要用于调试和分析程序的运行。</li>
</ul>
</li>
<li>GDB 通过操作系统提供的调试接口控制程序的执行，而 NEMU 通过软件模拟目标硬件的行为。</li>
</ul>
<h1 id="如何阅读手册"><a href="#如何阅读手册" class="headerlink" title="如何阅读手册"></a>如何阅读手册</h1><h2 id="学会使用目录-逐步细化搜索范围"><a href="#学会使用目录-逐步细化搜索范围" class="headerlink" title="学会使用目录+逐步细化搜索范围"></a>学会使用目录+逐步细化搜索范围</h2><h3 id="必做：尝试通过目录定位关注的问题"><a href="#必做：尝试通过目录定位关注的问题" class="headerlink" title="必做：尝试通过目录定位关注的问题"></a>必做：尝试通过目录定位关注的问题</h3><ul>
<li>假设你现在需要了解一个叫selector的概念, 请通过i386手册的目录确定你需要阅读手册中的哪些地方. 即使你选择的ISA并不是x86, 也可以尝试去查阅这个概念.</li>
</ul>
<h2 id="必答题"><a href="#必答题" class="headerlink" title="必答题"></a>必答题</h2><ul>
<li><p>程序是个状态机（1）</p>
</li>
<li><p>理解基础设施</p>
<ul>
<li>花75小时<ul>
<li>450 次调试 * 600 秒&#x2F;次 &#x3D; 270000 秒 &#x3D; 75小时</li>
</ul>
</li>
<li>简易调试器可以帮助节省50小时<ul>
<li>450次调试 * 200 秒&#x2F;次 &#x3D; 90000 秒 &#x3D; 25小时</li>
</ul>
</li>
</ul>
</li>
<li><p><code>RTFM</code> 理解了科学查阅手册的方法之后, 请你尝试在你选择的ISA手册中查阅以下问题所在的位置, 把需要阅读的范围写到你的实验报告里面:<code>riscv32</code></p>
<ul>
<li>riscv32有哪几种指令格式?<ul>
<li>2.2 Instruction Formats（基本指令格式）</li>
<li>四种，R&#x2F;I&#x2F;S&#x2F;U</li>
</ul>
</li>
<li>LUI指令的行为是什么?<ul>
<li>2.4: Integer Computational Instructions 中的 LUI (Load Upper Immediate) 子章节。</li>
</ul>
</li>
<li>mstatus寄存器的结构是怎么样的?<ul>
<li>3.1: Control and Status Registers (CSRs) 中的 mstatus Register 子章节。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>shell</code>命令 </p>
<ul>
<li>完成PA1的内容之后, nemu&#x2F;目录下的所有.c和.h和文件总共有多少行代码?<ul>
<li><strong>296394</strong> 总计</li>
<li>debug之后<strong>296412</strong></li>
</ul>
</li>
<li>你是使用什么命令得到这个结果的?<ul>
<li><code>find nemu/ -name &quot;*.c&quot; -o -name &quot;*.h&quot; | xargs wc -l</code></li>
</ul>
</li>
<li>和框架代码相比, 你在PA1中编写了多少行代码? (Hint: 目前pa0分支中记录的正好是做PA1之前的状态, 思考一下应该如何回到”过去”?) <ul>
<li><code>git checkout pa0</code>切换到pa0分支</li>
<li><code>find nemu/ -name &quot;*.c&quot; -o -name &quot;*.h&quot; | xargs wc -l</code></li>
<li>295794（pa0）</li>
<li>所以<strong>600行</strong>！</li>
</ul>
</li>
<li>你可以把这条命令写入Makefile中, 随着实验进度的推进, 你可以很方便地统计工程的代码行数, 例如敲入make count就会自动运行统计代码行数的命令. <ul>
<li>make count却报错【缺少分割符】，改了默认的“空格：2”为“制表符长度：4”，ok</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 统计代码行数</span><br><span class="line">count:</span><br><span class="line">@echo &quot;Total lines of code:&quot;</span><br><span class="line">@find . -name &quot;*.c&quot; -o -name &quot;*.h&quot; | xargs cat | wc -l</span><br><span class="line">@echo &quot;Total lines of code (excluding empty lines):&quot;</span><br><span class="line">@find . -name &quot;*.c&quot; -o -name &quot;*.h&quot; | xargs grep -v &#x27;^\s*$$&#x27; | wc -l</span><br></pre></td></tr></table></figure></li>
<li>再来个难一点的, 除去空行之外, nemu&#x2F;目录下的所有.c和.h文件总共有多少行代码?<ul>
<li><strong>259683</strong>（debug之后<strong>259700</strong>）</li>
<li><code>find nemu/ -name &quot;*.c&quot; -o -name &quot;*.h&quot; | xargs grep -v &#39;^\s*$&#39; | wc -l</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>RTFM</code> 打开<code>nemu/scripters/build.mk</code>文件, 你会在CFLAGS变量中看到gcc的一些编译选项. 请解释gcc中的-Wall和-Werror有什么作用? 为什么要使用-Wall和-Werror?<br><code>CFLAGS  := -O2 -MMD -Wall -Werror $(INCLUDES) $(CFLAGS)</code></p>
<ul>
<li><code>man gcc</code>可知：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Wall</span><br><span class="line">  This enables all the warnings about constructions that some users consider questionable, and that are easy to avoid (or modify to prevent the warning), even in conjunction with macros.</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Werror</span><br><span class="line">    Make all warnings into errors.</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-Wall</code>作用：<code>-Wall</code>选项用于启用所有常见的警告。这些警告可以帮助开发者发现代码中的潜在问题和不良实践。启用<code>-Wall</code>后，编译器会报告以下类型的警告（但不限于）：<ul>
<li>未使用的变量</li>
<li>未使用的函数</li>
<li>未初始化的变量</li>
<li>可疑的类型转换</li>
<li>可能的数组越界</li>
<li>其他潜在的编程错误</li>
</ul>
</li>
<li><code>-Werror`作用：</code>-Werror&#96;&#96;选项将所有警告视为错误。这意味着如果编译过程中出现任何警告，编译器将停止编译，并报告这些警告为错误。这样可以确保代码在编译时没有任何警告，从而提高代码的质量和可靠性。</li>
<li>为什么要使用 -Wall 和 -Werror<ol>
<li>提高代码质量：启用 -Wall 可以帮助开发者发现代码中的潜在问题和不良实践，从而提高代码的质量。</li>
<li>强制修复警告：使用 -Werror 可以确保所有警告都被视为错误，强制开发者在提交代码之前修复所有警告。这有助于保持代码库的整洁和高质量。</li>
<li>减少潜在错误：许多警告可能会导致运行时错误或难以调试的问题。通过修复这些警告，可以减少潜在的运行时错误。</li>
<li>一致性：在团队开发中，使用 -Wall 和 -Werror 可以确保所有开发者都遵循相同的编码标准，保持代码的一致性。</li>
</ol>
</li>
</ul>
</li>
<li><p>10.9凌晨，终于Accepted，PA1花了45h左右，收获良多，继续加油！</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机系统基础实验</category>
      </categories>
      <tags>
        <tag>PA</tag>
      </tags>
  </entry>
  <entry>
    <title>6-虚拟存储器</title>
    <url>/2025/02/22/6.%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    <content><![CDATA[<h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><ul>
<li>分别实现<strong>实模式、分段式、段页式</strong>三种内存的地址转换与数据加载功能。</li>
</ul>
<ol>
<li>地址转换<ul>
<li>在MMU类中，实现三个地址转换的方法，将逻辑地址转换为线性地址再转换为物理地址。</li>
<li>private String toRealLinearAddr(String logicAddr)</li>
<li>private String toSegLinearAddr(String logicAddr)</li>
<li>private String toPagePhysicalAddr(String linearAddr)</li>
</ul>
</li>
<li>数据加载<ul>
<li>在Memory类中，实现三个数据加载方法。</li>
<li>public void real_load(String pAddr, int len)</li>
<li>public void seg_load(int segIndex)</li>
<li>public void page_load(int vPageNo)</li>
</ul>
</li>
<li>融合cache与TLB<ul>
<li>将cache与TLB融合到MMU中。</li>
</ul>
</li>
</ol>
<ul>
<li>逻辑地址：<strong>指令</strong>中给出的地址， 48 位(16位段寄存器 + 32位段内偏移量)。<ul>
<li>CPU在运行指令时，如果想要访问内存，它并不是用直接使用内存的地址访问，而是给出一个由 16 位段寄存器和 32 位段内偏移量拼起来的 48 位的逻辑地址。<ul>
<li>比如，如果CPU想知道当前指令的地址，他给出的逻辑地址应该是(CS:EIP)。</li>
<li>其中，CS是 16 位代码段寄存器，EIP是 32 位指令指针寄存器（也就是程序计数器PC）。</li>
</ul>
</li>
</ul>
</li>
<li>线性地址：逻辑地址到物理地址的中间层， 32 位。<ul>
<li>如果<strong>没有启用分页机制</strong>，那么线性地址就<strong>等于物理地址</strong>。</li>
<li>如果启用了分页机制，那么线性地址需要通过再一次变换才能得到物理地址。</li>
</ul>
</li>
<li>物理地址：<strong>内存</strong>中的地址， 32 位。</li>
</ul>
<h1 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h1><h2 id="Memory的real-load方法"><a href="#Memory的real-load方法" class="headerlink" title="Memory的real_load方法"></a>Memory的<code>real_load</code>方法</h2><ul>
<li>SEGMENT和PAGE均为false时，为实模式</li>
<li>变量：<code>pAddr</code>与<code>len</code></li>
</ul>
<ol>
<li>直接用地址和长度从磁盘disk.read加载data</li>
<li>把data再写进内存(注意实模式下，内存地址对应磁盘地址，即pAddr)</li>
</ol>
<ul>
<li><code>System.arraycopy(data, 0, memory, start, len);</code><ul>
<li>将<strong>原数组</strong>data从<strong>起始位置</strong>0，复制到<strong>目标数组</strong>memory的start<strong>位置开始</strong>，复制的<strong>元素数量</strong>为len</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实模式下从磁盘中加载数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pAddr 实模式下，内存地址对应磁盘地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> len   数据段长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">real_load</span><span class="params">(String pAddr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] data = disk.read(pAddr, len);<span class="comment">//从磁盘中读取数据(方法在Disk.java中）</span></span><br><span class="line">    <span class="comment">//更新数据</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(pAddr));<span class="comment">//start,为内存地址</span></span><br><span class="line">    System.arraycopy(data, <span class="number">0</span>, memory, start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h2><ul>
<li>&#96;&#96;toRealLinearAddr&#96;方法: 逻辑地址转线性地址。<ul>
<li>段寄存器左移4位 + 段内偏移量的低16位 再补齐32位</li>
</ul>
</li>
</ul>
<ol>
<li><strong>截取前16位段寄存器</strong>；再<strong>截取offset低16位（实际截取32位）</strong>，转成int。<ul>
<li>在实际计算中，我们把高 16 位看作基址，低 32 位看作偏移量（实际有用的只有低 16 位）</li>
</ul>
</li>
<li>将段寄存器和偏移量<strong>化为整数</strong></li>
<li><strong>段寄存器左移4位</strong><ul>
<li>可以直接使用Java中的&lt;&lt;运算符将整数左移4位</li>
</ul>
</li>
<li>两个数字相加，转成二进制，高位补0到32位</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 实模式下的逻辑地址转线性地址</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> logicAddr 48位 = 16位段寄存器 + 32位offset，计算公式为：①(16-bits段寄存器左移4位 + offset的低16-bits) = 20-bits物理地址 ②高位补0到32-bits</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 32-bits实模式线性地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> String <span class="title function_">toRealLinearAddr</span><span class="params">(String logicAddr)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">segReg</span> <span class="operator">=</span> logicAddr.substring(<span class="number">0</span>, <span class="number">16</span>);<span class="comment">//取逻辑地址的前16位作为段寄存器</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">offset</span> <span class="operator">=</span> logicAddr.substring(<span class="number">16</span>, <span class="number">48</span>);<span class="comment">//取逻辑地址的后32位作为偏移量</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//将段寄存器和偏移量化为整数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">segRegInt</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(segReg));</span><br><span class="line">       <span class="type">int</span> <span class="variable">offsetLow16</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(offset));</span><br><span class="line"></span><br><span class="line">       <span class="comment">//计算20位物理地址</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">physicalAddr</span> <span class="operator">=</span> (segRegInt &lt;&lt; <span class="number">4</span>) + offsetLow16;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将20位物理地址转换为32位</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">linearAddr</span> <span class="operator">=</span> String.format(<span class="string">&quot;%32s&quot;</span>, Integer.toBinaryString(physicalAddr)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>);<span class="comment">//转换为32位，并用0填充高位</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> linearAddr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="分段式"><a href="#分段式" class="headerlink" title="分段式"></a>分段式</h1><h2 id="Memory类：实现seg-load段加载方法"><a href="#Memory类：实现seg-load段加载方法" class="headerlink" title="Memory类：实现seg_load段加载方法"></a>Memory类：实现seg_load段加载方法</h2><ol>
<li>从磁盘上加载该段的数据到内存。<ul>
<li>如何从磁盘上<strong>读取一整段</strong>呢？你应该使用<strong>段基址</strong>作为访问磁盘的地址，用**段限长（即段大小）**作为读取的长度。</li>
<li>至于段基址和段限长是多少，参考我们3.2.3的规定。<ul>
<li>private char[] base &#x3D; new char[32];  &#x2F;&#x2F; 32位基地址</li>
<li>private char[] limit &#x3D; new char[20]; &#x2F;&#x2F; 20位限长</li>
</ul>
</li>
<li>那么加载过来之后<strong>写到内存的哪里</strong>呢？由于分段式下每个段大小只有1MB，不会超出内存大小，所以我们<strong>默认把数据放在物理地址为 0 的地方</strong>。</li>
</ul>
</li>
<li>除了加载数据，你还需要<strong>填好全局描述符表GDT</strong>，需要填入的内容还是按照3.2.3的规定进行填写。下面为该规定的原文。<ul>
<li>每个由MMU装载进入GDT的段，<strong>其段基址均为全 0 ，其限长均为全 1</strong> ，<strong>未开启分页时粒度为false，开启分页后粒度为true</strong>。</li>
</ul>
</li>
</ol>
<ul>
<li>变量：segIndex段索引</li>
</ul>
<ol>
<li>获取段描述符：<ul>
<li>(有方法)通过 segIndex 获取对应的段描述符 segDes</li>
</ul>
</li>
<li>获取段基址和段限长：<ul>
<li><strong>段基址：32位全0</strong></li>
<li><strong>段限长：20位全1</strong></li>
</ul>
</li>
<li>判断是否开启分页<ul>
<li>如果<strong>未开启分页模式</strong>（PAGE 为 false），</li>
<li>则<strong>从磁盘中读取数据</strong>，并将数据<strong>写入内存</strong>的<strong>物理地址为0</strong>的地方。</li>
<li>注意，<strong>段限长</strong><em>是从0开始计数</em>，因此<strong>读取长度需要加1</strong>。</li>
</ul>
</li>
<li>更新段描述符：<ul>
<li>基址</li>
<li>限长</li>
<li>有效位：validBit 设置为 true 表示段已在内存中</li>
<li>粒度：granularity 设置为 PAGE（未开启分页时粒度为false，开启分页后粒度为true）</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 段式存储模式下，从磁盘中加载数据.段页式存储中，不用从磁盘中加载数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> segIndex 段索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//在段页式存储管理下，从磁盘加载数据应该是以页为单位的，不再是以段为单位。</span></span><br><span class="line"><span class="comment">// 开启分页之后，一个段应该是4GB。因此开启分页之后，seg_load应该跳过加载数据这一步，它的作用在开启分页之后仅仅是填写GDT，加载数据的任务应该交给page_load来完成。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">seg_load</span><span class="params">(<span class="type">int</span> segIndex)</span> &#123;</span><br><span class="line">    <span class="comment">//获取段描述符</span></span><br><span class="line">    <span class="type">SegDescriptor</span> <span class="variable">segDes</span> <span class="operator">=</span> getSegDescriptor(segIndex);</span><br><span class="line">   <span class="comment">//获取段基址(访问磁盘的地址)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">segBase</span> <span class="operator">=</span> <span class="string">&quot;00000000000000000000000000000000&quot;</span>; <span class="comment">// 32位基址，全0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">baseInt</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(segBase));</span><br><span class="line">    <span class="comment">//获取段限长(读取的长度)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="string">&quot;11111111111111111111&quot;</span>; <span class="comment">// 20位限长，全1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">limitInt</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(limit));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!PAGE) &#123;<span class="comment">//未开启分页,段式存储，要从磁盘中加载数据，并且写到内存的物理地址为0的地方</span></span><br><span class="line">        <span class="comment">//从磁盘中加载数据</span></span><br><span class="line">        <span class="type">byte</span>[] data = disk.read(segBase, limitInt + <span class="number">1</span>);<span class="comment">//注：段限长是一个从 0 开始的计数，因此需要+1才能表示实际的字节数</span></span><br><span class="line">        <span class="comment">//更新数据,写到内存的物理地址(destPost)为0的地方</span></span><br><span class="line">        System.arraycopy(data, <span class="number">0</span>, memory, <span class="number">0</span>, limitInt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填好全局描述符表GDT</span></span><br><span class="line">    segDes.base = segBase.toCharArray();</span><br><span class="line">    segDes.limit = limit.toCharArray();</span><br><span class="line">    segDes.validBit = <span class="literal">true</span>;<span class="comment">//有效位,为true表示被占用（段已在内存中）</span></span><br><span class="line">    segDes.granularity = PAGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MMU类：​​​​toSegLinearAddr​​​​-逻辑地址转线性地址。"><a href="#MMU类：​​​​toSegLinearAddr​​​​-逻辑地址转线性地址。" class="headerlink" title="MMU类：​​​​toSegLinearAddr​​​​ 逻辑地址转线性地址。"></a>MMU类：​​​​toSegLinearAddr​​​​ 逻辑地址转线性地址。</h2><ul>
<li>在分段式下，逻辑地址转线性地址应该要查全局描述符表GDT，按照2.3.4的流程进行计算。<ul>
<li>48 位的逻辑地址包含 16 位的段选择符和 32 位的段内偏移量。</li>
<li>MMU首先通过段选择符内的 13 位<strong>索引值</strong>，</li>
<li>从段描述符表中找到对应的段描述符，从中取出 32 位的<strong>基地址</strong>，与逻辑地址中 32 位的<strong>段内偏移量</strong>相加，就得到 32 位线性地址。</li>
</ul>
</li>
<li>注意，不要以为可以偷懒直接把逻辑地址的前 16 位去掉</li>
</ul>
<ol>
<li>直接调用已有的函数获得<strong>段索引</strong>​​​​segIndex​​​​</li>
<li>根据段索引获得<strong>段基址</strong>，也是直接调用函数。将段基址<strong>转成int</strong></li>
<li>截取32位段内偏移​​​​offset​​​​，<strong>转成int</strong></li>
<li>段基址与段内偏移<strong>相加</strong>，<strong>转成32位二进制</strong>，得到线性地址</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 分段模式下的逻辑地址转线性地址</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> logicAddr 48位 = 16位段选择符(高13位index选择段表项) + 32位段内偏移</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 32-bits 线性地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String <span class="title function_">toSegLinearAddr</span><span class="params">(String logicAddr)</span> &#123;</span><br><span class="line">       <span class="comment">//获取段索引(高13位index选择段表项)</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">segIndex</span> <span class="operator">=</span> getSegIndex(logicAddr);</span><br><span class="line">       <span class="comment">//从全局描述符表GDT中获取段描述符中的段基址base</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">segBaseAddr</span> <span class="operator">=</span> String.valueOf(Memory.getMemory().getBaseOfSegDes(segIndex));</span><br><span class="line">       <span class="comment">//提取段内偏移（32位）</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">offset</span> <span class="operator">=</span> logicAddr.substring(<span class="number">16</span>, <span class="number">48</span>);</span><br><span class="line">       <span class="comment">//将段基址和段内偏移转换为整数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">segBaseAddrInt</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(segBaseAddr));</span><br><span class="line">       <span class="type">int</span> <span class="variable">offsetInt</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(offset));</span><br><span class="line">       <span class="comment">//计算线性地址</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">linearAddr</span> <span class="operator">=</span> segBaseAddrInt + offsetInt;</span><br><span class="line">       <span class="comment">//将线性地址转换为32位</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">linearAddrStr</span> <span class="operator">=</span> String.format(<span class="string">&quot;%32s&quot;</span>, Integer.toBinaryString(linearAddr)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">       <span class="keyword">return</span> linearAddrStr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h1><h2 id="Memory类：page-load页加载方法。"><a href="#Memory类：page-load页加载方法。" class="headerlink" title="Memory类：page_load页加载方法。"></a>Memory类：page_load页加载方法。</h2><ol>
<li>从磁盘上加载该页数据到内存。<ul>
<li>如何在磁盘上读取该页数据呢？你应该使用<strong>该虚页的起始地址</strong>作为作为访问磁盘的地址，用<strong>页大小</strong>作为读取的长度。</li>
<li>至于<strong>该虚页的起始地址</strong>是多少，可以直接根据<strong>虚页号</strong>得到。</li>
<li>那么加载过来之后写到内存的哪里呢？这就需要你找出一个<strong>空闲的物理页框</strong>然后放下去啦。</li>
</ul>
</li>
<li>除了加载数据，你还需要<strong>填好页表</strong>，如果你使用有效位数组的话还需要<strong>填好有效位数组</strong>。</li>
</ol>
<ul>
<li>变量：​​​​vPageNo​​​​ 虚拟页号</li>
</ul>
<h3 id="1-加载页数据"><a href="#1-加载页数据" class="headerlink" title="1. 加载页数据"></a>1. 加载页数据</h3><ol>
<li>使用<strong>该虚页的起始地址</strong>作为访问磁盘的地址，<strong>起始地址&#x3D;虚页号×一页大小</strong></li>
<li>由于<strong>一页的大小是4KB</strong>，需要把虚拟页号乘以<strong>2的12次方</strong>，<ul>
<li>即转为二进制作为地址，<strong>二进制后面加12个0</strong></li>
</ul>
</li>
<li>从<strong>磁盘读</strong>出一页数据data。（长度为​​​​PAGE_SIZE_B​​​​页长）</li>
</ol>
<h3 id="2-写入内存"><a href="#2-写入内存" class="headerlink" title="2. 写入内存"></a>2. 写入内存</h3><ol>
<li>寻找<strong>空闲内存的物理页框</strong>——遍历valid找false。</li>
</ol>
<ul>
<li>范围<code>​​​​0 ~ pageValid.length​​​</code>​，<ul>
<li>当​​​pageValid[i]​​​​<strong>为​false​​​​，说明不在内存中，即空闲</strong>，将其<strong>改为占用</strong>，并<strong>记录页框号​​​​frameNO</strong>​​​​。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>接着将<em>数据装入页框</em>。将<strong>页框号×页大小</strong>，获得<strong>物理地址</strong>，将数据写入内存。（长度为​​​​PAGE_SIZE_B​​​​页长）</li>
</ol>
<h3 id="3-填页表"><a href="#3-填页表" class="headerlink" title="3. 填页表"></a>3. 填页表</h3><ol>
<li>由虚拟页号获得该页（​​​​getPageItem(vPageNo)​​​​），</li>
</ol>
<ul>
<li>将​​​​pageFrame​​​​设为页框号二进制的低20位转成的数组（物理页框号）</li>
<li>将​​​​isInMem​​​​设为true。（装入了内存）</li>
</ul>
<ol start="2">
<li>填好有效位（刚刚占用的设为true）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 段页式存储下，从磁盘中加载数据</span></span><br><span class="line"><span class="comment"> * 不考虑16MB内存用满的情况</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> vPageNo 虚拟页号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">page_load</span><span class="params">(<span class="type">int</span> vPageNo)</span> &#123;</span><br><span class="line">    <span class="comment">//虚拟页号的起始地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">vPageStartAddr</span> <span class="operator">=</span> Transformer.intToBinary(String.valueOf(vPageNo)).substring(<span class="number">12</span>) + <span class="string">&quot;000000000000&quot;</span>;</span><br><span class="line">    <span class="comment">//页大小作为读取的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> PAGE_SIZE_B;</span><br><span class="line">    <span class="comment">//从磁盘中加载数据</span></span><br><span class="line">    <span class="type">byte</span>[] data = disk.read(vPageStartAddr, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找出一个空闲的物理页框</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">freePageFrame</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;pageValid.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pageValid[i])&#123;<span class="comment">//如果该页不在内存中,即valid=false</span></span><br><span class="line">            freePageFrame = i;<span class="comment">//找到空闲的物理页框i</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (freePageFrame == -<span class="number">1</span>)&#123;<span class="comment">//无空闲</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;No free page frame&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据写到内存的物理地址为freePageFrame的地方</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">phyAddr</span> <span class="operator">=</span> freePageFrame * PAGE_SIZE_B;<span class="comment">//物理地址，即物理页框号*页大小</span></span><br><span class="line">    System.arraycopy(data, <span class="number">0</span>, memory, phyAddr, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填好页表</span></span><br><span class="line">    <span class="type">PageItem</span> <span class="variable">pageItem</span> <span class="operator">=</span> getPageItem(vPageNo);</span><br><span class="line">    pageItem.pageFrame = Transformer.intToBinary(String.valueOf(freePageFrame)).substring(<span class="number">12</span>).toCharArray();<span class="comment">//物理页框号</span></span><br><span class="line">    pageItem.isInMem = <span class="literal">true</span>;<span class="comment">//装入位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//填好有效位数组</span></span><br><span class="line">    pageValid[freePageFrame] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修改seg-load方法。"><a href="#修改seg-load方法。" class="headerlink" title="修改seg_load方法。"></a>修改seg_load方法。</h2><ul>
<li>因此开启分页之后，seg_load应该跳过加载数据这一步，它的作用在开启分页之后仅仅是填写GDT，加载数据的任务应该交给page_load来完成。</li>
<li>即<strong>if(!PAGE)</strong> {加载数据}</li>
</ul>
<h2 id="MMU类：toPagePhysicalAddr页级地址转换方法"><a href="#MMU类：toPagePhysicalAddr页级地址转换方法" class="headerlink" title="MMU类：toPagePhysicalAddr页级地址转换方法"></a>MMU类：toPagePhysicalAddr页级地址转换方法</h2><ul>
<li>在段页式下，线性地址转物理地址需要查页表，然后进行虚拟页号到物理页号的替换，具体流程可以参考课件。</li>
</ul>
<ol>
<li>从<strong>线性地址</strong>中<strong>提取前 20 位作为虚拟页号</strong>，<strong>后 12 位作为页内偏移</strong>。</li>
<li><strong>物理页号的获取</strong>（TLB是否可用）：都是使用 <code>getFrameOfPage</code> 函数，区别在于类不同<ol>
<li>如果开启了tlb，TLB<ul>
<li>调用<strong>tlb类的函数</strong>，由虚拟页号获取</li>
</ul>
</li>
<li>未开启，内存<ul>
<li>调用<strong>Memory类的函数</strong>，由虚拟页号获取</li>
</ul>
</li>
</ol>
</li>
<li>最后，将<strong>物理页号与页内偏移拼接</strong>获得物理地址。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 段页式下的线性地址转物理地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> linearAddr 32位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 32-bits 物理地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">toPagePhysicalAddr</span><span class="params">(String linearAddr)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="comment">//获取虚拟页号（线性地址的高20位）+获取页内偏移（线性地址的低12位）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">vPageNo</span> <span class="operator">=</span> linearAddr.substring(<span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">offset</span> <span class="operator">=</span> linearAddr.substring(<span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">vPageNoInt</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(vPageNo));</span><br><span class="line">    <span class="comment">//查页表，获取物理页号</span></span><br><span class="line">    <span class="type">char</span>[] pageFrame;</span><br><span class="line">    <span class="keyword">if</span>(TLB.isAvailable)&#123;</span><br><span class="line">        <span class="comment">//如果TLB可用，从TLB中获取物理页号</span></span><br><span class="line">        pageFrame = TLB.getTLB().getFrameOfPage(vPageNoInt);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果TLB不可用，从内存中获取物理页号</span></span><br><span class="line">        pageFrame = Memory.getMemory().getFrameOfPage(vPageNoInt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">pageFrameStr</span> <span class="operator">=</span> String.valueOf(pageFrame);</span><br><span class="line">    <span class="comment">//将物理页号和页内偏移拼接为物理地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">physicalAddr</span> <span class="operator">=</span> pageFrameStr + offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> physicalAddr;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> add tlb here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-cache与TLB的融合"><a href="#4-cache与TLB的融合" class="headerlink" title="4. cache与TLB的融合"></a>4. cache与TLB的融合</h1><h2 id="a-将cache融合进MMU中"><a href="#a-将cache融合进MMU中" class="headerlink" title="a. 将cache融合进MMU中"></a>a. 将cache融合进MMU中</h2><ul>
<li>这一步相对简单。需要注意，由于cache是memory的缓存，所以任何涉及到访问主存数据的地方都要添加对cache的调用。</li>
<li>只有两个标了todo的地方需要改，MMU类的read和write。直接加入<strong>当cache有效时，通过cache读&#x2F;写</strong>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] read(String logicAddr, <span class="type">int</span> length) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">physicalAddr</span> <span class="operator">=</span> addressTranslation(logicAddr, length);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> add cache here</span></span><br><span class="line">    <span class="keyword">if</span> (Cache.isAvailable) &#123;<span class="comment">//如果cache可用</span></span><br><span class="line">        <span class="keyword">return</span> cache.read(physicalAddr, length);<span class="comment">//从cache中读取数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果cache不可用,直接从内存中读取数据</span></span><br><span class="line">    <span class="keyword">return</span> memory.read(physicalAddr, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String logicAddr, <span class="type">int</span> length, <span class="type">byte</span>[] data)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">physicalAddr</span> <span class="operator">=</span> addressTranslation(logicAddr, length);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> add cache here</span></span><br><span class="line">    <span class="keyword">if</span> (Cache.isAvailable) &#123;<span class="comment">//如果cache可用</span></span><br><span class="line">        cache.write(physicalAddr, length, data);<span class="comment">//将数据写入cache</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无论cache是否可用，都要将数据写入内存</span></span><br><span class="line">    memory.write(physicalAddr, length, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="b-将TLB融合进MMU中"><a href="#b-将TLB融合进MMU中" class="headerlink" title="b. 将TLB融合进MMU中"></a>b. 将TLB融合进MMU中</h2><ol>
<li>MMU类<code>addressTranslation</code>函数。在标出的地方判断<ul>
<li>若TLB有效：若<strong>tlb中没有该页</strong>且<strong>内存中没有该页</strong>，缺页中断<ul>
<li>内存从磁盘加载该页的数据。</li>
<li>并且将该页写入tlb。<code>tlb.write(i);</code></li>
</ul>
</li>
<li>若TLB无效：<strong>直接判断内存</strong>中有没有该页（应该是有代码的）</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> add tlb here</span></span><br><span class="line"><span class="comment">//1. 启用TLB之后，判断是否缺页的工作应该首先交给TLB来完成。</span></span><br><span class="line"><span class="comment">//2. 如果发生缺页，page_load方法会进行填页表，填页表之后不要忘记填TLB。</span></span><br><span class="line"><span class="keyword">if</span> (TLB.isAvailable)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tlb.isValidPage(i))&#123;<span class="comment">//如果TLB中不存在该页</span></span><br><span class="line">    <span class="comment">// 缺页中断，该页不在内存中，内存从磁盘加载该页的数据</span></span><br><span class="line">        memory.page_load(i);<span class="comment">//从磁盘中加载数据,并填写页表</span></span><br><span class="line">        tlb.write(i);<span class="comment">//填写TLB</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (!memory.isValidPage(i)) &#123;</span><br><span class="line">    <span class="comment">// 缺页中断，该页不在内存中，内存从磁盘加载该页的数据</span></span><br><span class="line">    memory.page_load(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>toPagePhysicalAddr</code>方法，上面讲过了。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(TLB.isAvailable)&#123;</span><br><span class="line">    <span class="comment">//如果TLB可用，从TLB中获取物理页号</span></span><br><span class="line">    pageFrame = TLB.getTLB().getFrameOfPage(vPageNoInt);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果TLB不可用，从内存中获取物理页号</span></span><br><span class="line">    pageFrame = Memory.getMemory().getFrameOfPage(vPageNoInt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>PA2实验记录</title>
    <url>/2025/02/25/PA2%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="PA2-简单复杂的机器-冯诺依曼计算机系统"><a href="#PA2-简单复杂的机器-冯诺依曼计算机系统" class="headerlink" title="PA2 - 简单复杂的机器: 冯诺依曼计算机系统"></a>PA2 - 简单复杂的机器: 冯诺依曼计算机系统</h1><ul>
<li>首先切换到pa2分支</li>
<li>task PA2.1: 实现更多的指令, 在NEMU中运行大部分<code>cpu-tests</code></li>
<li>task PA2.2: 实现klib和基础设施</li>
<li>task PA2.3: 运行FCEUX, 提交完整的实验报告</li>
</ul>
<h1 id="不停计算的机器"><a href="#不停计算的机器" class="headerlink" title="不停计算的机器"></a>不停计算的机器</h1><ul>
<li>CPU究竟是怎么执行一条指令的：<ul>
<li>对于大部分指令来说, 执行它们都可以抽象成<strong>取指-译码-执行</strong>的<strong>指令周期</strong>.</li>
</ul>
</li>
<li>计算机不断重复下面四个步骤</li>
</ul>
<h3 id="1-取指-instruction-fetch-IF"><a href="#1-取指-instruction-fetch-IF" class="headerlink" title="1.取指(instruction fetch, IF)"></a>1.取指(instruction fetch, IF)</h3><ul>
<li>“存储控制，程序控制”——<strong>指令在存储器中, 由PC指出当前指令的位置</strong>.<ul>
<li>事实上, PC就是一个指针</li>
</ul>
</li>
<li>取指令要做的事情：将<strong>PC指向的指令</strong>从<strong>内存</strong>读入到<strong>CPU</strong>中.</li>
</ul>
<h3 id="2-译码-instruction-decode-ID"><a href="#2-译码-instruction-decode-ID" class="headerlink" title="2.译码(instruction decode, ID)"></a>2.译码(instruction decode, ID)</h3><ul>
<li>取指后发现是个01组成的比特串</li>
<li>指令是做什么的：CPU是用来处理数据的, 指令则是用来指示CPU具体对<em>什么数据</em>进行<em>什么样的处理</em>.  <ul>
<li>CPU需要从指令中解读出”<strong>操作码</strong>“和”<strong>操作数</strong>“两部分信息</li>
</ul>
</li>
<li>译码：CPU拿到一条指令之后, 可以通过<strong>查表</strong>的方式得知这条指令的操作数和操作码.</li>
</ul>
<h3 id="3-执行-execute-EX"><a href="#3-执行-execute-EX" class="headerlink" title="3.执行(execute, EX)"></a>3.执行(execute, EX)</h3><ul>
<li>执行阶段就是真正完成指令的工作</li>
</ul>
<h3 id="4-更新PC"><a href="#4-更新PC" class="headerlink" title="4.更新PC"></a>4.更新PC</h3><ul>
<li>执行完一条指令之后, CPU就要<strong>执行下一条指令</strong>. 在这之前, CPU需要更新PC的值</li>
<li>让PC<strong>加上刚才执行完的指令的长度</strong>, 即可指向下一条指令的位置.</li>
</ul>
<h2 id="YEMU-一个简单的CPU模拟器"><a href="#YEMU-一个简单的CPU模拟器" class="headerlink" title="YEMU: 一个简单的CPU模拟器"></a>YEMU: 一个简单的CPU模拟器</h2><ul>
<li>一个简单计算机：<ul>
<li>有4个8位的寄存器, 一个4位PC, 以及一段16字节的内存.</li>
<li>它支持R型和M型两种指令格式, 4条指令.</li>
</ul>
</li>
</ul>
<h4 id="必做：理解YEMU如何执行程序"><a href="#必做：理解YEMU如何执行程序" class="headerlink" title="必做：理解YEMU如何执行程序"></a>必做：理解YEMU如何执行程序</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YEMU可以看成是一个简化版的NEMU, 它们的原理是相通的, 因此你需要理解YEMU是如何执行程序的. 具体地, 你需要</span><br><span class="line">    1. 画出在YEMU上执行的加法程序的状态机</span><br><span class="line">    2. 通过RTFSC理解YEMU如何执行一条指令</span><br><span class="line">思考一下, 以上两者有什么联系?</span><br></pre></td></tr></table></figure>
<ol>
<li>画出在YEMU上执行的加法程序的状态机</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------+    +---------+    +---------+    +---------+    +---------+</span><br><span class="line">|         |    |         |    |         |    |         |    |         |</span><br><span class="line">|  取指    +---&gt;|  译码   +---&gt;|  加法    +---&gt;|  写回    +---&gt;|  更新PC |</span><br><span class="line">|         |    |         |    |         |    |         |    |         |</span><br><span class="line">+---------+    +---------+    +---------+    +---------+    +---------+</span><br><span class="line">                                                        |</span><br><span class="line">                                                        v</span><br><span class="line">                                                    +---------+</span><br><span class="line">                                                    |         |</span><br><span class="line">                                                    |  结束   |</span><br><span class="line">                                                    |         |</span><br><span class="line">                                                    +---------+</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>通过RTFSC理解YEMU如何执行一条指令<ol>
<li>取指</li>
</ol>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">this.inst = M[pc]; <span class="comment">// 从内存中取出当前PC指向的指令</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>译码</li>
</ol>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (this.rtype.op) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>执行<ul>
<li>对于操作码0b0000 (复制操作):</li>
</ul>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0b0000</span>: &#123; DECODE_R(this); R[rt] = R[rs]; <span class="keyword">break</span>; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于操作码0b0001 (加法操作):</li>
</ul>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0b0001</span>: &#123; DECODE_R(this); R[rt] += R[rs]; <span class="keyword">break</span>; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于操作码0b1110 (从内存加载):</li>
</ul>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0b1110</span>: &#123; DECODE_M(this); R[<span class="number">0</span>] = M[addr]; <span class="keyword">break</span>; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于操作码0b1111 (存储到内存):</li>
</ul>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0b1111</span>: &#123; DECODE_M(this); M[addr] = R[<span class="number">0</span>]; <span class="keyword">break</span>; &#125;</span><br></pre></td></tr></table></figure></li>
<li>更新PC</li>
</ol>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pc ++; <span class="comment">// 更新PC</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>结束<ul>
<li>如果遇到无效指令:</li>
</ul>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Invalid instruction with opcode = %x, halting...\n&quot;</span>, this.rtype.op);</span><br><span class="line">halt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>两者联系<ul>
<li>状态机图展示了YEMU执行加法程序的各个阶段，从取指到更新PC，再到结束。</li>
<li>RTFSC分析展示了这些阶段在代码中的具体实现。</li>
</ul>
</li>
</ol>
<h1 id="RTFSC-2"><a href="#RTFSC-2" class="headerlink" title="RTFSC(2)"></a>RTFSC(2)</h1><h2 id="RTFM"><a href="#RTFM" class="headerlink" title="RTFM"></a>RTFM</h2><ul>
<li>决定往TRM中添加各种高效指令</li>
<li>ISA手册(riscv32)中一般都会有以下内容, 尝试RTFM并寻找这些内容的位置:<ol>
<li>每一条指令具体行为的描述</li>
<li>指令opcode的编码表格</li>
</ol>
<ul>
<li>在PA中, riscv32的客户程序只会由RV32I和RV32M两类指令组成</li>
</ul>
</li>
<li>例子：在RISC-V手册中查找加法指令<code>ADD</code>的具体行为的描述和操作码编码表格<ol>
<li>具体行为的描述<ul>
<li><code>ADD rd, rs1, rs2</code>：将寄存器rs1和rs2的值相加，并将结果存储到寄存器rd中。</li>
<li>功能：rd &#x3D; rs1 + rs2</li>
<li>操作数：rd、rs1、rs2</li>
<li>执行结果：rd中存储相加结果</li>
<li>副作用：无</li>
</ul>
</li>
<li>操作码编码表格<ul>
<li>操作码：0b0110011</li>
<li>功能码：0b000</li>
<li>表格：</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------+---------+---------+---------+---------+---------+</span><br><span class="line">| funct7  | rs2     | rs1     | funct3  | rd      | opcode  |</span><br><span class="line">+---------+---------+---------+---------+---------+---------+</span><br><span class="line">| 0000000 | rs2(5)  | rs1(5)  | 000     | rd(5)   | 0110011 |</span><br><span class="line">+---------+---------+---------+---------+---------+---------+</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="RTFSC-2-1"><a href="#RTFSC-2-1" class="headerlink" title="RTFSC(2)"></a>RTFSC(2)</h2><ul>
<li>介绍NEMU的框架代码如何实现指令的执行.</li>
</ul>
<h4 id="NEMU-ISA相关的API说明文档"><a href="#NEMU-ISA相关的API说明文档" class="headerlink" title="NEMU ISA相关的API说明文档"></a>NEMU ISA相关的API说明文档</h4><ul>
<li>全局类型<ul>
<li><code>word_t</code>表示与ISA字长等长的<strong>无符号</strong>类型, 在32位的ISA中为uint32_t</li>
<li><code>sword_t</code>表示与ISA字长等长的<strong>有符号</strong>类型, 在32位的ISA中为int32_t</li>
<li><code>char *FMT_WORD</code>word_t类型对应的十六进制格式化说明符, 在32位的ISA中为”0x%08x”</li>
</ul>
</li>
<li>Monitor相关<ul>
<li><code>unsigned char isa_logo[];</code>用于在未实现指令的报错信息中提示开发者阅读相关的手册.</li>
<li>&#96;&#96;word_t RESET_VECTOR;&#96;表示<strong>PC的初始值</strong>.</li>
<li><code>void init_isa();</code>在<strong>monitor初始化</strong>时调用, 进行至少如下ISA相关的初始化工作:<ul>
<li>设置必要的<strong>寄存器初值</strong>, 如PC等</li>
<li>加载<strong>内置客户程序</strong></li>
</ul>
</li>
</ul>
</li>
<li>寄存器相关<ul>
<li><pre><code>  struct &#123;
  // ...
  word_t pc;
  &#125; CPU_state;
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        寄存器结构的类型定义, 其中必须包含一个名为pc, 类型为word_t的成员.</span><br><span class="line">    - ``CPU_state cpu;``寄存器结构的全局定义.</span><br><span class="line">    - ``void isa_reg_display();``打印寄存器当前的值.</span><br><span class="line">    - ``word_t isa_reg_str2val(const char *name, bool *success);``若存在名称为name的寄存器, 则返回其当前值, 并设置success为true; 否则设置success为false.</span><br><span class="line">- 指令执行相关</span><br><span class="line">    - ```</span><br><span class="line">        struct &#123;</span><br><span class="line">        // ...</span><br><span class="line">        &#125; ISADecodeInfo;</span><br></pre></td></tr></table></figure>
  用于存放ISA相关的译码信息, 会嵌入在译码信息结构体Decode的定义中.
</code></pre>
</li>
<li><code>int isa_exec_once(Decode *s);</code>取出<strong>s-&gt;pc指向的指令</strong>并译码<strong>执行</strong>, 同时<strong>更新s-&gt;snpc</strong>.</li>
</ul>
</li>
<li>虚拟内存相关<ul>
<li><code>int isa_mmu_check(vaddr_t vaddr, int len, int type);</code>检查当前系统状态下对内存区间为(vaddr, vaddr + len), 类型为type的访问是否需要经过地址转换.</li>
<li><code>paddr_t isa_mmu_translate(vaddr_t vaddr, int len, int type);</code>对内存区间为(vaddr, vaddr + len), 类型为type的内存访问进行地址转换.</li>
</ul>
</li>
<li>中断异常相关<ul>
<li><code>vaddr_t isa_raise_intr(word_t NO, vaddr_t epc);</code>抛出一个号码为NO的异常, 其中epc为触发异常的指令PC, 返回异常处理的出口地址.</li>
<li><code>word_t isa_query_intr();</code>查询当前是否有未处理的中断, 若有则返回中断号码, 否则返回INTR_EMPTY.</li>
</ul>
</li>
<li>DiffTest相关<ul>
<li><code>bool isa_difftest_checkregs(CPU_state *ref_r, vaddr_t pc);</code>检查当前的寄存器状态是否与ref_r相同, 其中pc为cpu.pc的上一条动态指令的PC, 即cpu.pc的旧值. 如果状态相同, 则返回true, 否则返回false.</li>
<li><code>void isa_difftest_attach();</code>将当前的所有状态同步到REF, 并在之后的执行中开启DiffTest.</li>
</ul>
</li>
</ul>
<h3 id="取指-instruction-fetch-IF"><a href="#取指-instruction-fetch-IF" class="headerlink" title="取指(instruction fetch, IF)"></a>取指(instruction fetch, IF)</h3><ol>
<li>在NEMU中, 有一个函数<code>inst_fetch()</code>(在<code>nemu/include/cpu/ifetch.h</code>中定义)专门负责取指令的工作.</li>
<li><code>inst_fetch()</code>最终会根据参数<strong>len</strong>来调用<code>vaddr_ifetch()</code>(在<code>nemu/src/memory/vaddr.c</code>中定义), 而目前<code>vaddr_ifetch()</code>又会通过<code>paddr_read()</code>来<strong>访问物理内存中的内容</strong>.</li>
</ol>
<ul>
<li>取指操作的本质：一次内存的访存</li>
</ul>
<ol start="3">
<li><code>isa_exec_once()</code>在调用<code>inst_fetch()</code>的时候<strong>传入了s-&gt;snpc的地址</strong>, 因此inst_fetch()最后还会根据len来<strong>更新s-&gt;snpc</strong>, 从而让s-&gt;snpc<strong>指向下一条指令</strong>.</li>
</ol>
<h3 id="译码-instruction-decode-ID"><a href="#译码-instruction-decode-ID" class="headerlink" title="译码(instruction decode, ID)"></a>译码(instruction decode, ID)</h3><h4 id="指令的具体操作"><a href="#指令的具体操作" class="headerlink" title="指令的具体操作"></a>指令的具体操作</h4><ul>
<li>代码进入<code>decode_exec()</code>函数, 它首先进行的是译码相关的操作<ul>
<li>译码的目的是得到<em>指令的操作</em>和<em>操作对象</em>, 这主要是通过查看指令的<strong>opcode</strong>来决定的</li>
</ul>
</li>
<li>NEMU的译码方式：<strong>模式匹配</strong>, NEMU可以通过一个模式字符串来指定指令中opcode</li>
<li>riscv32中有如下模式:例子（<code>auipc</code>指令，是<em>将当前PC值与立即数相加并写入寄存器</em>）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INSTPAT_START();</span><br><span class="line">INSTPAT(<span class="string">&quot;??????? ????? ????? ??? ????? 00101 11&quot;</span>, auipc, U, R(rd) = s-&gt;pc + imm);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">INSTPAT_END();</span><br></pre></td></tr></table></figure>
<ul>
<li>其中<code>INSTPAT</code>(意思是instruction pattern)是一个<strong>宏</strong>(在nemu&#x2F;include&#x2F;cpu&#x2F;decode.h中定义), 它用于定义一条模式匹配规则. 其格式如下:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSTPAT(模式字符串, 指令名称, 指令类型, 指令执行操作);</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>模式字符串</strong>中只允许出现4种字符:<ol>
<li>0表示相应的位只能匹配0</li>
<li>1表示相应的位只能匹配1</li>
<li>?表示相应的位可以匹配0或1</li>
<li>空格是分隔符, 只用于提升模式字符串的可读性, 不参与匹配</li>
</ol>
</li>
<li><strong>指令名称</strong>在代码中仅当注释使用, 不参与宏展开; </li>
<li><strong>指令类型</strong>用于后续译码过程; </li>
<li><strong>指令执行操作</strong>则是通过C代码来模拟指令执行的真正行为.</li>
</ol>
<ul>
<li>此外, nemu&#x2F;include&#x2F;cpu&#x2F;decode.h中还定义了宏INSTPAT_START和INSTPAT_END. INSTPAT又使用了另外两个宏INSTPAT_INST和INSTPAT_MATCH, 它们在nemu&#x2F;src&#x2F;isa&#x2F;$ISA&#x2F;inst.c中定义. </li>
<li>对上述代码进行宏展开并简单整理代码之后, 最后将会得到:  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123; <span class="type">const</span> <span class="type">void</span> * __instpat_end = &amp;&amp;__instpat_end_;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="type">uint64_t</span> key, mask, shift;</span><br><span class="line">pattern_decode(<span class="string">&quot;??????? ????? ????? ??? ????? 00101 11&quot;</span>, <span class="number">38</span>, &amp;key, &amp;mask, &amp;shift);</span><br><span class="line"><span class="keyword">if</span> ((((<span class="type">uint64_t</span>)s-&gt;isa.inst &gt;&gt; shift) &amp; mask) == key) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="type">int</span> rd = <span class="number">0</span>;</span><br><span class="line">    <span class="type">word_t</span> src1 = <span class="number">0</span>, src2 = <span class="number">0</span>, imm = <span class="number">0</span>;</span><br><span class="line">    decode_operand(s, &amp;rd, &amp;src1, &amp;src2, &amp;imm, TYPE_U);</span><br><span class="line">    R(rd) = s-&gt;pc + imm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> *(__instpat_end);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">__instpat_end_: ; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述代码中的&amp;&amp;__instpat_end_使用了GCC提供的标签地址扩展功能, goto语句将会跳转到最后的__instpat_end_标签. </li>
<li><code>pattern_decode()</code>函数在<code>nemu/include/cpu/decode.h</code>中定义, 它用于<strong>将模式字符串转换成3个整型变量</strong><ul>
<li><code>pattern_decode()</code>函数<em>将模式字符串中的0和1抽取到整型变量key</em>中, <code>mask</code>表示key的<strong>掩码</strong>, 而<code>shift</code>则表示<strong>opcode距离最低位的比特数量</strong>, 用于帮助编译器进行优化.</li>
</ul>
</li>
<li>NEMU取指令的时候会把指令记录到<code>s-&gt;isa.inst</code>中, 此时指令满足上述宏展开的<code>if语句</code>, 表示匹配到auipc指令的编码, 因此将会进行进一步的译码操作.</li>
</ul>
</li>
</ul>
<h4 id="指令的操作对象"><a href="#指令的操作对象" class="headerlink" title="指令的操作对象"></a>指令的操作对象</h4><ul>
<li>eg:已知<code>auipc</code>是将当前PC值与立即数相加并写入寄存器, 但我们还是<em>不知道操作对象</em>(比如立即数是多少, 写入到哪个寄存器).<ul>
<li>调用<code>decode_operand()</code>函数来完成</li>
</ul>
</li>
<li><code>decode_operand()函数</code><ul>
<li>会根据<strong>传入的指令类型type</strong>来进行操作数的译码, </li>
<li>译码<strong>结果</strong>将记录到<strong>函数参数rd, src1, src2和imm中</strong>, 它们分别代表<strong>目的操作数的寄存器号码, 两个源操作数和立即数</strong>.</li>
</ul>
</li>
<li>为了进一步实现<em>操作数译码和指令译码的解耦</em>, 我们对这些操作数的译码进行了<strong>抽象封装</strong>:<ul>
<li>框架代码定义了<code>src1R()</code>和<code>src2R()</code>两个辅助宏, 用于<strong>寄存器的读取结果</strong><em>记录到相应的操作数变量中</em></li>
<li>框架代码还定义了<code>immI</code>等辅助宏, 用于<strong>从指令中抽取出立即数</strong></li>
</ul>
</li>
<li>例如RISC-V中I型指令的译码过程可以通过如下代码实现:  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> TYPE_I: src1R(); immI(); <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="立即数背后的故事"><a href="#立即数背后的故事" class="headerlink" title="立即数背后的故事"></a>立即数背后的故事</h4><ul>
<li>Motorola 68k系列的处理器都是大端架构的. 现在问题来了, 考虑以下两种情况:<ol>
<li>假设我们需要将NEMU运行在Motorola 68k的机器上(把NEMU的源代码编译成Motorola 68k的机器码)</li>
<li>假设我们需要把Motorola 68k作为一个新的ISA加入到NEMU中<br>在这两种情况下, 你需要注意些什么问题? 为什么会产生这些问题? 怎么解决它们?<br>事实上不仅仅是立即数的访问, 长度大于1字节的内存访问都需要考虑类似的问题.</li>
</ol>
</li>
</ul>
<ol>
<li>情况1：将NEMU运行在Motorola 68k的机器上<ul>
<li>问题<ol>
<li>字节序问题<ul>
<li>Motorola 68k是大端架构，而NEMU可能是为小端架构设计的。</li>
<li>需要确保数据在内存中的存储顺序正确。</li>
</ul>
</li>
<li>编译器和工具链<ul>
<li>需要使用支持Motorola 68k架构的编译器和工具链。</li>
<li>可能需要修改Makefile或构建脚本以适应新的编译环境。</li>
</ul>
</li>
<li>系统调用和库函数<ul>
<li>需要确保NEMU使用的系统调用和库函数在Motorola 68k平台上可用。</li>
<li>可能需要对代码进行移植和适配。</li>
</ul>
</li>
</ol>
</li>
<li>解决方案<ol>
<li>字节序处理<ul>
<li>使用条件编译或宏定义来处理大端和小端的差异。</li>
<li>例如：</li>
</ul>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> BIG_ENDIAN</span></span><br><span class="line"><span class="comment">// 大端处理代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// 小端处理代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>编译器和工具链<ul>
<li>安装并配置支持Motorola 68k的编译器和工具链。</li>
<li>修改构建脚本以使用新的编译器。</li>
</ul>
</li>
<li>系统调用和库函数<ul>
<li>检查并移植系统调用和库函数，确保它们在Motorola 68k平台上正常工作。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>情况 2: 将Motorola 68k作为一个新的ISA加入到NEMU中<ul>
<li>问题+解决方案<ol>
<li>指令集架构 (ISA) 支持<ul>
<li>需要在NEMU中添加对Motorola 68k指令集的支持。</li>
<li>包括指令的译码、执行和模拟。</li>
</ul>
</li>
<li>寄存器和内存模型<ul>
<li>需要定义Motorola 68k的寄存器和内存模型。</li>
<li>确保模拟器能够正确处理寄存器和内存操作。</li>
</ul>
</li>
<li>异常和中断处理<ul>
<li>需要实现Motorola 68k的异常和中断处理机制。</li>
<li>确保模拟器能够正确模拟这些行为。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="立即数背后的故事-2"><a href="#立即数背后的故事-2" class="headerlink" title="立即数背后的故事(2)"></a>立即数背后的故事(2)</h4><ul>
<li>mips32和riscv32的指令长度只有32位, 因此它们不能像x86那样, 把C代码中的32位常数直接编码到一条指令中. 思考一下, mips32和riscv32应该如何解决这个问题?<ul>
<li>MIPS32和RISC-V32通过组合<strong>使用两条指令</strong>和<strong>伪指令</strong><code>li</code>来加载32位立即数。</li>
</ul>
</li>
</ul>
<h3 id="执行-execute-EX"><a href="#执行-execute-EX" class="headerlink" title="执行(execute, EX)"></a>执行(execute, EX)</h3><ul>
<li>模式匹配规则中指定的<code>指令执行操作</code></li>
<li>译码的结果+C代码——模拟指令执行的真正行为</li>
<li>eg：如对于auipc指令<ul>
<li>由于<code>译码阶段</code>已经把<code>U型立即数</code>记录到操作数<code>imm</code>中了</li>
<li>只需要通过<code>R(rd) = s-&gt;pc + imm</code>将立即数与当前PC值相加并写入目标寄存器中, 这样就完成了指令的执行.</li>
</ul>
</li>
<li>指令执行的阶段结束之后, <code>decode_exec()</code>函数将会返回<code>0</code>, 并一路返回到<code>exec_once()</code>函数中. 不过目前代码并没有使用这个返回值, 因此可以忽略它</li>
</ul>
<h3 id="更新PC"><a href="#更新PC" class="headerlink" title="更新PC"></a>更新PC</h3><ul>
<li>更新PC：把<code>s-&gt;dnpc</code><strong>赋值</strong>给<code>cpu.pc</code></li>
</ul>
<h4 id="静态指令snpc和动态指令dnpc"><a href="#静态指令snpc和动态指令dnpc" class="headerlink" title="静态指令snpc和动态指令dnpc"></a>静态指令snpc和动态指令dnpc</h4><ul>
<li>在程序分析领域中, 静态指令是指程序代码中的指令, 动态指令是指程序运行过程中的指令. 例如对于以下指令序列</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100: jmp 102</span><br><span class="line">101: add</span><br><span class="line">102: xor</span><br></pre></td></tr></table></figure>
<ul>
<li>jmp指令的下一条静态指令是add指令, 而下一条动态指令则是xor指令.</li>
<li><strong>snpc和dnpc的区别</strong>: <strong>snpc是下一条静态指令, 而dnpc是下一条动态指令</strong><ul>
<li>对于顺序执行的指令, 它们的snpc和dnpc是一样的;</li>
<li>对于跳转指令, snpc和dnpc就会有所不同, <strong>dnpc应该指向跳转目标的指令</strong>.</li>
<li>显然, 我们应该使用<strong>s-&gt;dnpc来更新PC</strong>, 并且<strong>在指令执行的过程中正确地维护s-&gt;dnpc</strong>.</li>
</ul>
</li>
</ul>
<h3 id="结构化程序设计"><a href="#结构化程序设计" class="headerlink" title="结构化程序设计"></a>结构化程序设计</h3><ul>
<li>如果指令集越复杂, 指令之间的共性特征就越多——Copy-Paste的话，维护难度很大！<ul>
<li>对于同一条指令的不同形式, 它们的执行阶段是相同的</li>
<li>对于不同指令的同一种形式, 它们的译码阶段是相同的</li>
<li>对于同一条指令同一种形式的不同操作数宽度</li>
</ul>
</li>
<li>一种好的做法是把译码, 执行和操作数宽度的<em>相关代码分离开来</em>, 实现<strong>解耦</strong>, 也就是在程序设计课上提到的<em>结构化程序设计</em>.</li>
</ul>
<h4 id="必做：RTFSC理解指令执行的过程"><a href="#必做：RTFSC理解指令执行的过程" class="headerlink" title="必做：RTFSC理解指令执行的过程"></a>必做：RTFSC理解指令执行的过程</h4><ul>
<li>请整理一条指令在NEMU中的执行过程</li>
</ul>
<ol>
<li>取指<ul>
<li>从内存中取出当前PC指向的指令</li>
<li>更新PC，指向下一条指令 <code>cpu.pc += 4;</code></li>
</ul>
</li>
<li>译码<ul>
<li>解析指令的操作码&amp;操作数</li>
<li>根据指令类型和操作数，确定指令的具体操作</li>
</ul>
</li>
<li>执行<ul>
<li>根据译码结果执行指令的具体操作<ul>
<li>对于算术运算指令，执行相应的算术运算</li>
<li>对于跳转指令。计算跳转目标地址</li>
</ul>
</li>
</ul>
</li>
<li>访存<ul>
<li>如果指令需要访问内存（加载&#x2F;存储指令）</li>
</ul>
</li>
<li>写回<ul>
<li>将执行结果写回寄存器或内存</li>
</ul>
</li>
<li>更新PC<ul>
<li>在指令执行完毕后，根据指令的类型和执行结果更新PC。</li>
<li>对于顺序执行的指令，PC已经在取指阶段更新过了，这里不需要再次更新。</li>
<li>对于跳转指令，PC需要更新为跳转目标地址。</li>
</ul>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cpu.pc = s-&gt;dnpc; <span class="comment">// 将dnpc的值赋给cpu.pc，更新PC</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="运行第一个C程序"><a href="#运行第一个C程序" class="headerlink" title="运行第一个C程序"></a>运行第一个C程序</h2><ul>
<li>开始实践啦！</li>
</ul>
<h4 id="必做：准备交叉编译环境"><a href="#必做：准备交叉编译环境" class="headerlink" title="必做：准备交叉编译环境"></a>必做：准备交叉编译环境</h4><ul>
<li>准备相应的gcc和binutils, 才能正确地进行编译</li>
<li>riscv32(64)<ul>
<li><code>apt-get install g++-riscv64-linux-gnu binutils-riscv64-linux-gnu</code></li>
</ul>
</li>
</ul>
<ol>
<li>报错 <code>/usr/riscv64-linux-gnu/include/gnu/stubs.h:8:11: fatal error: gnu/stubs-ilp32.h: No such file or directory</code></li>
<li>键入<code>sudo code --no-sandbox --user-data-dir=/home/xiaoyao/.vscode-root /usr/riscv64-linux-gnu/include/gnu/stubs.h</code></li>
<li>修改</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 32 &amp;&amp; defined __riscv_float_abi_soft</span></span><br><span class="line">-<span class="meta"># <span class="keyword">include</span> <span class="string">&lt;gnu/stubs-ilp32.h&gt;</span></span></span><br><span class="line">+<span class="comment">//# include &lt;gnu/stubs-ilp32.h&gt;</span></span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>报错</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ OBJCOPY -&gt; build/dummy-riscv32-nemu.bin</span><br><span class="line">/bin/sh: 1: python: not found</span><br><span class="line">make[1]: *** [/home/xiaoyao/ics2024/abstract-machine/scripts/platform/nemu.mk:22：insert-arg] 错误 127</span><br><span class="line">test list [1 item(s)]: dummy</span><br><span class="line">[         dummy] ***FAIL***</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>检查python3已安装，则创建python命令的符号链接<code>sudo ln -s /usr/bin/python3 /usr/bin/python</code><ul>
<li><code>python --version</code>确保可用后，重新运行</li>
</ul>
</li>
<li>输入<code>c</code>,报错<ul>
<li>这是因为你还没有实现<code>0x00000413</code>的指令, 因此, 你需要开始在NEMU中添加指令了.</li>
</ul>
</li>
</ol>
<h5 id="为什么执行了未实现指令会出现上述报错信息"><a href="#为什么执行了未实现指令会出现上述报错信息" class="headerlink" title="为什么执行了未实现指令会出现上述报错信息"></a>为什么执行了未实现指令会出现上述报错信息</h5><ul>
<li><p>RTFSC, 理解执行未实现指令的时候, NEMU具体会怎么做.</p>
</li>
<li><p>因为NEMU在执行指令时，会检查指令是否已实现。如果指令未实现，NEMU会触发异常并输出错误信息。</p>
</li>
<li><p>查看反汇编结果<code>am-kernels/tests/cpu-tests/build/dummy-$ISA-nemu.txt</code></p>
<ul>
<li>你只需实现那些目前还没实现的指令</li>
<li>为了实现一条新指令, 你只需要在<code>nemu/src/isa/$ISA/inst.c</code>中添加正确的模式匹配规则即可</li>
</ul>
</li>
</ul>
<h4 id="必做：运行第一个客户程序"><a href="#必做：运行第一个客户程序" class="headerlink" title="必做：运行第一个客户程序"></a>必做：运行第一个客户程序</h4><ul>
<li>在NEMU中<strong>实现上文提到的指令</strong>, 具体细节请务必<strong>参考手册</strong>. 实现成功后, 在NEMU中运行客户程序dummy, 你将会看到HIT GOOD TRAP的信息. 如果你没有看到这一信息, 说明你的指令实现不正确, 你可以使用PA1中实现的简易调试器帮助你调试.</li>
<li>li是一个伪指令，在riscv32里面汇编器会将它替换为lui和&#x2F;或addi<ul>
<li>根据func3字段判断,这里其实是要实现addi指令</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INSTPAT(<span class="string">&quot;??????? ????? ????? ??? ????? 00100 11&quot;</span>, li     , I, R(rd) = imm);</span><br></pre></td></tr></table></figure>
<ul>
<li>jal<ol>
<li>添加TYPE_J</li>
<li><code>#define immJ() do &#123; *imm = (SEXT(BITS(i, 31, 31), 1) &lt;&lt; 20) | BITS(i, 30, 21) &lt;&lt; 1| BITS(i, 20, 20) &lt;&lt; 11 | BITS(i, 19, 12) &lt;&lt; 12 ; &#125; while(0)</code></li>
<li><code>case TYPE_J:                  immJ(); break; // 新增 J 类型</code></li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INSTPAT(<span class="string">&quot;??????? ????? ????? ??? ????? 11011 11&quot;</span>, jal    , J, R(rd) = s -&gt; pc + <span class="number">4</span>; s -&gt; dnpc += imm <span class="number">-4</span>;); <span class="comment">// jal指令</span></span><br></pre></td></tr></table></figure>
<ul>
<li>sw</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INSTPAT(<span class="string">&quot;??????? ????? ????? 010 ????? 01000 11&quot;</span>, sw     , S, Mw(src1 + imm, <span class="number">4</span>, src2)); <span class="comment">// 新增 sw 指令</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>src/cpu/cpu-exec.c:126 cpu_exec] nemu: HIT GOOD TRAP at pc = 0x80000030</code>成功！</li>
</ul>
<h2 id="运行更多的程序"><a href="#运行更多的程序" class="headerlink" title="运行更多的程序"></a>运行更多的程序</h2><ul>
<li>测试用例：<code>am-kernels/tests/cpu-tests/</code><ul>
<li>在该目录下执行<code>make ARCH=$ISA-nemu ALL=xxx run</code><ul>
<li>其中xxx为测试用例的名称(不包含.c后缀).</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="必做：实现更多的指令"><a href="#必做：实现更多的指令" class="headerlink" title="必做：实现更多的指令"></a>必做：实现更多的指令</h4><h5 id="1-add-c"><a href="#1-add-c" class="headerlink" title="1. add.c"></a>1. add.c</h5><ol>
<li>lw<br><code>0x80000078: 00 0a a9 03 lw	s2, 0(s5)</code></li>
</ol>
<ul>
<li><code>INSTPAT(&quot;??????? ????? ????? 010 ????? 00000 11&quot;, lw     , I, R(rd) = Mr(src1 + imm, 4));</code></li>
</ul>
<ol start="2">
<li>add<br><code>0x80000090: 00 a9 05 33 add	a0, s2, a0</code></li>
</ol>
<ul>
<li><code>INSTPAT(&quot;0000000 ????? ????? 000 ????? 01100 11&quot;, add    , R, R(rd) = src1 + src2);</code></li>
</ul>
<ol start="3">
<li>sub<br><code>0x80000094: 40 f5 05 33 sub	a0, a0, a5</code></li>
</ol>
<ul>
<li><code>INSTPAT(&quot;0100000 ????? ????? 000 ????? 01100 11&quot;, sub    , R, R(rd) = src1 - src2);</code></li>
</ul>
<ol start="4">
<li>seqz：<code>0x80000098: 00 15 35 13 seqz	a0, a0</code><ul>
<li>此伪指令的实现原理为，使用SLTIU指令，并将立即数设置为1；此时只有当rs1寄存器值为0时，才能小于立即数，rd寄存器才会被赋值为1：</li>
</ul>
</li>
</ol>
<ul>
<li><code>INSTPAT(&quot;??????? ????? ????? 011 ????? 00100 11&quot;, seqz   , I, R(rd) = (uint32_t)src1 &lt; (uint32_t)imm ? 1: 0);</code></li>
</ul>
<ol start="5">
<li>beqz：<code>0x80000010: 00 05 04 63 beqz	a0, 8</code><ul>
<li>伪指令，可用beq指令来实现</li>
<li><code> INSTPAT(&quot;??????? ????? ????? 000 ????? 11000 11&quot;, beqz   , B, if (src1 == src2) s-&gt;dnpc = s-&gt;pc + imm);</code></li>
<li><code>#define immB() do &#123; *imm = (SEXT(BITS(i, 31, 31), 1) &lt;&lt; 12) | (BITS(i, 7, 7) &lt;&lt; 11) | (BITS(i, 30, 25) &lt;&lt; 5) | (BITS(i, 11, 8) &lt;&lt; 1); &#125; while(0)</code></li>
</ul>
</li>
<li>bne:<code>0x800000a4: fe 89 90 e3 bne	s3, s0, -0x20</code><ul>
<li><code>  INSTPAT(&quot;??????? ????? ????? 001 ????? 11000 11&quot;, bne    , B, if (src1 != src2) s-&gt;dnpc = s-&gt;pc + imm);</code></li>
<li>bne，比较两个寄存器的值，如果它们不相等，则跳转到目标地址</li>
</ul>
</li>
</ol>
<ul>
<li><code>HIT GOOD TRAP at pc = 0x80000120</code>,add.c成功！</li>
</ul>
<h5 id="2-add—longlong-c"><a href="#2-add—longlong-c" class="headerlink" title="2. add—longlong.c"></a>2. add—longlong.c</h5><ol>
<li>sltu:<code>0x800000a0: 01 97 b6 b3 sltu	a3, a5, s9</code><ul>
<li><code>  INSTPAT(&quot;0000000 ????? ????? 011 ????? 01100 11&quot;, sltu   , R, R(rd) = (uint32_t)src1 &lt; (uint32_t)src2 ? 1: 0);</code></li>
<li>sltu，无符号比较两个寄存器的值，如果第一个寄存器的值小于第二个，则将目标寄存器设置为 1，否则设置为 0</li>
</ul>
</li>
<li>xor:<code>0x800000ac: 00 f5 45 33 xor	a0, a0, a5</code><ul>
<li><code>INSTPAT(&quot;0000000 ????? ????? 100 ????? 01100 11&quot;, xor    , R, R(rd) = src1 ^ src2);</code></li>
<li>xor，异或运算，将两个寄存器的值进行异或运算，结果存入目标寄存器</li>
</ul>
</li>
<li>or:<code>0x800000b4: 00 f5 65 33 or	a0, a0, a5</code><ul>
<li><code>INSTPAT(&quot;0000000 ????? ????? 110 ????? 01100 11&quot;, or    , R, R(rd) = src1 | src2);</code></li>
<li>or，或运算，将两个寄存器的值进行或运算，结果存入目标寄存器</li>
</ul>
</li>
</ol>
<ul>
<li><code>HIT GOOD TRAP at pc = 0x80000138</code>,成功！</li>
</ul>
<h5 id="3-bit-c"><a href="#3-bit-c" class="headerlink" title="3. bit.c"></a>3. bit.c</h5><ol>
<li>sh:<code>0x800000bc: 00 f1 16 23 sh	a5, 0xc(sp)</code><ul>
<li><code>INSTPAT(&quot;??????? ????? ????? 001 ????? 01000 11&quot;, sh     , S, Mw(src1 + imm, 2, src2));</code></li>
<li>sh,将src2的低16位存入src1+imm地址</li>
</ul>
</li>
<li>srai:<code>0x80000028: 40 35 d7 93 srai	a5, a1, 3</code><ul>
<li><code>INSTPAT(&quot;0100000 ????? ????? 101 ????? 00100 11&quot;, srai   , I, R(rd) = (int32_t)src1 &gt;&gt; (imm &amp; 0x1F));</code></li>
<li>srai,算术右移，将src1的值右移imm位，空位用src1的符号位填充，结果存入rd</li>
</ul>
</li>
<li>andi:<code>0x80000034: 00 75 f5 93 andi	a1, a1, 7</code><ul>
<li><code>INSTPAT(&quot;??????? ????? ????? 111 ????? 00100 11&quot;, andi   , I, R(rd) = src1 &amp; imm);</code></li>
<li>andi,与立即数，将src1的值与imm进行与运算，结果存入rd</li>
</ul>
</li>
<li>sll:<code>0x8000003c: 00 b7 97 b3 sll	a5, a5, a1</code><ul>
<li><code>INSTPAT(&quot;0000000 ????? ????? 001 ????? 01100 11&quot;, sll    , R, R(rd) = src1 &lt;&lt; (src2 &amp; 0x1F));</code></li>
<li>sll,逻辑左移，将src1的值左移src2位，空位用0填充，结果存入rd</li>
</ul>
</li>
<li>and：<ul>
<li><code>INSTPAT(&quot;0000000 ????? ????? 111 ????? 01100 11&quot;, and    , R, R(rd) = src1 &amp; src2);</code></li>
<li>and,与运算，将src1的值与src2的值进行与运算，结果存入rd</li>
</ul>
</li>
<li>xori:<ul>
<li><code>INSTPAT(&quot;??????? ????? ????? 100 ????? 00100 11&quot;, xori   , I, R(rd) = src1 ^ imm);</code></li>
<li>xori,异或立即数，将src1的值与imm进行异或运算，结果存入rd</li>
</ul>
</li>
</ol>
<ul>
<li><code>HIT GOOD TRAP at pc = 0x8000021c</code>成功！</li>
</ul>
<h5 id="4-bubble-sort-c"><a href="#4-bubble-sort-c" class="headerlink" title="4. bubble-sort.c"></a>4. bubble-sort.c</h5><ol>
<li>blez:<code>0x80000040: 02 b0 50 63 blez	a1, 0x20</code><ul>
<li><code>INSTPAT(&quot;??????? ????? ????? 101 ????? 11000 11&quot;, blez   , B, if (src1 &gt;= src2) s-&gt;dnpc +=imm-4);</code></li>
<li>blez,伪指令可用bgz,当寄存器的值小于等于0时跳转，可用bgez指令实现</li>
</ul>
</li>
</ol>
<ul>
<li><code>HIT GOOD TRAP at pc = 0x80000140</code>成功！</li>
</ul>
<h5 id="5-crc32-c"><a href="#5-crc32-c" class="headerlink" title="5. crc32.c"></a>5. crc32.c</h5><ul>
<li>看<code>tests/cpu-tests/build/crc32-riscv32-nemu.txt</code></li>
</ul>
<ol>
<li>lui:<code>0x80000038: ed b8 88 b7 lui	a7, 0xedb88</code><ul>
<li><code>INSTPAT(&quot;??????? ????? ????? ??? ????? 01101 11&quot;, lui    , U, R(rd) = imm);</code></li>
<li>lui,将imm的值左移12位存入rd</li>
</ul>
</li>
<li>srli:<code>0x8000005c: 00 17 d7 93 srli	a5, a5, 1</code><ul>
<li><code>INSTPAT(&quot;0000000 ????? ????? 101 ????? 00100 11&quot;, srli   , I, R(rd) = (uint32_t)src1 &gt;&gt; (imm &amp; 0x1F));</code></li>
<li>srli,逻辑右移，将src1的值右移imm位，空位用0填充，结果存入rd</li>
</ul>
</li>
<li>bgeu:<code>8000008c:	02c5fc63          	bgeu	a1,a2,800000c4 &lt;rc_crc32+0x9c&gt;</code><ul>
<li><code>INSTPAT(&quot;??????? ????? ????? 111 ????? 11000 11&quot;, bgeu   , B, if ((uint32_t)src1 &gt;= (uint32_t)src2) s-&gt;dnpc = s-&gt;pc + imm);</code></li>
<li>bgeu，无符号比较两个寄存器的值，如果第一个寄存器的值大于等于第二个，则跳转到目标地址</li>
</ul>
</li>
<li>slli:<code>800000a8:	00279793          	slli	a5,a5,0x2</code><ul>
<li><code>   INSTPAT(&quot;0000000 ????? ????? 001 ????? 00100 11&quot;, slli   , I, R(rd) = src1 &lt;&lt; (imm &amp; 0x1F));</code></li>
</ul>
</li>
</ol>
<ul>
<li>slli,逻辑左移，将src1的值左移imm位，空位用0填充，结果存入rd</li>
<li><code>HIT GOOD TRAP at pc = 0x8000012c</code>成功！</li>
</ul>
<h5 id="6-div-c"><a href="#6-div-c" class="headerlink" title="6. div.c"></a>6. div.c</h5><ul>
<li><code>tests/cpu-tests/build/div-riscv32-nemu.txt</code></li>
</ul>
<ol>
<li>mul:<code>8000007c:	02f70733          	mul	a4,a4,a5</code><ul>
<li><code>INSTPAT(&quot;0000001 ????? ????? 000 ????? 01100 11&quot;, mul    , R, R(rd) = src1 * src2);</code></li>
</ul>
</li>
<li>div:<code>800000a8:	02f74733          	div	a4,a4,a5</code><ul>
<li><code>INSTPAT(&quot;0000001 ????? ????? 100 ????? 01100 11&quot;, div    , R, R(rd) = (int32_t)src1 / (int32_t)src2);</code></li>
</ul>
</li>
</ol>
<ul>
<li><code>HIT GOOD TRAP at pc = 0x80000124</code>成功！</li>
</ul>
<h5 id="7-fact-c-fib-c"><a href="#7-fact-c-fib-c" class="headerlink" title="7. fact.c+fib.c"></a>7. fact.c+fib.c</h5><ul>
<li>直接<code>HIT GOOD TRAP</code>了</li>
</ul>
<h5 id="8-goldbach-c"><a href="#8-goldbach-c" class="headerlink" title="8. goldbach.c"></a>8. goldbach.c</h5><ol>
<li>rem:<code>8000007c:	02f666b3          	rem	a3,a2,a5</code><ul>
<li><code>INSTPAT(&quot;0000001 ????? ????? 110 ????? 01100 11&quot;, rem    , R, R(rd) = (int32_t)src1 % (int32_t)src2);</code></li>
<li>求余</li>
</ul>
</li>
</ol>
<ul>
<li><code>HIT GOOD TRAP at pc = 0x80000118</code>成功</li>
</ul>
<h5 id="9-if-else-c"><a href="#9-if-else-c" class="headerlink" title="9. if-else.c"></a>9. if-else.c</h5><ol>
<li>blt:<code>80000080:	02f94063          	blt	s2,a5,800000a0 &lt;main+0x78&gt;</code><ul>
<li><code>INSTPAT(&quot;??????? ????? ????? 100 ????? 11000 11&quot;, blt    , B, if ((int32_t)src1 &lt;(int32_t)src2) s-&gt;dnpc += imm-4);</code></li>
<li>blt,比较两个寄存器的值，如果第一个小于第二个，则跳转到目标地址</li>
</ul>
</li>
<li>slt:<code>80000084:	00fa2733          	slt	a4,s4,a5</code><ul>
<li><code>INSTPAT(&quot;0000000 ????? ????? 010 ????? 01100 11&quot;, slt    , R, R(rd) = (int32_t)src1 &lt; (int32_t)src2 ? 1 : 0);</code></li>
<li>slt,有符号比较两个寄存器的值，如果第一个寄存器的值小于第二个，则将目标寄存器设置为 1，否则设置为 0</li>
</ul>
</li>
</ol>
<ul>
<li><code>HIT GOOD TRAP at pc = 0x80000110</code>成功！</li>
</ul>
<h5 id="10-leap-year-c-load-store-c"><a href="#10-leap-year-c-load-store-c" class="headerlink" title="10. leap-year.c+load-store.c"></a>10. leap-year.c+load-store.c</h5><ul>
<li><code>HIT GOOD TRAP at pc = 0x800000dc</code></li>
</ul>
<ol>
<li>lh:<code>80000064:	00049503          	lh	a0,0(s1)</code><ul>
<li><code>INSTPAT(&quot;??????? ????? ????? 001 ????? 00000 11&quot;, lh     , I, R(rd) = SEXT(Mr(src1 + imm, 2), 16));</code></li>
<li>lh,将src1+imm地址的值的低16位存入rd</li>
</ul>
</li>
<li>lhu:<code>8000008c:	00045503          	lhu	a0,0(s0)</code><ul>
<li><code>INSTPAT(&quot;??????? ????? ????? 101 ????? 00000 11&quot;, lhu    , I, R(rd) = Mr(src1 + imm, 2));</code></li>
<li>lhu,将src1+imm地址的值存入rd</li>
</ul>
</li>
</ol>
<ul>
<li><code>HIT GOOD TRAP at pc = 0x800001ec</code></li>
</ul>
<h5 id="11-matrix-mul-c-max-c"><a href="#11-matrix-mul-c-max-c" class="headerlink" title="11. matrix-mul.c+max.c"></a>11. matrix-mul.c+max.c</h5><ul>
<li><code>HIT GOOD TRAP at pc = 0x8000015c</code></li>
<li>出错：<code>0x8000008c: 01 25 54 63 bge	a0, s2, 8</code></li>
<li>bge：<code>INSTPAT(&quot;??????? ????? ????? 101 ????? 11000 11&quot;, blez   , B, if ((int)src1 &gt;= (int)src2) s-&gt;dnpc +=imm-4); </code><ul>
<li>无符号改成有符号（加上（int））！</li>
</ul>
</li>
<li><code>HIT GOOD TRAP at pc = 0x80000124</code></li>
</ul>
<h5 id="12-mersenne-c"><a href="#12-mersenne-c" class="headerlink" title="12. mersenne.c"></a>12. mersenne.c</h5><ol>
<li>mulh:<code>80000098:	02f795b3          	mulh	a1,a5,a5</code><ul>
<li><code>INSTPAT(&quot;0000001 ????? ????? 001 ????? 01100 11&quot;, mulh   , R, R(rd) = ((int64_t)src1 * (int64_t)src2) &gt;&gt; 32);</code></li>
</ul>
</li>
<li>remu:<code>8000018c:	02c577b3          	remu	a5,a0,a2</code><ul>
<li><code>INSTPAT(&quot;0000001 ????? ????? 111 ????? 01100 11&quot;, remu   , R, R(rd) = (uint32_t)src1 % (uint32_t)src2);</code></li>
<li>remu,无符号数，求余数</li>
</ul>
</li>
<li>divu:<code>80000198:	03695533          	divu	a0,s2,s6</code><ul>
<li><code>INSTPAT(&quot;0000001 ????? ????? 101 ????? 01100 11&quot;, divu   , R, R(rd) = (uint32_t)src1 / (uint32_t)src2);</code></li>
</ul>
</li>
</ol>
<ul>
<li><code>HIT GOOD TRAP at pc = 0x80000144</code></li>
</ul>
<h5 id="13-min3-c-mov-c-c-movsx-c-mul-longlong-c"><a href="#13-min3-c-mov-c-c-movsx-c-mul-longlong-c" class="headerlink" title="13. min3.c+mov-c.c+movsx.c+mul-longlong.c"></a>13. min3.c+mov-c.c+movsx.c+mul-longlong.c</h5><ul>
<li><code>HIT GOOD TRAP at pc = 0x80000170</code></li>
<li><code>HIT GOOD TRAP at pc = 0x80000124</code></li>
<li><code>HIT GOOD TRAP at pc = 0x800001d0</code></li>
<li><code>HIT BAD TRAP at pc = 0x80000140</code>!!</li>
<li>mul有问题，改：<code>  INSTPAT(&quot;0000001 ????? ????? 001 ????? 01100 11&quot;, mulh   , R, int32_t a1 = src1; int32_t a2 = src2; int64_t tmp = (int64_t)a1 * (int64_t)a2; R(rd) = BITS(tmp, 63, 32));</code></li>
<li>为什么原方法不对：<ol>
<li>符号扩展问题：<ul>
<li>src1 和 src2 被直接转换为 int64_t 类型。如果 src1 和 src2 是负数，符号扩展可能会导致错误的结果。</li>
<li>通过将 src1 和 src2 显式转换为 int32_t 类型，然后再转换为 int64_t 类型，确保了符号扩展的正确性。</li>
</ul>
</li>
<li>位移操作的行为：<ul>
<li>若乘积直接右移 32 位。如果乘积是负数，右移操作可能会保留符号位，导致错误的结果。</li>
<li>而通过使用 BITS 宏提取特定位数，确保了结果的正确性。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h5 id="14-pascal-c-prime-c-quick-sort-c-recursion-c-select-sort-c-shuixianhua-c"><a href="#14-pascal-c-prime-c-quick-sort-c-recursion-c-select-sort-c-shuixianhua-c" class="headerlink" title="14. pascal.c + prime.c + quick-sort.c + recursion.c + select-sort.c + shuixianhua.c"></a>14. pascal.c + prime.c + quick-sort.c + recursion.c + select-sort.c + shuixianhua.c</h5><ul>
<li><code>HIT GOOD TRAP at pc = 0x80000128</code></li>
<li><code>HIT GOOD TRAP at pc = 0x800000dc</code></li>
<li><code>HIT GOOD TRAP at pc = 0x800003cc</code></li>
<li><code>HIT GOOD TRAP at pc = 0x8000026c</code></li>
<li><code>HIT GOOD TRAP at pc = 0x8000015c</code></li>
<li><code>HIT GOOD TRAP at pc = 0x8000011c</code></li>
</ul>
<h5 id="15-shift-c"><a href="#15-shift-c" class="headerlink" title="15. shift.c"></a>15. shift.c</h5><ol>
<li>sra:<code>800000a8:	40855533          	sra	a0,a0,s0</code><ul>
<li><code>INSTPAT(&quot;0100000 ????? ????? 101 ????? 01100 11&quot;, sra    , R, R(rd) = (int32_t)src1 &gt;&gt; (src2 &amp; 0x1F));</code></li>
<li>sra,算术右移，将src1的值右移src2位，空位用src1的符号位填充，结果存入rd</li>
</ul>
</li>
<li>srl:<code>800000e0:	00855533          	srl	a0,a0,s0</code><ul>
<li><code>INSTPAT(&quot;0000000 ????? ????? 101 ????? 01100 11&quot;, srl    , R, R(rd) = (uint32_t)src1 &gt;&gt; (src2 &amp; 0x1F));</code></li>
<li>srl,逻辑右移，将src1的值右移src2位，空位用0填充，结果存入rd</li>
</ul>
</li>
</ol>
<ul>
<li><code>HIT GOOD TRAP at pc = 0x80000144</code></li>
</ul>
<h5 id="16-sub-longlong-c-sum-c-switch-c-to-lower-case-c-unalign-c-wanshu-c"><a href="#16-sub-longlong-c-sum-c-switch-c-to-lower-case-c-unalign-c-wanshu-c" class="headerlink" title="16. sub-longlong.c + sum.c + switch.c + to-lower-case.c + unalign.c + wanshu.c"></a>16. sub-longlong.c + sum.c + switch.c + to-lower-case.c + unalign.c + wanshu.c</h5><ul>
<li><code>HIT GOOD TRAP at pc = 0x80000138</code></li>
<li><code>HIT GOOD TRAP at pc = 0x8000009c</code></li>
</ul>
<ol>
<li>bltu:<code>80000070:	009a6463          	bltu	s4,s1,80000078 &lt;main+0x50&gt;</code><ul>
<li><code>INSTPAT(&quot;??????? ????? ????? 110 ????? 11000 11&quot;, bltu   , B, if ((uint32_t)src1 &lt; (uint32_t)src2) s-&gt;dnpc = s-&gt;pc + imm);</code></li>
<li>bltu，无符号比较两个寄存器的值，如果第一个寄存器的值小于第二个，则跳转到目标地址</li>
</ul>
</li>
</ol>
<ul>
<li><code>HIT GOOD TRAP at pc = 0x800000e8</code></li>
<li><code>HIT GOOD TRAP at pc = 0x800000d4</code></li>
<li><code>HIT GOOD TRAP at pc = 0x80000144</code></li>
<li><code>HIT GOOD TRAP at pc = 0x80000104</code></li>
</ul>
<h5 id="ps-hello-str-c和string-c"><a href="#ps-hello-str-c和string-c" class="headerlink" title="ps:hello-str.c和string.c"></a>ps:hello-str.c和string.c</h5><ul>
<li>还需要实现额外的内容才能运行(具体在后续小节介绍), 目前可以先使用其它测试用例进行测试.</li>
</ul>
<h4 id="mips32的分支延迟槽"><a href="#mips32的分支延迟槽" class="headerlink" title="mips32的分支延迟槽"></a>mips32的分支延迟槽</h4><ul>
<li>为了提升处理器的性能, mips使用了一种叫<strong>分支延迟槽</strong>的技术。</li>
<li>程序的执行顺序发生一些改变: <ul>
<li>把<em>紧跟在跳转指令(包括有条件和无条件)之后</em>的<em>静态指令</em>称为<strong>延迟槽</strong></li>
<li>那么程序在执行完跳转指令后, 会<em>先执行延迟槽中的指令</em>, 再<em>执行位于跳转目标的指令</em>。</li>
</ul>
</li>
<li>延迟槽技术需要软硬件协同才能正确工作: mips手册中描述了这一约定, 处理器设计者按照这一约定设计处理器, 而编译器开发者则会让编译器负责在延迟槽中放置一条有意义的指令, 使得无论是否跳转, 按照这一约定的执行顺序都能得到正确的执行结果.</li>
<li>如果你是编译器开发者, 你将会如何寻找合适的指令放到延迟槽中呢?<ol>
<li>尽量选择不会影响程序逻辑的无副作用的指令</li>
<li>选择与跳转指令无关的独立的指令，即不依赖于跳转指令的结果，也不影响跳转目标的执行。</li>
<li>将原本在跳转目标处执行的指令提前到延迟槽中执行，可以减少跳转目标处的指令数量，提升性能</li>
</ol>
</li>
</ul>
<h4 id="指令名对照"><a href="#指令名对照" class="headerlink" title="指令名对照"></a>指令名对照</h4><ul>
<li>AT&amp;T格式反汇编结果中的少量指令, <strong>与手册中列出的指令名称不符</strong>, 如x86的cltd, mips32和riscv32则有不少<strong>伪指令</strong>(pseudo instruction). 除了STFW之外, 你有办法在手册中找到对应的指令吗? 如果有的话, 为什么这个办法是有效的呢?</li>
<li>办法：</li>
</ul>
<ol>
<li>获取指令的机器码<ul>
<li>使用反汇编工具获取指令的机器码。</li>
</ul>
</li>
<li>查找操作码和功能码<ul>
<li>从机器码中提取操作码和功能码。</li>
<li>对于RISC-V指令，可以提取操作码（opcode）、功能码（funct3）和功能码（funct7）。</li>
</ul>
</li>
<li>查阅手册<ul>
<li>然后在指令手册中查找对应的操作码和功能码。</li>
</ul>
</li>
</ol>
<ul>
<li>为什么有效：<ol>
<li>唯一性：每条指令在机器码级别都有唯一的编码，通过操作码和功能码可以唯一确定一条指令。</li>
<li>标准化：指令手册中提供了详细的指令编码表和描述，通过这些表可以准确地找到指令的定义。</li>
<li>准确性：相比于直接搜索指令名称，通过操作码和功能码查找指令可以避免名称不一致的问题，确保查找结果的准确性。</li>
</ol>
</li>
</ul>
<h3 id="PA2-1结束"><a href="#PA2-1结束" class="headerlink" title="PA2.1结束"></a>PA2.1结束</h3><h1 id="程序-运行时环境与AM"><a href="#程序-运行时环境与AM" class="headerlink" title="程序, 运行时环境与AM"></a>程序, 运行时环境与AM</h1><h2 id="运行时环境"><a href="#运行时环境" class="headerlink" title="运行时环境"></a>运行时环境</h2><ul>
<li>“并不是每一个程序都可以在NEMU中运行”背后的缘由：<ul>
<li>应用程序的运行都需要运行时环境的支持, 包括<em>加载, 销毁程序</em>, 以及<em>提供程序运行时的各种动态链接库</em>(你经常使用的库函数就是运行时环境提供的)等</li>
</ul>
</li>
<li>要提供相应的运行时环境的支持了！</li>
<li>为了运行最简单的程序, 我们需要提供什么呢? 其实答案已经在PA1中了: <ul>
<li>只要<em>把程序放在正确的内存位置, 然后让PC指向第一条指令</em>, 计算机就会自动执行这个程序, 永不停止.</li>
</ul>
</li>
<li>so：只要有内存, 有结束运行的方式, 加上实现正确的指令, 就可以支撑最简单程序的运行了</li>
</ul>
<h2 id="将运行时环境封装成库函数"><a href="#将运行时环境封装成库函数" class="headerlink" title="将运行时环境封装成库函数"></a>将运行时环境封装成库函数</h2><ul>
<li>我们只需要定义一个结束程序的API, 比如<code>void halt()</code>, 它对不同架构上程序的不同结束方式进行了<strong>抽象</strong>: 程序只要调用<code>halt()</code>就可以结束运行, 而不需要关心自己运行在哪一个架构上.</li>
<li>运行时环境的一种普遍的存在方式: <strong>库</strong></li>
<li>通过库, 运行程序所需要的公共要素被抽象成API, 不同的架构只需要实现这些API, 也就相当于实现了支撑程序运行的运行时环境, 这提升了程序开发的效率: 需要的时候只要调用这些API, 就能使用运行时环境提供的相应功能.</li>
</ul>
<h4 id="思考：这又能怎么样呢"><a href="#思考：这又能怎么样呢" class="headerlink" title="思考：这又能怎么样呢"></a>思考：这又能怎么样呢</h4><ul>
<li>思考一下, 这样的抽象还会带来哪些好处呢? 你很快就会体会到这些好处了.</li>
</ul>
<ol>
<li>代码复用<ul>
<li>通过定义统一的API，可以在不同的架构上复用相同的程序代码。只需要为每个架构实现对应的API，而不需要为每个程序和每个架构分别编写代码。</li>
</ul>
</li>
<li>简化维护<ul>
<li>维护n个程序和m个架构相关的API实现，只需要维护n+m份代码，而不是n*m份代码。</li>
</ul>
</li>
<li>提高开发效率<ul>
<li>只需要关注程序逻辑，而不需要关心底层架构的具体实现。</li>
</ul>
</li>
<li>增强了程序的可移植性</li>
</ol>
<h2 id="AM-裸机-bare-metal-运行时环境"><a href="#AM-裸机-bare-metal-运行时环境" class="headerlink" title="AM - 裸机(bare-metal)运行时环境"></a>AM - 裸机(bare-metal)运行时环境</h2><ul>
<li>只进行纯粹计算任务的程序在TRM上就可以运行, 更复杂的应用程序<strong>对运行时环境必定还有其它的需求</strong><ul>
<li>eg：超级玛丽需要和用户进行交互</li>
</ul>
</li>
<li>如果我们把这些需求都收集起来, 将它们<strong>抽象成统一的API</strong>提供给程序, 这样我们就得到了一个可以支撑各种程序运行在各种架构上的<strong>库</strong>了! <ul>
<li>每个架构都按照它们的特性实现这组API</li>
<li>应用程序只需要直接调用这组API即可, 无需关心自己将来运行在哪个架构上.</li>
</ul>
</li>
<li>这组API被称为<strong>抽象计算机</strong>，即<strong>AM(Abstract machine)</strong></li>
<li>AM根据程序的需求把库划分成以下模块:  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AM = TRM + IOE + CTE + VME + MPE</span><br></pre></td></tr></table></figure>
<ul>
<li>TRM(Turing Machine) - 图灵机, 最简单的运行时环境, 为程序提供基本的计算能力</li>
<li>IOE(I&#x2F;O Extension) - 输入输出扩展, 为程序提供输出输入的能力</li>
<li>CTE(Context Extension) - 上下文扩展, 为程序提供上下文管理的能力</li>
<li>VME(Virtual Memory Extension) - 虚存扩展, 为程序提供虚存管理的能力</li>
<li>MPE(Multi-Processor Extension) - 多处理器扩展, 为程序提供多处理器通信的能力 (MPE超出了ICS课程的范围, 在PA中不会涉及)</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(在NEMU中)实现硬件功能 -&gt; (在AM中)提供运行时环境 -&gt; (在APP层)运行程序</span><br><span class="line">(在NEMU中)实现更强大的硬件功能 -&gt; (在AM中)提供更丰富的运行时环境 -&gt; (在APP层)运行更复杂的程序</span><br></pre></td></tr></table></figure>
<h4 id="思考-为什么要有AM-建议二周目思考"><a href="#思考-为什么要有AM-建议二周目思考" class="headerlink" title="思考:为什么要有AM? (建议二周目思考)"></a>思考:为什么要有AM? (建议二周目思考)</h4><ul>
<li>操作系统也有自己的运行时环境. AM和操作系统提供的运行时环境有什么不同呢? 为什么会有这些不同?</li>
<li>不同：<ol>
<li>抽象层次：<ul>
<li>AM：主要关注于硬件抽象，提供基本的硬件功能抽象，如上下文管理、虚存管理、多处理器通信等。它直接运行在硬件之上，提供一个简化的、统一的硬件接口。</li>
<li>操作系统：提供更高层次的抽象，包括进程管理、文件系统、网络通信、安全机制等。操作系统不仅抽象硬件，还管理系统资源，提供丰富的系统服务。</li>
</ul>
</li>
<li>功能范围<ul>
<li>AM：功能相对简单，主要提供硬件抽象和基本的运行时环境。</li>
<li>操作系统：功能丰富，提供全面的系统服务和资源管理，包括内存管理、进程调度、文件系统、网络堆栈等。</li>
</ul>
</li>
<li>目标和用途<ul>
<li>AM：主要用于简化应用程序的开发和移植，使得应用程序可以在不同的硬件平台上运行。它通常用于嵌入式系统、模拟器和教学环境中。</li>
<li>操作系统：主要用于管理计算机系统的资源，提供稳定和高效的运行环境。它用于通用计算平台，如桌面计算机、服务器和移动设备。</li>
</ul>
</li>
</ol>
</li>
<li>为什么会有这些不同：<ol>
<li>设计目标<ul>
<li>AM：设计目标是提供一个统一的硬件抽象层，简化应用程序的开发和移植。因此，它的功能范围相对简单，主要关注于硬件抽象。</li>
<li>操作系统：设计目标是管理系统资源，提供丰富的系统服务，确保系统的稳定性和高效性。因此，它的功能范围广泛，涉及资源管理和系统服务。</li>
</ul>
</li>
<li>复杂性和性能要求<ul>
<li>AM：由于功能简单，AM的实现相对简单，性能开销较小。它适用于对性能要求高、资源有限的环境。</li>
<li>操作系统：由于功能丰富，操作系统的实现复杂，性能开销较大。它适用于通用计算平台，提供全面的系统服务。</li>
</ul>
</li>
<li>应用场景不同<ul>
<li>AM：适用于嵌入式系统、模拟器和教学环境，提供一个简化的硬件抽象层，方便应用程序的开发和移植。</li>
<li>操作系统：适用于通用计算平台，提供全面的系统服务和资源管理，确保系统的稳定性和高效性。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="RTFSC-3"><a href="#RTFSC-3" class="headerlink" title="RTFSC(3)"></a>RTFSC(3)</h2><ul>
<li>AM的子项目<code>abstract-machine</code></li>
<li>整个AM项目分为两大部分:<ul>
<li><code>abstract-machine/am/</code> - 不同架构的AM API实现, 目前我们<strong>只需要关注NEMU相关的内容</strong>即可. 此外, abstract-machine&#x2F;am&#x2F;include&#x2F;am.h列出了AM中的所有API, 我们会在后续逐一介绍它们.</li>
<li><code>abstract-machine/klib/</code> - 一些架构无关的库函数, 方便应用程序的开发</li>
</ul>
</li>
<li>TRM的API：<ul>
<li><code>Area heap</code>结构用于指示<strong>堆区的起始和末尾</strong></li>
<li><code>void putch(char ch)</code>用于输出一个字符</li>
<li><code>void halt(int code)</code>用于结束程序的运行</li>
<li><code>void _trm_init()</code>用于进行TRM相关的初始化工作</li>
</ul>
</li>
<li><strong>堆区</strong>是<strong>给程序自由使用的一段内存区间</strong>, 为程序提供<strong>动态分配内存</strong>的功能. </li>
<li><code>halt()</code>里面调用了<code>nemu_trap()</code>宏 (在<code>abstract-machine/am/src/platform/nemu/include/nemu.h</code>中定义), 这个宏展开之后是一条内联汇编语句. 内联汇编语句允许我们在C代码中嵌入汇编语句, 以riscv32为例, 宏展开之后将会得到:<code>asm volatile(&quot;mv a0, %0; ebreak&quot; : :&quot;r&quot;(code));</code><ul>
<li>正是那条特殊的<code>nemu_trap</code></li>
</ul>
</li>
<li><code>am-kernels</code>子项目用于收录一些可以在AM上运行的测试集和简单程序</li>
<li>在让NEMU运行客户程序之前, 我们需要将客户程序的代码编译成可执行文件<ul>
<li>不能使用gcc的默认选项直接编译<ul>
<li>默认选项会根据GNU&#x2F;Linux的运行时环境将代码编译成运行在GNU&#x2F;Linux下的可执行文件,但此时的NEMU并不能为客户程序提供GNU&#x2F;Linux的运行时环境</li>
</ul>
</li>
<li>使用<strong>交叉编译</strong><ul>
<li>需要在GNU&#x2F;Linux下根据AM的运行时环境编译出能够在<code>$ISA-nemu</code>这个新环境中运行的可执行文件</li>
<li>为了不让链接器ld使用默认的方式链接, 我们还需要提供描述<code>$ISA-nemu</code>的运行时环境的链接脚本</li>
</ul>
</li>
</ul>
</li>
<li>交叉编译生成一个可以在NEMU的运行时环境上运行的程序的过程大致如下:<ul>
<li>gcc将<code>$ISA-nemu</code>的AM实现源文件编译成目标文件, 然后通过ar将这些目标文件作为一个库, 打包成一个归档文件<code>abstract-machine/am/build/am-$ISA-nemu.a</code></li>
<li>gcc把应用程序源文件(如<code>am-kernels/tests/cpu-tests/tests/dummy.c</code>)编译成目标文件</li>
<li>通过gcc和ar把程序依赖的运行库(如<code>abstract-machine/klib/</code>)也编译并打包成归档文件</li>
<li>根据Makefile文件<code>abstract-machine/scripts/$ISA-nemu.mk</code>中的指示, 让ld根据链接脚本<code>abstract-machine/scripts/linker.ld</code>, 将上述目标文件和归档文件链接成可执行文件</li>
</ul>
</li>
<li>对编译得到的可执行文件的行为进行简单的梳理:<ol>
<li>第一条指令从<code>abstract-machine/am/src/$ISA/nemu/start.S</code>开始, 设置好栈顶之后就跳转到<code>abstract-machine/am/src/platform/nemu/trm.c的_trm_init()</code>函数处执行.</li>
<li>在<code>_trm_init()</code>中调用<code>main()</code>函数执行程序的主体功能, main()函数还带一个参数, 目前我们暂时不会用到, 后面我们再介绍它.</li>
<li>从main()函数返回后, 调用<code>halt()</code>结束运行.</li>
</ol>
</li>
</ul>
<h4 id="必做：阅读Makefile"><a href="#必做：阅读Makefile" class="headerlink" title="必做：阅读Makefile"></a>必做：阅读Makefile</h4><ul>
<li><code>abstract-machine</code>项目的Makefile设计得非常巧妙, 你需要把它们看成一种代码来RTFSC, 从而理解它们是如何工作的. 这样一来, 你就知道怎么编写有一定质量的Makefile了; 同时, 如果哪天Makefile出现了非预期的行为, 你就可以尝试对Makefile进行调试了. 当然, 这少不了RTFM.</li>
</ul>
<ol>
<li>基本设置和检查<ul>
<li>默认目标：如果没有指定目标，默认构建<code>image</code>。</li>
<li>环境变量检查：确保<code>$AM_HOME</code>和<code>$ARCH</code>环境变量设置正确。</li>
<li>提取架构和平台：从<code>$ARCH</code>中提取指令集架构（ISA）和平台。</li>
<li>检查源文件：确保有源文件可供构建。</li>
</ul>
</li>
<li>通用编译目标<ul>
<li>创建目标目录：在<code>build/$ARCH</code>目录下创建构建输出目录。</li>
<li>编译目标：定义生成的二进制镜像或归档文件的路径。</li>
<li>收集链接文件：收集所有需要链接的对象文件和库文件。</li>
</ul>
</li>
<li>通用编译标志<ul>
<li>编译器和工具链：定义交叉编译工具链的路径。</li>
<li>编译标志：设置编译标志，包括包含路径、架构定义和优化选项。</li>
</ul>
</li>
<li>架构特定配置<ul>
<li>包含架构特定配置：从<code>scripts/$(ARCH).mk</code>文件中包含架构特定的配置。</li>
</ul>
</li>
<li>编译规则<ul>
<li>编译规则：定义如何从<code>.c</code>、<code>.cc</code>、<code>.cpp</code>和<code>.S</code>文件生成对象文件。</li>
<li>递归构建库：递归调用 Makefile 构建依赖库。</li>
<li>链接规则：定义如何从对象文件和库文件生成最终的 ELF 二进制文件。</li>
<li>归档规则：定义如何从对象文件生成归档文件（<code>.a</code>）。</li>
<li>依赖文件：包含由 gcc 生成的依赖文件（<code>.d</code>）。</li>
</ul>
</li>
<li>杂项<ul>
<li>构建顺序控制：定义构建顺序，确保依赖关系正确。</li>
<li>清理规则：定义清理单个项目和所有子项目的规则。</li>
</ul>
</li>
</ol>
<h4 id="必做：通过批处理模式运行NEMU"><a href="#必做：通过批处理模式运行NEMU" class="headerlink" title="必做：通过批处理模式运行NEMU"></a>必做：通过批处理模式运行NEMU</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们知道, 大部分同学很可能会这么想: 反正我不阅读Makefile, 老师助教也不知道, 总觉得不看也无所谓.</span><br><span class="line"></span><br><span class="line">所以在这里我们加一道必做题: 我们之前启动NEMU的时候, 每次都需要手动键入c才能运行客户程序. 但如果不是为了使用NEMU中的sdb, 我们其实可以节省c的键入. NEMU中实现了一个批处理模式, 可以在启动NEMU之后直接运行客户程序. 请你阅读NEMU的代码并合适地修改Makefile, 使得通过AM的Makefile可以默认启动批处理模式的NEMU.</span><br><span class="line"></span><br><span class="line">你现在仍然可以跳过这道必做题, 但很快你就会感到不那么方便了.</span><br></pre></td></tr></table></figure>
<ul>
<li>看nemu的代码:  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sdb_mainloop</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//检查是否处于批处理模式</span></span><br><span class="line">    <span class="keyword">if</span>(is_batch_mode)&#123;</span><br><span class="line">        cmd_c(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......<span class="comment">//其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>进入sdb循环前要进行<code>is_batch_mode</code>的判断，为true，就会自动执行cmd_c函数，且不会进入sdb循环</li>
</ul>
</li>
<li>所以使<code>is_batch_mode=true</code>,而nemu提供了<code>sdb_set_batch_mode()</code>函数,应该调用它。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:sdb_set_batch_mode();<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>所以：在<strong>运行NEMU时传入参数b</strong>即可。</li>
<li>添加<code>NEMUFLAGS += -b -l $(shell dirname $(IMAGE).elf)/nemu-log.txt</code></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">### Compilation flags</span></span><br><span class="line">INC_PATH += <span class="variable">$(WORK_DIR)</span>/<span class="keyword">include</span> <span class="variable">$(<span class="built_in">addsuffix</span> /include/, $(<span class="built_in">addprefix</span> <span class="variable">$(AM_HOME)</span>/, <span class="variable">$(LIBS)</span>)</span>)</span><br><span class="line">INCFLAGS += <span class="variable">$(<span class="built_in">addprefix</span> -I, <span class="variable">$(INC_PATH)</span>)</span></span><br><span class="line"></span><br><span class="line">ARCH_H := arch/<span class="variable">$(ARCH)</span>.h</span><br><span class="line">CFLAGS   += -O2 -MMD -Wall -Werror <span class="variable">$(INCFLAGS)</span> \</span><br><span class="line">            -D__ISA__=\<span class="string">&quot;<span class="variable">$(ISA)\&quot;</span> -D__ISA_$(shell echo <span class="variable">$(ISA)</span> | tr a-z A-Z)__ \</span></span><br><span class="line"><span class="string">            -D__ARCH__=<span class="variable">$(ARCH)</span> -D__ARCH_$(shell echo <span class="variable">$(ARCH)</span> | tr a-z A-Z | tr - _) \</span></span><br><span class="line"><span class="string">            -D__PLATFORM__=<span class="variable">$(PLATFORM)</span> -D__PLATFORM_$(shell echo <span class="variable">$(PLATFORM)</span> | tr a-z A-Z | tr - _) \</span></span><br><span class="line"><span class="string">            -DARCH_H=\&quot;<span class="variable">$(ARCH_H)\&quot;</span> \</span></span><br><span class="line"><span class="string">            -fno-asynchronous-unwind-tables -fno-builtin -fno-stack-protector \</span></span><br><span class="line"><span class="string">            -Wno-main -U_FORTIFY_SOURCE -fvisibility=hidden</span></span><br><span class="line"><span class="string">CXXFLAGS +=  <span class="variable">$(CFLAGS)</span> -ffreestanding -fno-rtti -fno-exceptions</span></span><br><span class="line"><span class="string">ASFLAGS  += -MMD <span class="variable">$(INCFLAGS)</span></span></span><br><span class="line"><span class="string">LDFLAGS  += -z noexecstack $(addprefix -T, <span class="variable">$(LDSCRIPTS)</span>)</span></span><br><span class="line"><span class="string">NEMUFLAGS += -b -l $(shell dirname <span class="variable">$(IMAGE)</span>.elf)/nemu-log.txt</span></span><br></pre></td></tr></table></figure>
<h2 id="实现常用的库函数"><a href="#实现常用的库函数" class="headerlink" title="实现常用的库函数"></a>实现常用的库函数</h2><ul>
<li>把运行时环境分成两部分: <ol>
<li>一部分是架构相关的运行时环境, 也就是我们之前介绍的AM</li>
<li>另一部分是架构无关的运行时环境, 类似<code>memcpy()</code>这种常用的函数应该归入这部分, <code>abstract-machine/klib/</code>用于收录这些架构无关的库函数. <ul>
<li><code>klib</code>是<code>kernel library</code>的意思, 用于提供一些兼容<code>libc</code>的基础功能.</li>
</ul>
</li>
</ol>
</li>
<li>框架代码在<code>abstract-machine/klib/src/string.c</code>和<code>abstract-machine/klib/src/stdio.c</code>中列出了将来可能会用到的库函数, 但并没有提供相应的实现.</li>
</ul>
<h4 id="必做：实现字符串处理函数"><a href="#必做：实现字符串处理函数" class="headerlink" title="必做：实现字符串处理函数"></a>必做：实现字符串处理函数</h4><ul>
<li>根据需要实现<code>abstract-machine/klib/src/string.c</code>中列出的字符串处理函数, 让<code>cpu-tests</code>中的测试用例<code>string</code>可以成功运行. 关于这些库函数的具体行为, 请务必RTFM.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;klib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;klib-macros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(__ISA_NATIVE__) || defined(__NATIVE_USE_KLIB__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算字符串长度</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">size_t</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(s[n] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    n++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制字符串</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dst, <span class="type">const</span> <span class="type">char</span> *src)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (src == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">char</span> *ret = dst;</span><br><span class="line">  <span class="keyword">while</span> ((*dst++ = *src++) != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制一定长度的字符串</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dst, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *ret = dst;</span><br><span class="line">  <span class="keyword">while</span>(n&amp;&amp;(*dst++ = *src++) != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    n--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">    *dst++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将源字符串连接到目标字符串的末尾</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dst, <span class="type">const</span> <span class="type">char</span> *src)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *ret = dst;</span><br><span class="line">  <span class="keyword">while</span>(*dst != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    dst++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>((*dst++ = *src++) != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较字符串,返回差值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span>(*s1&amp;&amp; *s1 == *s2) &#123;</span><br><span class="line">    s1++;</span><br><span class="line">    s2++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *)s1 - *(<span class="type">unsigned</span> <span class="type">char</span> *)s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较字符串的前n个字符,返回差值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span>(n!=<span class="number">0</span> &amp;&amp; *s1 &amp;&amp; *s1 == *s2) &#123;</span><br><span class="line">    n--;</span><br><span class="line">    s1++;</span><br><span class="line">    s2++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *)s1 - *(<span class="type">unsigned</span> <span class="type">char</span> *)s2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将内存块的前n个字节设置为指定的值</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *s, <span class="type">int</span> c, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">  <span class="comment">//使用unsigned char类型指针遍历内存块，并将每个字节设置为c</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">unsigned</span> <span class="type">char</span> *)s;</span><br><span class="line">  <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)c;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//安全地移动内存块，处理源和目标内存区域重叠的情况</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memmove</span><span class="params">(<span class="type">void</span> *dst, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *d = (<span class="type">unsigned</span> <span class="type">char</span> *)dst;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)src;</span><br><span class="line">  <span class="keyword">if</span>(d &lt; s) &#123;<span class="comment">//如果目标地址小于源地址，从前往后复制。</span></span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">      *d++ = *s++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;<span class="comment">//如果目标地址大于源地址，从后往前复制</span></span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *lasts = s + (n - <span class="number">1</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *lastd = d + (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">      *lastd-- = *lasts--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将内存块的前n个字节从源复制到目标</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *out, <span class="type">const</span> <span class="type">void</span> *in, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *dst = (<span class="type">unsigned</span> <span class="type">char</span> *)out;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *src = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)in;</span><br><span class="line">  <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">    *dst++ = *src++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逐字节比较两个内存块的前n个字节，返回它们的差值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *s1, <span class="type">const</span> <span class="type">void</span> *s2, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *p1 = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)s1;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *p2 = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)s2;</span><br><span class="line">  <span class="keyword">while</span>(n--) &#123;<span class="comment">//使用unsigned char类型指针遍历两个内存块，并比较每个字节</span></span><br><span class="line">    <span class="keyword">if</span>(*p1 != *p2) &#123;<span class="comment">//如果发现不同的字节，返回差值</span></span><br><span class="line">      <span class="keyword">return</span> *p1 - *p2;</span><br><span class="line">    &#125;</span><br><span class="line">    p1++;</span><br><span class="line">    p2++;</span><br><span class="line">  &#125;<span class="comment">//所有字节都相同，返回0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="实现sprintf"><a href="#实现sprintf" class="headerlink" title="实现sprintf"></a>实现sprintf</h4><ul>
<li>实现<code>abstract-machine/klib/src/stdio.c</code>中的<code>sprintf()</code>, 具体行为可以参考<code>man 3 printf</code>. 目前你只需要实现<code>%s</code>和<code>%d</code>就能通过<code>hello-str</code>的测试了, <strong>其它功能(包括位宽, 精度等)可以在将来需要的时候再自行实现</strong>.</li>
<li>和其它库函数相比, <code>sprintf()</code>比较特殊, 因为它的参数数目是可变的. 为了获得<strong>数目可变的参数</strong>, 你可以使用C库<code>stdarg.h</code>中提供的<strong>宏</strong>, 具体用法请查阅<code>man stdarg</code>.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//（辅助）将整数转换为字符串</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">itoa</span><span class="params">(<span class="type">int</span> num,<span class="type">char</span> *str)</span>&#123;</span><br><span class="line">  <span class="type">char</span> *p = str;</span><br><span class="line">  <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;<span class="comment">//为0</span></span><br><span class="line">    *p++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(num &lt; <span class="number">0</span>)&#123;<span class="comment">//负数</span></span><br><span class="line">    *p++ = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    num = -num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//计算整数的长度，并将每一位转换为字符</span></span><br><span class="line">  <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> temp = num;</span><br><span class="line">  <span class="keyword">while</span>(temp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    temp /= <span class="number">10</span>;</span><br><span class="line">    len++;</span><br><span class="line">  &#125;</span><br><span class="line">  str[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    str[--len] = num % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    num /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *out, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start(ap, fmt);</span><br><span class="line">  <span class="type">char</span> *p = out;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *f=fmt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(*f)&#123;</span><br><span class="line">    <span class="keyword">if</span>(*f == <span class="string">&#x27;%&#x27;</span>)&#123;<span class="comment">//遇到%，检查下一个字符以确定格式类型</span></span><br><span class="line">      f++;</span><br><span class="line">      <span class="keyword">if</span>(*f == <span class="string">&#x27;d&#x27;</span>)&#123;<span class="comment">//如果是%d，将整数参数转换为字符串并复制到输出缓冲区</span></span><br><span class="line">        <span class="type">int</span> num = va_arg(ap, <span class="type">int</span>);</span><br><span class="line">        <span class="type">char</span> num_str[<span class="number">20</span>];<span class="comment">//足够大</span></span><br><span class="line">        itoa(num, num_str);</span><br><span class="line">        <span class="type">char</span> *num_p = num_str;</span><br><span class="line">        <span class="keyword">while</span>(*num_p)&#123;</span><br><span class="line">          *p++ = *num_p++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(*f == <span class="string">&#x27;s&#x27;</span>)&#123;<span class="comment">//如果是%s，将字符串参数复制到输出缓冲区</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *str = va_arg(ap, <span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">        <span class="keyword">while</span>(*str)&#123;</span><br><span class="line">          *p++ = *str++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//未知格式</span></span><br><span class="line">      *p++ = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">      *p++ = *f;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    *p++ = *f;</span><br><span class="line">  &#125;</span><br><span class="line">  f++;</span><br><span class="line">  &#125;</span><br><span class="line">  *p = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//末尾设置为&#x27;\0&#x27;</span></span><br><span class="line">  va_end(ap);</span><br><span class="line">  <span class="keyword">return</span> p - out;<span class="comment">//返回写入的字符数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重新认识计算机-计算机是个抽象层"><a href="#重新认识计算机-计算机是个抽象层" class="headerlink" title="重新认识计算机: 计算机是个抽象层"></a>重新认识计算机: 计算机是个抽象层</h2><ul>
<li>讨论在TRM上运行的程序, 我们对这些程序的需求进行分类, 来看看我们的计算机系统是如何支撑这些需求的<ul>
<li>计算</li>
<li>内存申请</li>
<li>结束运行</li>
<li>打印信息</li>
</ul>
</li>
<li>宏观视角：底层——&gt;高层<ul>
<li>微观视角: 程序是个状态机</li>
<li>宏观视角: 计算机是个抽象层</li>
<li>理解计算机是如何把底层的功能经过层层抽象, 最终支撑程序的运行.</li>
</ul>
</li>
</ul>
<h1 id="基础设施（2）"><a href="#基础设施（2）" class="headerlink" title="基础设施（2）"></a>基础设施（2）</h1><h2 id="bug诊断的利器-踪迹"><a href="#bug诊断的利器-踪迹" class="headerlink" title="bug诊断的利器 - 踪迹"></a>bug诊断的利器 - 踪迹</h2><ul>
<li>为了提高效率, 我们可以通过<code>printf()</code>来输出我们关心的某些信息. </li>
<li>在软件工程领域, <strong>记录程序执行过程的信息</strong>称为<strong>踪迹(trace)</strong>. 有了踪迹信息, 我们就可以判断程序的执行过程是否符合预期, 从而进行bug的诊断.</li>
</ul>
<h3 id="指令执行的踪迹-itrace"><a href="#指令执行的踪迹-itrace" class="headerlink" title="指令执行的踪迹 - itrace"></a>指令执行的踪迹 - itrace</h3><ul>
<li>NEMU已经实现– <code>itrace (instruction trace)</code>, 它可以记录客户程序执行的每一条指令. </li>
<li>itrace会输出<strong>指令的PC, 二进制表示以及反汇编结果</strong></li>
<li>框架代码默认已经打开了这个功能, 客户程序执行的指令都会被记录到<code>build/nemu-log.txt</code>中</li>
<li>NEMU可以限制trace输出的时机, 你可以<strong>手动指定</strong>什么时候才输出它们, 甚至还可以自定义输出trace的条件. 具体如何指定, RTFSC. </li>
<li>对于一些输出规整的trace, 我们还可以通过<strong>grep, awk, sed</strong>等文本处理工具来对它们进行<strong>筛选和处理</strong>. </li>
<li><code>nemu/src/cpu/cpu-exec.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">exec_once</span><span class="params">(Decode *s, <span class="type">vaddr_t</span> pc)</span> &#123;</span><br><span class="line">  s-&gt;pc = pc;<span class="comment">///</span></span><br><span class="line">  s-&gt;snpc = pc;</span><br><span class="line">  isa_exec_once(s);</span><br><span class="line">  cpu.pc = s-&gt;dnpc;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Executed instruction at pc = 0x%x, next pc = 0x%x\n&quot;</span>, s-&gt;pc, s-&gt;dnpc);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ITRACE</span></span><br><span class="line">  <span class="type">char</span> *p = s-&gt;logbuf;</span><br><span class="line">  p += <span class="built_in">snprintf</span>(p, <span class="keyword">sizeof</span>(s-&gt;logbuf), FMT_WORD <span class="string">&quot;:&quot;</span>, s-&gt;pc);</span><br><span class="line">  <span class="type">int</span> ilen = s-&gt;snpc - s-&gt;pc;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">uint8_t</span> *inst = (<span class="type">uint8_t</span> *)&amp;s-&gt;isa.inst.val;</span><br><span class="line">  <span class="keyword">for</span> (i = ilen - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">    p += <span class="built_in">snprintf</span>(p, <span class="number">4</span>, <span class="string">&quot; %02x&quot;</span>, inst[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ilen_max = MUXDEF(CONFIG_ISA_x86, <span class="number">8</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="type">int</span> space_len = ilen_max - ilen;</span><br><span class="line">  <span class="keyword">if</span> (space_len &lt; <span class="number">0</span>) space_len = <span class="number">0</span>;</span><br><span class="line">  space_len = space_len * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">memset</span>(p, <span class="string">&#x27; &#x27;</span>, space_len);</span><br><span class="line">  p += space_len;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">disassemble</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> size, <span class="type">uint64_t</span> pc, <span class="type">uint8_t</span> *code, <span class="type">int</span> nbyte)</span>;</span><br><span class="line">  disassemble(p, s-&gt;logbuf + <span class="keyword">sizeof</span>(s-&gt;logbuf) - p,</span><br><span class="line">      MUXDEF(CONFIG_ISA_x86, s-&gt;snpc, s-&gt;pc), (<span class="type">uint8_t</span> *)&amp;s-&gt;isa.inst.val, ilen);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指令环形缓冲区-iringbuf"><a href="#指令环形缓冲区-iringbuf" class="headerlink" title="指令环形缓冲区 - iringbuf"></a>指令环形缓冲区 - iringbuf</h3><ul>
<li>我们能不能在<strong>客户程序出错</strong>(例如访问物理内存越界)的时候<strong>输出最近执行的若干条指令</strong>呢?</li>
<li><strong>环形缓冲区(ring buffer)</strong><ul>
<li>在每执行一条指令的时候, 就把这条指令的信息写入到环形缓冲区中</li>
<li>如果缓冲区满了, 就会覆盖旧的内容</li>
<li>客户程序出错的时候, 就把环形缓冲区中的指令打印出来, 供调试进行参考.</li>
</ul>
</li>
</ul>
<h4 id="必做：实现iringbuf"><a href="#必做：实现iringbuf" class="headerlink" title="必做：实现iringbuf"></a>必做：实现iringbuf</h4><ul>
<li>根据上述内容, 在NEMU中实现iringbuf. 你可以按照自己的喜好来设计输出的格式, 如果你想输出指令的反汇编, 可以参考itrace的相关代码; 如果你不知道应该在什么地方添加什么样的代码, 你就需要RTFSC了.</li>
<li>思考在哪添加代码：<ul>
<li><code>nemu/src/memory/padder.c</code></li>
</ul>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">out_of_bound</span><span class="params">(<span class="type">paddr_t</span> addr)</span> &#123;</span><br><span class="line">panic(<span class="string">&quot;address = &quot;</span> FMT_PADDR <span class="string">&quot; is out of bound of pmem [&quot;</span> FMT_PADDR <span class="string">&quot;, &quot;</span> FMT_PADDR <span class="string">&quot;] at pc = &quot;</span> FMT_WORD,</span><br><span class="line">    addr, PMEM_LEFT, PMEM_RIGHT, cpu.pc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>panic定义在<code>nemu/include/debug.h</code></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//nemu/include/debug.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DEBUG_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DEBUG_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;common.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Log(format, ...) \</span></span><br><span class="line"><span class="meta">    _Log(ANSI_FMT(<span class="string">&quot;[%s:%d %s] &quot;</span> format, ANSI_FG_BLUE) <span class="string">&quot;\n&quot;</span>, \</span></span><br><span class="line"><span class="meta">        __FILE__, __LINE__, __func__, ## __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Assert(cond, format, ...) \</span></span><br><span class="line"><span class="meta">  do &#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!(cond)) &#123; \</span></span><br><span class="line"><span class="meta">      MUXDEF(CONFIG_TARGET_AM, printf(ANSI_FMT(format, ANSI_FG_RED) <span class="string">&quot;\n&quot;</span>, ## __VA_ARGS__), \</span></span><br><span class="line"><span class="meta">        (fflush(stdout), fprintf(stderr, ANSI_FMT(format, ANSI_FG_RED) <span class="string">&quot;\n&quot;</span>, ##  __VA_ARGS__))); \</span></span><br><span class="line"><span class="meta">      IFNDEF(CONFIG_TARGET_AM, extern FILE* log_fp; fflush(log_fp)); \</span></span><br><span class="line"><span class="meta">      extern void assert_fail_msg(); \</span></span><br><span class="line"><span class="meta">      assert_fail_msg(); \</span></span><br><span class="line"><span class="meta">      assert(cond); \</span></span><br><span class="line"><span class="meta">    &#125; \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> panic(format, ...) Assert(0, format, ## __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TODO() panic(<span class="string">&quot;please implement me&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>由此可知panic通过Assert实现</li>
<li>推出要在<code>assert_fail_msg()</code>实现</li>
</ul>
<ol>
<li>新建<code>src/cpu/iringbuf.h</code>定义环形缓冲区的数据结构和接口</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> IRINGBUF_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRINGBUF_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRINGBUF_SIZE 16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">uint64_t</span> pc;</span><br><span class="line">  <span class="type">char</span> asm_code[<span class="number">128</span>];</span><br><span class="line">&#125; IRingBufEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  IRingBufEntry entries[IRINGBUF_SIZE];</span><br><span class="line">  <span class="type">int</span> head;</span><br><span class="line">  <span class="type">int</span> tail;</span><br><span class="line">  <span class="type">int</span> count;</span><br><span class="line">&#125; IRingBuf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> iringbuf_nowidx;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">record_inst</span><span class="params">(<span class="type">uint64_t</span> pc, <span class="type">const</span> <span class="type">char</span> *asm_code)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">display_iringbuf</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// IRINGBUF_H</span></span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>新建<code>src/cpu/iringbuf.c</code>，实现环形缓冲区的操作函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../include/common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../include/debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iringbuf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> IRingBuf iringbuf = &#123; .head = <span class="number">0</span>, .tail = <span class="number">0</span>, .count = <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> iringbuf_nowidx=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">record_inst</span><span class="params">(<span class="type">uint64_t</span> pc, <span class="type">const</span> <span class="type">char</span> *asm_code)</span> &#123;</span><br><span class="line">  IRingBufEntry *entry = &amp;iringbuf.entries[iringbuf.head];</span><br><span class="line">  entry-&gt;pc = pc;</span><br><span class="line">  <span class="built_in">strncpy</span>(entry-&gt;asm_code, asm_code, <span class="keyword">sizeof</span>(entry-&gt;asm_code) - <span class="number">1</span>);</span><br><span class="line">  entry-&gt;asm_code[<span class="keyword">sizeof</span>(entry-&gt;asm_code) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  iringbuf_nowidx = iringbuf.head;</span><br><span class="line"></span><br><span class="line">  iringbuf.head = (iringbuf.head + <span class="number">1</span>) % IRINGBUF_SIZE;</span><br><span class="line">  <span class="keyword">if</span> (iringbuf.count &lt; IRINGBUF_SIZE) &#123;</span><br><span class="line">    iringbuf.count++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    iringbuf.tail = (iringbuf.tail + <span class="number">1</span>) % IRINGBUF_SIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调试输出</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;record_inst: pc = 0x%016lx, count = %d, head = %d, tail = %d\n&quot;</span>, pc, iringbuf.count, iringbuf.head, iringbuf.tail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display_iringbuf</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Recent instructions:\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iringbuf.count; i++) &#123;</span><br><span class="line">    <span class="type">int</span> index = (iringbuf.tail + i) % IRINGBUF_SIZE;</span><br><span class="line">    IRingBufEntry *entry = &amp;iringbuf.entries[index];</span><br><span class="line">    <span class="keyword">if</span> (index == iringbuf_nowidx) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;--&gt; &quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;    &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%016lx: %s\n&quot;</span>, entry-&gt;pc, entry-&gt;asm_code);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在<code>src/cpu/cpu-exec.c</code>的<code>trace_and_difftest</code>函数中，将原本打印指令的位置更改为将指令记录到缓冲区：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">trace_and_difftest</span><span class="params">(Decode *_this, <span class="type">vaddr_t</span> dnpc)</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ITRACE_COND</span></span><br><span class="line">  <span class="keyword">if</span> (ITRACE_COND) &#123; log_write(<span class="string">&quot;%s\n&quot;</span>, _this-&gt;logbuf); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (g_print_step) &#123; </span><br><span class="line">    IFDEF(CONFIG_ITRACE, <span class="built_in">puts</span>(_this-&gt;logbuf)); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记录指令到环形缓冲区</span></span><br><span class="line">  record_inst(_this-&gt;pc, _this-&gt;logbuf);</span><br><span class="line">  IFDEF(CONFIG_DIFFTEST, difftest_step(_this-&gt;pc, dnpc));</span><br><span class="line">  IFDEF(CONFIG_WATCHPOINT, check_watchpoints());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在<code>src/cpu/cpu-exec.c</code>中,在<code>assert_fail_msg</code>函数中，调用<code>display_iringbuf()</code>来打印缓冲区中的指令信息。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">assert_fail_msg</span><span class="params">()</span> &#123;</span><br><span class="line">  isa_reg_display();</span><br><span class="line">  display_iringbuf();</span><br><span class="line">  statistic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>在<code>src/memory/paddr.c</code>中添加引用</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">out_of_bound</span><span class="params">(<span class="type">paddr_t</span> addr)</span> &#123;</span><br><span class="line">  panic(<span class="string">&quot;address = &quot;</span> FMT_PADDR <span class="string">&quot; is out of bound of pmem [&quot;</span> FMT_PADDR <span class="string">&quot;, &quot;</span> FMT_PADDR <span class="string">&quot;] at pc = &quot;</span> FMT_WORD,</span><br><span class="line">      addr, PMEM_LEFT, PMEM_RIGHT, cpu.pc);</span><br><span class="line">  assert_fail_msg();</span><br><span class="line">  assert(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>效果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Recent instructions:</span><br><span class="line">    0x0000000080000050: 0x80000050: 0d 00 00 ef jal	0xd0</span><br><span class="line">    0x0000000080000120: 0x80000120: fd 01 01 13 addi	sp, sp, -0x30</span><br><span class="line">    0x0000000080000124: 0x80000124: 00 81 24 23 sw	s0, 8(sp)</span><br><span class="line">    0x0000000080000128: 0x80000128: 00 11 26 23 sw	ra, 0xc(sp)</span><br><span class="line">    0x000000008000012c: 0x8000012c: 00 c1 2c 23 sw	a2, 0x18(sp)</span><br><span class="line">    0x0000000080000130: 0x80000130: 00 d1 2e 23 sw	a3, 0x1c(sp)</span><br><span class="line">    0x0000000080000134: 0x80000134: 02 e1 20 23 sw	a4, 0x20(sp)</span><br><span class="line">    0x0000000080000138: 0x80000138: 02 f1 22 23 sw	a5, 0x24(sp)</span><br><span class="line">    0x000000008000013c: 0x8000013c: 03 01 24 23 sw	a6, 0x28(sp)</span><br><span class="line">    0x0000000080000140: 0x80000140: 03 11 26 23 sw	a7, 0x2c(sp)</span><br><span class="line">    0x0000000080000144: 0x80000144: 00 00 04 17 auipc	s0, 0</span><br><span class="line">    0x0000000080000148: 0x80000148: 12 04 04 13 addi	s0, s0, 0x120</span><br><span class="line">    0x000000008000014c: 0x8000014c: 04 10 05 13 addi	a0, zero, 0x41</span><br><span class="line">    0x0000000080000150: 0x80000150: 00 14 04 13 addi	s0, s0, 1</span><br><span class="line">    0x0000000080000154: 0x80000154: f9 5f f0 ef jal	-0x6c</span><br><span class="line">--&gt; 0x00000000800000e8: 0x800000e8: a0 00 07 b7 lui	a5, 0xa0000</span><br></pre></td></tr></table></figure>
<h3 id="内存访问的踪迹-mtrace"><a href="#内存访问的踪迹-mtrace" class="headerlink" title="内存访问的踪迹 - mtrace"></a>内存访问的踪迹 - mtrace</h3><ul>
<li>可以很容易地对访存的结果进行追踪, 从而记录访存的踪迹(memory trace).</li>
</ul>
<h4 id="必做：实现mtrace"><a href="#必做：实现mtrace" class="headerlink" title="必做：实现mtrace"></a>必做：实现mtrace</h4><ul>
<li>这个功能非常简单, 你已经想好如何实现了: 只需要在<code>paddr_read()</code>和<code>paddr_write()</code>中进行记录即可. 你可以自行定义mtrace输出的格式.</li>
<li>不过和最后只输出一次的iringbuf不同, 程序一般会执行很多访存指令, 这意味着开启mtrace将会产生大量的输出, 因此<strong>最好可以在不需要的时候关闭mtrace</strong>. 噢, 那就参考一下itrace的相关实现吧: <strong>尝试在Kconfig和相关文件中添加相应的代码</strong>, 使得我们可以通过<strong>menuconfig</strong>来打开或者关闭mtrace. 另外也可以实现mtrace输出的条件, 例如你可能只会关心某一段内存区间的访问, 有了相关的条件控制功能, mtrace使用起来就更加灵活了.</li>
</ul>
<ol>
<li>更新<code>Kconfig</code>文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config MTRACE</span><br><span class="line">    bool &quot;Enable memory trace&quot;</span><br><span class="line">    default n</span><br><span class="line">    help</span><br><span class="line">      Enable memory trace to record memory access behavior.</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在<code>include/common.h</code>中添加 mtrace 宏定义</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MTRACE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MTRACE_COND (1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MTRACE_COND (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在<code>paddr.c</code>文件中实现<code>mtrace</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../include/common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">word_t</span> <span class="title function_">paddr_read</span><span class="params">(<span class="type">paddr_t</span> addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (MTRACE_COND) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MTRACE: Read from address 0x%08x, length %d\n&quot;</span>, addr, len);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (likely(in_pmem(addr))) <span class="keyword">return</span> pmem_read(addr, len);</span><br><span class="line">  IFDEF(CONFIG_DEVICE, <span class="keyword">return</span> mmio_read(addr, len));</span><br><span class="line">  out_of_bound(addr);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">paddr_write</span><span class="params">(<span class="type">paddr_t</span> addr, <span class="type">int</span> len, <span class="type">word_t</span> data)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (MTRACE_COND) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MTRACE: Write to address 0x%08x, length %d, data 0x%08x\n&quot;</span>, addr, len, data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (likely(in_pmem(addr))) &#123; pmem_write(addr, len, data); <span class="keyword">return</span>; &#125;</span><br><span class="line">  IFDEF(CONFIG_DEVICE, mmio_write(addr, len, data); <span class="keyword">return</span>);</span><br><span class="line">  out_of_bound(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><code>make menuconfig</code>,找到<code>Enable memory trace</code>选项,打开即启用</li>
</ol>
<ul>
<li>belike：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MTRACE: Read from address 0x80000000, length 4</span><br><span class="line">Executed instruction at pc = 0x80000000, next pc = 0x80000004</span><br><span class="line">MTRACE: Read from address 0x80000004, length 4</span><br><span class="line">Executed instruction at pc = 0x80000004, next pc = 0x80000008</span><br><span class="line">MTRACE: Read from address 0x80000008, length 4</span><br><span class="line">Executed instruction at pc = 0x80000008, next pc = 0x8000000c</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>实现mtrace输出的条件, 例如你可能只会关心某一段内存区间的访问;在<code>paddr.c</code>文件中实现:</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">in_mtrace_range</span><span class="params">(<span class="type">paddr_t</span> addr)</span> &#123;</span><br><span class="line">  <span class="comment">// 假设只关心某一段内存区间的访问，例如 [0x80000000, 0x8000ffff]</span></span><br><span class="line">  <span class="keyword">return</span> (addr &gt;= <span class="number">0x80000000</span> &amp;&amp; addr &lt;= <span class="number">0x8000ffff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">word_t</span> <span class="title function_">paddr_read</span><span class="params">(<span class="type">paddr_t</span> addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (MTRACE_COND &amp;&amp; in_mtrace_range(addr)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MTRACE: Read from address 0x%08x, length %d\n&quot;</span>, addr, len);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (likely(in_pmem(addr))) <span class="keyword">return</span> pmem_read(addr, len);</span><br><span class="line">  IFDEF(CONFIG_DEVICE, <span class="keyword">return</span> mmio_read(addr, len));</span><br><span class="line">  out_of_bound(addr);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">paddr_write</span><span class="params">(<span class="type">paddr_t</span> addr, <span class="type">int</span> len, <span class="type">word_t</span> data)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (MTRACE_COND &amp;&amp; in_mtrace_range(addr)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MTRACE: Write to address 0x%08x, length %d, data 0x%08x\n&quot;</span>, addr, len, data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (likely(in_pmem(addr))) &#123; pmem_write(addr, len, data); <span class="keyword">return</span>; &#125;</span><br><span class="line">  IFDEF(CONFIG_DEVICE, mmio_write(addr, len, data); <span class="keyword">return</span>);</span><br><span class="line">  out_of_bound(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数调用的踪迹-ftrace"><a href="#函数调用的踪迹-ftrace" class="headerlink" title="函数调用的踪迹 - ftrace"></a>函数调用的踪迹 - ftrace</h3><ul>
<li>要实现ftrace, 我们只需要关心<strong>函数调用</strong>和<strong>返回相关的指令</strong>就可以了.<ul>
<li>我们可以<strong>在函数调用指令中记录目标地址</strong>, 表示<strong>将要调用某个函数</strong>;</li>
<li>然后在<strong>函数返回指令中记录当前PC</strong>, 表示<strong>将要从PC所在的函数返回</strong>.</li>
<li>我们很容易在相关指令的实现中添加代码来实现这些功能. 但目标地址和PC值仍然缺少程序语义, 如果我们能把它们翻译成函数名, 就更容易理解了</li>
</ul>
</li>
<li>给定一个位于代码段的地址, 如何得知它位于哪一个函数<ul>
<li>这就需要<strong>ELF文件中符号表</strong>(symbol table)的帮助了. </li>
<li>符号表是可执行文件的一个section, 它记录了程序编译时刻的一些信息, 其中就包括变量和函数的信息. 为了实现ftrace, 我们首先需要了解符号表中都记录了哪些信息.</li>
</ul>
</li>
<li>以cpu-tests中add这个用户程序为例, 使用readelf命令查看ELF可执行文件的信息:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">riscv64-linux-gnu-readelf -a add-riscv32-nemu.elf</span><br></pre></td></tr></table></figure>
<ul>
<li>符号表<ul>
<li>Type属性为FUNC的表项</li>
<li>仔细观察Name属性之后, 你会发现这些表项正好对应了程序中定义的函数</li>
<li>相应的Value属性正好是它们的起始地址(你可以与反汇编结果进行对比)</li>
<li>而相应的Size属性则给出了函数的大小.</li>
</ul>
</li>
</ul>
<h4 id="思考：消失的符号"><a href="#思考：消失的符号" class="headerlink" title="思考：消失的符号"></a>思考：消失的符号</h4><ul>
<li>我们在<code>am-kernels/tests/cpu-tests/tests/add.c</code>中定义了宏NR_DATA, 同时也在add()函数中定义了局部变量c和形参a, b, 但你会发现在符号表中找不到和它们对应的表项, 为什么会这样? 思考一下, 什么才算是一个符号(symbol)?</li>
</ul>
<ol>
<li>符号表中记录的是全局变量、函数和其他具有名称和地址的实体。局部变量和宏定义不会出现在符号表中，因为它们的作用域和生命周期<em>局限于函数内部或预处理阶段</em>。</li>
<li>一个符号（Symbol）通常是指在编译和链接过程中具有名称和地址的实体。以下是一些常见的符号类型：<ul>
<li>全局变量（Global Variables）<ul>
<li>在程序的全局作用域中定义的变量。</li>
<li>这些变量在符号表中有对应的表项，记录了它们的名称、类型和地址。</li>
</ul>
</li>
<li>函数（Functions）<ul>
<li>在程序中定义的函数。</li>
<li>符号表中记录了函数的名称、类型（FUNC）和起始地址。</li>
</ul>
</li>
<li>常量（Constants）<ul>
<li>在程序中定义的具有名称的常量。</li>
<li>这些常量在符号表中有对应的表项。</li>
</ul>
</li>
<li>外部变量（External Variables）<ul>
<li>在一个文件中声明但在另一个文件中定义的变量。</li>
<li>符号表中记录了这些变量的名称和类型。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="思考：寻找”Hello-World-”"><a href="#思考：寻找”Hello-World-”" class="headerlink" title="思考：寻找”Hello World!”"></a>思考：寻找”Hello World!”</h4><ul>
<li>在Linux下编写一个Hello World程序, 编译后通过上述方法找到ELF文件的字符串表, 你发现”Hello World!”字符串在字符串表中的什么位置? 为什么会这样?</li>
</ul>
<ol>
<li>在编译后的ELF文件中，”Hello World!”字符串通常位于.rodata（只读数据段）或.data（数据段）中，而不是在字符串表（.strtab）中。字符串表主要用于存储符号名称和调试信息，而程序中的字符串常量则存储在数据段中。</li>
<li>原因：<ul>
<li>字符串表的用途：<ul>
<li>字符串表（.strtab）用于存储符号名称、调试信息等与程序执行无关的字符串。</li>
<li>它主要用于链接和调试阶段，而不是程序运行时的数据存储。</li>
</ul>
</li>
<li>字符串常量的存储：</li>
<li>程序中的字符串常量（如”Hello World!”）存储在数据段（如.rodata或.data）中。</li>
<li>这些段用于存储程序运行时需要访问的常量和变量。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="必做：实现ftrace"><a href="#必做：实现ftrace" class="headerlink" title="必做：实现ftrace"></a>必做：实现ftrace</h4><ul>
<li>根据上述内容, 在NEMU中实现ftrace. 你可以自行决定输出的格式. 你需要注意以下内容:<ul>
<li>你需要为NEMU传入一个ELF文件, 你可以通过在parse_args()中添加相关代码来实现这一功能</li>
<li>你可能需要在初始化ftrace时从ELF文件中读出符号表和字符串表, 供你后续使用</li>
<li>关于如何解析ELF文件, 可以参考man 5 elf</li>
<li>如果你选择的是riscv32, 你还需要考虑如何从jal和jalr指令中正确识别出函数调用指令和函数返回指令</li>
</ul>
</li>
<li>注意, 你不应该通过readelf等工具直接解析ELF文件. 在真实的项目中, 这个方案确实可以解决问题; 但作为一道学习性质的题目, 其目标是让你了解ELF文件的组织结构, 使得将来你在必要的时候(例如在裸机环境中)可以自己从中解析出所需的信息. 如果你通过readelf等工具直接解析ELF文件, 相当于自动放弃训练的机会, 与我们设置这道题目的目的背道而驰.</li>
</ul>
<ol>
<li>为NEMU传入一个ELF文件, 在<code>src/monitor/monitor.c</code>的<code>parse_args()</code>中添加:</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *elf_file = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">parse_args</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">table</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;batch&quot;</span>    , no_argument      , <span class="literal">NULL</span>, <span class="string">&#x27;b&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;log&quot;</span>      , required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;l&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;diff&quot;</span>     , required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;d&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;port&quot;</span>     , required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;p&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;help&quot;</span>     , no_argument      , <span class="literal">NULL</span>, <span class="string">&#x27;h&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;elf&quot;</span>      , required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;e&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>          , <span class="number">0</span>                , <span class="literal">NULL</span>,  <span class="number">0</span> &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="type">int</span> o;</span><br><span class="line">  <span class="keyword">while</span> ( (o = getopt_long(argc, argv, <span class="string">&quot;-bhl:d:p:e:&quot;</span>, table, <span class="literal">NULL</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (o) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: sdb_set_batch_mode(); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>: <span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%d&quot;</span>, &amp;difftest_port); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>: log_file = optarg; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>: elf_file = optarg; <span class="keyword">break</span>;  <span class="comment">// 解析ELF文件路径并解析ELF文件</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: diff_so_file = optarg; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: img_file = optarg; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s [OPTION...] IMAGE [args]\n\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t-b,--batch              run with batch mode\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t-l,--log=FILE           output log to FILE\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t-d,--diff=REF_SO        run DiffTest with reference REF_SO\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t-p,--port=PORT          run DiffTest with port PORT\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t-e,--elf=FILE           parse elf from FILE\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_monitor</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"> <span class="comment">/* 函数调用踪迹,ftrace. */</span></span><br><span class="line">	IFDEF(CONFIG_FTRACE, init_ftrace(elf_file));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>新建<code>nemu/src/cpu/elf_parser.c</code>和<code>nemu/src/cpu/elf_parser.h</code>,</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//nemu/src/cpu/elf_parser.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ELF_PARSER_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ELF_PARSER_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;elf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="type">paddr_t</span> addr;      <span class="comment">// the function head address</span></span><br><span class="line">    Elf32_Xword size;</span><br><span class="line">&#125;FuncSymbol;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_STACK_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> pc;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *func_name;</span><br><span class="line">&#125; CallStackEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> CallStackEntry call_stack[CALL_STACK_SIZE];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> call_stack_top ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> FuncSymbol *func_symbols;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> func_symbol_count;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">parse_elf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *elf_file)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// __ELF_PARSER_H__</span></span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在初始化ftrace时从ELF文件中读出符号表和字符串表, 供后续使用</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//nemu/src/cpu/elf_parser.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;elf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;elf_parser.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">FuncSymbol *func_symbols = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> func_symbol_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">parse_elf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *elf_file)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elf_file == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    FILE *fp = fopen(elf_file, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open ELF file&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 ELF 头</span></span><br><span class="line">    Elf32_Ehdr ehdr;</span><br><span class="line">    <span class="keyword">if</span> (fread(&amp;ehdr, <span class="keyword">sizeof</span>(Elf32_Ehdr), <span class="number">1</span>, fp) != <span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to read ELF header&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证文件是否是 ELF 格式</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(ehdr.e_ident, ELFMAG, SELFMAG) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Not a valid ELF file\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fseek(fp, ehdr.e_shoff, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    Elf32_Shdr shdr;</span><br><span class="line">    <span class="type">char</span> *string_table = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找字符串表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ehdr.e_shnum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fread(&amp;shdr, <span class="keyword">sizeof</span>(Elf32_Shdr), <span class="number">1</span>, fp) != <span class="number">1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;Failed to read section header&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shdr.sh_type == SHT_STRTAB) &#123;</span><br><span class="line">            <span class="comment">// 获取字符串表</span></span><br><span class="line">            string_table = <span class="built_in">malloc</span>(shdr.sh_size);</span><br><span class="line">            fseek(fp, shdr.sh_offset, SEEK_SET);</span><br><span class="line">            <span class="keyword">if</span> (fread(string_table, shdr.sh_size, <span class="number">1</span>, fp) != <span class="number">1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;Failed to read string table&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找符号表</span></span><br><span class="line">    fseek(fp, ehdr.e_shoff, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ehdr.e_shnum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fread(&amp;shdr, <span class="keyword">sizeof</span>(Elf32_Shdr), <span class="number">1</span>, fp) != <span class="number">1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;Failed to read section header&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shdr.sh_type == SHT_SYMTAB) &#123;</span><br><span class="line">            fseek(fp, shdr.sh_offset, SEEK_SET);</span><br><span class="line"></span><br><span class="line">            Elf32_Sym sym;</span><br><span class="line">            <span class="type">size_t</span> sym_count = shdr.sh_size / shdr.sh_entsize;</span><br><span class="line">            func_symbols = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(FuncSymbol) * sym_count);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; sym_count; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fread(&amp;sym, <span class="keyword">sizeof</span>(Elf32_Sym), <span class="number">1</span>, fp) != <span class="number">1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;Failed to read symbol table&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ELF32_ST_TYPE(sym.st_info) == STT_FUNC) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="type">char</span> *name = string_table + sym.st_name;</span><br><span class="line">                    <span class="built_in">strncpy</span>(func_symbols[func_symbol_count].name, name, <span class="keyword">sizeof</span>(func_symbols[func_symbol_count].name) - <span class="number">1</span>);</span><br><span class="line">                    func_symbols[func_symbol_count].name[<span class="keyword">sizeof</span>(func_symbols[func_symbol_count].name) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 确保字符串以 null 结尾</span></span><br><span class="line">                    func_symbols[func_symbol_count].addr = sym.st_value;</span><br><span class="line">                    func_symbols[func_symbol_count].size = sym.st_size;</span><br><span class="line">                    func_symbol_count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">free</span>(string_table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在<code>abstract-machine/scripts/platform/nemu.mk</code>中添加</li>
</ol>
<ul>
<li><code>NEMUFLAGS += -e $(IMAGE).elf</code></li>
</ul>
<ol start="5">
<li>在<code>nemu/src/cpu/cpu-exec.c</code>中：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> FuncSymbol *func_symbols;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> func_symbol_count;</span><br><span class="line"></span><br><span class="line">CallStackEntry call_stack[CALL_STACK_SIZE];</span><br><span class="line"><span class="type">int</span> call_stack_top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title function_">find_func_name</span><span class="params">(<span class="type">paddr_t</span> addr)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; func_symbol_count; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (func_symbols[i].addr &lt;= addr &amp;&amp; addr &lt; func_symbols[i].addr + func_symbols[i].size) &#123;</span><br><span class="line">      <span class="keyword">return</span> func_symbols[i].name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;???&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">trace_and_difftest</span><span class="params">(Decode *_this, <span class="type">vaddr_t</span> dnpc)</span> &#123;</span><br><span class="line"><span class="comment">//其它</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 记录函数调用和返回</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *func_name = find_func_name(_this-&gt;pc);</span><br><span class="line">  <span class="keyword">if</span> (func_name) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FTRACE: Call %s at 0x%08x\n&quot;</span>, func_name, _this-&gt;pc);</span><br><span class="line">  &#125;</span><br><span class="line">  func_name = find_func_name(dnpc);</span><br><span class="line">  <span class="keyword">if</span> (func_name) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FTRACE: Return from %s to 0x%08x\n&quot;</span>, func_name, dnpc);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//其它</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">exec_once</span><span class="params">(Decode *s, <span class="type">vaddr_t</span> pc)</span> &#123;</span><br><span class="line">  s-&gt;pc = pc;</span><br><span class="line">  s-&gt;snpc = pc;</span><br><span class="line">  isa_exec_once(s);</span><br><span class="line">  cpu.pc = s-&gt;dnpc;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 识别函数调用和返回指令</span></span><br><span class="line">  <span class="type">uint32_t</span> inst = s-&gt;isa.inst.val;</span><br><span class="line">  <span class="keyword">if</span> ((inst &amp; <span class="number">0x7f</span>) == <span class="number">0x6f</span>) &#123; <span class="comment">// JAL</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *func_name = find_func_name(s-&gt;dnpc);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(func_name, <span class="string">&quot;???&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;FTRACE: Call %s at 0x%08x\n&quot;</span>, func_name, s-&gt;dnpc);</span><br><span class="line">      <span class="keyword">if</span> (call_stack_top &lt; CALL_STACK_SIZE) &#123;</span><br><span class="line">        call_stack[call_stack_top].pc = s-&gt;dnpc;</span><br><span class="line">        call_stack[call_stack_top].func_name = func_name;</span><br><span class="line">        call_stack_top++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((inst &amp; <span class="number">0x7f</span>) == <span class="number">0x67</span>) &#123; <span class="comment">// JALR</span></span><br><span class="line">    <span class="keyword">if</span> (((inst &gt;&gt; <span class="number">7</span>) &amp; <span class="number">0x1f</span>) == <span class="number">1</span>) &#123; <span class="comment">// rd == ra</span></span><br><span class="line">      <span class="type">const</span> <span class="type">char</span> *func_name = find_func_name(s-&gt;dnpc);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(func_name, <span class="string">&quot;???&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;FTRACE: Return from %s to 0x%08x\n&quot;</span>, func_name, s-&gt;dnpc);</span><br><span class="line">        <span class="keyword">if</span> (call_stack_top &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          call_stack_top--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Executed instruction at pc = 0x%08x, next pc = 0x%08x\n&quot;</span>, s-&gt;pc, s-&gt;dnpc);</span><br><span class="line"><span class="comment">//其它</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">assert_fail_msg</span><span class="params">()</span> &#123;</span><br><span class="line">  isa_reg_display();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 输出当前函数调用信息</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Current function call information:\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; call_stack_top; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%08x: call [%s@0x%08x]\n&quot;</span>, call_stack[i].pc, call_stack[i].func_name, call_stack[i].pc);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *func_name = find_func_name(cpu.pc);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(func_name, <span class="string">&quot;???&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FTRACE: Current function %s at 0x%08x\n&quot;</span>, func_name, cpu.pc);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FTRACE: No function found at 0x%08x\n&quot;</span>, cpu.pc);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  display_iringbuf();</span><br><span class="line">  statistic();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>一直没有解析ELF，调试后发现:在当前的代码实现中，只有在命令行参数中提供 -e 选项时，才会解析 ELF 文件。要实现不提供 -e 选项时自动解析 ELF 文件，可以在<code>nemu/src/monitor/monitor.c</code>的<code>init_monitor</code> 函数中添加一个默认的 ELF 文件路径，并在没有提供 -e 选项时使用这个默认路径。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 函数调用踪迹,ftrace. */</span></span><br><span class="line">  <span class="keyword">if</span> (elf_file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    elf_file = <span class="string">&quot;default.elf&quot;</span>;  <span class="comment">// 设置默认的ELF文件路径</span></span><br><span class="line">  &#125;</span><br><span class="line">  init_ftrace(elf_file);</span><br></pre></td></tr></table></figure>
<ul>
<li>删掉<code>elf_file = &quot;default.elf&quot;;</code>，不自动启动，需要在命令行提供-e和elf文件</li>
</ul>
<ol start="7">
<li>成功！类似：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Executed instruction at pc = 0x800002c4, next pc = 0x800000cc</span><br><span class="line">FTRACE: Call strcmp at 0x800002c4</span><br><span class="line">FTRACE: Return from main to 0x800000cc</span><br><span class="line">Executed instruction at pc = 0x800000cc, next pc = 0x800000d0</span><br><span class="line">FTRACE: Call main at 0x800000cc</span><br><span class="line">FTRACE: Return from main to 0x800000d0</span><br><span class="line">FTRACE: Call check at 0x80000010</span><br><span class="line">Executed instruction at pc = 0x800000d0, next pc = 0x80000010</span><br><span class="line">FTRACE: Call main at 0x800000d0</span><br><span class="line">FTRACE: Return from check to 0x80000010</span><br><span class="line">Executed instruction at pc = 0x80000010, next pc = 0x80000014</span><br><span class="line">FTRACE: Call check at 0x80000010</span><br><span class="line">FTRACE: Return from check to 0x80000014</span><br></pre></td></tr></table></figure>
<ul>
<li>但是有点丑，<ul>
<li>把<code>printf(&quot;Executed instruction at pc = 0x%08x, next pc = 0x%08x\n&quot;, s-&gt;pc, s-&gt;dnpc);</code>注释后，片段如下：</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FTRACE: Call main at 0x800000dc</span><br><span class="line">FTRACE: Return from main to 0x800000e0</span><br><span class="line">FTRACE: Call main at 0x800000e0</span><br><span class="line">FTRACE: Return from main to 0x800000e4</span><br><span class="line">FTRACE: Call main at 0x800000e4</span><br><span class="line">FTRACE: Return from _trm_init to 0x80000108</span><br><span class="line">FTRACE: Call _trm_init at 0x80000108</span><br><span class="line">FTRACE: Return from _trm_init to 0x8000010c</span><br><span class="line">FTRACE: Call _trm_init at 0x8000010c</span><br><span class="line">FTRACE: Return from _trm_init to 0x80000110</span><br></pre></td></tr></table></figure>
<h4 id="思考：不匹配的函数调用和返回"><a href="#思考：不匹配的函数调用和返回" class="headerlink" title="思考：不匹配的函数调用和返回"></a>思考：不匹配的函数调用和返回</h4><ul>
<li>如果你仔细观察上文recursion的示例输出, 你会发现一些有趣的现象. 具体地, 注释(1)处的ret的函数是和对应的call匹配的, 也就是说, call调用了f2, 而与之对应的ret也是从f2返回; 但注释(2)所指示的一组call和ret的情况却有所不同, call调用了f1, 但却从f0返回; 注释(3)所指示的一组call和ret也出现了类似的现象, call调用了f1, 但却从f3返回.</li>
<li>尝试结合反汇编结果, 分析为什么会出现这一现象.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x8000000c: call [_trm_init@0x80000260]</span><br><span class="line">0x80000270:   call [main@0x800001d4]</span><br><span class="line">0x800001f8:     call [f0@0x80000010]</span><br><span class="line">0x8000016c:       call [f2@0x800000a4]</span><br><span class="line">0x800000e8:         call [f1@0x8000005c]</span><br><span class="line">0x8000016c:           call [f2@0x800000a4]</span><br><span class="line">0x800000e8:             call [f1@0x8000005c]</span><br><span class="line">0x8000016c:               call [f2@0x800000a4]</span><br><span class="line">0x800000e8:                 call [f1@0x8000005c]</span><br><span class="line">0x8000016c:                   call [f2@0x800000a4]</span><br><span class="line">0x800000e8:                     call [f1@0x8000005c]</span><br><span class="line">0x8000016c:                       call [f2@0x800000a4]</span><br><span class="line">0x800000e8:                         call [f1@0x8000005c]</span><br><span class="line">0x80000058:                         ret  [f0]              # 注释(2)</span><br><span class="line">0x800000fc:                       ret  [f2]                # 注释(1)</span><br><span class="line">0x80000180:                       call [f2@0x800000a4]</span><br><span class="line">0x800000e8:                         call [f1@0x8000005c]</span><br><span class="line">0x80000058:                         ret  [f0]</span><br><span class="line">0x800000fc:                       ret  [f2]</span><br><span class="line">0x800001b0:                     ret  [f3]                  # 注释(3)</span><br><span class="line">0x800000fc:                   ret  [f2]</span><br><span class="line">0x80000180:                   call [f2@0x800000a4]</span><br><span class="line">0x800000e8:                     call [f1@0x8000005c]</span><br><span class="line">0x8000016c:                       call [f2@0x800000a4]</span><br><span class="line">0x800000e8:                         call [f1@0x8000005c]</span><br><span class="line">0x80000058:                         ret  [f0]</span><br></pre></td></tr></table></figure>
<ol>
<li>现象描述</li>
<li>注释(1)<br>- call [f2@0x800000a4]<br>- ret [f2]<br>- 这是正常的函数调用和返回，call调用了f2，并从f2返回。</li>
<li>注释(2)<br>- call [f1@0x8000005c]<br>- ret [f0]<br>- 这里出现了不匹配的现象，call调用了f1，但却从f0返回。</li>
<li>注释(3)<br>- call [f1@0x8000005c]<br>- ret [f3]<br>- 这里也出现了不匹配的现象，call调用了f1，但却从f3返回。</li>
<li>可能的原因</li>
</ol>
<ul>
<li>这种不匹配的现象通常是由于函数调用过程中存在间接调用或尾调用优化（Tail Call Optimization, TCO）导致的。以下是两种可能的原因：</li>
</ul>
<ol>
<li>间接调用<br>- 在函数f1内部，可能存在对其他函数（如f0或f3）的间接调用。<br>- 这种情况下，f1在执行过程中调用了f0或f3，并直接从这些函数返回，而不是从f1返回。</li>
<li>尾调用优化<br>- 尾调用优化是一种编译器优化技术，当一个函数的最后一个操作是调用另一个函数时，编译器可以优化为直接跳转到被调用函数，而不需要返回到调用者。<br>- 这种优化可以减少栈帧的开销，提高程序的执行效率。<br>- 在这种情况下，f1的最后一个操作是调用f0或f3，编译器优化为直接跳转到f0或f3，并从这些函数返回。</li>
</ol>
<h4 id="思考：冗余的符号表"><a href="#思考：冗余的符号表" class="headerlink" title="思考：冗余的符号表"></a>思考：冗余的符号表</h4><ol>
<li>在Linux下编写一个Hello World程序, 然后使用strip命令丢弃可执行文件中的符号表:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br><span class="line">strip -s hello</span><br></pre></td></tr></table></figure>
<ul>
<li>用readelf查看hello的信息, 你会发现符号表被丢弃了, 此时的hello程序能成功运行吗?</li>
</ul>
<ol start="2">
<li>目标文件中也有符号表, 我们同样可以丢弃它:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -c hello.c</span><br><span class="line">strip -s hello.o</span><br></pre></td></tr></table></figure>
<ul>
<li>用readelf查看hello.o的信息, 你会发现符号表被丢弃了. 尝试对hello.o进行链接:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -o hello hello.o</span><br></pre></td></tr></table></figure>
<ul>
<li>你发现了什么问题? 尝试对比上述两种情况, 并分析其中的原因.</li>
</ul>
<ol>
<li>Hello World程序: 即使符号表被丢弃，hello程序仍然能够成功运行。</li>
</ol>
<ul>
<li>因为可执行文件中的符号表主要用于调试和链接阶段，而不是程序运行时所需的内容。</li>
<li>程序运行时所需的所有信息（如代码和数据）已经被嵌入到可执行文件中，因此丢弃符号表不会影响程序的运行。</li>
</ul>
<ol start="2">
<li>目标文件中的符号表: 在尝试链接时，发现链接失败，出现错误信息：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/ld: hello.o: in function `main&#x27;:</span><br><span class="line">(.text+0x1b): undefined reference to `printf&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
<ul>
<li>目标文件中的符号表用于链接阶段，记录了函数和变量的名称、类型和地址等信息。</li>
<li>链接器需要这些符号信息来解析外部引用和生成最终的可执行文件。</li>
<li>如果目标文件中的符号表被丢弃，链接器将无法解析外部引用（如printf函数），导致链接失败。</li>
</ul>
<h2 id="AM作为基础设施"><a href="#AM作为基础设施" class="headerlink" title="AM作为基础设施"></a>AM作为基础设施</h2><ul>
<li>AM的核心思想了: 通过一组抽象的API把程序和架构解耦<ul>
<li>保证了运行在AM之上的代码(包括klib)都是架构无关的, 这恰恰增加了代码的可移植性.</li>
</ul>
</li>
</ul>
<ol>
<li><code>abstract-machine</code>中有一个特殊的架构叫<code>native</code>, 是用GNU&#x2F;Linux默认的运行时环境来实现的AM API. </li>
<li>在<code>abstract-machine</code>中, 我们可以很容易地把程序编译到另一个架构上运行, 例如在<code>am-kernels/tests/cpu-tests/</code>目录下执行</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make ALL=string ARCH=native run</span><br></pre></td></tr></table></figure>
<ul>
<li>即可将string程序编译到native并运行. 由于我们会将程序编译到不同的架构中, 因此你需要注意make命令中的ARCH参数.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exit code = 00h</span><br><span class="line">test list [1 item(s)]: string</span><br><span class="line">[        string] PASS</span><br></pre></td></tr></table></figure>
<ul>
<li>如果string程序没有通过测试, 终端将会输出</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make[1]: *** [run] Error 1</span><br></pre></td></tr></table></figure>
<ul>
<li>当然也有可能输出段错误等信息.</li>
</ul>
<h4 id="思考：奇怪的错误码"><a href="#思考：奇怪的错误码" class="headerlink" title="思考：奇怪的错误码"></a>思考：奇怪的错误码</h4><ul>
<li>为什么错误码是1呢? 你知道make程序是如何得到这个错误码的吗?</li>
</ul>
<ol>
<li>错误码1的含义：</li>
</ol>
<ul>
<li>在Unix和Linux系统中，程序的退出状态码（exit code）是一个整数值，用于表示程序的执行结果。</li>
<li>通常，0表示成功，非0表示失败。</li>
<li>错误码1通常表示一般性错误（general error），即程序执行过程中发生了某种错误，但没有具体的错误类型。</li>
</ul>
<ol start="2">
<li>make得到错误码的过程：</li>
</ol>
<ul>
<li>make程序通过执行命令并检查其退出状态码来确定命令是否成功。如果命令返回非0的退出状态码，make会认为该命令失败，并输出相应的错误信息</li>
</ul>
<hr>
<ul>
<li>框架代码编译到native的时候默认链接到<code>glibc</code>, 我们需要把这些库函数的调用链接到我们编写的<code>klib</code>来进行测试. <ul>
<li>我们可以通过在<code>abstract-machine/klib/include/klib.h</code> 中通过<strong>定义宏</strong><code>__NATIVE_USE_KLIB__</code>来把库函数链接到klib. </li>
<li>如果不定义这个宏, 库函数将会链接到glibc,** 可以作为正确的参考实现来进行对比**.</li>
</ul>
</li>
</ul>
<h4 id="思考：这是如何实现的"><a href="#思考：这是如何实现的" class="headerlink" title="思考：这是如何实现的?"></a>思考：这是如何实现的?</h4><ul>
<li>为什么定义宏__NATIVE_USE_KLIB__之后就可以把native上的这些库函数链接到klib? 这具体是如何发生的? 尝试根据你在课堂上学习的链接相关的知识解释这一现象.</li>
<li>当定义了宏__NATIVE_USE_KLIB__时，编译器会包含klib_impl.h，从而使用我们自己实现的klib库函数；否则，编译器会包含标准库的头文件，使用glibc的实现。</li>
<li>具体过程：<ol>
<li>定义宏：在编译时定义宏__NATIVE_USE_KLIB__。</li>
<li>条件编译：编译器根据宏__NATIVE_USE_KLIB__选择性地包含klib_impl.h，从而使用我们自己实现的klib库函数。</li>
<li>链接过程：链接器在链接过程中将printf函数链接到klib_impl.c中实现的printf函数，而不是标准库中的printf函数。</li>
</ol>
</li>
</ul>
<h2 id="测试你的klib"><a href="#测试你的klib" class="headerlink" title="测试你的klib"></a>测试你的klib</h2><ul>
<li>需要编写一些充分的测试用例来专门对klib的实现进行测试.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----&gt; 测试对象 ----&gt; 实际输出</span><br><span class="line"> |                        |</span><br><span class="line">输入                      +----&gt; 一致?</span><br><span class="line"> |                        |</span><br><span class="line"> +----&gt; 某种方法 ----&gt; 预期输出</span><br></pre></td></tr></table></figure>
<h4 id="选做：编写更多的测试"><a href="#选做：编写更多的测试" class="headerlink" title="选做：编写更多的测试"></a>选做：编写更多的测试</h4><ul>
<li>尝试理解上述测试代码是如何进行测试的, 并在<code>am-kernels/tests/</code>目录下新增一个针对<code>klib</code>的测试集<code>klib-tests</code>, 测试集的文件结构可以参考<code>am-kernels/tests/am-tests</code>或<code>am-kernels/kernels/hello</code>.</li>
<li>然后针对上文所述的第一类写入函数编写相应的测试代码. 编写测试的时候需要注意一些地方:<ul>
<li><code>memcpy()</code>的行为在区间重叠的时候是UB, 你可以在遍历的时候检查区间是否重叠, 若是, 则跳过此次检查; 或者使用另一个相同的数组来作为src, 这样就不会出现重叠的情况</li>
<li>字符串处理函数需要额外注意\0和缓冲区溢出的问题</li>
</ul>
</li>
<li>编写后, 你可以先在native上用glibc的库函数来测试你编写的测试代码, 然后在native上用这些测试代码来测试你的klib实现, 最后再在NEMU上运行这些测试代码来测试你的NEMU实现.</li>
</ul>
<ol>
<li>创建目录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">am-kernels/tests/klib-tests/</span><br><span class="line">├── include/</span><br><span class="line">│   └── klib.h</span><br><span class="line">├── src/</span><br><span class="line">│   └── test_memset.c</span><br><span class="line">├── Makefile</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在<code>klib.h</code>中包含需要测试的函数声明</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KLIB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KLIB_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *s, <span class="type">int</span> c, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// KLIB_H</span></span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在<code>src/test_type1.c</code>中编写测试代码</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;klib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> data[N];</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> src[N];</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> str_data[N];</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> src_str[N] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置数据数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reset</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        data[i] = i + <span class="number">1</span>;</span><br><span class="line">        src[i] = i + <span class="number">101</span>;</span><br><span class="line">        str_data[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查[l,r)区间中的值是否依次为val, val + 1, val + 2...</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_seq</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt; r; i++) &#123;</span><br><span class="line">        assert(data[i] == val + i - l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查[l,r)区间中的值是否均为val</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_eq</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt; r; i++) &#123;</span><br><span class="line">        assert(data[i] == val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 memset 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_memset</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="keyword">for</span> (l = <span class="number">0</span>; l &lt; N; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (r = l + <span class="number">1</span>; r &lt;= N; r++) &#123;</span><br><span class="line">            reset();</span><br><span class="line">            <span class="type">uint8_t</span> val = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">memset</span>(data + l, val, r - l);</span><br><span class="line">            check_seq(<span class="number">0</span>, l, <span class="number">1</span>);</span><br><span class="line">            check_eq(l, r, val);</span><br><span class="line">            check_seq(r, N, r + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test_memset passed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 memcpy 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_memcpy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="keyword">for</span> (l = <span class="number">0</span>; l &lt; N; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (r = l + <span class="number">1</span>; r &lt;= N; r++) &#123;</span><br><span class="line">            reset();</span><br><span class="line">            <span class="built_in">memcpy</span>(data + l, src + l, r - l);</span><br><span class="line">            check_seq(<span class="number">0</span>, l, <span class="number">1</span>);</span><br><span class="line">            check_seq(l, r, <span class="number">101</span> + l);</span><br><span class="line">            check_seq(r, N, r + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test_memcpy passed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 strcpy 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_strcpy</span><span class="params">()</span> &#123;</span><br><span class="line">    reset();</span><br><span class="line">    <span class="built_in">strcpy</span>(str_data, src_str);</span><br><span class="line">    assert(<span class="built_in">strcmp</span>(str_data, src_str) == <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test_strcpy passed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    test_memset();</span><br><span class="line">    test_memcpy();</span><br><span class="line">    test_strcpy();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在<code>Makefile</code>中添加编译和运行测试的规则</li>
</ol>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">ARCH ?= native</span><br><span class="line">CFLAGS := -I<span class="variable">$(PWD)</span>/<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: test_type1</span></span><br><span class="line"></span><br><span class="line"><span class="section">test_type1: src/test_type1.c</span></span><br><span class="line">  <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">run: test_type1</span></span><br><span class="line">	./test_type1</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f test_type1</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>在<code>am-kernels/tests/klib-tests</code>下<code>make</code>,</li>
</ol>
<ul>
<li>报错<code>make Makefile:7: *** 缺失分隔符。 停止。</code></li>
<li>改了设置的：使用Tab键时插入空格”为用缩进！</li>
<li>编译成功得到</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cc -I/home/xiaoyao/ics2024/am-kernels/tests/klib-tests/include -o test_type1 src/test_type1.c</span><br></pre></td></tr></table></figure>
<ol start="6">
<li><code>make run</code>,成功则得到：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./test_type1</span><br><span class="line">test_memset passed.</span><br><span class="line">test_memcpy passed.</span><br><span class="line">test_strcpy passed.</span><br></pre></td></tr></table></figure>
<h4 id="选做：编写更多的测试-2"><a href="#选做：编写更多的测试-2" class="headerlink" title="选做：编写更多的测试(2)"></a>选做：编写更多的测试(2)</h4><ul>
<li>尝试为klib-tests添加针对<strong>第二类只读函数</strong>的测试, 例如<code>memcmp()</code>, <code>strlen()</code>等. 思考一下, 应该如何得到函数的预期输出?</li>
</ul>
<ol>
<li><code>tests/klib-tests/src/test_type2.c</code>:</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/klib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> data[N];</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> str_data[N] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> str_data2[N] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> str_data3[N] = <span class="string">&quot;Hello, Klib!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置数据数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reset</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        data[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 memcmp 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_memcmp</span><span class="params">()</span> &#123;</span><br><span class="line">    reset();</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(data, data, N) == <span class="number">0</span>);</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(data, data + <span class="number">1</span>, N - <span class="number">1</span>) &lt; <span class="number">0</span>);</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(data + <span class="number">1</span>, data, N - <span class="number">1</span>) &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test_memcmp passed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 strlen 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_strlen</span><span class="params">()</span> &#123;</span><br><span class="line">    assert(<span class="built_in">strlen</span>(str_data) == <span class="number">13</span>);</span><br><span class="line">    assert(<span class="built_in">strlen</span>(str_data2) == <span class="number">13</span>);</span><br><span class="line">    assert(<span class="built_in">strlen</span>(str_data3) == <span class="number">12</span>);<span class="comment">//字符串&quot;Hello, Klib!&quot;的实际长度是 12，因为它包含了一个终止字符\0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test_strlen passed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    test_memcmp();</span><br><span class="line">    test_strlen();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>klib.h</code>增加：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *s1, <span class="type">const</span> <span class="type">void</span> *s2, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>Makefile</code>补充为:</li>
</ol>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">ARCH ?= native</span><br><span class="line">CFLAGS := -I<span class="variable">$(PWD)</span>/<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: test_type1 test_type2</span></span><br><span class="line"></span><br><span class="line"><span class="section">test_type1: src/test_type1.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">test_type2: src/test_type2.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">run: test_type1 test_type2</span></span><br><span class="line">    ./test_type1</span><br><span class="line">    ./test_type2</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f test_type1 test_type2</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><code>make</code>一下,然后<code>make run</code>：(成功！)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/test_type2.c</span><br><span class="line">./test_type1</span><br><span class="line">test_memset passed.</span><br><span class="line">test_memcpy passed.</span><br><span class="line">test_strcpy passed.</span><br><span class="line">./test_type2</span><br><span class="line">test_memcmp passed.</span><br><span class="line">test_strlen passed.</span><br></pre></td></tr></table></figure>
<h4 id="选做：编写更多的测试-3"><a href="#选做：编写更多的测试-3" class="headerlink" title="选做：编写更多的测试(3)"></a>选做：编写更多的测试(3)</h4><ul>
<li>尝试为klib-tests添加针对<strong>格式化输出函数</strong>的测试. 你可以先通过<code>sprintf()</code>把实际输出打印到一个缓冲区中, 然后通过<code>strcmp()</code>来和预期输出进行对比.</li>
<li>你也可以考虑实现位宽, 精度, 长度修饰符等功能, 然后生成相应的测试用例来进行测试.</li>
<li>以<code>%d</code>为例, 我们需要构造一些输入. 但整数的范围太大了, 不能全部遍历它们, 因此我们需要挑选一些有代表性的整数.<code>limits.h</code>这个C标准头文件里面包含了一些最大数和最小数的定义, 你可以打开<code>/usr/include/limits.h</code>来阅读它们. 一些有代表性的整数可以是:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int data[] = &#123;0, INT_MAX / 17, INT_MAX, INT_MIN, INT_MIN + 1,</span><br><span class="line">              UINT_MAX / 17, INT_MAX / 17, UINT_MAX&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>为了得到相应的预期输出, 我们可以先编写一个<code>native</code>程序来用<code>printf</code>输出它们, 然后把输出结果整理到测试代码里面. <code>cpu-tests</code>中的预期输出也是这样生成的.</li>
</ul>
<h5 id="先编写一个native程序来用printf输出它们"><a href="#先编写一个native程序来用printf输出它们" class="headerlink" title="先编写一个native程序来用printf输出它们"></a>先编写一个native程序来用printf输出它们</h5><ol>
<li>在<code>klib-tests</code>目录下创建一个新的文件<code>generate_expected_output.c</code>：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> data[] = &#123;<span class="number">0</span>, INT_MAX / <span class="number">17</span>, INT_MAX, INT_MIN, INT_MIN + <span class="number">1</span>,</span><br><span class="line">                  UINT_MAX / <span class="number">17</span>, INT_MAX / <span class="number">17</span>, UINT_MAX&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(data) / <span class="keyword">sizeof</span>(data[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>编译<code>generate_expected_output.c</code>:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /path/to/am-kernels/tests/klib-tests</span><br><span class="line">gcc -o generate_expected_output generate_expected_output.c</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>运行生成的可执行文件&#96;:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./generate_expected_output</span><br></pre></td></tr></table></figure>
<ul>
<li>输出结果为：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">126322567</span><br><span class="line">2147483647</span><br><span class="line">-2147483648</span><br><span class="line">-2147483647</span><br><span class="line">252645135</span><br><span class="line">126322567</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<h5 id="把输出结果整理到测试代码里面，编写nemu的测试"><a href="#把输出结果整理到测试代码里面，编写nemu的测试" class="headerlink" title="把输出结果整理到测试代码里面，编写nemu的测试"></a>把输出结果整理到测试代码里面，编写nemu的测试</h5><ol>
<li><code>src/test_type3.c</code>中编写测试代码：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/klib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_sprintf</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> data[] = &#123;<span class="number">0</span>, INT_MAX / <span class="number">17</span>, INT_MAX, INT_MIN, INT_MIN + <span class="number">1</span>,</span><br><span class="line">                  UINT_MAX / <span class="number">17</span>, INT_MAX / <span class="number">17</span>, UINT_MAX&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *expected[] = &#123;</span><br><span class="line">        <span class="string">&quot;0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;126322567&quot;</span>,</span><br><span class="line">        <span class="string">&quot;2147483647&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-2147483648&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-2147483647&quot;</span>,</span><br><span class="line">        <span class="string">&quot;252645135&quot;</span>,</span><br><span class="line">        <span class="string">&quot;126322567&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-1&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(data) / <span class="keyword">sizeof</span>(data[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%d&quot;</span>, data[i]);</span><br><span class="line">        assert(<span class="built_in">strcmp</span>(buffer, expected[i]) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test_sprintf passed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    test_sprintf();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>klib.h</code>补充函数声明：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>Makefile中添加编译和运行<code>test_type3.c</code>的规则：</li>
</ol>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: test_type1 test_type2 test_type3</span></span><br><span class="line"></span><br><span class="line"><span class="section">test_type3: src/test_type3.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">run: test_type1 test_type2</span></span><br><span class="line">	./test_type1</span><br><span class="line">	./test_type2</span><br><span class="line">	./test_type3</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f test_type1 test_type2 test_type3</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><code>make</code>和<code>make run</code>:(成功！！)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./test_type3</span><br><span class="line">Expected: 0, Got: 0</span><br><span class="line">Expected: 126322567, Got: 126322567</span><br><span class="line">Expected: 2147483647, Got: 2147483647</span><br><span class="line">Expected: -2147483648, Got: -2147483648</span><br><span class="line">Expected: -2147483647, Got: -2147483647</span><br><span class="line">Expected: 252645135, Got: 252645135</span><br><span class="line">Expected: 126322567, Got: 126322567</span><br><span class="line">Expected: -1, Got: -1</span><br><span class="line">test_sprintf passed.</span><br></pre></td></tr></table></figure>
<h2 id="Differential-Testing——强大的测试工具！"><a href="#Differential-Testing——强大的测试工具！" class="headerlink" title="Differential Testing——强大的测试工具！"></a>Differential Testing——强大的测试工具！</h2><ul>
<li>如果有一种方法能够表达指令的正确行为, 我们就可以基于这种方法来进行类似<code>assert()</code>的检查了——ISA手册。<ul>
<li>如果有一个ISA手册的参考实现就好了——我们用的<strong>真机</strong>。</li>
<li>我们让在NEMU中执行的每条指令也在真机中执行一次, 然后对比NEMU和真机的状态, 如果NEMU和真机的状态不一致, 我们就捕捉到error了</li>
</ul>
</li>
<li>这种方法在软件测试领域称为<strong>differential testing</strong>(后续简称<strong>DiffTest</strong>).<ul>
<li>进行DiffTest需要提供一个和<strong>DUT</strong>(Design Under Test, 测试对象) <strong>功能相同但实现方式不同</strong>的<strong>REF</strong>(Reference, 参考实现)</li>
<li>然后让它们接受<strong>相同的有定义的输入</strong>, 观测它们的<strong>行为是否相同</strong>.</li>
</ul>
</li>
<li>遗憾：真机上是运行了操作系统GNU&#x2F;Linux的, 我们无法在native中运行编译到<code>x86-nemu</code>的AM程序, 对于<code>mips32</code>和<code>riscv32</code>的程序, 真机更是无法直接运行. <ul>
<li>所以, 我们需要的不仅是一个ISA手册的正确实现, 而且<strong>需要在上面能正确运行$ISA-nemu的AM程序</strong>.</li>
</ul>
</li>
<li>因此, 为了通过DiffTest的方法测试NEMU实现的正确性, 我们让NEMU和另一个模拟器逐条指令地执行同一个客户程序. 双方每执行完一条指令, 就检查各自的寄存器和内存的状态, 如果发现状态不一致, 就马上报告错误, 停止客户程序的执行.</li>
</ul>
<ol>
<li>为了方便实现DiffTest, 我们在DUT和REF之间定义了如下的一组API:</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在DUT host memory的`buf`和REF guest memory的`addr`之间拷贝`n`字节,</span></span><br><span class="line"><span class="comment">// `direction`指定拷贝的方向, `DIFFTEST_TO_DUT`表示往DUT拷贝, `DIFFTEST_TO_REF`表示往REF拷贝</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">difftest_memcpy</span><span class="params">(<span class="type">paddr_t</span> addr, <span class="type">void</span> *buf, <span class="type">size_t</span> n, <span class="type">bool</span> direction)</span>;</span><br><span class="line"><span class="comment">// `direction`为`DIFFTEST_TO_DUT`时, 获取REF的寄存器状态到`dut`;</span></span><br><span class="line"><span class="comment">// `direction`为`DIFFTEST_TO_REF`时, 设置REF的寄存器状态为`dut`;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">difftest_regcpy</span><span class="params">(<span class="type">void</span> *dut, <span class="type">bool</span> direction)</span>;</span><br><span class="line"><span class="comment">// 让REF执行`n`条指令</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">difftest_exec</span><span class="params">(<span class="type">uint64_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 初始化REF的DiffTest功能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">difftest_init</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中寄存器状态<code>dut</code>要求<strong>寄存器的成员按照某种顺序排列</strong>, 若未按要求顺序排列, difftest_regcpy()的行为是未定义的. <ul>
<li>REF需要实现这些API, DUT会使用这些API来进行DiffTest. 在这里, DUT和REF分别是NEMU和其它模拟器.</li>
</ul>
</li>
</ul>
<ol start="2">
<li>NEMU的框架代码已经准备好DiffTest的功能了, 在menuconfig中打开相应的选项:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Testing and Debugging</span><br><span class="line">  [*] Enable differential testing</span><br></pre></td></tr></table></figure>
<ul>
<li>然后重新编译NEMU并运行即可</li>
<li>riscv32: <strong>Spike</strong>. Spike是RISC-V社区的一款全系统模拟器, 它的工作原理与NEMU非常类似. 我们在Spike中增加了少量接口来实现DiffTest的API. 由于Spike包含较多源文件, 编译过程可能需要花费数分钟. 为了运行Spike, 你还需要安装另一个工具:</li>
<li><code>apt-get install device-tree-compiler</code></li>
</ul>
<ol start="3">
<li>由于不同ISA的寄存器有所不同, 框架代码把寄存器对比抽象成一个ISA相关的API, 即<code>isa_difftest_checkregs()</code>函数(在<code>nemu/src/isa/$ISA/difftest/dut.c</code>中定义). 你需要实现<code>isa_difftest_checkregs()</code>函数, 把通用寄存器和PC与从DUT中读出的寄存器的值进行比较. 若对比结果一致, 函数返回true; 如果发现值不一样, 函数返回false, 框架代码会自动停止客户程序的运行. 特别地, isa_difftest_checkregs()对比结果不一致时, 第二个参数pc应指向导致对比结果不一致的指令, 可用于打印提示信息.</li>
</ol>
<h4 id="选做：实现DiffTest"><a href="#选做：实现DiffTest" class="headerlink" title="选做：实现DiffTest"></a>选做：实现DiffTest</h4><ul>
<li>上文在介绍API约定的时候, 提到了寄存器状态r需要把寄存器按照某种顺序排列. 你首先需要RTFSC, 从中找出这一顺序, 并检查你的NEMU实现是否已经满足约束.</li>
<li>然后在isa_difftest_checkregs()中添加相应的代码, 实现DiffTest的核心功能. 实现正确后, 你将会得到一款无比强大的测试工具.</li>
<li>体会到DiffTest的强大之后, 不妨思考一下: 作为一种基础设施, DiffTest能帮助你节省多少调试的时间呢?</li>
</ul>
<ol>
<li>寄存器状态r需要把<strong>寄存器按照某种顺序排列</strong>. 你首先需要RTFSC, 从中找出这一顺序, 并检查你的NEMU实现是否已经满足约束.</li>
</ol>
<ul>
<li><code>nemu/tools/spike-diff/difftest.cc</code></li>
</ul>
<ol start="2">
<li>实现<code>isa_difftest_checkregs</code>:——将<code>ref_c</code>的寄存器与<code>dut_cpu</code>的寄存器逐一比较</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isa_difftest_checkregs</span><span class="params">(CPU_state *ref_r, <span class="type">vaddr_t</span> pc)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ARRLEN(cpu.gpr); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cpu.gpr[i]._32 != ref_r-&gt;gpr[i]._32) &#123;</span><br><span class="line">      Log(<span class="string">&quot;Mismatch at gpr[%d]: DUT = 0x%08x, REF = 0x%08x&quot;</span>, i, cpu.gpr[i]._32, ref_r-&gt;gpr[i]._32);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cpu.pc != ref_r-&gt;pc) &#123;</span><br><span class="line">    Log(<span class="string">&quot;Mismatch at pc: DUT = 0x%08x, REF = 0x%08x&quot;</span>, cpu.pc, ref_r-&gt;pc);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>make run</code>一下，发现NEMU成功编译和运行，启用了 DiffTest 功能，并且使用了 spike-diff 作为参考动态库。</li>
</ol>
<h4 id="思考：匪夷所思的QEMU行为-有点难度"><a href="#思考：匪夷所思的QEMU行为-有点难度" class="headerlink" title="思考：匪夷所思的QEMU行为 (有点难度)"></a>思考：匪夷所思的QEMU行为 (有点难度)</h4><ul>
<li>在一些旧版的mips32-QEMU中, 仅在上述指令的PC值后12位为0xffc时, 才会进行指令打包. 这个打包条件看上去非常奇怪, 你知道可能的原因是什么吗?</li>
</ul>
<ol>
<li>缓存行对齐</li>
</ol>
<ul>
<li>现代处理器通常使用缓存来提高内存访问速度。缓存行的大小通常是固定的，例如64字节或128字节。</li>
<li>如果PC值的后12位为0xffc，这意味着指令的地址接近一个缓存行的末尾。为了避免跨缓存行访问，QEMU可能会选择在这种情况下进行指令打包，以提高缓存命中率和指令执行效率。</li>
</ul>
<ol start="2">
<li>指令预取优化</li>
</ol>
<ul>
<li>指令预取是处理器在执行指令之前，从内存中预先读取指令的一种技术。预取的指令通常存储在指令缓存中。</li>
<li>当PC值的后12位为0xffc时，指令地址接近一个预取块的末尾。为了确保预取块中的指令能够连续执行，QEMU可能会选择在这种情况下进行指令打包，以优化指令预取的效果。</li>
</ul>
<ol start="3">
<li>特定硬件行为的模拟</li>
</ol>
<ul>
<li>QEMU作为一个模拟器，可能需要模拟特定硬件的行为。在某些硬件平台上，指令打包可能会在特定的地址范围内触发。</li>
<li>QEMU可能在PC值的后12位为0xffc时进行指令打包，以模拟这些硬件平台的行为，确保模拟器的行为与实际硬件一致。</li>
</ul>
<ol start="4">
<li>历史遗留问题</li>
</ol>
<h4 id="使用QEMU作为REF时-不要同时运行两份NEMU"><a href="#使用QEMU作为REF时-不要同时运行两份NEMU" class="headerlink" title="使用QEMU作为REF时, 不要同时运行两份NEMU"></a>使用QEMU作为REF时, 不要同时运行两份NEMU</h4><ul>
<li>DiffTest会通过一个固定的端口连接到QEMU, 同时运行两份打开DiffTest的NEMU会出现以下信息:<code>Failed to find an available port: Address already in use</code></li>
<li>如果你确信没有同时运行两份NEMU, 但仍然遇到上述信息, 可以通过执行以下命令把残留在后台的QEMU杀掉:<code>pkill -9 qemu</code></li>
</ul>
<h2 id="一键回归测试"><a href="#一键回归测试" class="headerlink" title="一键回归测试"></a>一键回归测试</h2><ul>
<li>以后你还需要在NEMU中加入新的功能, 为了保证加入的<strong>新功能</strong>没有影响到<strong>已有功能</strong>的实现, 你还需要<em>重新运行这些测试用例</em>. 在软件测试中, 这个过程称为<strong>回归测试</strong>.</li>
<li>为了提高效率, 我们为<code>cpu-tests</code>提供了一键回归测试的功能:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make ARCH=$ISA-nemu run</span><br></pre></td></tr></table></figure>
<ul>
<li>即可自动批量运行cpu-tests中的所有测试, 并报告每个测试用例的运行结果.</li>
</ul>
<hr>
<ul>
<li>PA2.2结束！</li>
</ul>
<h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><h2 id="设备与CPU"><a href="#设备与CPU" class="headerlink" title="设备与CPU"></a>设备与CPU</h2><ul>
<li>除了纯粹的数据读写之外, 我们还需要对设备进行控制:</li>
<li>比如需要获取键盘控制器的状态, 查看当前是否有按键被按下;</li>
<li>或者是需要有方式可以查询或设置VGA控制器的分辨率.</li>
<li>所以, 在程序看来, <strong>访问设备 &#x3D; 读出数据 + 写入数据 + 控制状态</strong>.</li>
<li>既然设备也有寄存器, 一种最简单的方法就是把<strong>设备的寄存器</strong>作为<strong>接口</strong>, 让<strong>CPU</strong>来访问这些寄存器. <ol>
<li>比如CPU可以从&#x2F;往设备的<em>数据寄存器</em>中读出&#x2F;写入数据, 进行数据的输入输出;</li>
<li>可以从设备的<em>状态寄存器</em>中读出设备的状态, 询问设备是否忙碌;</li>
<li>或者往设备的<em>命令寄存器</em>中写入命令字, 来修改设备的状态.</li>
</ol>
</li>
<li>CPU如何访问设备寄存器：</li>
<li>给<strong>设备中允许CPU访问的寄存器逐一编号</strong>, 然后通过<strong>指令</strong>来<strong>引用这些编号</strong>.</li>
<li>设备中可能会有一些<strong>私有</strong>寄存器, 它们是由设备自己维护的, 它们没有这样的编号, CPU不能直接访问它们.</li>
<li>这就是所谓的<strong>I&#x2F;O编址方式</strong>, 因此这些<strong>编号</strong>也称为<strong>设备的地址</strong>.</li>
<li>常用的编址方式有两种：</li>
</ul>
<h3 id="端口I-O"><a href="#端口I-O" class="headerlink" title="端口I&#x2F;O"></a>端口I&#x2F;O</h3><ul>
<li>一种I&#x2F;O编址方式是<strong>端口映射I&#x2F;O(port-mapped I&#x2F;O)</strong>, CPU使用专门的I&#x2F;O指令对设备进行访问, 并把<strong>设备的地址</strong>称作<strong>端口号</strong>.<ul>
<li>有了端口号以后, 在<em>I&#x2F;O指令中给出端口号</em>, 就知道要访问哪一个设备寄存器了.</li>
</ul>
</li>
<li>端口映射I&#x2F;O<code>把端口号作为I/O指令的一部分</code>, 这种方法很简单, 但同时也是它最大的<code>缺点</code><ul>
<li>指令集为了兼容已经开发的程序, 是只能添加但不能修改的. 这意味着, 端口映射I&#x2F;O所能访问的I&#x2F;O地址空间的大小, 在设计I&#x2F;O指令的那一刻就已经决定下来了. 所谓I&#x2F;O地址空间, 其实就是所有能访问的设备的地址的集合.</li>
<li>随着设备越来越多, 功能也越来越复杂, I&#x2F;O地址空间有限的端口映射I&#x2F;O已经逐渐不能满足需求了.</li>
</ul>
</li>
</ul>
<h3 id="內存映射I-O"><a href="#內存映射I-O" class="headerlink" title="內存映射I&#x2F;O"></a>內存映射I&#x2F;O</h3><ul>
<li><strong>内存映射I&#x2F;O(memory-mapped I&#x2F;O, MMIO)</strong> ,是通过不同的<strong>物理内存地址</strong>给设备编址的</li>
<li>这种编址方式将一部分物理内存的访问”重定向”到I&#x2F;O地址空间中, CPU尝试访问这部分物理内存的时候, 实际上最终是访问了相应的I&#x2F;O设备. 这样以后, CPU就可以通过普通的访存指令来访问设备</li>
<li>好处: 物理内存的地址空间和CPU的位宽都会不断增长, 内存映射I&#x2F;O从来不需要担心I&#x2F;O地址空间耗尽的问题.</li>
</ul>
<h4 id="思考：理解volatile关键字"><a href="#思考：理解volatile关键字" class="headerlink" title="思考：理解volatile关键字"></a>思考：理解volatile关键字</h4><ul>
<li>也许你从来都没听说过C语言中有volatile这个关键字, 但它从C语言诞生开始就一直存在. volatile关键字的作用十分特别, 它的作用是避免编译器对相应代码进行优化. 你应该动手体会一下volatile的作用, 在GNU&#x2F;Linux下编写以下代码:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> _end;  <span class="comment">// _end是什么?</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> *p = &amp;_end;</span><br><span class="line">  *p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(*p != <span class="number">0xff</span>);</span><br><span class="line">  *p = <span class="number">0x33</span>;</span><br><span class="line">  *p = <span class="number">0x34</span>;</span><br><span class="line">  *p = <span class="number">0x86</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后使用<code>-O2</code>编译代码. 尝试去掉代码中的<code>volatile</code>关键字, 重新使用<code>-O2</code>编译, 并对比去掉<code>volatile</code>前后反汇编结果的不同.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -O2 -c fun.c -o fun.o</span><br><span class="line">objdump -d fun.o &gt; fun_with_volatile.s</span><br></pre></td></tr></table></figure>
<ul>
<li>你或许会感到疑惑, 代码优化不是一件好事情吗? 为什么会有volatile这种奇葩的存在? 思考一下, 如果代码中p指向的地址最终被映射到一个设备寄存器, 去掉volatile可能会带来什么问题?</li>
</ul>
<ol>
<li>使用volatile关键字的反汇编结果</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000 &lt;fun&gt;:</span><br><span class="line">   0:   c6 05 00 00 00 00 00    movb   $0x0,0x0(%rip)        # 0x6</span><br><span class="line">   7:   80 3d 00 00 00 00 ff    cmpb   $0xff,0x0(%rip)       # 0xe</span><br><span class="line">   e:   75 f7                   jne    7 &lt;fun+0x7&gt;</span><br><span class="line">  10:   c6 05 00 00 00 00 33    movb   $0x33,0x0(%rip)       # 0x17</span><br><span class="line">  17:   c6 05 00 00 00 00 34    movb   $0x34,0x0(%rip)       # 0x1e</span><br><span class="line">  1e:   c6 05 00 00 00 00 86    movb   $0x86,0x0(%rip)       # 0x25</span><br></pre></td></tr></table></figure>
<ul>
<li>编译器不会对变量p进行优化，每次访问*p时都会从内存中读取最新的值。</li>
<li>反汇编结果中保留了所有对*p的写操作。</li>
</ul>
<ol start="2">
<li>去掉volatile关键字的反汇编结果</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000 &lt;fun&gt;:</span><br><span class="line">   0:   c6 05 00 00 00 00 00    movb   $0x0,0x0(%rip)        # 0x6</span><br><span class="line">   7:   80 3d 00 00 00 00 ff    cmpb   $0xff,0x0(%rip)       # 0xe</span><br><span class="line">   e:   75 f7                   jne    7 &lt;fun+0x7&gt;</span><br><span class="line">  10:   c6 05 00 00 00 00 86    movb   $0x86,0x0(%rip)       # 0x17</span><br></pre></td></tr></table></figure>
<ul>
<li>编译器认为*p的值不会在循环中被改变，因此可能会对代码进行优化。</li>
<li>反汇编结果中，编译器优化掉了中间的写操作，只保留了最后一次写操作。</li>
</ul>
<ol start="3">
<li>为什么会有volatile关键字:</li>
</ol>
<ul>
<li>代码优化通常是一件好事，可以提高程序的执行效率。然而，在某些情况下，优化可能会导致程序行为不符合预期。特别是当<strong>变量的值可能在程序的其他部分或外部环境中被改变时，编译器的优化可能会忽略这些变化，从而导致错误的行为</strong>。</li>
</ul>
<ol start="4">
<li>如果代码中p指向的地址最终被映射到一个设备寄存器，去掉volatile可能会带来什么问题？</li>
<li>设备状态无法及时更新<br>- 设备寄存器的值可能会在程序执行过程中被设备硬件改变。如果编译器对访问设备寄存器的代码进行了优化，可能会导致程序无法及时读取到设备的最新状态。</li>
<li>指令被优化掉<br>- 编译器可能会优化掉一些关键的读写操作，导致设备无法正确接收命令或数据。例如，上述代码中的循环可能会被优化掉，导致程序无法正确等待设备状态的变化。</li>
<li>不可预测的行为<br>- 由于设备寄存器的值可能在程序执行过程中被外部硬件改变，去掉volatile关键字可能会导致程序行为不可预测，难以调试和维护。</li>
</ol>
<h3 id="状态机视角下的输入输出"><a href="#状态机视角下的输入输出" class="headerlink" title="状态机视角下的输入输出"></a>状态机视角下的输入输出</h3><ul>
<li>设备是连接计算机和物理世界的桥梁.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">状态机模型           |           状态机模型之外</span><br><span class="line">S = &lt;R, M&gt;         |        D</span><br><span class="line">计算机/程序  &lt;----I/O指令----&gt; 设备 &lt;----模拟电路----&gt; 物理世界</span><br><span class="line">                   |</span><br><span class="line">                   |</span><br></pre></td></tr></table></figure>
<ul>
<li>对状态机模型的行为进行扩展——&gt;对输入输出相关指令的行为进行建模:<ol>
<li>执行<strong>普通指令</strong>时, 状态机按照<strong>TRM的模型</strong>进行状态转移</li>
<li>执行<strong>设备输出</strong>相关的指令(如x86的out指令或者RISC架构的MMIO写指令)时, 状态机除了<strong>更新PC</strong>之外, 其它状态均保持<em>不变</em>, 但<em>设备的状态和物理世界</em>则会发生相应的变化</li>
<li>执行<strong>设备输入</strong>相关的指令(如x86的in指令或者RISC架构的MMIO读指令)时, 状态机的<em>转移将会”分叉”</em>: 状态机不再像TRM那样有唯一的新状态了, <strong>状态机具体会转移到哪一个新状态, 将取决于执行这条指令时设备的状态</strong></li>
</ol>
</li>
</ul>
<h2 id="NEMU中的输入输出"><a href="#NEMU中的输入输出" class="headerlink" title="NEMU中的输入输出"></a>NEMU中的输入输出</h2><ul>
<li>NEMU的框架代码已经在<code>nemu/src/device/</code>目录下提供了设备相关的代码,</li>
</ul>
<h3 id="映射和I-O方式"><a href="#映射和I-O方式" class="headerlink" title="映射和I&#x2F;O方式"></a>映射和I&#x2F;O方式</h3><ul>
<li>可以通过对<strong>映射</strong>的管理来将<code>端口映射I/O</code>和<code>内存映射I/O</code>两种I&#x2F;O编址方式<strong>统一</strong>起来</li>
</ul>
<ol>
<li>框架代码为映射定义了一个<em>结构体类型</em><strong>IOMap</strong>(在<code>nemu/include/device/map.h</code>中定义), 包括</li>
</ol>
<ul>
<li>名字</li>
<li>映射的起始地址和结束地址</li>
<li>映射的目标空间</li>
<li>一个回调函数.</li>
</ul>
<ol start="2">
<li>然后在<code>nemu/src/device/io/map.c</code>实现了<strong>映射的管理</strong>, 包括</li>
</ol>
<ul>
<li>I&#x2F;O空间的分配及其映射</li>
<li>映射的访问接口.</li>
<li>其中<code>map_read()</code>和<code>map_write()</code>用于将地址<code>addr</code>映射到<code>map</code>所指示的目标空间, 并进行访问. 访问时, 可能会触发相应的回调函数, 对设备和目标空间的状态进行更新. 由于NEMU是单线程程序, 因此只能串行模拟整个计算机系统的工作, 每次进行I&#x2F;O读写的时候, 才会调用设备提供的<strong>回调函数</strong>(callback). <ul>
<li>基于这两个API, 我们就可以很容易实现端口映射I&#x2F;O和内存映射I&#x2F;O的模拟了.</li>
</ul>
</li>
</ul>
<ol start="3">
<li><code>nemu/src/device/io/port-io.c</code>是对<strong>端口映射I&#x2F;O</strong>的模拟. </li>
<li><code>add_pio_map()</code>函数用于为<strong>设备的初始化</strong>来<strong>注册</strong>一个端口映射I&#x2F;O的<strong>映射关系</strong>.</li>
<li><code>pio_read()</code>和<code>pio_write()</code>是面向CPU的端口I&#x2F;O读写接口, 它们最终会调用map_read()和map_write(), 对通过add_pio_map()注册的I&#x2F;O空间进行访问.</li>
<li><strong>内存映射I&#x2F;O</strong>的模拟是类似的, <code>paddr_read()</code>和<code>paddr_write()</code>会判断地址addr落在物理内存空间还是设备空间,</li>
</ol>
<ul>
<li>若落在物理内存空间, 就会通过<code>pmem_read()</code>和<code>pmem_write()</code>来访问真正的物理内存;</li>
<li>若落在设备空间, 就通过<code>map_read()</code>和<code>map_write()</code>来访问相应的设备.</li>
<li>从这个角度来看, 内存和外设在CPU来看并没有什么不同, 只不过都是一个字节编址的对象而已.</li>
</ul>
<h3 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h3><ul>
<li>为了开启设备模拟的功能, 你需要在menuconfig选中相关选项:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[*] Devices  ---&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>重新编译后, 你会看到运行NEMU时会<strong>弹出一个新窗口</strong>, 用于<strong>显示VGA的输出</strong>(见下文). 需要注意的是, <strong>终端显示的提示符(nemu)仍然在等待用户输入</strong>, 此时窗口并未显示任何内容.</li>
<li>NEMU使用SDL库来实现设备的模拟, <code>nemu/src/device/device.c</code>含有和SDL库相关的代码.<ul>
<li><code>init_device()</code>函数主要进行以下工作:<ul>
<li>调用<code>init_map()</code>进行<strong>初始化</strong>.</li>
<li>对上述设备进行<strong>初始化</strong>, 其中在初始化<strong>VGA</strong>时还会进行一些和<strong>SDL相关的初始化</strong>工作, 包括<strong>创建窗口</strong>, <strong>设置显示模式</strong>等;</li>
<li>然后会进行<strong>定时器(alarm)相关的初始化工作</strong>. 定时器的功能在<em>PA4</em>最后才会用到, 目前可以忽略它.</li>
</ul>
</li>
</ul>
</li>
<li>另一方面, <code>cpu_exec()</code>在<strong>执行每条指令之后</strong>就会<strong>调用</strong><code>device_update()</code>函数, 这个函数首先会检查距离上次设备更新是否已经超过一定时间, 若是, 则会尝试刷新屏幕, 并进一步检查是否有按键按下&#x2F;释放, 以及是否点击了窗口的<code>X</code>按钮; 否则则直接返回, 避免检查过于频繁, 因为上述事件发生的频率是很低的.</li>
</ul>
<h2 id="将输入输出抽象成IOE"><a href="#将输入输出抽象成IOE" class="headerlink" title="将输入输出抽象成IOE"></a>将输入输出抽象成IOE</h2><ul>
<li>与TRM不同, 设备访问是为计算机提供输入输出的功能, 因此我们把它们划入一类新的API, 名字叫<strong>IOE(I&#x2F;O Extension)</strong>.</li>
<li>访问设备 &#x3D; 读&#x2F;写操作</li>
<li>IOE提供三个API:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ioe_init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ioe_read</span><span class="params">(<span class="type">int</span> reg, <span class="type">void</span> *buf)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ioe_write</span><span class="params">(<span class="type">int</span> reg, <span class="type">void</span> *buf)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个API用于进行IOE相关的<strong>初始化</strong>操作.</li>
<li>后两个API分别用于<strong>从编号为reg的寄存器中读出内容到缓冲区buf中</strong>, 以及<strong>往编号为reg寄存器中写入缓冲区buf中的内容</strong>.<ul>
<li>需要注意的是, 这里的reg寄存器<em>并不是上文讨论的设备寄存器</em>, 因为设备寄存器的编号是架构相关的. 在IOE中, 我们希望采用一种架构无关的”抽象寄存器”, <strong>这个reg其实是一个功能编号</strong>, 我们约定在不同的架构中, 同一个功能编号的含义也是相同的, 这样就实现了设备寄存器的抽象.</li>
</ul>
</li>
<li><code>abstract-machine/am/include/amdev.h</code>中定义了<strong>常见设备的”抽象寄存器”编号和相应的结构</strong>. <ul>
<li>这些定义是<strong>架构无关</strong>的, 每个架构在<strong>实现各自的IOE API</strong>时, 都需要<strong>遵循</strong>这些定义(约定).</li>
<li>为了方便地对这些抽象寄存器进行访问, <code>klib</code>中提供了<code>io_read()</code>和<code>io_write()</code>这两个<strong>宏</strong>, 它们分别对ioe_read()和ioe_write()这两个<strong>API</strong>进行了进一步的封装.</li>
</ul>
</li>
<li>特别地, NEMU作为一个平台, 设备的行为是与ISA无关的, 因此我们只需要在<code>abstract-machine/am/src/platform/nemu/ioe/</code>目录下<strong>实现一份IOE, 来供NEMU平台的架构共享</strong>. 其中, <code>abstract-machine/am/src/platform/nemu/ioe/ioe.c</code>中实现了上述的三个IOE API, ioe_read()和ioe_write()都是通过抽象寄存器的编号索引到一个处理函数, 然后调用它.</li>
<li>处理函数的具体功能和寄存器编号相关, 下面我们来逐一介绍NEMU中每个设备的功能.</li>
</ul>
<h3 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h3><ul>
<li>串口是最简单的<strong>输出</strong>设备. <code>nemu/src/device/serial.c</code>模拟了串口的功能</li>
</ul>
<h4 id="必做：运行Hello-World"><a href="#必做：运行Hello-World" class="headerlink" title="必做：运行Hello World"></a>必做：运行Hello World</h4><ul>
<li>如果你选择的是mips32和riscv32, 你不需要实现额外的代码, 因为NEMU的框架代码已经支持MMIO了.</li>
<li>实现后, <code>在am-kernels/kernels/hello/</code>目录下键入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make ARCH=riscv32-nemu run</span><br></pre></td></tr></table></figure>
<ul>
<li>如果你的实现正确, 你将会看到程序往终端输出一些信息(请注意不要让输出淹没在调试信息中).</li>
<li>需要注意的是, 这个hello程序和我们在程序设计课上写的第一个hello程序所处的抽象层次是不一样的: 这个hello程序可以说是直接运行在裸机上, 可以在AM的抽象之上直接输出到设备(串口); 而我们在程序设计课上写的hello程序位于操作系统之上, 不能直接操作设备, 只能通过操作系统提供的服务进行输出, 输出的数据要经过很多层抽象才能到达设备层. 我们会在PA3中进一步体会操作系统的作用.</li>
</ul>
<ol>
<li><code>am-kernels/kernels/hello/hello.c</code>中代码：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;am.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;klib-macros.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *args)</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *fmt =</span><br><span class="line">    <span class="string">&quot;Hello, AbstractMachine!\n&quot;</span></span><br><span class="line">    <span class="string">&quot;mainargs = &#x27;%&#x27;.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span> *p = fmt; *p; p++) &#123;</span><br><span class="line">    (*p == <span class="string">&#x27;%&#x27;</span>) ? putstr(args) : putch(*p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>HIT GOOD TRAP at pc = 0x800000b0</code></li>
</ol>
<ul>
<li>输出<code>Hello, AbstractMachine!/n</code>和<code>mainargs = &#39;&#39;.\n</code></li>
<li>在AM中, main()函数允许带有一个字符串参数, 这一参数通过mainargs指定, 并由AM的运行时环境负责将它传给main()函数, 供AM程序使用. 具体的参数传递方式和架构相关.例如你可以在运行hello的时候给出一个字符串参数:<code>make ARCH=riscv32-nemu run mainargs=I-love-PA</code><ul>
<li>输出<code>Hello, AbstractMachine!/n</code>和<code>mainargs = &#39;I-love-PA&#39;.\n</code></li>
</ul>
</li>
</ul>
<h4 id="必做：实现printf"><a href="#必做：实现printf" class="headerlink" title="必做：实现printf"></a>必做：实现printf</h4><ul>
<li>有了<code>putch()</code>, 我们就可以在<code>klib</code>中实现<code>printf()</code>了.</li>
<li>你之前已经实现了<code>sprintf()</code>了, 它和<code>printf()</code>的功能非常相似, 这意味着它们之间会有不少重复的代码. 你已经见识到Copy-Paste编程习惯的坏处了, 思考一下, 如何简洁地实现它们呢?</li>
<li>实现了<code>printf()</code>之后, 你就可以在AM程序中使用输出调试法了.</li>
</ul>
<ol>
<li>在<code>ics2024/abstract-machine/klib/src/stdio.c</code>中：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">number</span><span class="params">(<span class="type">char</span> *str, <span class="type">unsigned</span> <span class="type">int</span> num, <span class="type">int</span> base, <span class="type">int</span> is_upper)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">  <span class="type">char</span> *p = buf + <span class="number">31</span>;</span><br><span class="line">  *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="type">int</span> digit = num % base;</span><br><span class="line">    *--p = (digit &lt; <span class="number">10</span>) ? <span class="string">&#x27;0&#x27;</span> + digit : (is_upper ? <span class="string">&#x27;A&#x27;</span> : <span class="string">&#x27;a&#x27;</span>) + digit - <span class="number">10</span>;</span><br><span class="line">    num /= base;</span><br><span class="line">  &#125; <span class="keyword">while</span> (num &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">    *str++ = *p++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">1024</span>]; <span class="comment">// 临时缓冲区</span></span><br><span class="line">  va_list args;</span><br><span class="line">  va_start(args, fmt);</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">vsprintf</span>(buf, fmt, args);</span><br><span class="line">  va_end(args);</span><br><span class="line">  <span class="type">char</span> *tmp = buf;</span><br><span class="line">  <span class="keyword">while</span> (*tmp != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    putch(*tmp++);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *out, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *str = out;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s;</span><br><span class="line">  <span class="type">int</span> base;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (; *fmt != <span class="string">&#x27;\0&#x27;</span>; ++fmt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">      *str++ = *fmt;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++fmt;</span><br><span class="line">    base = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (*fmt) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">        *str++ = (<span class="type">unsigned</span> <span class="type">char</span>) va_arg(ap, <span class="type">int</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">        s = va_arg(ap, <span class="type">char</span> *);</span><br><span class="line">        <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">          *str++ = *s++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">        num = va_arg(ap, <span class="type">int</span>);</span><br><span class="line">        str = number(str, num, base, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">        base = <span class="number">16</span>;</span><br><span class="line">        num = va_arg(ap, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">        str = number(str, num, base, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">        base = <span class="number">16</span>;</span><br><span class="line">        num = va_arg(ap, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">        str = number(str, num, base, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">        base = <span class="number">8</span>;</span><br><span class="line">        num = va_arg(ap, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">        str = number(str, num, base, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">        num = va_arg(ap, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">        str = number(str, num, base, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">        num = (<span class="type">unsigned</span> <span class="type">long</span>) va_arg(ap, <span class="type">void</span> *);</span><br><span class="line">        base = <span class="number">16</span>;</span><br><span class="line">        *str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        *str++ = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">        str = number(str, num, base, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">        *str++ = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        *str++ = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (*fmt) &#123;</span><br><span class="line">          *str++ = *fmt;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          --fmt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *str = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> str - out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="必做：运行alu-tests"><a href="#必做：运行alu-tests" class="headerlink" title="必做：运行alu-tests"></a>必做：运行alu-tests</h4><ul>
<li>我们在<code>am-kernels/tests/alu-tests/</code>目录下移植了一个专门测试各种C语言运算的程序, 实现<code>printf()</code>后你就可以运行它了. 编译过程可能需要花费1分钟.</li>
<li><code>make ARCH=riscv32-nemu run</code></li>
<li><code>HIT GOOD TRAP at pc = 0x800ebb34</code></li>
<li>但是没有printf输出，不知道为什么</li>
</ul>
<h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><h4 id="必做：实现IOE"><a href="#必做：实现IOE" class="headerlink" title="必做：实现IOE"></a>必做：实现IOE</h4><ul>
<li>在<code>abstract-machine/am/src/platform/nemu/ioe/timer.c</code>中实现AM_TIMER_UPTIME的功能. 在<code>abstract-machine/am/src/platform/nemu/include/nemu.h</code>和 <code>abstract-machine/am/src/$ISA/$ISA.h</code>中有一些输入输出相关的代码供你使用.</li>
<li>实现后, 在<code>$ISA-nemu</code>中运行<code>am-kernel/tests/am-tests</code>中的<code>real-time clock test</code>测试. 如果你的实现正确, 你将会看到<strong>程序每隔1秒往终端输出一行信息</strong>. 由于我们没有实现AM_TIMER_RTC, 测试总是输出1900年0月0日0时0分0秒, 这属于正常行为, 可以忽略.</li>
</ul>
<ol>
<li>实现：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __am_timer_uptime(AM_TIMER_UPTIME_T *uptime) &#123;</span><br><span class="line">  <span class="type">uint32_t</span> low = inl(RTC_ADDR);</span><br><span class="line">  <span class="type">uint32_t</span> high = inl(RTC_ADDR + <span class="number">4</span>);</span><br><span class="line">  uptime-&gt;us = ((<span class="type">uint64_t</span>)high &lt;&lt; <span class="number">32</span>) | low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不正确，之后有修改。修改后：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __am_timer_uptime(AM_TIMER_UPTIME_T *uptime) &#123;</span><br><span class="line">  <span class="type">uint32_t</span> high = inl(RTC_ADDR + <span class="number">4</span>);</span><br><span class="line">  <span class="type">uint32_t</span> low = inl(RTC_ADDR);</span><br><span class="line">  uptime-&gt;us = ((<span class="type">uint64_t</span>)high &lt;&lt; <span class="number">32</span>) | low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>要如何运行<code>real-time clock test</code>这个测试, 就交给你来RTFSC吧:</li>
</ol>
<ul>
<li>在<code>am-kernels/tests/am-tests/src/main.c</code>中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;amtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (*entry)() = <span class="literal">NULL</span>; <span class="comment">// mp entry</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *tests[<span class="number">256</span>] = &#123;</span><br><span class="line">  [<span class="string">&#x27;h&#x27;</span>] = <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">  [<span class="string">&#x27;H&#x27;</span>] = <span class="string">&quot;display this help message&quot;</span>,</span><br><span class="line">  [<span class="string">&#x27;i&#x27;</span>] = <span class="string">&quot;interrupt/yield test&quot;</span>,</span><br><span class="line">  [<span class="string">&#x27;d&#x27;</span>] = <span class="string">&quot;scan devices&quot;</span>,</span><br><span class="line">  [<span class="string">&#x27;m&#x27;</span>] = <span class="string">&quot;multiprocessor test&quot;</span>,</span><br><span class="line">  [<span class="string">&#x27;t&#x27;</span>] = <span class="string">&quot;real-time clock test&quot;</span>,</span><br><span class="line">  [<span class="string">&#x27;k&#x27;</span>] = <span class="string">&quot;readkey test&quot;</span>,</span><br><span class="line">  [<span class="string">&#x27;v&#x27;</span>] = <span class="string">&quot;display test&quot;</span>,</span><br><span class="line">  [<span class="string">&#x27;a&#x27;</span>] = <span class="string">&quot;audio test&quot;</span>,</span><br><span class="line">  [<span class="string">&#x27;p&#x27;</span>] = <span class="string">&quot;x86 virtual memory test&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *args)</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (args[<span class="number">0</span>]) &#123;</span><br><span class="line">    CASE(<span class="string">&#x27;h&#x27;</span>, hello);</span><br><span class="line">    CASE(<span class="string">&#x27;i&#x27;</span>, hello_intr, IOE, CTE(simple_trap));</span><br><span class="line">    CASE(<span class="string">&#x27;d&#x27;</span>, devscan, IOE);</span><br><span class="line">    CASE(<span class="string">&#x27;m&#x27;</span>, mp_print, MPE);</span><br><span class="line">    CASE(<span class="string">&#x27;t&#x27;</span>, rtc_test, IOE);</span><br><span class="line">    CASE(<span class="string">&#x27;k&#x27;</span>, keyboard_test, IOE);</span><br><span class="line">    CASE(<span class="string">&#x27;v&#x27;</span>, video_test, IOE);</span><br><span class="line">    CASE(<span class="string">&#x27;a&#x27;</span>, audio_test, IOE);</span><br><span class="line">    CASE(<span class="string">&#x27;p&#x27;</span>, vm_test, CTE(vm_handler), VME(simple_pgalloc, simple_pgfree));</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Usage: make run mainargs=*\n&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> ch = <span class="number">0</span>; ch &lt; <span class="number">256</span>; ch++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tests[ch]) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;  %c: %s\n&quot;</span>, ch, tests[ch]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>所以输入命令为<code>make ARCH=riscv32-nemu run mainargs=t</code></li>
</ul>
<ol start="3">
<li>成功,部分为：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1900-0-0 %02d:%02d:%02d GMT (1 second).</span><br><span class="line">1900-0-0 %02d:%02d:%02d GMT (2 seconds).</span><br><span class="line">1900-0-0 %02d:%02d:%02d GMT (3 seconds).</span><br><span class="line">1900-0-0 %02d:%02d:%02d GMT (4 seconds).</span><br><span class="line">1900-0-0 %02d:%02d:%02d GMT (5 seconds).</span><br><span class="line">1900-0-0 %02d:%02d:%02d GMT (6 seconds).</span><br><span class="line">1900-0-0 %02d:%02d:%02d GMT (7 seconds).</span><br><span class="line">1900-0-0 %02d:%02d:%02d GMT (8 seconds).</span><br><span class="line">1900-0-0 %02d:%02d:%02d GMT (9 seconds).</span><br></pre></td></tr></table></figure>
<h4 id="看看NEMU跑多快"><a href="#看看NEMU跑多快" class="headerlink" title="看看NEMU跑多快"></a>看看NEMU跑多快</h4><ul>
<li>有了时钟之后, 我们就可以测试一个程序跑多快, 从而测试计算机的性能. 尝试在NEMU中依次运行以下benchmark(已经按照程序的复杂度排序, 均在am-kernel&#x2F;benchmarks&#x2F;目录下; 另外跑分时请关闭NEMU的监视点, trace以及DiffTest, 同时取消menuconfig中的 Enable debug information并重新编译NEMU, 以获得较为真实的跑分):<ul>
<li>dhrystone</li>
<li>coremark</li>
<li>microbench</li>
</ul>
</li>
<li>成功运行后会输出跑分. 其中microbench跑分以i9-9900K @ 3.60GHz的处理器为参照, 100000分表示与参照机器性能相当, 100分表示性能为参照机器的千分之一. 除了和参照机器比较之外, 也可以和小伙伴进行比较. 如果把上述benchmark编译到native, 还可以比较native的性能.</li>
<li>另外, microbench提供了四个不同规模的测试集, 包括test, train, ref和huge. 你可以先运行test规模, 它可以较快地运行结束, 来检查NEMU实现的正确性, 然后再运行ref规模来测量性能. 具体的运行方法请阅读README.</li>
<li>此外, huge规模一般用于真机的测试, 在NEMU中需要运行很长时间, 我们不要求你运行它.</li>
</ul>
<ol>
<li>都报错</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make[1]: *** [/home/xiaoyao/ics2024/nemu/scripts/native.mk:38: run] 浮点异常 (核心已转储)</span><br><span class="line">make[1]: 离开目录“/home/xiaoyao/ics2024/nemu”</span><br><span class="line">make: *** [/home/xiaoyao/ics2024/abstract-machine/scripts/platform/nemu.mk:32：run] 错误 2</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>关于<code>AM_TIMER_UPTIME</code>的实现, 我们在框架代码中埋了一些小坑, 如果你没有修复相关的问题, 你可能会在运行<code>benchmark</code>的时候出现跑分不正确的现象. 这是为了强迫大家认真RTFSC了解程序运行过程中的一切细节:<code> benchmark</code>读取时钟信息的时候, 整个计算机系统究竟发生了什么? 只有这样你才能把时钟相关的bug调试正确.</li>
</ol>
<ul>
<li><code>am-kernels/benchmarks/dhrystone/dry.c</code>中944行有除0错误：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Dhrystone %s         %d Marks\n&quot;</span>, pass ? <span class="string">&quot;PASS&quot;</span> : <span class="string">&quot;FAIL&quot;</span>,</span><br><span class="line">      <span class="number">880900</span> / (<span class="type">int</span>)User_Time * NUMBER_OF_RUNS/ <span class="number">500000</span>);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>修改<code>time.c</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __am_timer_uptime(AM_TIMER_UPTIME_T *uptime) &#123;</span><br><span class="line">  <span class="type">uint32_t</span> high = inl(RTC_ADDR + <span class="number">4</span>);</span><br><span class="line">  <span class="type">uint32_t</span> low = inl(RTC_ADDR);</span><br><span class="line">  uptime-&gt;us = ((<span class="type">uint64_t</span>)high &lt;&lt; <span class="number">32</span>) | low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>Dhrystone:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dhrystone Benchmark, Version C, Version 2.2</span><br><span class="line">Trying 500000 runs through Dhrystone.</span><br><span class="line">Finished in 16861 ms</span><br><span class="line">==================================================</span><br><span class="line">Dhrystone PASS         52 Marks</span><br><span class="line">                   vs. 100000 Marks (i7-7700K @ 4.20GHz)</span><br><span class="line">[src/cpu/cpu-exec.c:196 cpu_exec] nemu: HIT GOOD TRAP at pc = 0x80000d24</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>coremark:</li>
</ol>
<ul>
<li>报错！</li>
<li>查看<code>benchmarks/coremark/build/coremark-riscv32-nemu.txt</code></li>
<li><code>80000df4:	00178783          	lb	a5,1(a5)</code></li>
</ul>
<ol>
<li><code>  INSTPAT(&quot;??????? ????? ????? 000 ????? 00000 11&quot;, lb     , I, R(rd) = SEXT(Mr(src1 + imm, 1), 8));//lb,将src1+imm地址的值的低8位存入rd</code></li>
</ol>
<ul>
<li><code>80000968:	08046413          	ori	s0,s0,128</code></li>
</ul>
<ol start="2">
<li><code>INSTPAT(&quot;??????? ????? ????? 110 ????? 00100 11&quot;, ori    , I, R(rd) = src1 | imm); //ori，或立即数，将src1的值与imm进行或运算，结果存入rd</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CoreMark PASS       118 Marks</span><br><span class="line">                vs. 100000 Marks (i7-7700K @ 4.20GHz)</span><br><span class="line">[src/cpu/cpu-exec.c:196 cpu_exec] nemu: HIT GOOD TRAP at pc = 0x80002288</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>microbench</li>
</ol>
<ul>
<li>报错！</li>
<li>查看：<code>benchmarks/microbench/build/microbench-riscv32-nemu.txt</code></li>
<li><code>80004a54:	02f535b3          	mulhu	a1,a0,a5</code></li>
</ul>
<ol>
<li><code>  INSTPAT(&quot;0000001 ????? ????? 011 ????? 01100 11&quot;, mulhu  , R, R(rd) = ((uint64_t)src1 * (uint64_t)src2) &gt;&gt; 32);//mulhu</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MicroBench PASS        153 Marks</span><br><span class="line">                   vs. 100000 Marks (i9-9900K @ 3.60GHz)</span><br><span class="line">Scored time: 122518.853 ms</span><br><span class="line">Total  time: 141086.480 ms</span><br><span class="line">[src/cpu/cpu-exec.c:196 cpu_exec] nemu: HIT GOOD TRAP at pc = 0x80004e1c</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>正确实现时钟后, 你就可以在NEMU上运行一些具有展示性的程序了: 我们在<code>am-kernels/kernels/demo/</code>目录下移植了一些小型演示程序</li>
<li>为了运行它们, 你还需要实现<code>klib</code>中的<code>malloc()</code>和<code>free()</code>, 目前你可以实现一个简单的版本:<ul>
<li>在<code>malloc()</code>中维护一个上次分配内存位置的变量addr, 每次调用<code>malloc()</code>时, 就返回[addr, addr + size)这段空间. <code>addr</code>的初值设为<code>heap.start</code>, 表示从堆区开始分配. 你也可以参考<code>microbench</code>中的相关代码. 注意malloc()对<em>返回的地址有一定的要求</em>, 具体情况请RTFM.</li>
<li><code>free()</code>直接留空即可, 表示只分配不释放. 目前NEMU中的可用内存足够运行各种测试程序.</li>
</ul>
</li>
</ul>
<h4 id="选做："><a href="#选做：" class="headerlink" title="选做："></a>选做：</h4><h3 id="设备访问的踪迹-dtrace"><a href="#设备访问的踪迹-dtrace" class="headerlink" title="设备访问的踪迹 - dtrace"></a>设备访问的踪迹 - dtrace</h3><h4 id="必做：实现dtrace"><a href="#必做：实现dtrace" class="headerlink" title="必做：实现dtrace"></a>必做：实现dtrace</h4><ul>
<li>这个功能非常简单, 你可以自行定义<code>dtrace</code>输出的格式. 注意你可以通过<code>map-&gt;name</code>来<strong>获取一段设备地址空间的名字</strong>, 这样可以帮助你输出可读性较好的信息. 同样地, 你也可以为dtrace实现<strong>条件控制功能</strong>, 提升dtrace使用的灵活性.</li>
</ul>
<ol>
<li>在Kconfig中定义DTRACE，<code>nemu/Kconfig</code>:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu &quot;Tracing Options&quot;</span><br><span class="line">config DTRACE</span><br><span class="line">    bool &quot;Enable device trace&quot;</span><br><span class="line">    default n</span><br><span class="line">    help</span><br><span class="line">      Enable device trace to record device access behavior.</span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在 <code>map_read </code>和 <code>map_write </code>函数中添加 <code>dtrace</code> 功能:<code>nemu/src/device/io/map.c</code>:</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">word_t</span> <span class="title function_">map_read</span><span class="params">(<span class="type">paddr_t</span> addr, <span class="type">int</span> len, IOMap *<span class="built_in">map</span>)</span> &#123;</span><br><span class="line">  assert(len &gt;= <span class="number">1</span> &amp;&amp; len &lt;= <span class="number">8</span>);</span><br><span class="line">  check_bound(<span class="built_in">map</span>, addr);</span><br><span class="line">  <span class="type">paddr_t</span> offset = addr - <span class="built_in">map</span>-&gt;low;</span><br><span class="line">  invoke_callback(<span class="built_in">map</span>-&gt;callback, offset, len, <span class="literal">false</span>); <span class="comment">// prepare data to read</span></span><br><span class="line">  <span class="type">word_t</span> ret = host_read(<span class="built_in">map</span>-&gt;space + offset, len);</span><br><span class="line">  IFDEF(CONFIG_DTRACE, Log(<span class="string">&quot;address = &quot;</span> FMT_PADDR <span class="string">&quot; read &quot;</span> FMT_PADDR <span class="string">&quot; at device = %s&quot;</span>, addr, ret, <span class="built_in">map</span>-&gt;name));</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">map_write</span><span class="params">(<span class="type">paddr_t</span> addr, <span class="type">int</span> len, <span class="type">word_t</span> data, IOMap *<span class="built_in">map</span>)</span> &#123;</span><br><span class="line">  assert(len &gt;= <span class="number">1</span> &amp;&amp; len &lt;= <span class="number">8</span>);</span><br><span class="line">  check_bound(<span class="built_in">map</span>, addr);</span><br><span class="line">  <span class="type">paddr_t</span> offset = addr - <span class="built_in">map</span>-&gt;low;</span><br><span class="line">  host_write(<span class="built_in">map</span>-&gt;space + offset, len, data);</span><br><span class="line">  invoke_callback(<span class="built_in">map</span>-&gt;callback, offset, len, <span class="literal">true</span>);</span><br><span class="line">  IFDEF(CONFIG_DTRACE, Log(<span class="string">&quot;address = &quot;</span> FMT_PADDR <span class="string">&quot; write &quot;</span> FMT_PADDR <span class="string">&quot; at device = %s&quot;</span>, addr, data, <span class="built_in">map</span>-&gt;name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>成功，片段如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[src/device/io/map.c:61 map_read] address = 0xa0000060 read 0x00000000 at device = keyboard</span><br></pre></td></tr></table></figure>
<h3 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h3><ul>
<li>一般键盘的工作方式如下: 当按下一个键的时候, 键盘将会发送该键的通码(make code); 当释放一个键的时候, 键盘将会发送该键的断码(break code).</li>
<li><code>nemu/src/device/keyboard.c</code></li>
<li>每当用户敲下&#x2F;释放按键时, 将会把相应的键盘码放入数据寄存器, CPU可以访问数据寄存器, 获得键盘码; 当无按键可获取时, 将会返回AM_KEY_NONE.</li>
<li><code>abstract-machine/am/include/amdev.h</code>中为键盘的功能定义了一个抽象寄存器:<ul>
<li><code>AM_INPUT_KEYBRD</code>, AM键盘控制器, 可读出按键信息. <code>keydown</code>为<code>true</code>时表示按下按键, 否则表示释放按键. <code>keycode</code>为按键的断码, 没有按键时, <code>keycode</code>为<code>AM_KEY_NONE</code>.</li>
</ul>
</li>
</ul>
<h4 id="必做：实现IOE-2"><a href="#必做：实现IOE-2" class="headerlink" title="必做：实现IOE(2)"></a>必做：实现IOE(2)</h4><ul>
<li>在<code>abstract-machine/am/src/platform/nemu/ioe/input.c</code>中实现<code>AM_INPUT_KEYBRD</code>的功能. 实现后, 在<code>$ISA-nemu</code>中运行<code>am-tests</code>中的<code>readkey test</code>测试. 如果你的实现正确, 在程序运行时弹出的新窗口中<strong>按下按键</strong>, 你将会看到<strong>程序输出相应的按键信息</strong>, 包括<strong>按键名, 键盘码, 以及按键状态</strong>.</li>
</ul>
<ol>
<li><code>am/src/platform/nemu/ioe/input.c</code>:</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __am_input_keybrd(AM_INPUT_KEYBRD_T *kbd) &#123;</span><br><span class="line">  <span class="type">uint32_t</span> keycode = inl(KBD_ADDR);</span><br><span class="line">  <span class="keyword">if</span> (keycode == AM_KEY_NONE) &#123;</span><br><span class="line">    kbd-&gt;keydown = <span class="literal">false</span>;</span><br><span class="line">    kbd-&gt;keycode = AM_KEY_NONE;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    kbd-&gt;keydown =(keycode &amp; KEYDOWN_MASK ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">    kbd-&gt;keycode = keycode &amp; ~KEYDOWN_MASK;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>tests/am-tests/src/main.c</code>中：<code>[&#39;k&#39;] = &quot;readkey test&quot;</code></li>
</ol>
<ul>
<li><code>make ARCH=riscv32-nemu run mainargs=k</code></li>
</ul>
<ol start="3">
<li>成功：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Got  (kbd): Y (34) DOWN</span><br><span class="line">Got  (kbd): Y (34) UP</span><br><span class="line">Got  (kbd): O (37) DOWN</span><br><span class="line">Got  (kbd): O (37) UP</span><br><span class="line">Got  (kbd): U (35) DOWN</span><br><span class="line">Got  (kbd): U (35) UP</span><br></pre></td></tr></table></figure>
<h4 id="思考：如何检测多个键同时被按下"><a href="#思考：如何检测多个键同时被按下" class="headerlink" title="思考：如何检测多个键同时被按下?"></a>思考：如何检测多个键同时被按下?</h4><ul>
<li>在游戏中, 很多时候需要判断玩家是否同时按下了多个键, 例如RPG游戏中的八方向行走, 格斗游戏中的组合招式等等. 根据键盘码的特性, 你知道这些功能是如何实现的吗?</li>
<li>思路：<ol>
<li>使用数组或位图记录按键状态</li>
</ol>
<ul>
<li>使用一个数组或位图来记录每个按键的状态（按下或释放）。</li>
<li>当接收到按键事件时，更新相应的数组或位图。</li>
</ul>
<ol start="2">
<li>检测多个键同时按下</li>
</ol>
<ul>
<li>在游戏逻辑中，检查数组或位图中多个按键的状态，判断是否同时按下了这些按键。</li>
</ul>
</li>
</ul>
<h3 id="VGA"><a href="#VGA" class="headerlink" title="VGA"></a>VGA</h3><ul>
<li>VGA可以用于显示颜色像素, 是最常用的输出设备. <code>nemu/src/device/vga.c</code>模拟了VGA的功能</li>
</ul>
<h4 id="思考：神奇的调色板"><a href="#思考：神奇的调色板" class="headerlink" title="思考：神奇的调色板"></a>思考：神奇的调色板</h4><ul>
<li>现代的显示器一般都支持24位的颜色(R, G, B各占8个bit, 共有2^8<em>2^8</em>2^8约1600万种颜色), 为了让屏幕显示不同的颜色成为可能, 在8位颜色深度时会使用调色板的概念. 调色板是一个颜色信息的数组, 每一个元素占4个字节, 分别代表R(red), G(green), B(blue), A(alpha)的值. 引入了调色板的概念之后, 一个像素存储的就不再是颜色的信息, 而是一个调色板的索引: 具体来说, 要得到一个像素的颜色信息, 就要把它的值当作下标, 在调色板这个数组中做下标运算, 取出相应的颜色信息. 因此, 只要使用不同的调色板, 就可以在不同的时刻使用不同的256种颜色了.</li>
<li>在一些90年代的游戏中(比如仙剑奇侠传), 很多渐出渐入效果都是通过调色板实现的, 聪明的你知道其中的玄机吗?</li>
<li>可以通过<strong>动态修改调色板中的颜色信息</strong>来实现渐变效果。例如，可以逐步调整调色板中的颜色值，使得屏幕上的图像逐渐变暗或变亮。</li>
</ul>
<hr>
<ul>
<li>在AM中, 显示相关的设备叫GPU, GPU是一个专门用来进行图形渲染的设备. 在NEMU中, 我们并不支持一个完整GPU的功能, 而仅仅保留绘制像素的基本功能.</li>
<li><code>abstract-machine/am/include/amdev.h</code>中为GPU定义了五个抽象寄存器, 在NEMU中只会用到其中的两个:<ol>
<li><code>AM_GPU_CONFIG</code>, <strong>AM显示控制器信息</strong>, 可<code>读出</code><strong>屏幕大小信息width和height</strong>. 另外AM假设系统<em>在运行过程中</em>, 屏幕大小<em>不会发生变化</em>.</li>
<li><code>AM_GPU_FBDRAW</code>, <strong>AM帧缓冲控制器</strong>, 可<code>写入</code><strong>绘图信息</strong>, 向屏幕<code>(x, y)</code>坐标处绘制<strong>w*h的矩形图像</strong>. 图像像素按<strong>行优先</strong>方式存储在<code>pixels</code>中, 每个像素用<code>32位整数</code>以<code>00RRGGBB</code>的方式描述颜色. 若<code>sync</code>为<code>true</code>, 则马上将帧缓冲中的内容<strong>同步到屏幕上</strong>.</li>
</ol>
</li>
</ul>
<h4 id="必做：实现IOE-3"><a href="#必做：实现IOE-3" class="headerlink" title="必做：实现IOE(3)"></a>必做：实现IOE(3)</h4><ul>
<li>事实上, VGA设备还有两个寄存器: <strong>屏幕大小寄存器</strong>和<strong>同步寄存器</strong>. 我们在讲义中并未介绍它们, 我们把它们作为相应的练习留给大家. 具体地, 屏幕大小寄存器的硬件(NEMU)功能已经实现, 但软件(AM)还没有去使用它; 而对于同步寄存器则相反, 软件(AM)已经实现了同步屏幕的功能, 但硬件(NEMU)尚未添加相应的支持.</li>
<li>好了, 提示已经足够啦, 至于要在什么地方添加什么样的代码, 就由你来RTFSC吧. 这也是明白软硬件如何协同工作的很好的练习. 实现后, 向__am_gpu_init()中添加如下测试代码:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">--- abstract-machine/am/src/platform/nemu/ioe/gpu.c</span><br><span class="line">+++ abstract-machine/am/src/platform/nemu/ioe/gpu.c</span><br><span class="line">@@ <span class="number">-6</span>,<span class="number">2</span> +<span class="number">6</span>,<span class="number">8</span> @@</span><br><span class="line"> <span class="type">void</span> __am_gpu_init() &#123;</span><br><span class="line">+  <span class="type">int</span> i;</span><br><span class="line">+  <span class="type">int</span> w = <span class="number">0</span>;  <span class="comment">// <span class="doctag">TODO:</span> get the correct width</span></span><br><span class="line">+  <span class="type">int</span> h = <span class="number">0</span>;  <span class="comment">// <span class="doctag">TODO:</span> get the correct height</span></span><br><span class="line">+  <span class="type">uint32_t</span> *fb = (<span class="type">uint32_t</span> *)(<span class="type">uintptr_t</span>)FB_ADDR;</span><br><span class="line">+  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; w * h; i ++) fb[i] = i;</span><br><span class="line">+  outl(SYNC_ADDR, <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中上述代码中的w和h并未设置正确的值, 你需要阅读am-tests中的display test测试, 理解它如何获取正确的屏幕大小, 然后修改上述代码的w和h. 你可能还需要对gpu.c中的代码进行一些修改. 修改后, 在$ISA-nemu中运行am-tests中的display test测试, 如果你的实现正确, 你会看到新窗口中输出了全屏的颜色信息.</li>
</ul>
<ol>
<li><code>nemu/src/device/vga.c</code>中<code>vga_update_screen()</code>,调用<code>update_screen</code>函数并将同步寄存器清零：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vga_update_screen</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> call `update_screen()` when the sync register is non-zero,</span></span><br><span class="line">  <span class="comment">// then zero out the sync register</span></span><br><span class="line">  <span class="keyword">if</span> (vgactl_port_base[<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">    update_screen();</span><br><span class="line">    vgactl_port_base[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>abstract-machine/am/src/platform/nemu/ioe/gpu.c</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __am_gpu_config(AM_GPU_CONFIG_T *cfg) &#123;</span><br><span class="line">  <span class="type">uint32_t</span> screen_data = inl(VGACTL_ADDR);</span><br><span class="line">  <span class="type">int</span> screen_width = (screen_data &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  <span class="type">int</span> screen_height = screen_data &amp; <span class="number">0xffff</span>;</span><br><span class="line">  <span class="type">int</span> screen_vmemsz = screen_width * screen_height * <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line"> </span><br><span class="line">  *cfg = (AM_GPU_CONFIG_T) &#123;</span><br><span class="line">    .present = <span class="literal">true</span>, .has_accel = <span class="literal">false</span>,</span><br><span class="line">    .width = screen_width, .height = screen_height,</span><br><span class="line">    .vmemsz = screen_vmemsz</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>abstract-machine/am/src/platform/nemu/ioe/gpu.c</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __am_gpu_init() &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> w=inl(VGACTL_ADDR) &gt;&gt; <span class="number">16</span>;<span class="comment">// <span class="doctag">TODO:</span> get the correct width</span></span><br><span class="line">  <span class="type">int</span> h=inl(VGACTL_ADDR)&amp; <span class="number">0x0000ffff</span>;<span class="comment">// <span class="doctag">TODO:</span> get the correct height</span></span><br><span class="line">  <span class="type">uint32_t</span> *fb = (<span class="type">uint32_t</span> *)(<span class="type">uintptr_t</span>)FB_ADDR;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; w * h; i ++) fb[i] = i;</span><br><span class="line">  outl(SYNC_ADDR, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>运行<code>  [&#39;v&#39;] = &quot;display test&quot;</code>:<code>make ARCH=riscv32-nemu run mainargs=v</code><br><img src="/2025/02/25/PA2%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-1.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<h4 id="必做：实现IOE-4"><a href="#必做：实现IOE-4" class="headerlink" title="必做：实现IOE(4)"></a>必做：实现IOE(4)</h4><ul>
<li>事实上, 刚才输出的颜色信息并不是display test期望输出的画面, 这是因为AM_GPU_FBDRAW的功能并未正确实现. 你需要正确地实现AM_GPU_FBDRAW的功能. 实现后, 重新运行display test. 如果你的实现正确, 你将会看到新窗口中输出了相应的动画效果.</li>
<li>实现正确后, 你就可以去掉上文添加的测试代码了.</li>
</ul>
<ol>
<li><code>abstract-machine/am/src/platform/nemu/ioe/gpu.c</code>:</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __am_gpu_fbdraw(AM_GPU_FBDRAW_T *ctl) &#123;</span><br><span class="line">  <span class="type">int</span> x = ctl-&gt;x, y = ctl-&gt;y, w = ctl-&gt;w, h = ctl-&gt;h;</span><br><span class="line">  <span class="type">uint32_t</span> screen_data = inl(VGACTL_ADDR);</span><br><span class="line">  <span class="type">int</span> screen_width = (screen_data &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  <span class="type">int</span> screen_height = screen_data &amp; <span class="number">0xffff</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> *pixels = (<span class="type">uint32_t</span> *)ctl-&gt;pixels;</span><br><span class="line">  <span class="type">uint32_t</span> *fb = (<span class="type">uint32_t</span> *)(<span class="type">uintptr_t</span>)FB_ADDR;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; h &amp;&amp; j &lt; screen_height - y; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; w &amp;&amp; i &lt; screen_width - x; i++) &#123;</span><br><span class="line">      fb[(j + y) * screen_width + i + x] = pixels[j * w + i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctl-&gt;sync) &#123;</span><br><span class="line">    outl(SYNC_ADDR, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>去掉测试代码</li>
<li>运行<code>  [&#39;v&#39;] = &quot;display test&quot;</code>:<code>make ARCH=riscv32-nemu run mainargs=v</code><br><img src="/2025/02/25/PA2%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-2.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3264: FPS = 2</span><br><span class="line">6388: FPS = 1</span><br><span class="line">8857: FPS = 1</span><br><span class="line">11971: FPS = 1</span><br><span class="line">15062: FPS = 1</span><br><span class="line">18262: FPS = 1</span><br><span class="line">21386: FPS = 1</span><br><span class="line">24425: FPS = 1</span><br><span class="line">27507: FPS = 1</span><br><span class="line">30531: FPS = 1</span><br><span class="line">33067: FPS = 1</span><br><span class="line">35720: FPS = 1</span><br></pre></td></tr></table></figure>
<h2 id="冯诺依曼计算机系统"><a href="#冯诺依曼计算机系统" class="headerlink" title="冯诺依曼计算机系统"></a>冯诺依曼计算机系统</h2><h4 id="展示你的计算机系统"><a href="#展示你的计算机系统" class="headerlink" title="展示你的计算机系统"></a>展示你的计算机系统</h4><ul>
<li>完整实现IOE后, 我们还可以运行一些酷炫的程序:</li>
</ul>
<ol>
<li>幻灯片播放(在<code>am-kernels/kernels/slider/</code>目录下). 程序将每隔5秒切换images&#x2F;目录下的图片.<br><img src="/2025/02/25/PA2%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-3.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>打字小游戏(在<code>am-kernels/kernels/typing-game/</code>目录下).</li>
</ol>
<ul>
<li><code>Hit: 4; Miss: 172; Wrong: 25</code>,好快哈哈哈<br><img src="/2025/02/25/PA2%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-4.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>(略)</li>
</ul>
<hr>
<ul>
<li>事实上, 游戏可以抽象成一个死循环:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  等待新的一帧();  <span class="comment">// AM_TIMER_UPTIME</span></span><br><span class="line">  处理用户按键();  <span class="comment">// AM_INPUT_KEYBRD</span></span><br><span class="line">  更新游戏逻辑();  <span class="comment">// TRM</span></span><br><span class="line">  绘制新的屏幕();  <span class="comment">// AM_GPU_FBDRAW</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们的计算机添加IOE之后, 完全可以通过AM的抽象支撑起循环体中的功能, 所以要在NEMU中运行这些酷炫的游戏, 并不是不可能的. 甚至我们也可以把刚才运行的am-tests测试中的死循环看成是一些简化的游戏. 你将要在PA3中运行的复杂游戏仙剑奇侠传, 背后也是这样的一个死循环.</li>
</ul>
<h4 id="必做：游戏是如何运行的"><a href="#必做：游戏是如何运行的" class="headerlink" title="必做：游戏是如何运行的"></a>必做：游戏是如何运行的</h4><ul>
<li>请你以打字小游戏为例, 结合”程序在计算机上运行”的两个视角, 来剖析打字小游戏究竟是如何在计算机上运行的. 具体地, 当你按下一个字母并命中的时候, 整个计算机系统(NEMU, ISA, AM, 运行时环境, 程序) 是如何协同工作, 从而让打字小游戏实现出”命中”的游戏效果?</li>
<li>打字小游戏只有不到200行的简单代码, 非常适合大家RTFSC. 如果你发现自己难以理解打字小游戏的具体行为, 你需要给自己敲响警钟了: 你在做PA的时候很有可能只关注怎么把必做内容的代码写对, 而不去思考这些代码和计算机系统的关系. 从ICS和PA的角度来说, 这种做法是不及格的, 而且很快你就会吃苦头了.</li>
</ul>
<ol>
<li>RTFSC-程序视角：</li>
<li>初始化：<br>- main() 函数首先调用 ioe_init() 和 video_init() 函数来初始化输入输出设备和视频显示。<br>- ioe_init() 初始化输入输出环境。<br>- video_init() 初始化屏幕宽度和高度，并设置字符纹理和背景颜色。</li>
<li>主循环：<br>- main() 函数进入一个无限循环，持续更新游戏逻辑和渲染屏幕。<br>- 在每一帧中，游戏逻辑通过 game_logic_update() 函数更新，处理字符的移动和状态。<br>- render() 函数负责将字符绘制到屏幕上，并显示命中、错过和错误的统计信息。</li>
<li>输入处理：<br>- 在每一帧中，游戏通过 io_read(AM_INPUT_KEYBRD) 函数读取键盘输入事件。<br>- 如果按下的键是 ESC，游戏调用 halt(0) 函数退出。<br>- 如果按下的键是字母键，游戏调用 check_hit() 函数检查是否命中字符。</li>
<li>命中处理：</li>
</ol>
<ul>
<li>check_hit() 函数遍历所有字符，检查按下的键是否与字符匹配，并且字符是否在屏幕上。</li>
<li>如果命中，更新命中统计信息，并将字符的速度设置为负值，使其向上移动。</li>
<li>如果未命中，更新错误统计信息。</li>
</ul>
<ol start="2">
<li>系统视角</li>
<li>NEMU：<br>- NEMU用于模拟计算机硬件环境。它执行打字小游戏的二进制代码，并模拟 CPU、内存和外设。<br>- 当游戏运行时，NEMU 负责解释和执行每一条指令，并处理硬件中断和设备 I&#x2F;O。</li>
<li>ISA：<br>- ISA 定义了 CPU 支持的指令集和寄存器。打字小游戏的二进制代码是基于特定 ISA 编译的。<br>- NEMU 根据 ISA 解释和执行指令，更新寄存器和内存状态。</li>
<li>AM：<br>- AM 提供了一组抽象的硬件接口，使得程序可以在不同的硬件平台上运行。<br>- 打字小游戏通过 AM 提供的接口（如 io_read() 和 io_write()）与硬件交互，而不需要关心底层硬件的具体实现。</li>
<li>运行时环境：<br>- 运行时环境包括操作系统和库函数，提供程序运行所需的基本服务。<br>- 打字小游戏依赖于运行时环境提供的输入输出、内存管理和中断处理等功能。</li>
<li>按下一个字母并命中的过程：</li>
<li>按下字母键：<br>- 用户按下一个字母键，键盘控制器生成一个键盘中断。<br>- NEMU 捕获键盘中断，并调用相应的中断处理程序。</li>
<li>处理键盘中断：<br>- 中断处理程序读取键盘输入，并将键码存储在输入缓冲区中。<br>- 游戏主循环调用 io_read(AM_INPUT_KEYBRD) 函数读取键盘输入事件。</li>
<li>检查命中：<br>- 游戏调用 check_hit() 函数，遍历所有字符，检查按下的键是否与字符匹配。<br>- 如果命中，更新命中统计信息，并将字符的速度设置为负值，使其向上移动。</li>
<li>更新屏幕：<br>- 游戏调用 render() 函数，将字符绘制到屏幕上，并显示命中、错过和错误的统计信息。<br>- NEMU 模拟 GPU，将绘制的内容显示在屏幕上。</li>
</ol>
<h3 id="必答题："><a href="#必答题：" class="headerlink" title="必答题："></a>必答题：</h3><h4 id="程序是个状态机"><a href="#程序是个状态机" class="headerlink" title="程序是个状态机"></a>程序是个状态机</h4><ul>
<li>已完成，在“不停计算的机器”</li>
</ul>
<h4 id="RTFSC-请整理一条指令在NEMU中的执行过程"><a href="#RTFSC-请整理一条指令在NEMU中的执行过程" class="headerlink" title="RTFSC 请整理一条指令在NEMU中的执行过程"></a>RTFSC 请整理一条指令在NEMU中的执行过程</h4><ul>
<li>已完成，在“RTFSC（2）”的“运行第一个C程序”中</li>
</ul>
<h4 id="程序如何运行-理解打字小游戏如何运行"><a href="#程序如何运行-理解打字小游戏如何运行" class="headerlink" title="程序如何运行 理解打字小游戏如何运行"></a>程序如何运行 理解打字小游戏如何运行</h4><ul>
<li>已完成，就在上面</li>
</ul>
<h4 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h4><ul>
<li>在<code>nemu/include/cpu/ifetch.h</code>中, 你会看到由<code>static inline</code>开头定义的<code>inst_fetch()</code>函数. 分别尝试去掉<code>static</code>, 去掉<code>inline</code>或去掉两者, 然后重新进行编译, 你可能会看到发生错误. 请分别解释为什么这些错误会发生&#x2F;不发生? 你有办法证明你的想法吗?</li>
</ul>
<ol>
<li>去掉<code>static</code>：</li>
</ol>
<ul>
<li>无错误</li>
<li>原因：去掉<code>static</code>后，函数<code>inst_fetch</code>仍然是<strong>内联函数</strong>。内联函数在编译时会<em>将函数体直接插入到调用点</em>，因此不会产生<em>多重定义</em>的问题。</li>
</ul>
<ol start="2">
<li>去掉<code>inline</code>：</li>
</ol>
<ul>
<li>无错误</li>
<li>原因：去掉<code>inline</code>后，函数<code>inst_fetch</code>仍然是<strong>静态函数</strong>。静态函数的<em>作用域仅限于定义它的文件</em>，因此不会产生<em>多重定义</em>的问题。</li>
</ul>
<ol start="3">
<li>去掉两者：</li>
</ol>
<ul>
<li>报错：</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/ld: /home/xiaoyao/ics2024/nemu/build/obj-riscv32-nemu-interpreter/src/isa/riscv32/inst.o: in function `inst_fetch&#x27;:</span><br><span class="line">/home/xiaoyao/ics2024/nemu/include/cpu/ifetch.h:20: multiple definition of `inst_fetch&#x27;; /home/xiaoyao/ics2024/nemu/build/obj-riscv32-nemu-interpreter/src/engine/interpreter/hostcall.o:/home/xiaoyao/ics2024/nemu/include/cpu/ifetch.h:20: first defined here</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">make: *** [/home/xiaoyao/ics2024/nemu/scripts/build.mk:54：/home/xiaoyao/ics2024/nemu/build/riscv32-nemu-interpreter] 错误 1</span><br></pre></td></tr></table></figure>
<ul>
<li>原因：去掉<code>static</code>和<code>inline</code>后，函数<code>inst_fetch</code>变成了一个<strong>普通的全局函数</strong>。由于头文件<code>ifetch.h</code>会<strong>被多个源文件包含</strong>，因此会导致多个源文件中都定义了<code>inst_fetch</code>函数，从而在链接时产生<strong>多重定义</strong>错误。</li>
</ul>
<h4 id="编译与链接-1"><a href="#编译与链接-1" class="headerlink" title="编译与链接"></a>编译与链接</h4><ol>
<li>在<code>nemu/include/common.h</code>中添加一行<code>volatile static int dummy</code>; 然后重新编译NEMU. 请问重新编译后的NEMU含有多少个dummy变量的实体? 你是如何得到这个结果的?</li>
<li>一共有：37个</li>
<li>方法：每个包含<code>common.h</code>的源文件都会打印dummy变量的地址，从而确认dummy变量的数量(数出37个)</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">static</span> <span class="type">int</span> dummy;</span><br><span class="line">__attribute__((constructor)) <span class="type">static</span> <span class="type">void</span> <span class="title function_">print_dummy_address</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Address of dummy: %p\n&quot;</span>, (<span class="type">void</span>*)&amp;dummy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>原因：<br>- 重新编译后的 NEMU 含有多个 dummy 变量的实体。每个包含 common.h 的源文件都会有一个独立的 dummy 变量。<br>- static 关键字使得 dummy 变量在每个源文件中都是局部的，因此每个包含 common.h 的源文件都会有一个独立的 dummy 变量。</li>
<li>添加上题中的代码后, 再在nemu&#x2F;include&#x2F;debug.h中添加一行<code>volatile static int dummy</code>; 然后重新编译NEMU. 请问此时的NEMU含有多少个dummy变量的实体? 与上题中dummy变量实体数目进行比较, 并解释本题的结果.</li>
<li>一共有：37个</li>
<li>方法：输出+数</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//common.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">static</span> <span class="type">int</span> dummy_common;</span><br><span class="line">__attribute__((constructor)) <span class="type">static</span> <span class="type">void</span> <span class="title function_">print_dummy_address_common</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Address of dummy in common.h: %p\n&quot;</span>, (<span class="type">void</span>*)&amp;dummy_common);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//debug.h</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">static</span> <span class="type">int</span> dummy;</span><br><span class="line">__attribute__((constructor)) <span class="type">static</span> <span class="type">void</span> <span class="title function_">print_dummy_address_debug</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Address of dummy in debug.h: %p\n&quot;</span>, (<span class="type">void</span>*)&amp;dummy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>比较：结果<strong>相同</strong>。</li>
<li>原因：<br>- static 关键字使得 dummy 变量<strong>在每个源文件中都是局部的</strong>，即每个包含 common.h 和 debug.h 的源文件都会有一个<strong>独立的</strong> dummy 变量。<br>- volatile 关键字告诉编译器该变量可能会被外部因素修改，因此编译器不会对该变量进行优化。<br>- debug.h 包含了 common.h，因此每个包含 debug.h 的源文件中会有两个 dummy 变量，一个来自 common.h，一个来自 debug.h。</li>
<li>修改添加的代码, 为两处dummy变量进行初始化:volatile static int dummy &#x3D; 0; 然后重新编译NEMU. 你发现了什么问题? 为什么之前没有出现这样的问题? (回答完本题后可以删除添加的代码.)</li>
</ol>
<ul>
<li>报错，<strong>重复定义</strong></li>
<li>报错原因：<ul>
<li>static 关键字：<ul>
<li><strong>static</strong>关键字使得变量<strong>在每个源文件中都是局部的</strong>，即每个包含 common.h 和 debug.h 的源文件都会有一个独立的 dummy 变量。</li>
<li>但是，当在头文件中<strong>初始化</strong> static 变量时，编译器会尝试在每个包含该头文件的源文件中定义并初始化该变量。这会导致多个定义冲突。</li>
</ul>
</li>
</ul>
</li>
<li>之前没有出现这样的问题是因为：<ul>
<li>未初始化的 static 变量：<ul>
<li>当 static 变量<strong>未初始化时</strong>，编译器只会在每个包含该头文件的源文件中生成该变量的声明，而不会生成定义和初始化代码。</li>
<li>因此，每个源文件都会有一个独立的 dummy 变量，而不会导致多个定义冲突。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="了解Makefile"><a href="#了解Makefile" class="headerlink" title="了解Makefile"></a>了解Makefile</h4><ul>
<li>请描述你在<code>am-kernels/kernels/hello/</code>目录下敲入<code>make ARCH=$ISA-nemu</code> 后, make程序如何组织<code>.c</code>和<code>.h</code>文件, 最终生成可执行文件<code>am-kernels/kernels/hello/build/hello-$ISA-nemu.elf.</code> (这个问题包括两个方面:Makefile的工作方式和编译链接的过程.) 关于Makefile工作方式的提示:<ul>
<li>Makefile中使用了变量, 包含文件等特性</li>
<li>Makefile运用并重写了一些implicit rules</li>
<li>在man make中搜索-n选项, 也许会对你有帮助</li>
<li>RTFM</li>
</ul>
</li>
</ul>
<ol>
<li>Makefile 工作方式</li>
<li>变量和包含文件<br>- 在 <code>am-kernels/kernels/hello/Makefile</code> 中是以下内容：<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">NAME = hello</span><br><span class="line">SRCS = hello.c</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(AM_HOME)</span>/Makefile</span><br></pre></td></tr></table></figure><br>- <code>NAME</code> 变量定义了目标文件的名称。<br>- <code>SRCS</code> 变量定义了源文件。<br>- <code>include $(AM_HOME)/Makefile</code> 包含了 <code>$(AM_HOME)/Makefile</code> 文件中的内容</li>
<li>隐式规则和重写<br>- Makefile 使用了一些隐式规则和重写规则来简化编译和链接过程。隐式规则是 make 的默认规则，可以自动推断如何编译和链接文件。</li>
<li>编译链接过程</li>
<li>解析 Makefile<br>- 当你在 am-kernels&#x2F;kernels&#x2F;hello&#x2F; 目录下敲入 make ARCH&#x3D;$ISA-nemu 时，make 程序首先解析 Makefile。</li>
<li>包含 $(AM_HOME)&#x2F;Makefile<br>- make 程序解析 include $(AM_HOME)&#x2F;Makefile，将 $(AM_HOME)&#x2F;Makefile 文件的内容包含进来。假设 $(AM_HOME) 是 am-kernels&#x2F;abstract-machine 目录。</li>
<li>解析 $(AM_HOME)&#x2F;Makefile<br>- 在 $(AM_HOME)&#x2F;Makefile 中，定义了一些通用规则和变量，用于编译和链接不同的目标文件。</li>
<li>编译源文件<br>- make 程序根据隐式规则和重写规则，首先编译源文件 hello.c</li>
<li>链接目标文件<br>- 编译完成后，make 程序链接目标文件 hello.o，生成可执行文件 hello-$ISA-nemu.elf</li>
</ol>
]]></content>
      <categories>
        <category>计算机系统基础实验</category>
      </categories>
      <tags>
        <tag>PA</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/02/20/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
  </entry>
  <entry>
    <title>PA3实验记录</title>
    <url>/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="PA3-穿越时空的旅程：批处理系统"><a href="#PA3-穿越时空的旅程：批处理系统" class="headerlink" title="PA3-穿越时空的旅程：批处理系统"></a>PA3-穿越时空的旅程：批处理系统</h2><h1 id="最简单的操作系统"><a href="#最简单的操作系统" class="headerlink" title="最简单的操作系统"></a>最简单的操作系统</h1><h2 id="1-批处理系统"><a href="#1-批处理系统" class="headerlink" title="1. 批处理系统"></a>1. 批处理系统</h2><ul>
<li>批处理系统的思想：<ul>
<li>事先准备好一组程序, 让计算机执行完一个程序之后, 就自动执行下一个程序</li>
</ul>
</li>
<li>批处理系统的关键：<ul>
<li>有一个后台程序, 当一个前台程序执行结束的时候, 后台程序就会自动加载一个新的前台程序来执行</li>
<li>这样的一个后台程序, 其实就是<em>操作系统</em></li>
</ul>
</li>
<li>操作系统具体又需要实现以下两点功能:  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 用户程序执行结束之后, 可以跳转到操作系统的代码继续执行</span><br><span class="line">- 操作系统可以加载一个新的用户程序来执行</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-1-来自操作系统的新需求"><a href="#1-1-来自操作系统的新需求" class="headerlink" title="1.1 来自操作系统的新需求"></a>1.1 来自操作系统的新需求</h3><ul>
<li>上述两点功能中其实蕴含着一个新的需求: <strong>程序之间的执行流切换</strong></li>
<li>能否也使用call&#x2F;jal指令来实现程序之间的执行流切换呢?<ul>
<li>如果操作系统崩溃了, 整个计算机系统都将无法工作. 所以希望能把操作系统保护起来。</li>
<li>所以这样太随意了</li>
</ul>
</li>
<li>一种可以限制入口的执行流切换方式<ul>
<li>显然, 这种方式是无法通过程序代码来实现的.</li>
</ul>
</li>
</ul>
<h3 id="1-2-等级森严的制度"><a href="#1-2-等级森严的制度" class="headerlink" title="1.2 等级森严的制度"></a>1.2 等级森严的制度</h3><ul>
<li>eg：<code>RISC-V</code>处理器存在M, S, U三个特权模式, 分别代表机器模式, 监管者模式和用户模式<ul>
<li>M模式特权级最高, U模式特权级最低,</li>
</ul>
</li>
<li>如何判断一个进程是否执行了无权限操作呢<ul>
<li>在硬件上维护一个用于标识<strong>当前特权模式</strong>的寄存器(属于计算机状态的一部分), 然后在访问那些<strong>高特权级才能访问的资源</strong>时, 对当前特权模式进行<strong>检查</strong>.</li>
<li>eg：<code>RISC-V</code>中有一条特权指令<code>sfence.vma</code>, 手册要求只有当处理器当前的特权模式不低于S模式才能执行, 因此我们可以在硬件上添加一些简单的逻辑来实现特权模式的检查:<ul>
<li><code>is_sfence_vma_ok = (priv_mode == M_MODE) || (priv_mode == S_MODE);</code></li>
</ul>
</li>
<li>如果检查不通过, 此次操作将会被判定为非法操作, CPU将会抛出异常信号, 并跳转到一个和操作系统约定好的内存位置, 交由操作系统进行后续处理.</li>
</ul>
</li>
<li>通常来说, 操作系统运行在S模式, 因此有权限访问所有的代码和数据; 而一般的程序运行在U模式, 这就决定了它只能访问U模式的代码和数据. 这样, 只要<strong>操作系统将其私有代码和数据放S模式中</strong>, 恶意程序就永远没有办法访问到它们.</li>
</ul>
<h1 id="穿越时空的旅程"><a href="#穿越时空的旅程" class="headerlink" title="穿越时空的旅程"></a>穿越时空的旅程</h1><h2 id="1-穿越时空的旅程"><a href="#1-穿越时空的旅程" class="headerlink" title="1. 穿越时空的旅程"></a>1. 穿越时空的旅程</h2><ul>
<li>自陷指令：硬件提供的一种可以限制入口的执行流切换方式</li>
<li>程序执行自陷指令之后, 就会陷入到操作系统预先设置好的跳转目标</li>
<li>异常入口地址：操作系统预先设置好的这个跳转目标</li>
</ul>
<h3 id="1-1-x86"><a href="#1-1-x86" class="headerlink" title="1.1 x86"></a>1.1 x86</h3><ul>
<li>提供<code>int</code>指令作为自陷指令</li>
<li>异常入口地址是通过*门描述符(Gate Descriptor)*来指示</li>
<li>门描述符:一个8字节的结构体<ul>
<li>NEMU中简化了门描述符的结构, 只保留存在位P和偏移量OFFSET</li>
<li>P位来用表示这一个门描述符是否有效</li>
<li>OFFSET用来指示异常入口地址</li>
</ul>
</li>
<li>IDT(Interrupt Descriptor Table, 中断描述符表), 数组的一个元素就是一个门描述符<ul>
<li>从数组中找到一个门描述符——索引</li>
<li>在内存中找到IDT——IDTR寄存器，存放IDT的首地址和长度</li>
</ul>
</li>
</ul>
<h3 id="1-2-mips32"><a href="#1-2-mips32" class="headerlink" title="1.2 mips32"></a>1.2 mips32</h3><ul>
<li>提供<code>syscall</code>指令作为自陷指令</li>
<li>异常入口地址总是<code>0x80000180</code></li>
<li>0号协处理器(Co-Processor 0)</li>
</ul>
<h3 id="1-3-riscv32"><a href="#1-3-riscv32" class="headerlink" title="1.3 riscv32"></a>1.3 riscv32</h3><ul>
<li>提供<code>ecall</code>指令作为自陷指令</li>
<li><code>mtvec寄存器</code>来存放异常入口地址</li>
<li>为了保存程序当前的状态, riscv32提供了一些特殊的系统寄存器, 叫<strong>控制状态寄存器</strong>(<code>CSR</code>寄存器)<ul>
<li>PA中, 我们只使用如下3个CSR寄存器:</li>
</ul>
<ol>
<li>mepc寄存器 - 存放触发异常的PC</li>
<li>mstatus寄存器 - 存放处理器的状态</li>
<li>mcause寄存器 - 存放触发异常的原因</li>
</ol>
</li>
<li>riscv32触发异常后硬件的响应过程如下:<ol>
<li>将当前PC值保存到mepc寄存器</li>
<li>在mcause寄存器中设置异常号</li>
<li>从mtvec寄存器中取出异常入口地址</li>
<li>跳转到异常入口地址</li>
</ol>
</li>
<li>riscv32通过<code>mret</code>指令从异常处理过程中返回, 它将根据mepc寄存器恢复PC.</li>
</ul>
<h4 id="思考：特殊的原因-建议二周目思考"><a href="#思考：特殊的原因-建议二周目思考" class="headerlink" title="思考：特殊的原因? (建议二周目思考)"></a>思考：特殊的原因? (建议二周目思考)</h4><ul>
<li>这些程序状态(x86的eflags, cs, eip; mips32的epc, status, cause; riscv32的mepc, mstatus, mcause)必须由硬件来保存吗? 能否通过软件来保存? 为什么?</li>
<li>理论上应该可以软件来保存，但是：</li>
</ul>
<ol>
<li>硬件保存这些状态寄存器比软件保存要快得多，因为硬件操作是直接的，而软件保存需要额外的指令和时间。</li>
<li>硬件保存状态寄存器在保存过程中不会被其他中断或异常打断。</li>
<li>软件保存状态需要额外的指令和代码，这会增加处理异常或中断的时间，降低系统性能，增加程序复杂性。</li>
</ol>
<h3 id="1-4-状态机视角下的异常响应机制"><a href="#1-4-状态机视角下的异常响应机制" class="headerlink" title="1.4 状态机视角下的异常响应机制"></a>1.4 状态机视角下的异常响应机制</h3><ul>
<li>程序是个<code>S = &lt;R, M&gt;</code>的状态机, 如果要给计算机添加异常响应机制, 我们又应该如何对这个状态机进行扩充呢?</li>
</ul>
<ol>
<li>首先,是对R的扩充<ul>
<li>添加系统寄存器(System Register)</li>
<li>扩充之后的寄存器可以表示为<code>R = &#123;GPR, PC, SR&#125;</code></li>
</ul>
</li>
<li>异常响应机制和内存无关, 无需对<code>M</code>的含义进行修改</li>
<li>对状态转移的扩充<ul>
<li>为了描述指令执行失败的行为, 我们可以假设CPU有一条虚构的指令<code>raise_intr</code>,执行它的行为就是异常响应过程</li>
</ul>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SR[mepc] &lt;- PC</span><br><span class="line">SR[mcause] &lt;- 一个描述失败原因的号码</span><br><span class="line">PC &lt;- SR[mtvec]</span><br></pre></td></tr></table></figure>
<ul>
<li>如果一条指令执行成功, 其行为和之前介绍的TRM与IOE相同; 如果一条指令执行失败, 其行为等价于执行了虚构的<code>raise_intr</code>指令.</li>
</ul>
</li>
</ol>
<h2 id="2-将上下文管理抽象成CTE"><a href="#2-将上下文管理抽象成CTE" class="headerlink" title="2. 将上下文管理抽象成CTE"></a>2. 将上下文管理抽象成CTE</h2><ul>
<li>操作系统的处理过程需要哪些信息<ol>
<li>引发这次执行流切换的原因</li>
<li>程序的上下文</li>
</ol>
</li>
<li>另外两个统一的API:<ul>
<li><code>bool cte_init(Context* (*handler)(Event ev, Context *ctx))</code>用于进行CTE相关的<strong>初始化操作</strong>. 其中它还接受一个来自操作系统的事件处理回调函数的指针, 当发生事件时, CTE将会把事件和相关的上下文作为参数, 来调用这个回调函数, 交由操作系统进行后续处理.</li>
<li><code>void yield()</code>用于进行<strong>自陷操作</strong>, 会触发一个编号为<code>EVENT_YIELD</code>事件. 不同的ISA会使用不同的自陷指令来触发自陷操作, 具体实现请RTFSC.</li>
</ul>
</li>
<li>接下来, 我们尝试通过<code>am-tests</code>中的<code>yield test</code>测试触发一次自陷操作, 来梳理过程中的细节</li>
</ul>
<h3 id="2-1-设置异常入口地址"><a href="#2-1-设置异常入口地址" class="headerlink" title="2.1 设置异常入口地址"></a>2.1 设置异常入口地址</h3><ul>
<li>当我们选择<code>yield test</code>时, <code>am-tests</code>会通过<code>cte_init()</code>函数对CTE进行初始化, 其中包含一些简单的宏展开代码. 这最终会调用位于<code>abstract-machine/am/src/$ISA/nemu/cte.c</code>中的<code>cte_init()</code>函数. <ul>
<li><code>cte_init()</code>函数会做两件事情, 第一件就是<em>设置异常入口地址</em>.<ul>
<li>对于riscv32来说, <strong>直接将异常入口地址设置到mtvec寄存器中</strong>即可.</li>
</ul>
</li>
<li><code>cte_init()</code>函数做的第二件事是<em>注册一个事件处理回调函数</em>, 这个回调函数由<code>yield test</code>提供, 更多信息会在下文进行介绍.</li>
</ul>
</li>
</ul>
<h3 id="2-2-触发自陷操作"><a href="#2-2-触发自陷操作" class="headerlink" title="2.2 触发自陷操作"></a>2.2 触发自陷操作</h3><ol>
<li>从<code>cte_init()</code>函数返回后, <code>yield test</code>将会调用<strong>测试主体函数</strong><code>hello_intr()</code>, 首先输出一些信息, 然后通过io_read(AM_INPUT_CONFIG)启动输入设备(不过在NEMU中, 这一启动并无实质性操作). </li>
<li>接下来<code>hello_intr()</code>将通过<code>iset(1)</code><strong>打开中断</strong>, 不过我们目前还没有实现中断相关的功能, 因此同样可以忽略这部分的代码. </li>
<li>最后<code>hello_intr()</code>将进入<strong>测试主循环</strong>: 代码将不断调用<code>yield()</code>进行<strong>自陷操作</strong>, 为了<em>防止调用频率过高导致输出过快</em>, 测试主循环中还添加了一个<em>空循环</em>用于空转.</li>
</ol>
<ul>
<li>为了<strong>支撑自陷操作</strong>, 同时<strong>测试异常入口地址是否已经设置正确</strong>, 你需要在NEMU中实现<code>isa_raise_intr()</code>函数 (在<code>nemu/src/isa/$ISA/system/intr.c</code>中定义)来模拟上文提到的异常响应机制.</li>
<li>需要注意的是:<ul>
<li>PA不涉及特权级的切换, RTFM的时候你不需要关心和特权级切换相关的内容.</li>
<li>你需要<strong>在自陷指令的实现中调用</strong><code>isa_raise_intr()</code>, 而不要把异常响应机制的代码放在自陷指令的helper函数中实现, 因为在后面我们会<strong>再次</strong>用到<code>isa_raise_intr()</code>函数.</li>
</ul>
</li>
</ul>
<h4 id="必做：实现异常响应机制"><a href="#必做：实现异常响应机制" class="headerlink" title="必做：实现异常响应机制"></a>必做：实现异常响应机制</h4><ul>
<li>你需要<ol>
<li>实现上文提到的<strong>新指令</strong>,</li>
<li>实现<code>isa_raise_intr()</code>函数</li>
<li>阅读<code>cte_init()</code>的代码, 找出相应的<strong>异常入口地址</strong>.</li>
</ol>
</li>
<li>如果你选择mips32和riscv32, 你会发现status&#x2F;mstatus寄存器中有非常多状态位, 不过目前完全不实现这些状态位的功能也不影响程序的执行, 因此目前<em>只需要将status&#x2F;mstatus寄存器看成一个只用于存放32位数据的寄存器即可</em>.</li>
<li>实现后, 重新运行<code>yield test</code>, 如果你发现NEMU确实跳转到你找到的异常入口地址, 说明你的实现正确(NEMU也可能因为触发了未实现指令而终止运行).</li>
</ul>
<ol>
<li>实现新指令在<code>nemu/src/isa/riscv32/inst.c</code><ul>
<li>实现csr写指令<code>csrrw</code></li>
<li>实现csr读指令<code>csrrs</code></li>
<li>实现<code>ecall</code></li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//csr相关宏定义</span></span><br><span class="line"><span class="type">static</span> <span class="type">vaddr_t</span> *<span class="title function_">csr_register</span><span class="params">(<span class="type">word_t</span> imm)</span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (imm)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x341</span>: <span class="keyword">return</span> &amp;(cpu.csr.mepc);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x342</span>: <span class="keyword">return</span> &amp;(cpu.csr.mcause);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x300</span>: <span class="keyword">return</span> &amp;(cpu.csr.mstatus);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x305</span>: <span class="keyword">return</span> &amp;(cpu.csr.mtvec);</span><br><span class="line">  <span class="keyword">default</span>: panic(<span class="string">&quot;Unknow csr_register:%x&quot;</span>, imm);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECALL(dnpc) &#123; bool success; dnpc = (isa_qraise_intr(isa_reg_str2val(<span class="string">&quot;a7&quot;</span>, &amp;success), s-&gt;pc)); &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR(i) *csr_register(i)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//csr有关指令</span></span><br><span class="line">INSTPAT(<span class="string">&quot;??????? ????? ????? 001 ????? 11100 11&quot;</span>, csrrw  , I, R(rd) = CSR(imm); CSR(imm) = src1);</span><br><span class="line">INSTPAT(<span class="string">&quot;??????? ????? ????? 010 ????? 11100 11&quot;</span>, csrrs  , I, R(rd) = CSR(imm); CSR(imm) |= src1);</span><br><span class="line">INSTPAT(<span class="string">&quot;0000000 00000 00000 000 00000 11100 11&quot;</span>, ecall  , N, ECALL(s-&gt;dnpc));</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在<code>nemu/src/isa/riscv32/include/isa-def.h</code>添加特殊寄存器</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">word_t</span> mepc;</span><br><span class="line">  <span class="type">word_t</span> mcause;</span><br><span class="line">  <span class="type">word_t</span> mtvec;</span><br><span class="line">  <span class="type">word_t</span> mstatus;</span><br><span class="line">&#125;MUXDEF(CONFIG_RV64, riscv64_CSRS, riscv32_CSRS);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在<code>nemu/src/isa/riscv32/system/intr.c</code>中实现<code>isa_raise_intr()</code>函数:</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">word_t</span> <span class="title function_">isa_raise_intr</span><span class="params">(<span class="type">word_t</span> NO, <span class="type">vaddr_t</span> epc)</span> &#123;</span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> Trigger an interrupt/exception with ``NO&#x27;&#x27;.</span></span><br><span class="line"><span class="comment">   * Then return the address of the interrupt/exception vector.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//保存当前的pc到mepc寄存器</span></span><br><span class="line">  cpu.csr.mepc = epc;</span><br><span class="line">  <span class="comment">//设置mcause寄存器为异常号</span></span><br><span class="line">  cpu.csr.mcause = NO;</span><br><span class="line">  <span class="comment">//获取mtvec寄存器的值</span></span><br><span class="line">  <span class="type">word_t</span> mtvec = cpu.csr.mtvec;</span><br><span class="line">  <span class="comment">//返回异常向量地址</span></span><br><span class="line">  <span class="keyword">return</span> mtvec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在<code>abstract-machine/am/src/riscv/nemu/cte.c</code>中的<code>cte_init()</code>函数中找到异常入口地址。<ul>
<li><code>asm volatile(&quot;csrw mtvec, %0&quot; : : &quot;r&quot;(__am_asm_trap));</code><ul>
<li>这行代码使用内联汇编指令<code>csrw mtvec, %0</code>,将 <code>__am_asm_trap</code> 的地址写入 mtvec 寄存器。</li>
<li>mtvec 寄存器用于<em>存储异常入口地址</em>，当发生异常时，程序会跳转到这个地址执行异常处理程序。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>因此，<strong>异常入口地址</strong>是<code>__am_asm_trap</code> 的地址。</li>
</ul>
<ol start="5">
<li>重新运行<code>yield tests</code>：</li>
</ol>
<ul>
<li>在<code>am-kernels/tests/am-tests</code>目录下<code>make ARCH=riscv32-nemu run mainargs=i</code></li>
<li>NEMU确实跳转到你找到的异常入口地址, 说明你的实现正确(NEMU也可能因为触发了未实现指令而终止运行).</li>
</ul>
<ol start="6">
<li>一直第一个指令就不行，很疑惑，改了好久实在是不知道哪里没好<ul>
<li>结果发现是写指令的时候，把新写的csr相关指令不小心放到全“？”指令之后了，导致识别不到！</li>
</ul>
</li>
</ol>
<h3 id="2-3-保存上下文"><a href="#2-3-保存上下文" class="headerlink" title="2.3 保存上下文"></a>2.3 保存上下文</h3><ul>
<li>成功跳转到异常入口地址之后——开始真正的异常处理过程</li>
<li>上下文包括：<ul>
<li><strong>通用寄存器</strong>：<ul>
<li>riscv32通过<strong>sw指令</strong>将各个通用寄存器依次<strong>压栈</strong>.</li>
</ul>
</li>
<li><strong>触发异常时的PC和处理器状态</strong>：<ul>
<li>riscv32：<code>epc/mepc</code>和<code>status/mstatus</code>寄存器, 异常响应机制把它们保存在相应的系统寄存器中, 我们还需要将它们<strong>从系统寄存器中读出</strong>, 然后<strong>保存在堆栈上</strong>.</li>
</ul>
</li>
<li><strong>异常号</strong>:<ul>
<li>riscv32中, 异常号已经由硬件保存在<code>cause/mcause</code>寄存器中, 我们还需要将其<strong>保存在堆栈上</strong>.</li>
</ul>
</li>
<li><strong>地址空间</strong>:<ul>
<li>(这是为PA4准备的)riscv32是将地址空间信息与0号寄存器共用存储空间, 反正0号寄存器的值总是0, 也不需要保存和恢复. 不过目前我们暂时不使用地址空间信息, 你目前可以忽略它们的含义.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="思考：异常号的保存"><a href="#思考：异常号的保存" class="headerlink" title="思考：异常号的保存"></a>思考：异常号的保存</h4><ul>
<li>x86通过软件来保存异常号, 没有类似cause的寄存器. mips32和riscv32也可以这样吗? 为什么?</li>
<li>对于 mips32 和 riscv32 架构，它们都有专门的寄存器（如 cause 寄存器）来保存异常号。这些寄存器的存在有以下几个原因：<ul>
<li>性能：硬件寄存器保存异常号比通过软件保存要快得多，减少了异常处理的开销。</li>
<li>简化设计：硬件寄存器使得异常处理更加简单和直接，减少了软件处理的复杂性。</li>
<li>一致性：硬件寄存器可以确保在异常发生时立即保存异常号，避免了在软件保存过程中可能出现的竞态条件。</li>
</ul>
</li>
<li>虽然 mips32 和 riscv32 理论上可以通过软件来保存异常号，但这样做会带来性能下降和设计复杂性增加的问题。因此，使用硬件寄存器来保存异常号是更为合理和高效的选择。</li>
</ul>
<h4 id="思考：对比异常处理与函数调用"><a href="#思考：对比异常处理与函数调用" class="headerlink" title="思考：对比异常处理与函数调用"></a>思考：对比异常处理与函数调用</h4><ul>
<li>我们知道进行函数调用的时候也需要<strong>保存调用者的状态</strong>: <strong>返回地址</strong>, 以及calling convention中需要<strong>调用者保存的寄存器</strong>. 而<code>CTE</code>在保存上下文的时候却要保存<em>更多的信息</em>. 尝试对比它们, 并思考两者保存信息不同是什么原因造成的.</li>
</ul>
<ol>
<li>函数调用时的状态保存<ul>
<li>以便在函数执行完毕后能够正确返回并继续执行。保存的状态包括：</li>
</ul>
<ol>
<li>返回地址：函数执行完毕后需要返回的地址。</li>
<li>调用者保存的寄存器：根据调用约定（calling convention），需要调用者保存的寄存器（如 x86 中的 ebx, esi, edi 等）。</li>
</ol>
</li>
<li>异常处理（<code>CTE</code>）时的状态保存<ul>
<li>保存更多的信息，以便在处理完异常后能够正确恢复并继续执行。保存的状态包括：</li>
</ul>
<ol>
<li>程序计数器（PC）：发生异常时的指令地址。</li>
<li>状态寄存器：处理器的状态（如 x86 中的 eflags，mips32 中的 status，riscv32 中的 mstatus）。</li>
<li>异常号：表示发生了哪种异常（如 mips32 中的 cause，riscv32 中的 mcause）。</li>
<li>其他上下文信息：可能包括更多的寄存器和处理器状态，以确保异常处理程序能够正确执行。</li>
</ol>
</li>
<li>保存信息不同的原因<ul>
<li>复杂性：异常处理比函数调用更复杂，因为异常可能发生在任何时候，处理器需要保存更多的状态信息以确保能够正确恢复执行。</li>
<li>原子性：异常处理需要确保状态保存和恢复的原子性，以避免在处理中断或异常时出现竞态条件。</li>
<li>硬件支持：异常处理通常由硬件直接支持，硬件可以快速保存和恢复状态，而函数调用主要由软件管理，保存的状态较少。</li>
<li>恢复执行：函数调用的返回地址和调用者保存的寄存器足以恢复执行，而异常处理需要保存更多的状态信息，以确保在处理完异常后能够正确恢复到异常发生前的状态。</li>
</ul>
</li>
</ol>
<hr>
<ul>
<li>接下来代码会调用C函数<code>__am_irq_handle()</code>(在<code>abstract-machine/am/src/$ISA/nemu/cte.c</code>中定义), 来<strong>进行异常的处理</strong>.</li>
</ul>
<h4 id="必做：重新组织Context结构体"><a href="#必做：重新组织Context结构体" class="headerlink" title="必做：重新组织Context结构体"></a>必做：重新组织Context结构体</h4><ul>
<li>你的任务如下:<ul>
<li>实现这一过程中的<strong>新指令</strong>, 详情请RTFM.</li>
<li>理解上下文形成的过程并RTFSC, 然后<strong>重新组织</strong><code>abstract-machine/am/include/arch/$ISA-nemu.h</code> (如果你选择RISC-V, 则文件名为riscv.h) 中定义的<strong>Context结构体的成员</strong>, <strong>使得这些成员的定义顺序和</strong><code>abstract-machine/am/src/$ISA/nemu/trap.S</code><strong>中构造的上下文保持一致</strong>.</li>
</ul>
</li>
<li>需要注意的是, 虽然我们目前暂时不使用上文提到的地址空间信息, 但你在重新组织Context结构体时<strong>仍然需要正确地处理地址空间信息的位置</strong>, 否则你可能会在PA4中遇到难以理解的错误.</li>
<li>实现之后, 你可以在<code>__am_irq_handle()</code>中通过<code>printf</code>输出上下文c的内容, 然后通过简易调试器观察触发自陷时的寄存器状态, 从而检查你的Context实现是否正确.</li>
</ul>
<ol>
<li>实现新指令：<ul>
<li><code>INSTPAT(&quot;0011000 00010 00000 000 00000 11100 11&quot;, mret   , N, s-&gt;dnpc = CSR(0x341));</code></li>
</ul>
</li>
<li>在&#96;&#96;&#96;&#96;abstract-machine&#x2F;am&#x2F;include&#x2F;arch&#x2F;riscv.h<code>中，通过</code>trap.S&#96;&#96;重排Context：</li>
</ol>
<ul>
<li>分析：在<code>trap.S</code>中：<ul>
<li>#define CONTEXT_SIZE  ((NR_REGS + 3) * XLEN)<ul>
<li>NR_REGS：表示通用寄存器的数量——通用寄存器</li>
</ul>
</li>
<li>#define OFFSET_SP     ( 2 * XLEN)<ul>
<li>OFFSET_SP：表示堆栈指针（SP）在上下文中的偏移量——*pdir</li>
</ul>
</li>
<li>#define OFFSET_CAUSE  ((NR_REGS + 0) * XLEN)<ul>
<li>mcause</li>
</ul>
</li>
<li>#define OFFSET_STATUS ((NR_REGS + 1) * XLEN)<ul>
<li>mstatus</li>
</ul>
</li>
<li>#define OFFSET_EPC    ((NR_REGS + 2) * XLEN)<ul>
<li>mepc</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Context</span> &#123;</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> fix the order of these members to match trap.S</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// uintptr_t mepc, mcause, gpr[NR_REGS], mstatus;</span></span><br><span class="line">  <span class="type">uintptr_t</span> gpr[NR_REGS];<span class="comment">//通用寄存器</span></span><br><span class="line">  <span class="type">uintptr_t</span> mcause;<span class="comment">//异常号</span></span><br><span class="line">  <span class="type">uintptr_t</span> mstatus;<span class="comment">//处理器状态</span></span><br><span class="line">  <span class="type">uintptr_t</span> mepc;<span class="comment">//异常pc</span></span><br><span class="line">  <span class="type">void</span> *pdir;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在<code>abstract-machine/am/src/riscv/nemu/cte.c</code>的<code>__am_irq_handle()</code>函数中，通过<code>printf</code>输出上下文<code>c</code>的内容:</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Context* __am_irq_handle(Context *c) &#123;<span class="comment">//异常处理函数</span></span><br><span class="line">  <span class="keyword">if</span> (user_handler) &#123;</span><br><span class="line">    Event ev = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">switch</span> (c-&gt;mcause) &#123;</span><br><span class="line">      <span class="keyword">default</span>: ev.event = EVENT_ERROR; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出上下文内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mcause = %x\n&quot;</span>, c-&gt;mcause);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mstatus = %x\n&quot;</span>, c-&gt;mstatus);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mepc = %x\n&quot;</span>, c-&gt;mepc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NR_REGS; i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;gpr[%d] = %x\n&quot;</span>, i, c-&gt;gpr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c = user_handler(ev, c);</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="必做：必答题-需要在实验报告中回答-理解上下文结构体的前世今生"><a href="#必做：必答题-需要在实验报告中回答-理解上下文结构体的前世今生" class="headerlink" title="必做：必答题(需要在实验报告中回答) - 理解上下文结构体的前世今生"></a>必做：必答题(需要在实验报告中回答) - 理解上下文结构体的前世今生</h4><ul>
<li>你会在__am_irq_handle()中看到有一个上下文结构指针c, c指向的上下文结构究竟在哪里? 这个上下文结构又是怎么来的? 具体地, 这个上下文结构有很多成员, 每一个成员究竟在哪里赋值的? $ISA-nemu.h, trap.S, 上述讲义文字, 以及你刚刚在NEMU中实现的新指令, 这四部分内容又有什么联系?</li>
<li>如果你不是脑袋足够灵光, 还是不要眼睁睁地盯着代码看了, 理解程序的细节行为还是要从状态机视角入手.</li>
</ul>
<ol>
<li>c指向的上下文结构的来源：<ul>
<li>上下文结构体<code>Context</code>是在异常处理过程中创建的。它包含了处理器的寄存器状态，包括通用寄存器、异常号、处理器状态和异常 PC 等。</li>
</ul>
</li>
<li>上下文结构体的创建过程<ol>
<li><strong>异常触发</strong>：当发生异常时，处理器会自动跳转到异常处理入口地址，该地址存储在<code>mtvec</code>寄存器中。ps:这个地址是<code>__am_asm_trap</code>。</li>
<li><strong>保存上下文</strong>：在 <code>__am_asm_trap</code> 中，使用汇编代码保存当前的处理器状态到栈中。具体来说，将所有通用寄存器、mcause、mstatus 和 mepc 寄存器的值保存到栈中。</li>
<li><strong>调用异常处理函数</strong>：保存完上下文后，我们将栈指针传递给 <code>__am_irq_handle</code> 函数，并调用它进行异常处理。</li>
</ol>
</li>
<li>上下文结构体的成员赋值:<ul>
<li>在 <code>trap.S</code> 中被赋值</li>
</ul>
<ol>
<li>保存<strong>通用寄存器</strong>：<code>MAP(REGS, PUSH)</code><ul>
<li>使用宏<code>PUSH</code>将所有通用寄存器的值保存到栈中。</li>
</ul>
</li>
<li>保存<strong>mcause、mstatus和mepc寄存器</strong>： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">csrr t0, mcause</span><br><span class="line">csrr t1, mstatus</span><br><span class="line">csrr t2, mepc</span><br><span class="line"></span><br><span class="line">STORE t0, OFFSET_CAUSE(sp)</span><br><span class="line">STORE t1, OFFSET_STATUS(sp)</span><br><span class="line">STORE t2, OFFSET_EPC(sp)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>csrr</code>指令将mcause、mstatus 和 mepc寄存器的值读取到临时寄存器t0、t1 和 t2，然后使用<code>STORE</code>宏将它们保存到栈中。</li>
</ul>
</li>
</ol>
</li>
<li>各部分内容的联系<ol>
<li><code>riscv.h</code>：定义了上下文结构体 Context，包括通用寄存器、mcause、mstatus 和 mepc 等成员。</li>
<li><code>trap.S</code>：在异常发生时，保存处理器的状态到栈中，并调用 __am_irq_handle 进行异常处理。</li>
<li><code>cte.c</code>：实现了异常处理函数 __am_irq_handle，通过指针 c 访问上下文结构体，并输出其成员的值。</li>
<li>新指令的实现：在 inst.c 中实现了 <code>csrr</code> 和 <code>csrw</code> 指令，用于读取和写入 CSR 寄存器的值。这些指令在 trap.S 中被使用，用于保存和恢复 mcause、mstatus 和 mepc 寄存器的值。</li>
</ol>
</li>
</ol>
<h3 id="2-4-事件分发"><a href="#2-4-事件分发" class="headerlink" title="2.4 事件分发"></a>2.4 事件分发</h3><ul>
<li><code>__am_irq_handle()</code>的代码会把执行流切换的原因打包成事件, 然后调用在<code>cte_init()</code>中注册的<strong>事件处理回调函数</strong>, 将事件交给<code>yield test</code>来处理.</li>
<li>在<code>yield test</code>中, 这一<strong>回调函数</strong>是<code>am-kernels/tests/am-tests/src/tests/intr.c</code>中的<code>simple_trap()</code>函数. <code>simple_trap()</code>函数会<em>根据事件类型再次进行分发</em>. 不过我们在这里会<strong>触发一个未处理的事件</strong>:<ul>
<li><code>AM Panic: Unhandled event @ am-kernels/tests/am-tests/src/tests/intr.c:12</code></li>
</ul>
</li>
<li>因为CTE的<code>__am_irq_handle()</code>函数<strong>并未正确识别出自陷事件</strong>. 根据<code>yield()</code>的定义, <code>__am_irq_handle()</code>函数需要将自陷事件打包成编号为<code>EVENT_YIELD</code>的事件.</li>
</ul>
<h4 id="必做：识别自陷事件"><a href="#必做：识别自陷事件" class="headerlink" title="必做：识别自陷事件"></a>必做：识别自陷事件</h4><ul>
<li>你需要在<code>__am_irq_handle()</code>中<strong>通过异常号识别出自陷异常</strong>, 并<strong>打包成编号为EVENT_YIELD的自陷事件</strong>. 重新运行yield test, 如果你的实现正确, 你会看到识别到自陷事件之后<strong>输出一个字符y</strong>.</li>
</ul>
<ol>
<li>在<code>__am_irq_handle()</code>中：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (c-&gt;mcause) &#123;</span><br><span class="line">      <span class="comment">//添加对异常号的处理</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: ev.event = EVENT_YIELD; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>: ev.event = EVENT_ERROR; <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>运行yield test效果：（有输出y,但很快很多，接着往下看吧！）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello, AM World @ riscv32</span><br><span class="line">  t = timer, d = device, y = yield</span><br><span class="line">yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy</span><br></pre></td></tr></table></figure>
<h3 id="2-5-恢复上下文"><a href="#2-5-恢复上下文" class="headerlink" title="2.5 恢复上下文"></a>2.5 恢复上下文</h3><ul>
<li>代码将会一路返回到<code>trap.S</code>的<code>__am_asm_trap()</code>中, 接下来的事情就是<em>恢复程序的上下文</em>. </li>
<li>之前自陷指令保存的PC,对于riscv32的ecall, 保存的是自陷指令的PC<ul>
<li>因此软件需要<strong>在适当的地方对保存的PC加上4</strong>, 使得将来返回到自陷指令的下一条指令.</li>
</ul>
</li>
<li>代码最后会返回到<code>yield test</code>触发自陷的代码位置, 然后继续执行</li>
</ul>
<h4 id="思考：从加4操作看CISC和RISC"><a href="#思考：从加4操作看CISC和RISC" class="headerlink" title="思考：从加4操作看CISC和RISC"></a>思考：从加4操作看CISC和RISC</h4><ul>
<li>事实上, 自陷只是其中一种异常类型. 有一种故障类异常, 它们返回的PC和触发异常的PC是同一个, 例如缺页异常, 在系统将故障排除后, 将会重新执行相同的指令进行重试, 因此异常返回的PC无需加4. 所以根据异常类型的不同, 有时候需要加4, 有时候则不需要加.</li>
<li>这时候, 我们就可以考虑这样的一个问题了: 决定要不要加4的, 是硬件还是软件呢? CISC和RISC的做法正好相反, CISC都交给硬件来做, 而RISC则交给软件来做. 思考一下, 这两种方案各有什么取舍? 你认为哪种更合理呢? 为什么?</li>
</ul>
<ol>
<li>硬件 vs 软件决定加4<ul>
<li>CISC（复杂指令集计算机）：通常由硬件决定是否加4。硬件会根据异常类型自动调整PC。</li>
<li>RISC（精简指令集计算机）：通常由软件决定是否加4。软件在异常处理程序中根据异常类型调整PC。</li>
</ul>
</li>
<li>取舍分析<ul>
<li>硬件决定（CISC）：<ul>
<li>优点：<ol>
<li>简化软件设计：软件不需要关心异常类型和PC的调整，减少了异常处理程序的复杂性。</li>
<li>快速响应：硬件直接处理，速度更快。</li>
</ol>
</li>
<li>缺点：<ol>
<li>硬件复杂度增加：硬件需要识别各种异常类型并做出相应处理，增加了硬件设计的复杂性。</li>
<li>灵活性较低：硬件实现的处理方式固定，软件无法灵活调整。</li>
</ol>
</li>
</ul>
</li>
<li>软件决定（RISC）：<ul>
<li>优点：<ol>
<li>硬件简单：硬件只需触发异常，不需要处理PC的调整，简化了硬件设计。</li>
<li>灵活性高：软件可以根据具体需求灵活调整PC，适应不同的异常处理需求。</li>
</ol>
</li>
<li>缺点：<ol>
<li>增加软件复杂性：异常处理程序需要识别异常类型并调整PC，增加了软件设计的复杂性。</li>
<li>响应速度较慢：软件处理需要额外的指令，可能导致响应速度较慢。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>我认为合理性取决于设计目标，<ul>
<li>如果系统设计目标是简化软件开发，提高响应速度，CISC的硬件决定方式可能更合理。</li>
<li>如果系统设计目标是简化硬件设计，提高灵活性，RISC的软件决定方式可能更合理。</li>
</ul>
</li>
</ol>
<h4 id="必做：恢复上下文"><a href="#必做：恢复上下文" class="headerlink" title="必做：恢复上下文"></a>必做：恢复上下文</h4><ul>
<li>你需要<strong>实现这一过程中的新指令</strong>. 重新运行<code>yield test</code>. 如果你的实现正确, <code>yield test</code>将<strong>不断输出y</strong>.</li>
</ul>
<ol>
<li>在<code>mret</code>指令处进行“+4”：<ul>
<li><code>INSTPAT(&quot;0011000 00010 00000 000 00000 11100 11&quot;, mret   , N, s-&gt;dnpc = CSR(0x341)+4);</code></li>
</ul>
</li>
</ol>
<ul>
<li>实现后效果：不断输出y（有节奏地输出y，没有疯狂输出了，而是遇到再输出）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello, AM World @ riscv32</span><br><span class="line">  t = timer, d = device, y = yield</span><br><span class="line">yyyyyyyyyyyyyyyyyyyyyyyyyy</span><br></pre></td></tr></table></figure>
<h4 id="必答题-需要在实验报告中回答-理解穿越时空的旅程"><a href="#必答题-需要在实验报告中回答-理解穿越时空的旅程" class="headerlink" title="必答题(需要在实验报告中回答) - 理解穿越时空的旅程"></a>必答题(需要在实验报告中回答) - 理解穿越时空的旅程</h4><ul>
<li>从<code>yield test</code>调用<code>yield()</code>开始, 到从<code>yield()</code>返回的期间, 这一趟旅程具体经历了什么? 软(AM, <code>yield test</code>)硬(NEMU)件是如何相互协助来完成这趟旅程的? 你需要解释这一过程中的每一处细节, 包括涉及的每一行汇编代码&#x2F;C代码的行为, 尤其是一些比较关键的指令&#x2F;变量. 事实上, 上文的必答题”理解上下文结构体的前世今生”已经涵盖了这趟旅程中的一部分, 你可以把它的回答包含进来.</li>
<li>别被”每一行代码”吓到了, 这个过程也就大约50行代码, 要完全理解透彻并不是不可能的. 我们之所以设置这道必答题, 是为了强迫你理解清楚这个过程中的每一处细节. 这一理解是如此重要, 以至于如果你缺少它, 接下来你面对bug几乎是束手无策.</li>
</ul>
<ol>
<li><code>yield()</code> 函数调用<ul>
<li>在 <code>yield test</code> 中，调用 <code>yield()</code> 函数：</li>
</ul>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">yield</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __riscv_e</span></span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;li a5, -1; ecall&quot;</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;li a7, -1; ecall&quot;</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这段代码使用内联汇编触发一个环境调用（ECALL）</li>
<li><code>li a7, -1</code>：将立即数 -1 加载到寄存器 a7 中</li>
<li><code>ecall</code>：触发一个环境调用异常。</li>
</ul>
</li>
<li>触发异常<ul>
<li><code>ecall</code>指令触发一个环境调用异常，处理器进入异常处理模式，并跳转到由 <code>mtvec</code> 寄存器指定的异常处理程序地址。</li>
</ul>
</li>
<li>异常处理程序(在 <code>trap.S</code> 文件中定义)：<ul>
<li><code>addi sp, sp, -CONTEXT_SIZE</code>： 为保存上下文分配空间。</li>
<li><code>MAP(REGS, PUSH)</code>： 保存所有通用寄存器的值。</li>
<li><code>csrr t0, mcause</code>： 读取 mcause 寄存器的值到 t0。</li>
<li><code>csrr t1, mstatus</code>： 读取 mstatus 寄存器的值到 t1。</li>
<li><code>csrr t2, mepc</code>： 读取 mepc 寄存器的值到 t2。</li>
<li><code>STORE t0, OFFSET_CAUSE(sp)</code>： 将 mcause 的值保存到栈中。</li>
<li><code>STORE t1, OFFSET_STATUS(sp)</code>： 将 mstatus 的值保存到栈中。</li>
<li><code>STORE t2, OFFSET_EPC(sp)</code>： 将 mepc 的值保存到栈中。</li>
<li><code>li a0, (1 &lt;&lt; 17)</code>： 将立即数 1 &lt;&lt; 17 加载到 a0 中。</li>
<li><code>or t1, t1, a0</code>： 将 t1 和 a0 进行或运算，结果存入 t1。</li>
<li><code>csrw mstatus, t1</code>： 将 t1 的值写入 mstatus 寄存器。</li>
<li><code>mv a0, sp</code>： 将栈指针的值移动到 a0。</li>
<li><code>call __am_irq_handle</code>： 调用 __am_irq_handle 函数。</li>
</ul>
</li>
<li><code>__am_irq_handle</code>函数(在 <code>cte.c</code> 文件中定义)：<ul>
<li><code>switch (c-&gt;mcause)</code>：根据 mcause 的值判断异常类型。</li>
<li><code>case 0: ev.event = EVENT_YIELD; break;</code>：如果 mcause 为 0，表示自陷异常，将事件类型设置为 EVENT_YIELD。</li>
<li><code>c = user_handler(ev, c);</code>：调用用户注册的事件处理程序 user_handler，并传递事件和上下文。</li>
</ul>
</li>
<li>用户事件处理程序(在 <code>intr.c</code> 文件中定义)：<ul>
<li><code>case EVENT_YIELD: putch(&#39;y&#39;); break;</code>：如果事件类型为 EVENT_YIELD，输出字符 y。</li>
</ul>
</li>
<li>恢复上下文并返回<ul>
<li>回到异常处理程序：</li>
<li><code>LOAD t1, OFFSET_STATUS(sp)</code>：从栈中恢复 mstatus 的值到 t1。</li>
<li><code>LOAD t2, OFFSET_EPC(sp)</code>：从栈中恢复 mepc 的值到 t2。</li>
<li><code>csrw mstatus, t1</code>：将 t1 的值写入 mstatus 寄存器。</li>
<li><code>csrw mepc, t2</code>：将 t2 的值写入 mepc 寄存器。</li>
<li><code>MAP(REGS, POP)</code>：恢复所有通用寄存器的值。</li>
<li><code>addi sp, sp, CONTEXT_SIZE</code>：释放为保存上下文分配的空间。</li>
<li><code>mret</code>：从异常处理程序返回，恢复程序的正常执行。</li>
</ul>
</li>
</ol>
<h3 id="2-6-异常处理的踪迹-etrace"><a href="#2-6-异常处理的踪迹-etrace" class="headerlink" title="2.6 异常处理的踪迹-etrace"></a>2.6 异常处理的踪迹-etrace</h3><h4 id="必做：实现etrace"><a href="#必做：实现etrace" class="headerlink" title="必做：实现etrace"></a>必做：实现etrace</h4><ul>
<li>在<code>isa_raise_intr</code>中添加：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//etrace</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nmcause = %d\n&quot;</span>,NO);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;mepc = %x\n&quot;</span>,epc);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;mtvec = %x\n&quot;</span>,mtvec);</span><br></pre></td></tr></table></figure>
<ul>
<li>效果（运行yield test）：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello, AM World @ riscv32</span><br><span class="line">  t = timer, d = device, y = yield</span><br><span class="line"></span><br><span class="line">mcause = -1</span><br><span class="line">mepc = 80001438</span><br><span class="line">mtvec = 80001448</span><br><span class="line">y</span><br><span class="line">mcause = -1</span><br><span class="line">mepc = 80001438</span><br><span class="line">mtvec = 80001448</span><br><span class="line">y</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h2 id="PA-3-1到此结束"><a href="#PA-3-1到此结束" class="headerlink" title="PA 3.1到此结束"></a>PA 3.1到此结束</h2><hr>
<h1 id="用户程序和系统调用"><a href="#用户程序和系统调用" class="headerlink" title="用户程序和系统调用"></a>用户程序和系统调用</h1><h2 id="1-最简单的操作系统"><a href="#1-最简单的操作系统" class="headerlink" title="1. 最简单的操作系统"></a>1. 最简单的操作系统</h2><ul>
<li>在PA中使用的操作系统叫<code>Nanos-lite</code>, 它是南京大学操作系统<code>Nanos</code>的裁剪版</li>
<li>Nanos-lite的框架代码, 通过执行以下命令获取:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ics2024</span><br><span class="line">bash init.sh nanos-lite</span><br></pre></td></tr></table></figure>
<ul>
<li>会通过<code>nanos-lite/include/common.h</code>中一些<strong>与实验进度相关的宏</strong>来控制<code>Nanos-lite</code>的功能</li>
<li>由于Nanos-lite本质上也是一个AM程序, 我们可以采用相同的方式来<strong>编译&#x2F;运行</strong>Nanos-lite. 在nanos-lite&#x2F;目录下执行<code>make ARCH=$ISA-nemu run</code>即可</li>
<li>需要在<code>nanos-lite/include/common.h</code>中定义<strong>宏HAS_CTE</strong>, 这样以后, Nanos-lite会多进行以下操作:<ul>
<li>初始化时调用init_irq()函数, 它将通过cte_init()函数初始化CTE</li>
<li>在panic()前调用yield()来触发自陷操作</li>
</ul>
</li>
</ul>
<h4 id="必做：为Nanos-lite实现正确的事件分发"><a href="#必做：为Nanos-lite实现正确的事件分发" class="headerlink" title="必做：为Nanos-lite实现正确的事件分发"></a>必做：为Nanos-lite实现正确的事件分发</h4><ul>
<li><code>Nanos-lite</code>的事件处理回调函数默认不处理所有事件, 你需要在其中<strong>识别出自陷事件EVENT_YIELD</strong>, 然后<strong>输出一句话</strong>即可, 目前无需进行其它操作.</li>
<li>重新运行Nanos-lite, 如果你的实现正确, 你会看到识别到自陷事件之后输出的信息, 并且最后仍然触发了main()函数末尾设置的panic().</li>
</ul>
<ol>
<li>在<code>nanos-lite/include/common.h</code>中定义<strong>宏HAS_CTE</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HAS_CTE</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>ics2024/nanos-lite/src/irq.c</code>:(中断异常处理)</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> Context* <span class="title function_">do_event</span><span class="params">(Event e, Context* c)</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (e.event) &#123;</span><br><span class="line">    <span class="keyword">case</span> EVENT_YIELD: </span><br><span class="line">      Log(<span class="string">&quot;Yield event happened&quot;</span>); </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: panic(<span class="string">&quot;Unhandled event ID = %d&quot;</span>, e.event);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>现在运行<code>make ARCH=riscv32-nemu run </code>,得到有识别到自陷事件之后输出的信息, 也有触发main()函数末尾设置的panic()：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mcause = -1</span><br><span class="line">mepc = 800005d8</span><br><span class="line">mtvec = 800005e0</span><br><span class="line">[/home/xiaoyao/ics2024/nanos-lite/src/irq.c,6,do_event] Yield event happened</span><br><span class="line">[/home/xiaoyao/ics2024/nanos-lite/src/main.c,36,main] system panic: Should not reach here</span><br><span class="line">[src/cpu/cpu-exec.c:196 cpu_exec] nemu: HIT BAD TRAP at pc = 0x80000278</span><br></pre></td></tr></table></figure>
<h2 id="2-加载第一个用户程序"><a href="#2-加载第一个用户程序" class="headerlink" title="2. 加载第一个用户程序"></a>2. 加载第一个用户程序</h2><ul>
<li>在操作系统中, 加载用户程序是由<strong>loader(加载器)模块</strong>负责的<ul>
<li>加载的过程就是把可执行文件中的代码和数据放置在正确的内存位置, 然后跳转到程序入口, 程序就开始执行了</li>
</ul>
</li>
<li>为了实现loader()函数, 我们需要解决以下问题:<ul>
<li>可执行文件在哪里?</li>
<li>代码和数据在可执行文件的哪个位置?</li>
<li>代码和数据有多少?</li>
<li>“正确的内存位置”在哪里?</li>
</ul>
</li>
<li>用户程序是从哪里来的<ul>
<li>准备了一个新的子项目<strong>Navy-apps</strong>, 专门用于<strong>编译出操作系统的用户程序</strong></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ics2024</span><br><span class="line">bash init.sh navy-apps</span><br></pre></td></tr></table></figure>
<ul>
<li>用户程序的入口位于<code>navy-apps/libs/libos/src/crt0/start.S</code>中的<code>_start()</code>函数<ul>
<li>这里的crt是C RunTime的缩写, 0的含义表示最开始. </li>
<li><code>_start()</code>函数会<ol>
<li>调用<code>navy-apps/libs/libos/src/crt0/crt0.c</code>中的<code>call_main()</code>函数</li>
<li>然后调用用户程序的main()函数</li>
<li>从main()函数返回后会调用exit()结束运行.</li>
</ol>
</li>
</ul>
</li>
<li>C库的代码”总是”对的</li>
<li>要在Nanos-lite上运行的第一个用户程序是<code>navy-apps/tests/dummy/dummy.c</code><ul>
<li>为了编译dummy, 在<code>navy-apps/tests/dummy/</code>目录下执行<code>make ISA=$ISA</code></li>
<li>一直编译不了，终端执行了<code>export NAVY_HOME=/home/xiaoyao/ics2024/navy-apps</code>之后可以了</li>
<li>编译成功后把<code>navy-apps/tests/dummy/build/dummy-$ISA</code><strong>手动复制并重命名</strong>为<code>nanos-lite/build/ramdisk.img</code>, 然后在nanos-lite&#x2F;目录下执行<code>make ARCH=$ISA-nemu</code>会生成Nanos-lite的可执行文件,</li>
</ul>
</li>
</ul>
<h4 id="思考：堆和栈在哪里"><a href="#思考：堆和栈在哪里" class="headerlink" title="思考：堆和栈在哪里?"></a>思考：堆和栈在哪里?</h4><ul>
<li>我们提到了代码和数据都在可执行文件里面, 但却没有提到堆(heap)和栈(stack). 为什么堆和栈的内容没有放入可执行文件里面? 那程序运行时刻用到的堆和栈又是怎么来的? AM的代码是否能给你带来一些启发?</li>
</ul>
<ol>
<li>堆和栈的内容没有放入可执行文件里面的原因如下：<ul>
<li>堆和栈的动态性：<ul>
<li>栈：栈用于存储函数调用的局部变量、函数参数和返回地址等。栈的大小和内容在程序运行时是动态变化的，随着函数的调用和返回，栈上的数据不断变化。</li>
<li>堆：堆用于动态分配内存，程序在运行时可以根据需要分配和释放内存。堆的大小和内容也是动态变化的，取决于程序的运行情况。</li>
</ul>
</li>
<li>可执行文件的静态性：<ul>
<li>可执行文件在编译时生成，包含了程序的代码段和数据段。这些内容在程序运行时是相对固定的，不会像堆和栈那样动态变化。</li>
</ul>
</li>
<li>堆和栈的初始化：<ul>
<li>栈：栈在程序启动时由操作系统或运行时环境初始化。通常，栈的起始地址和大小在程序加载时由操作系统分配。</li>
<li>堆：堆在程序运行时由操作系统或运行时环境管理。程序通过动态内存分配函数（如 malloc、free 等）来请求和释放堆内存。</li>
</ul>
</li>
</ul>
</li>
<li>AM代码的启发：<ul>
<li>AM 的代码中有初始化堆和栈的部分。例如，在操作系统启动时，会设置栈指针（SP）和堆指针（HP），并为它们分配初始内存区域。</li>
</ul>
</li>
</ol>
<h4 id="思考：如何识别不同格式的可执行文件"><a href="#思考：如何识别不同格式的可执行文件" class="headerlink" title="思考：如何识别不同格式的可执行文件?"></a>思考：如何识别不同格式的可执行文件?</h4><ul>
<li>从如果你在GNU&#x2F;Linux下执行一个从Windows拷过来的可执行文件, 将会报告”格式错误”. 思考一下, GNU&#x2F;Linux是如何知道”格式错误”的?</li>
</ul>
<ol>
<li>在 GNU&#x2F;Linux 下，操作系统通过检查可执行文件的文件头（header）来识别不同格式的可执行文件。每种可执行文件格式都有其特定的文件头结构和魔数（magic number），操作系统可以通过这些信息来判断文件的格式是否正确。</li>
<li>以下是一些常见的可执行文件格式及其魔数：<ol>
<li>ELF（Executable and Linkable Format）：<ul>
<li>ELF 是 GNU&#x2F;Linux 系统中常见的可执行文件格式。</li>
<li>ELF 文件的魔数是 0x7F ‘E’ ‘L’ ‘F’，即文件的前四个字节是 0x7F 45 4C 46。</li>
</ul>
</li>
<li>PE（Portable Executable）：<ul>
<li>PE 是 Windows 系统中常见的可执行文件格式。</li>
<li>PE 文件的魔数是 0x4D 5A，即文件的前两个字节是 MZ（DOS MZ 可执行文件标记）。</li>
</ul>
</li>
<li>Mach-O：<ul>
<li>Mach-O 是 macOS 系统中常见的可执行文件格式。</li>
<li>Mach-O 文件的魔数是 0xFEEDFACE 或 0xCAFEBABE，具体取决于文件的字节序。</li>
</ul>
</li>
</ol>
</li>
<li>当你在 GNU&#x2F;Linux 下执行一个从 Windows 拷贝过来的可执行文件时，操作系统会检查文件头的魔数。如果魔数不匹配，操作系统会报告“格式错误”。</li>
</ol>
<h4 id="思考：-冗余的属性"><a href="#思考：-冗余的属性" class="headerlink" title="思考： 冗余的属性?"></a>思考： 冗余的属性?</h4><ul>
<li>使用readelf查看一个ELF文件的信息, 你会看到一个segment包含两个大小的属性, 分别是FileSiz和MemSiz, 这是为什么? 再仔细观察一下, 你会发现FileSiz通常不会大于相应的MemSiz, 这又是为什么?</li>
</ul>
<ol>
<li>FileSiz 和 MemSiz 的含义：<ul>
<li>FileSiz：表示段在文件中的大小。即该段在磁盘上的实际存储大小。</li>
<li>MemSiz：表示段在内存中的大小。即该段在程序加载到内存后占用的大小。</li>
</ul>
</li>
<li>为什么需要两个属性：<ul>
<li>某些段在加载到内存后需要额外的空间来存储运行时数据。例如，BSS 段（未初始化数据段）在文件中可能只占用很小的空间（甚至为零），但在内存中需要分配实际的大小来存储未初始化的全局变量。</li>
<li>通过区分 FileSiz 和 MemSiz，操作系统可以正确地分配内存并初始化段的内容。例如，对于 BSS 段，操作系统会根据 MemSiz 分配内存，并将其内容初始化为零。</li>
</ul>
</li>
<li>为什么 FileSiz 通常不会大于 MemSiz：<ul>
<li>通常情况下，段在文件中的大小不会超过其在内存中的大小，因为文件中的内容是段的实际数据，而内存中的内容可能包含额外的运行时数据。</li>
<li>例如，代码段（text segment）和已初始化数据段（data segment）的 FileSiz 和 MemSiz 通常是相等的，因为它们在文件中和内存中的大小是一致的。</li>
<li>对于 BSS 段，FileSiz 通常为零，而 MemSiz 则表示需要分配的内存大小。</li>
</ul>
</li>
</ol>
<h4 id="思考：为什么要清零"><a href="#思考：为什么要清零" class="headerlink" title="思考：为什么要清零?"></a>思考：为什么要清零?</h4><ul>
<li>为什么需要将 <code>[VirtAddr + FileSiz, VirtAddr + MemSiz)</code> 对应的物理区间清零?</li>
<li>原因：</li>
</ul>
<ol>
<li>未初始化数据段（BSS 段）：<ul>
<li>在 ELF 文件中，BSS 段（未初始化数据段）通常在文件中不占用空间（FileSiz 为 0），但在内存中需要分配实际的大小（MemSiz）。</li>
<li>BSS 段用于存储未初始化的全局变量和静态变量，这些变量在程序启动时默认初始化为零。</li>
<li>因此，需要将 BSS 段对应的内存区域清零，以确保这些变量在程序运行时被正确初始化为零。</li>
</ul>
</li>
<li>安全性和一致性：<ul>
<li>清零内存区域可以防止程序访问未初始化的内存，从而避免潜在的安全漏洞和未定义行为。</li>
<li>确保内存区域的一致性，使得程序在不同环境下运行时具有相同的初始状态。</li>
</ul>
</li>
<li>内存分配的规范：<ul>
<li>根据内存分配的规范，未初始化的数据段在加载到内存时应该被清零。这是操作系统和运行时环境的一部分职责。</li>
</ul>
</li>
</ol>
<h4 id="必做：实现loader"><a href="#必做：实现loader" class="headerlink" title="必做：实现loader"></a>必做：实现loader</h4><ul>
<li>你需要在<code>Nanos-lite</code>中实现loader的功能, 来<strong>把用户程序加载到正确的内存位置, 然后执行用户程序</strong>. <ul>
<li>loader()函数在<code>nanos-lite/src/loader.c</code>中定义, 其中的pcb参数目前暂不使用, 可以忽略, 而因为ramdisk中目前只有一个文件, filename参数也可以忽略. 在下一个阶段实现文件系统之后, filename就派上用场了.</li>
</ul>
</li>
<li>实现后, 在<code>init_proc()</code>中调用<code>naive_uload(NULL, NULL)</code>, 它会调用你实现的loader来加载第一个用户程序, 然后跳转到用户程序中执行. <ul>
<li>如果你的实现正确, 你会看到执行dummy程序时在Nanos-lite中<strong>触发了一个未处理的4号事件</strong>. 这说明loader已经成功加载dummy, 并且成功地跳转到dummy中执行了. 关于未处理的事件, 我们会在下文进行说明.</li>
</ul>
</li>
</ul>
<ol>
<li>在<code>loader.c</code>中：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;loader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ramdisk.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uintptr_t</span> <span class="title function_">loader</span><span class="params">(PCB *pcb, <span class="type">const</span> <span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">  <span class="comment">//TODO();</span></span><br><span class="line">  <span class="comment">//读取elf文件头</span></span><br><span class="line">  Elf_Ehdr ehdr;</span><br><span class="line">  ramdisk_read(&amp;ehdr, <span class="number">0</span>, <span class="keyword">sizeof</span>(Elf_Ehdr));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//读取程序头表</span></span><br><span class="line">  Elf_Phdr phdr[ehdr.e_phnum];</span><br><span class="line">  ramdisk_read(phdr, ehdr.e_phoff, ehdr.e_phnum * <span class="keyword">sizeof</span>(Elf_Phdr));</span><br><span class="line">  <span class="comment">//加载程序段</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ehdr.e_phnum; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (phdr[i].p_type == PT_LOAD) &#123;</span><br><span class="line">      ramdisk_read((<span class="type">void</span> *)phdr[i].p_vaddr, phdr[i].p_offset, phdr[i].p_filesz);</span><br><span class="line">      <span class="comment">//把.bss段初始化为0</span></span><br><span class="line">      <span class="built_in">memset</span>((<span class="type">void</span> *)(phdr[i].p_vaddr + phdr[i].p_filesz), <span class="number">0</span>, phdr[i].p_memsz - phdr[i].p_filesz);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//返回入口地址</span></span><br><span class="line">  <span class="keyword">return</span> ehdr.e_entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>新建loader.h</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">naive_uload</span><span class="params">(PCB *pcb, <span class="type">const</span> <span class="type">char</span> *filename)</span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>新建ramdisk.h</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;common.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">ramdisk_read</span><span class="params">(<span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">ramdisk_write</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_ramdisk</span><span class="params">()</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">get_ramdisk_size</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在proc.c中：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;loader.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_proc</span><span class="params">()</span> &#123;</span><br><span class="line">  switch_boot_pcb();</span><br><span class="line"></span><br><span class="line">  Log(<span class="string">&quot;Initializing processes...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// load program here</span></span><br><span class="line">  naive_uload(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>运行效果：<ul>
<li>出现了<strong>system panic: Unhandled event ID &#x3D; 4</strong>，与文档所说相符合</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[/home/xiaoyao/ics2024/nanos-lite/src/irq.c,8,do_event] system panic: Unhandled event ID = 4</span><br><span class="line">[src/cpu/cpu-exec.c:196 cpu_exec] nemu: HIT BAD TRAP at pc = 0x80000458</span><br><span class="line">[src/cpu/cpu-exec.c:147 statistic] host time spent = 30,635 us</span><br><span class="line">[src/cpu/cpu-exec.c:148 statistic] total guest instructions = 131,423</span><br><span class="line">[src/cpu/cpu-exec.c:149 statistic] simulation frequency = 4,289,962 inst/s</span><br><span class="line">make[1]: *** [/home/xiaoyao/ics2024/nemu/scripts/native.mk:38：run] 错误 1</span><br><span class="line">make[1]: 离开目录“/home/xiaoyao/ics2024/nemu”</span><br><span class="line">make: *** [/home/xiaoyao/ics2024/abstract-machine/scripts/platform/nemu.mk:32：run] 错误 2</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="选做：检查ELF文件的魔数"><a href="#选做：检查ELF文件的魔数" class="headerlink" title="选做：检查ELF文件的魔数"></a>选做：检查ELF文件的魔数</h4><ul>
<li>我们知道ELF文件的开头都有一个特殊的魔数, 为了防止loader加载了一个非ELF格式的文件, 我们可以在loader中对魔数进行检查:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">assert(*(<span class="type">uint32_t</span> *)elf-&gt;e_ident == <span class="number">0xBadC0de</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>你需要把上述的0xBadC0de换成正确的魔数.</li>
<li>别小看这个表面上很蠢的assert(), 当你哪天手抖不知道做了什么而又被它抓到的时候, 你就知道谢天谢地了.</li>
</ul>
<ol>
<li>在loader.c中：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uintptr_t</span> <span class="title function_">loader</span><span class="params">(PCB *pcb, <span class="type">const</span> <span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 检查 ELF 文件头是否合法</span></span><br><span class="line">    assert(*(<span class="type">uint32_t</span> *)ehdr.e_ident == <span class="number">0x464c457f</span>);  <span class="comment">// 正确的 ELF 魔数</span></span><br><span class="line">    <span class="comment">//```</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-操作系统的运行时环境"><a href="#3-操作系统的运行时环境" class="headerlink" title="3. 操作系统的运行时环境"></a>3. 操作系统的运行时环境</h2><h4 id="思考：系统调用的必要性"><a href="#思考：系统调用的必要性" class="headerlink" title="思考：系统调用的必要性"></a>思考：系统调用的必要性</h4><ul>
<li>对于批处理系统来说, 系统调用是必须的吗? 如果直接把AM的API暴露给批处理系统中的程序, 会不会有问题呢?</li>
</ul>
<ol>
<li>对于批处理系统来说，系统调用是必须的。以下是原因和直接暴露 AM（Abstract Machine）API 给批处理系统中的程序可能带来的问题：<ol>
<li>资源管理和保护：<ul>
<li>系统调用：系统调用提供了一种受控的方式来访问系统资源。操作系统可以通过系统调用来管理和保护资源，确保资源的合理分配和使用，防止程序之间的相互干扰。</li>
<li>直接暴露 AM API：如果直接暴露 AM 的 API 给程序，程序可以直接访问硬件资源。这会导致资源管理混乱，程序之间可能会相互干扰，覆盖彼此的内存空间或屏幕内容，导致系统不稳定。</li>
</ul>
</li>
<li>安全性：<ul>
<li>系统调用：系统调用通过特权级别的转换来保护系统资源。用户程序在请求系统资源时，需要通过系统调用进入内核态，由操作系统进行权限检查和资源分配。</li>
<li>直接暴露 AM API：直接暴露 AM API 给程序，程序可以绕过操作系统直接访问硬件资源，可能会导致安全漏洞，恶意程序可以利用这些漏洞破坏系统或窃取敏感信息。</li>
</ul>
</li>
<li>抽象和简化：<ul>
<li>系统调用：系统调用提供了一种抽象的接口，隐藏了底层硬件的复杂性，使得程序员可以更方便地编写应用程序，而不需要关心底层硬件的细节。</li>
<li>直接暴露 AM API：直接暴露 AM API 给程序，程序员需要了解底层硬件的细节，增加了编程的复杂性和出错的可能性。</li>
</ul>
</li>
<li>可移植性：<ul>
<li>系统调用：系统调用提供了一种标准化的接口，使得应用程序可以在不同的硬件平台上运行，只需要操作系统提供相应的系统调用实现。</li>
<li>直接暴露 AM API：直接暴露 AM API 给程序，程序与特定硬件平台紧密耦合，降低了程序的可移植性。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="4-系统调用"><a href="#4-系统调用" class="headerlink" title="4. 系统调用"></a>4. 系统调用</h2><ul>
<li>触发一个系统调用的具体过程是怎么样的呢?</li>
<li>在<code>GNU/Linux</code>中, 用户程序通过<strong>自陷指令</strong>来触发系统调用, <code>Nanos-lite</code>也沿用这个约定</li>
<li>CTE中的<code>yield()</code>也是通过自陷指令来实现</li>
<li>那么对用户程序来说, 用来<em>向操作系统描述需求</em>的最方便手段就是使用<strong>通用寄存器</strong><ul>
<li>执行自陷指令之后, 执行流就会马上切换到<strong>事先设置好的入口</strong>, 通用寄存器也会作为<strong>上下文的一部分被保存</strong>起来</li>
<li><strong>系统调用处理函数</strong>只需要<em>从上下文中获取必要的信息</em>, 就能知道用户程序发出的服务请求是什么了.</li>
</ul>
</li>
<li>Navy已经为用户程序准备好了系统调用的接口了. <code>navy-apps/libs/libos/src/syscall.c</code>中定义的<code>_syscall_()</code>函数已经蕴含着上述过程:<ul>
<li>先把系统调用的参数依次放入寄存器中, 然后执行自陷指令. </li>
<li>由于寄存器和自陷指令都是ISA相关的, 因此这里根据不同的ISA定义了不同的宏, 来对它们进行抽象. </li>
<li>CTE会将这个自陷操作打包成一个系统调用事件EVENT_SYSCALL, 并交由Nanos-lite继续处理.</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">intptr_t</span> _syscall_(<span class="type">intptr_t</span> type, <span class="type">intptr_t</span> a0, <span class="type">intptr_t</span> a1, <span class="type">intptr_t</span> a2) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(SYSCALL : <span class="string">&quot;=r&quot;</span> (ret) : <span class="string">&quot;r&quot;</span>(_gpr1), <span class="string">&quot;r&quot;</span>(_gpr2), <span class="string">&quot;r&quot;</span>(_gpr3), <span class="string">&quot;r&quot;</span>(_gpr4))</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="必做：识别系统调用"><a href="#必做：识别系统调用" class="headerlink" title="必做：识别系统调用"></a>必做：识别系统调用</h4><ul>
<li>目前<code>dummy</code>已经通过<code>_syscall_()</code>直接触发系统调用, 你需要让<code>Nanos-lite</code><strong>识别出系统调用事件EVENT_SYSCALL</strong>.</li>
<li>处理器通常只会提供一条自陷指令, 这时EVENT_SYSCALL和EVENT_YIELD 都通过相同的自陷指令来实现, 因此CTE需要额外的方式区分它们. 如果自陷指令本身可以携带参数, 就可以用不同的参数指示不同的事件, 例如x86和mips32都可以采用这种方式; 如果自陷指令本身不能携带参数, 那就需要通过其他状态来区分, 一种方式是通过某个寄存器的值来区分, riscv32采用这种方式.</li>
<li>你可能需要对多处代码进行修改, 当你为代码无法实现正确而感到疑惑时, 请检查这个过程中的每一个细节. 我们已经强调了很多次, 理解细节是很重要的.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Context* __am_irq_handle(Context *c) &#123;</span><br><span class="line">  <span class="keyword">if</span> (user_handler) &#123;</span><br><span class="line">    Event ev = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">switch</span> (c-&gt;mcause) &#123;</span><br><span class="line">      <span class="comment">//添加对异常号的处理</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">-1</span>:ev.event=EVENT_YIELD;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:<span class="keyword">case</span> <span class="number">1</span>:<span class="keyword">case</span> <span class="number">2</span>:<span class="keyword">case</span> <span class="number">3</span>:<span class="keyword">case</span> <span class="number">4</span>:<span class="keyword">case</span> <span class="number">5</span>:<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:<span class="keyword">case</span> <span class="number">8</span>:<span class="keyword">case</span> <span class="number">9</span>:<span class="keyword">case</span> <span class="number">10</span>:<span class="keyword">case</span> <span class="number">11</span>:<span class="keyword">case</span> <span class="number">12</span>:<span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">14</span>:<span class="keyword">case</span> <span class="number">15</span>:<span class="keyword">case</span> <span class="number">16</span>:<span class="keyword">case</span> <span class="number">17</span>:<span class="keyword">case</span> <span class="number">18</span>:<span class="keyword">case</span> <span class="number">19</span>:ev.event=EVENT_SYSCALL;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>: ev.event = EVENT_ERROR; <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出上下文内容</span></span><br><span class="line">    <span class="comment">// printf(&quot;mcause = %x\n&quot;, c-&gt;mcause);</span></span><br><span class="line">    <span class="comment">// printf(&quot;mstatus = %x\n&quot;, c-&gt;mstatus);</span></span><br><span class="line">    <span class="comment">// printf(&quot;mepc = %x\n&quot;, c-&gt;mepc);</span></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; NR_REGS; i++) &#123;</span></span><br><span class="line">    <span class="comment">//   printf(&quot;gpr[%d] = %x\n&quot;, i, c-&gt;gpr[i]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    c = user_handler(ev, c);</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="必做：实现SYS-yield系统调用"><a href="#必做：实现SYS-yield系统调用" class="headerlink" title="必做：实现SYS_yield系统调用"></a>必做：实现SYS_yield系统调用</h4><ul>
<li>你需要:<ul>
<li>在<code>abstract-machine/am/include/arch/</code>目录下的<strong>相应头文件</strong>中实现正确的<code>GPR?</code>宏, 让它们从上下文c中获得正确的系统调用参数寄存器.</li>
<li>添加<code>SYS_yield</code>系统调用.</li>
<li>设置系统调用的返回值.</li>
</ul>
</li>
<li>重新运行dummy程序, 如果你的实现正确, 你会看到dummy程序又<strong>触发了一个号码为0的系统调用</strong>. 查看<code>nanos-lite/src/syscall.h</code>, 你会发现它是一个<code>SYS_exit</code>系统调用. 这说明之前的<code>SYS_yield</code>已经成功返回, 触发<code>SYS_exit</code>是因为dummy已经执行完毕, 准备退出了.</li>
</ul>
<ol>
<li>在<code>abstract-machine/am/include/arch/</code>目录下的相应头文件就是<code>riscv.h</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPR2 gpr[10] <span class="comment">//a0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPR3 gpr[11] <span class="comment">//a1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPR4 gpr[12] <span class="comment">//a2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPRx gpr[10] <span class="comment">//a0</span></span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>先补充完整syscall.h，再在irq.c中：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;common.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;syscall.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Context* <span class="title function_">do_event</span><span class="params">(Event e, Context* c)</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (e.event) &#123;</span><br><span class="line">    <span class="keyword">case</span> EVENT_YIELD: </span><br><span class="line">      Log(<span class="string">&quot;Yield event happened&quot;</span>); </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> EVENT_SYSCALL: do_syscall(c); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: panic(<span class="string">&quot;Unhandled event ID = %d&quot;</span>, e.event);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_irq</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  Log(<span class="string">&quot;Initializing interrupt![alt text](image-5.png)/exception handler...&quot;</span>);</span><br><span class="line">  cte_init(do_event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在syscall.c中，do_syscall:</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_syscall</span><span class="params">(Context *c)</span> &#123;</span><br><span class="line">  <span class="type">uintptr_t</span> a[<span class="number">4</span>];</span><br><span class="line">  a[<span class="number">0</span>] = c-&gt;GPR1; <span class="comment">//a7</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (a[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      yield();</span><br><span class="line">      c-&gt;GPRx = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: panic(<span class="string">&quot;Unhandled syscall ID = %d&quot;</span>, a[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>成功,dummy程序又触发了一个号码为0的系统调用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[/home/xiaoyao/ics2024/nanos-lite/src/syscall.c,12,do_syscall] system panic: Unhandled syscall ID = 0</span><br><span class="line">[src/cpu/cpu-exec.c:196 cpu_exec] nemu: HIT BAD TRAP at pc = 0x800004d8</span><br><span class="line">[src/cpu/cpu-exec.c:147 statistic] host time spent = 19,768 us</span><br><span class="line">[src/cpu/cpu-exec.c:148 statistic] total guest instructions = 132,645</span><br><span class="line">[src/cpu/cpu-exec.c:149 statistic] simulation frequency = 6,710,087 inst/s</span><br><span class="line">make[1]: *** [/home/xiaoyao/ics2024/nemu/scripts/native.mk:38：run] 错误 1</span><br></pre></td></tr></table></figure>
<ul>
<li>查看nanos-lite&#x2F;src&#x2F;syscall.h, 你会发现它是一个SYS_exit系统调用</li>
</ul>
<h4 id="必做：实现SYS-exit系统调用"><a href="#必做：实现SYS-exit系统调用" class="headerlink" title="必做：实现SYS_exit系统调用"></a>必做：实现SYS_exit系统调用</h4><ul>
<li>你需要实现<code>SYS_exit</code>系统调用, 它会接收一个退出状态的参数. 为了方便测试, 我们目前先直接使用这个参数调用<code>halt()</code>. 实现成功后, 再次运行dummy程序, 你会看到HIT GOOD TRAP的信息.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      halt(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>成功！<code>[src/cpu/cpu-exec.c:196 cpu_exec] nemu: HIT GOOD TRAP at pc = 0x800004e4</code></li>
</ul>
<h2 id="5-系统调用的踪迹："><a href="#5-系统调用的踪迹：" class="headerlink" title="5. 系统调用的踪迹："></a>5. 系统调用的踪迹：</h2><h4 id="必做：实现strace"><a href="#必做：实现strace" class="headerlink" title="必做：实现strace"></a>必做：实现strace</h4><h2 id="6-操作系统之上的TRM"><a href="#6-操作系统之上的TRM" class="headerlink" title="6. 操作系统之上的TRM"></a>6. 操作系统之上的TRM</h2><h3 id="标准输出"><a href="#标准输出" class="headerlink" title="标准输出"></a>标准输出</h3><ul>
<li>根据write的函数声明(参考man 2 write), 你需要在do_syscall()中识别出系统调用号是SYS_write之后, 检查fd的值, 如果fd是1或2(分别代表stdout和stderr), 则将buf为首地址的len字节输出到串口(使用putch()即可). 最后还要设置正确的返回值, 否则系统调用的调用者会认为write没有成功执行, 从而进行重试. 至于write系统调用的返回值是什么, 请查阅man 2 write. 另外不要忘记在navy-apps&#x2F;libs&#x2F;libos&#x2F;src&#x2F;syscall.c的_write()中调用系统调用接口函数.</li>
</ul>
<h4 id="必做：在Nanos-lite上运行Hello-world"><a href="#必做：在Nanos-lite上运行Hello-world" class="headerlink" title="必做：在Nanos-lite上运行Hello world"></a>必做：在Nanos-lite上运行Hello world</h4><ul>
<li>Navy中提供了一个<code>hello</code>测试程序(<code>navy-apps/tests/hello</code>), 它首先通过<code>write()</code>来输出一句话, 然后通过<code>printf()</code>来不断输出.</li>
<li>你需要实现<code>write()</code>系统调用, 然后把Nanos-lite上运行的用户程序切换成<code>hello</code>程序来运行.</li>
</ul>
<ol>
<li>在do_syscall中补充+完成FSwrite</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_syscall</span><span class="params">(Context *c)</span> &#123;</span><br><span class="line">  <span class="type">uintptr_t</span> a[<span class="number">4</span>];</span><br><span class="line">  a[<span class="number">0</span>] = c-&gt;GPR1; <span class="comment">//a7</span></span><br><span class="line">  a[<span class="number">1</span>] = c-&gt;GPR2; <span class="comment">//a0</span></span><br><span class="line">  a[<span class="number">2</span>] = c-&gt;GPR3; <span class="comment">//a1</span></span><br><span class="line">  a[<span class="number">3</span>] = c-&gt;GPR4; <span class="comment">//a2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (a[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//exit</span></span><br><span class="line">      halt(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//yield</span></span><br><span class="line">      yield();</span><br><span class="line">      c-&gt;GPRx = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:<span class="comment">//write</span></span><br><span class="line">      c-&gt;GPRx = FSwrite((<span class="type">intptr_t</span> *)a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: panic(<span class="string">&quot;Unhandled syscall ID = %d&quot;</span>, a[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">FSwrite</span><span class="params">(<span class="type">void</span> *buf, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">  <span class="comment">// Log(&quot;FSwrite: buf=%p, count=%d&quot;, buf, count);</span></span><br><span class="line">  <span class="comment">// if (fd == 1 || fd == 2) &#123;//fd是1或2(分别代表stdout和stderr)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">      putch(((<span class="type">char</span> *)buf)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  Log(<span class="string">&quot;FSwrite failed&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>切换成hallo程序</li>
</ol>
<ul>
<li>运行，<code>HIT GOOD TRAP at pc = 0x80000560</code>但是没有正确输出！</li>
<li>没找出问题，先往后看</li>
<li>（实现堆区管理后成功了）</li>
</ul>
<h3 id="堆区管理"><a href="#堆区管理" class="headerlink" title="堆区管理"></a>堆区管理</h3><ul>
<li>调整堆区大小是通过sbrk()库函数来实现的, 它的原型是</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">sbrk</span><span class="params">(<span class="type">intptr_t</span> increment)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="必做：实现堆区管理"><a href="#必做：实现堆区管理" class="headerlink" title="必做：实现堆区管理"></a>必做：实现堆区管理</h4><ul>
<li>根据上述内容在Nanos-lite中实现<code>SYS_brk</code>系统调用, 然后在用户层实现<code>_sbrk()</code>. 你可以通过<code>man 2 sbrk</code>来查阅libc中<code>brk()</code>和<code>sbrk()</code>的行为, 另外通过man 3 end来查阅如何使用_end符号.</li>
<li>需要注意的是, 调试的时候不要在<code>_sbrk()</code>中通过<code>printf()</code>进行输出, 这是因为<code>printf()</code>还是会尝试通过<code>malloc()</code>来申请缓冲区, 最终会再次调用<code>_sbrk()</code>, 造成死递归. 你可以通过<code>sprintf()</code>先把调试信息输出到一个字符串缓冲区中, 然后通过<code>_write()</code>进行输出.</li>
<li>如果你的实现正确, 你可以借助<code>strace</code>看到<code>printf()</code>不再是逐个字符地通过<code>write()</code>进行输出, 而是将格式化完毕的字符串通过一次性进行输出.</li>
</ul>
<ol>
<li>在do_syscall中补充</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">9</span>:<span class="comment">// brk</span></span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        c-&gt;GPRx = program_break;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        program_break = a[<span class="number">1</span>];</span><br><span class="line">        c-&gt;GPRx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在<code>/navy-apps/libs/libos/src/syscall.c</code>中：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> _end;</span><br><span class="line"><span class="type">static</span> <span class="type">intptr_t</span> cur_brk = (<span class="type">intptr_t</span>)&amp;_end;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *_sbrk(<span class="type">intptr_t</span> increment) &#123;</span><br><span class="line">  <span class="comment">// Log(&quot;sbrk&quot;);</span></span><br><span class="line">  <span class="type">intptr_t</span> old_brk = cur_brk;</span><br><span class="line">  <span class="type">intptr_t</span> new_brk = old_brk + increment;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_syscall_(SYS_brk, new_brk, <span class="number">0</span>, <span class="number">0</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Log(&quot;sbrk success&quot;);</span></span><br><span class="line">      cur_brk = new_brk;</span><br><span class="line">      <span class="keyword">return</span> (<span class="type">void</span>*)old_brk;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Log(&quot;sbrk failed&quot;);</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>成功！</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello World!</span><br><span class="line">Hello World from Navy-apps for the 2th time!</span><br><span class="line">Hello World from Navy-apps for the 3th time!</span><br><span class="line">Hello World from Navy-apps for the 4th time!</span><br><span class="line">Hello World from Navy-apps for the 5th time!</span><br><span class="line">Hello World from Navy-apps for the 6th time!</span><br><span class="line">Hello World from Navy-apps for the 7th time!</span><br><span class="line">Hello World from Navy-apps for the 8th time!</span><br><span class="line">Hello World from Navy-apps for the 9th time!</span><br><span class="line">Hello World from Navy-apps for the 10th time!</span><br><span class="line">Hello World from Navy-apps for the 11th time!</span><br><span class="line">Hello World from Navy-apps for the 12th time!</span><br><span class="line">Hello World from Navy-apps for the 13th time!</span><br><span class="line">Hello World from Navy-apps for the 14th time!</span><br><span class="line">Hello World from Navy-apps for the 15th time!</span><br><span class="line">Hello World from Navy-apps for the 16th time!</span><br><span class="line">Hello World from Navy-apps for the 17th time!</span><br><span class="line">Hello World from Navy-apps for the 18th time!</span><br><span class="line">Hello World from Navy-apps for the 19th time!</span><br><span class="line">Hello World from Navy-apps for the 20th time!</span><br><span class="line">Hello World from Navy-apps for the 21th time!</span><br><span class="line">Hello World from Navy-apps for the 22th time!</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h4 id="必答题：hello程序是什么-它从而何来-要到哪里去"><a href="#必答题：hello程序是什么-它从而何来-要到哪里去" class="headerlink" title="必答题：hello程序是什么, 它从而何来, 要到哪里去"></a>必答题：hello程序是什么, 它从而何来, 要到哪里去</h4><p>（见文档最后）</p>
<h4 id="PA3-2结束"><a href="#PA3-2结束" class="headerlink" title="PA3.2结束"></a>PA3.2结束</h4><hr>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="1-简易文件系统"><a href="#1-简易文件系统" class="headerlink" title="1. 简易文件系统"></a>1. 简易文件系统</h2><h4 id="必做：让loader使用文件-实现完整的文件系统"><a href="#必做：让loader使用文件-实现完整的文件系统" class="headerlink" title="必做：让loader使用文件+实现完整的文件系统"></a>必做：让loader使用文件+实现完整的文件系统</h4><ul>
<li>我们之前是让loader来直接调用<code>ramdisk_read()</code>来加载用户程序. ramdisk中的文件数量增加之后, 这种方式就不合适了, 我们首先需要让loader享受到文件系统的便利.</li>
<li>你需要先实现<code>fs_open()</code>, <code>fs_read()</code>和<code>fs_close()</code>, 这样就可以在loader中使用文件名来指定加载的程序了, 例如”&#x2F;bin&#x2F;hello”.</li>
<li>实现之后, 以后更换用户程序只需要修改传入<code>naive_uload()</code>函数的文件名即可.</li>
<li>实现<code>fs_write()</code>和<code>fs_lseek()</code>, 然后运行测试程序<code>navy-apps/tests/file-test</code>. 为了编译它, 你需要把它加到<code>navy-apps/Makefile</code>的TESTS变量中, 这样它最终就会被包含在ramdisk镜像中. 这个测试程序用于进行一些简单的文件读写和定位操作. 如果你的实现正确, 你将会看到程序输出**PASS!!!**的信息.</li>
</ul>
<ol>
<li>补充do_syscall()</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> SYS_open:<span class="comment">//open</span></span><br><span class="line">  c-&gt;GPRx = fs_open((<span class="type">const</span> <span class="type">char</span> *)a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SYS_read:<span class="comment">//read</span></span><br><span class="line">  c-&gt;GPRx = fs_read(a[<span class="number">1</span>], (<span class="type">char</span> *)a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SYS_lseek:<span class="comment">//lseek</span></span><br><span class="line">  c-&gt;GPRx = fs_lseek(a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SYS_close:<span class="comment">//close</span></span><br><span class="line">  c-&gt;GPRx = fs_close(a[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>libos：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> _open(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> flags, <span class="type">mode_t</span> mode) &#123;</span><br><span class="line">  <span class="keyword">return</span> _syscall_(SYS_open, (<span class="type">intptr_t</span>)path, flags, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _read(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count) &#123;</span><br><span class="line">  <span class="keyword">return</span> _syscall_(SYS_read, fd, (<span class="type">intptr_t</span>)buf, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _close(<span class="type">int</span> fd) &#123;</span><br><span class="line">  <span class="keyword">return</span> _syscall_(SYS_close, fd, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> _lseek(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence) &#123;</span><br><span class="line">  <span class="keyword">return</span> _syscall_(SYS_lseek, fd, offset, whence);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>fs.c</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line">  <span class="type">size_t</span> disk_offset;</span><br><span class="line">  ReadFn read;</span><br><span class="line">  WriteFn write;</span><br><span class="line">  <span class="type">size_t</span> open_offset;</span><br><span class="line">&#125; Finfo;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fs_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">int</span> mode)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; NR_FILES; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(file_table[i].name, pathname) == <span class="number">0</span>) &#123;</span><br><span class="line">      file_table[i].open_offset = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;no such file: %s&quot;</span>, pathname);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fs_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  assert(fd &gt;= <span class="number">0</span> &amp;&amp; fd &lt; NR_FILES);</span><br><span class="line">  <span class="keyword">if</span> (fd == FD_STDIN || fd == FD_STDOUT || fd == FD_STDERR) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Finfo *f = &amp;file_table[fd];</span><br><span class="line">  <span class="type">size_t</span> read_len = len;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;open_offset + len &gt; f-&gt;size) &#123;</span><br><span class="line">    read_len = f-&gt;size - f-&gt;open_offset;</span><br><span class="line">  &#125;</span><br><span class="line">  ramdisk_read(buf, f-&gt;disk_offset + f-&gt;open_offset, read_len);</span><br><span class="line">  f-&gt;open_offset += read_len;</span><br><span class="line">  <span class="keyword">return</span> read_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fs_write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  assert(fd &gt;= <span class="number">0</span> &amp;&amp; fd &lt; NR_FILES);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">1</span> || fd == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      putch(((<span class="type">char</span> *)buf)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Finfo *f = &amp;file_table[fd];</span><br><span class="line">  <span class="type">size_t</span> write_len = len;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;open_offset + len &gt; f-&gt;size) &#123;</span><br><span class="line">    write_len = f-&gt;size - f-&gt;open_offset;</span><br><span class="line">  &#125;</span><br><span class="line">  ramdisk_write(buf, f-&gt;disk_offset + f-&gt;open_offset, write_len);</span><br><span class="line">  f-&gt;open_offset += write_len;</span><br><span class="line">  <span class="keyword">return</span> write_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fs_lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">size_t</span> offset, <span class="type">int</span> whence)</span> &#123;</span><br><span class="line">  assert(fd &gt;= <span class="number">0</span> &amp;&amp; fd &lt; NR_FILES);</span><br><span class="line">  Finfo *f = &amp;file_table[fd];</span><br><span class="line">  <span class="type">size_t</span> new_offset = f-&gt;open_offset;</span><br><span class="line">  <span class="keyword">switch</span> (whence) &#123;</span><br><span class="line">    <span class="keyword">case</span> SEEK_SET: new_offset = offset; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SEEK_CUR: new_offset += offset; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SEEK_END: new_offset = f-&gt;size + offset; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: assert(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (new_offset &gt; f-&gt;size) &#123;</span><br><span class="line">    new_offset = f-&gt;size;</span><br><span class="line">  &#125;</span><br><span class="line">  f-&gt;open_offset = new_offset;</span><br><span class="line">  <span class="keyword">return</span> new_offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fs_close</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">  assert(fd &gt;= <span class="number">0</span> &amp;&amp; fd &lt; NR_FILES);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>loader.c更改：<ul>
<li>ramdisk改成fs</li>
</ul>
</li>
<li>proc.c更改程序</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">naive_uload(<span class="literal">NULL</span>, <span class="string">&quot;/bin/file-test&quot;</span>);</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>makefile添加file-test到TEST</li>
</ol>
<ul>
<li>记得update再run——更新应用程序列表</li>
<li>成功</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PASS!!!</span><br><span class="line">[src/cpu/cpu-exec.c:196 cpu_exec] nemu: HIT GOOD TRAP at pc = 0x80000b30</span><br></pre></td></tr></table></figure>
<h4 id="支持sfs的strace"><a href="#支持sfs的strace" class="headerlink" title="支持sfs的strace"></a>支持sfs的strace</h4><ul>
<li>由于sfs的特性, 打开同一个文件总是会返回相同的文件描述符. 这意味着, 我们可以把strace中的文件描述符直接翻译成文件名, 得到可读性更好的trace信息. 尝试实现这一功能, 它可以为你将来使用strace提供一些便利.</li>
</ul>
<h2 id="2-一切皆文件"><a href="#2-一切皆文件" class="headerlink" title="2. 一切皆文件"></a>2. 一切皆文件</h2><ul>
<li>文件就是字节序列</li>
<li>为不同的事物提供了统一的接口: 我们可以使用文件的接口来操作计算机上的一切, 而不必对它们进行详细的区分</li>
</ul>
<h3 id="虚拟文件系统-VFS"><a href="#虚拟文件系统-VFS" class="headerlink" title="虚拟文件系统 VFS"></a>虚拟文件系统 VFS</h3><ul>
<li>VFS其实是对不同种类的真实文件系统的抽象, 它用一组API来描述了这些真实文件系统的抽象行为, 屏蔽了真实文件系统之间的差异, 上层模块(比如系统调用处理函数)不必关心当前操作的文件具体是什么类型, 只要调用这一组API即可完成相应的文件操作.</li>
<li>有了VFS的概念, 要添加一个真实文件系统就非常容易了: 只要把真实文件系统的访问方式包装成VFS的API, 上层模块无需修改任何代码, 就能支持一个新的真实文件系统了.</li>
<li>在Nanos-lite中, 实现VFS的关键就是<strong>Finfo结构体中的两个读写函数指针</strong>:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> *name;         <span class="comment">// 文件名</span></span><br><span class="line">  <span class="type">size_t</span> size;        <span class="comment">// 文件大小</span></span><br><span class="line">  <span class="type">size_t</span> disk_offset;  <span class="comment">// 文件在ramdisk中的偏移</span></span><br><span class="line">  ReadFn read;        <span class="comment">// 读函数指针</span></span><br><span class="line">  WriteFn write;      <span class="comment">// 写函数指针</span></span><br><span class="line">&#125; Finfo;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中ReadFn和WriteFn分别是两种函数指针, 它们用于指向真正进行读写的函数, 并返回成功读写的字节数. 有了这两个函数指针, 我们只需要<strong>在文件记录表中对不同的文件设置不同的读写函数</strong>, 就可以通过<code>f-&gt;read()</code>和<code>f-&gt;write()</code>的方式来调用具体的读写函数了.</li>
<li>约定, 当上述的函数指针为<strong>NULL</strong>时, 表示相应文件是一个<strong>普通文件</strong>, 通过ramdisk的API来进行文件的读写,</li>
</ul>
<h3 id="操作系统之上的IOE"><a href="#操作系统之上的IOE" class="headerlink" title="操作系统之上的IOE"></a>操作系统之上的IOE</h3><ol>
<li>在Nanos-lite中, stdout和stderr都会输出到串口. 之前你可能会通过判断fd是否为1或2, 来决定<code>sys_write()</code>是否写入到串口</li>
<li>有了VFS, 只需要在<code>nanos-lite/src/device.c</code>中实现<code>serial_write()</code>, 然后在文件记录表中设置相应的写函数, 就可以实现上述功能</li>
<li>由于串口是一个字符设备, 对应的字节序列没有”位置”的概念, 因此<code>serial_write()</code>中的offset参数可以忽略.</li>
<li>另外Nanos-lite也不打算支持stdin的读入, 因此在文件记录表中设置相应的报错函数即可.</li>
</ol>
<h4 id="必做：把串口抽象成文件"><a href="#必做：把串口抽象成文件" class="headerlink" title="必做：把串口抽象成文件"></a>必做：把串口抽象成文件</h4><ul>
<li>根据上述内容, 让VFS支持串口的写入.</li>
</ul>
<ol>
<li>在<code>nanos-lite/src/device.c</code>中实现<code>serial_write()</code>,并在common.h里补充函数原型</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">serial_write</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    putch(((<span class="type">char</span> *)buf)[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在文件记录表中设置相应的写函数:在 <code>nanos-lite/src/fs.c</code> 中，将stdout和stderr的写函数设置为<code>serial_write()</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> Finfo file_table[] __attribute__((used)) = &#123;</span><br><span class="line">  [FD_STDIN]  = &#123;<span class="string">&quot;stdin&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, invalid_read, invalid_write&#125;,</span><br><span class="line">  [FD_STDOUT] = &#123;<span class="string">&quot;stdout&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, invalid_read, serial_write&#125;,</span><br><span class="line">  [FD_STDERR] = &#123;<span class="string">&quot;stderr&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, invalid_read, serial_write&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;files.h&quot;</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>修改<code>fs_read()</code>和<code>fs_write()</code>：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//read添加</span></span><br><span class="line"><span class="keyword">if</span> (f-&gt;read) &#123;</span><br><span class="line">    <span class="keyword">return</span> f-&gt;read(buf, f-&gt;open_offset, len);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//write添加</span></span><br><span class="line"><span class="keyword">if</span> (f-&gt;write) &#123;</span><br><span class="line">    <span class="keyword">return</span> f-&gt;write(buf, f-&gt;open_offset, len);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>运行helo来检验：成功！</li>
</ol>
<h4 id="必做：实现gettimeofday"><a href="#必做：实现gettimeofday" class="headerlink" title="必做：实现gettimeofday"></a>必做：实现gettimeofday</h4><ul>
<li>实现gettimeofday系统调用, 这一系统调用的参数含义请RTFM. 实现后, 在navy-apps&#x2F;tests&#x2F;中新增一个timer-test测试, 在测试中通过gettimeofday()获取当前时间, 并每过0.5秒输出一句话.</li>
</ul>
<ol>
<li>实现<code>SYS_gettimeofday</code>系统调用,syscall.c中：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_syscall</span><span class="params">(Context *c)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (a[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> SYS_gettimeofday:</span><br><span class="line">            c-&gt;GPRx = sys_gettimeofday((<span class="keyword">struct</span> timeval *)a[<span class="number">1</span>], (<span class="keyword">struct</span> timezone *)a[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_gettimeofday</span><span class="params">(<span class="keyword">struct</span> timeval *tv, <span class="keyword">struct</span> timezone *tz)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (tv) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> us = io_read(AM_TIMER_UPTIME).us;</span><br><span class="line">    tv-&gt;tv_sec = us / <span class="number">1000000</span>;</span><br><span class="line">    tv-&gt;tv_usec = us % <span class="number">1000000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>libos</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> _gettimeofday(<span class="keyword">struct</span> timeval *tv, <span class="keyword">struct</span> timezone *tz) &#123;</span><br><span class="line">  <span class="keyword">return</span> _syscall_(SYS_gettimeofday, (<span class="type">intptr_t</span>)tv, (<span class="type">intptr_t</span>)tz, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>新增<code>timer-test</code>测试程序</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//timer-test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>, <span class="title">start</span>;</span></span><br><span class="line">  gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">long</span> elapsed = (tv.tv_sec - start.tv_sec) * <span class="number">1000000</span> + (tv.tv_usec - start.tv_usec);</span><br><span class="line">    <span class="keyword">if</span> (elapsed &gt;= <span class="number">500000</span>) &#123; <span class="comment">// 0.5 秒</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;0.5 seconds passed\n&quot;</span>);</span><br><span class="line">      start = tv; <span class="comment">// 重置起始时间</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">NAME = timer-test</span><br><span class="line">SRCS = timer-test.c</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(NAVY_HOME)</span>/Makefile</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在 <code>navy-apps/Makefile</code> 中将<code>timer-test</code>添加到TESTS变量中</li>
<li>测试，成功！<br><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-6.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<h4 id="必做：实现NDL的时钟"><a href="#必做：实现NDL的时钟" class="headerlink" title="必做：实现NDL的时钟"></a>必做：实现NDL的时钟</h4><ul>
<li>你需要用<code>gettimeofday()</code>实现<code>NDL_GetTicks()</code>, 然后修改<code>timer-test</code>测试, 让它通过调用<code>NDL_GetTicks()</code>来获取当前时间. 你可以根据需要在<code>NDL_Init()</code>和<code>NDL_Quit()</code>中添加初始化代码和结束代码, 我们约定程序在使用NDL库的功能之前必须先调用<code>NDL_Init()</code>. 如果你认为无需添加初始化代码, 则无需改动它们.</li>
</ul>
<ol>
<li>NDL.c:</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">NDL_GetTicks</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">  gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> tv.tv_sec * <span class="number">1000</span> + tv.tv_usec / <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>修改测试</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;NDL.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  NDL_Init(<span class="number">0</span>);  <span class="comment">// 初始化 NDL</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> start = NDL_GetTicks();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">uint32_t</span> current = NDL_GetTicks();</span><br><span class="line">    <span class="keyword">if</span> (current - start &gt;= <span class="number">500</span>) &#123; <span class="comment">// 0.5 秒</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;0.5 seconds passed\n&quot;</span>);</span><br><span class="line">      start = current; <span class="comment">// 重置起始时间</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  NDL_Quit();  <span class="comment">// 结束 NDL</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>timer-test的makefile里添加</li>
</ol>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">LIBS = libndl</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>运行检验，成功！</li>
</ol>
<h4 id="必做：把按键输入抽象成文件"><a href="#必做：把按键输入抽象成文件" class="headerlink" title="必做：把按键输入抽象成文件"></a>必做：把按键输入抽象成文件</h4><ul>
<li>你需要:<ul>
<li>实现<code>events_read()</code>(在<code>nanos-lite/src/device.c</code>中定义), 把事件写入到buf中, 最长写入len字节, 然后返回写入的实际长度. 其中按键名已经在字符串数组names中定义好了, 你需要借助IOE的API来获得设备的输入. 另外, 若当前没有有效按键, 则返回0即可.</li>
<li>在VFS中添加对<code>/dev/events</code>的支持.</li>
<li>在NDL中实现<code>NDL_PollEvent()</code>, 从<code>/dev/events</code>中读出事件并写入到buf中.</li>
</ul>
</li>
<li>我们可以假设一次最多只会读出一个事件, 这样可以简化你的实现. 实现后, 让Nanos-lite运行<code>navy-apps/tests/event-test</code>, 如果实现正确, 敲击按键时程序会输出按键事件的信息.</li>
</ul>
<ol>
<li>实现 events_read() 函数，将事件写入到 buf 中。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">events_read</span><span class="params">(<span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  AM_INPUT_KEYBRD_T ev=io_read(AM_INPUT_KEYBRD);</span><br><span class="line">  <span class="keyword">if</span> (ev.keycode == AM_KEY_NONE) &#123;</span><br><span class="line">    *(<span class="type">char</span> *)buf = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> n =<span class="built_in">sprintf</span>((<span class="type">char</span> *)buf,<span class="string">&quot;%s %s\n&quot;</span>, ev.keydown ? <span class="string">&quot;keydown&quot;</span> : <span class="string">&quot;keyup&quot;</span>,keyname[ev.keycode]);</span><br><span class="line">  <span class="keyword">return</span> n &lt; len ? n : len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 VFS 中添加对 &#x2F;dev&#x2F;events 的支持。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fs.c</span></span><br><span class="line"><span class="type">static</span> Finfo file_table[] __attribute__((used)) = &#123;</span><br><span class="line">  [FD_STDIN]  = &#123;<span class="string">&quot;stdin&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, invalid_read, invalid_write&#125;,</span><br><span class="line">  [FD_STDOUT] = &#123;<span class="string">&quot;stdout&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, invalid_read, serial_write&#125;,</span><br><span class="line">  [FD_STDERR] = &#123;<span class="string">&quot;stderr&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, invalid_read, serial_write&#125;,</span><br><span class="line">  [FD_EVENTS] = &#123;<span class="string">&quot;/dev/events&quot;</span>, <span class="number">0</span>, <span class="number">0</span>,  events_read, invalid_write&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;files.h&quot;</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在 NDL 中实现 NDL_PollEvent()，从 &#x2F;dev&#x2F;events 中读出事件并写入到 buf 中。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">NDL_PollEvent</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/dev/events&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> read(fd, buf, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>改一下，运行event-test</li>
<li>成功！</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">receive event: keydown W</span><br><span class="line"></span><br><span class="line">receive event: keyup W</span><br><span class="line"></span><br><span class="line">receive event: keydown W</span><br><span class="line"></span><br><span class="line">receive event: keyup W</span><br><span class="line"></span><br><span class="line">receive event: keydown E</span><br><span class="line"></span><br><span class="line">receive event: keyup E</span><br><span class="line"></span><br><span class="line">receive event: keydown E</span><br><span class="line"></span><br><span class="line">receive event: keyup E</span><br></pre></td></tr></table></figure>
<h4 id="必做：在NDL中获取屏幕大小"><a href="#必做：在NDL中获取屏幕大小" class="headerlink" title="必做：在NDL中获取屏幕大小"></a>必做：在NDL中获取屏幕大小</h4><ul>
<li>实现<code>dispinfo_read()</code>(在<code>nanos-lite/src/device.c</code>中定义), 按照约定将文件的len字节写到buf中(我们认为这个文件不支持lseek, 可忽略offset).</li>
<li>在NDL中读出这个文件的内容, 从中解析出屏幕大小, 然后实现<code>NDL_OpenCanvas()</code>的功能. 目前<code>NDL_OpenCanvas()</code>只需要记录画布的大小就可以了, 当然我们要求画布大小不能超过屏幕大小.</li>
<li>让Nanos-lite运行<code>navy-apps/tests/bmp-test</code>, 由于目前还没有实现绘图功能, 因此无法输出图像内容, 但你可以先通过<code>printf()</code>输出解析出的屏幕大小.</li>
</ul>
<ol>
<li>实现 <code>dispinfo_read()</code> 函数，按照约定将文件的内容写到 buf 中。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">dispinfo_read</span><span class="params">(<span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  <span class="type">int</span> width = io_read(AM_GPU_CONFIG).width;</span><br><span class="line">  <span class="type">int</span> height = io_read(AM_GPU_CONFIG).height;</span><br><span class="line">  <span class="type">int</span> n = <span class="built_in">sprintf</span>(buf, <span class="string">&quot;WIDTH : %d\nHEIGHT : %d\n&quot;</span>, width, height);</span><br><span class="line">  <span class="keyword">return</span> n &lt; len ? n : len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>fs.c</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[FD_DISP] = &#123;<span class="string">&quot;/proc/dispinfo&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, dispinfo_read, invalid_write&#125;,</span><br><span class="line">[FD_FB] = &#123;<span class="string">&quot;/dev/fb&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, invalid_read, fb_write&#125;,</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在 NDL 中读出 <code>/proc/dispinfo</code> 文件的内容，从中解析出屏幕大小。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">NDL_Init</span><span class="params">(<span class="type">uint32_t</span> flags)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/dispinfo&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;WIDTH : %d\nHEIGHT : %d\n&quot;</span>, &amp;screen_w, &amp;screen_h);</span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;NWM_APP&quot;</span>)) &#123;</span><br><span class="line">    evtdev = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>实现 <code>NDL_OpenCanvas()</code> 的功能，记录画布的大小</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NDL_OpenCanvas</span><span class="params">(<span class="type">int</span> *w, <span class="type">int</span> *h)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;NWM_APP&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">int</span> fbctl = <span class="number">4</span>;</span><br><span class="line">    fbdev = <span class="number">5</span>;</span><br><span class="line">    screen_w = *w; screen_h = *h;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d %d&quot;</span>, screen_w, screen_h);</span><br><span class="line">    <span class="comment">// let NWM resize the window and create the frame buffer</span></span><br><span class="line">    write(fbctl, buf, len);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 3 = evtdev</span></span><br><span class="line">      <span class="type">int</span> nread = read(<span class="number">3</span>, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (nread &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      buf[nread] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, <span class="string">&quot;mmap ok&quot;</span>) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fbctl);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>实现 <code>NDL_DrawRect()</code> 的功能，向画布 (x, y) 坐标处绘制 w*h 的矩形图像</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NDL_DrawRect</span><span class="params">(<span class="type">uint32_t</span> *pixels, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/dev/fb&quot;</span>, O_WRONLY);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">    lseek(fd, ((y + i) * screen_w + x) * <span class="number">4</span>, SEEK_SET);</span><br><span class="line">    write(fd, pixels + i * w, w * <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="必做：把VGA显存抽象成文件"><a href="#必做：把VGA显存抽象成文件" class="headerlink" title="必做：把VGA显存抽象成文件"></a>必做：把VGA显存抽象成文件</h4><ul>
<li>在<code>init_fs()</code>(在<code>nanos-lite/src/fs.c</code>中定义)中对文件记录表中<code>/dev/fb</code>的大小进行初始化.</li>
<li>实现<code>fb_write()</code>(在<code>nanos-lite/src/device.c</code>中定义), 用于把buf中的len字节写到屏幕上offset处. 你需要先从offset计算出屏幕上的坐标, 然后调用IOE来进行绘图. 另外我们约定每次绘图后总是马上将frame buffer中的内容同步到屏幕上.</li>
<li>在NDL中实现<code>NDL_DrawRect()</code>, 通过往&#x2F;dev&#x2F;fb中的正确位置写入像素信息来绘制图像. 你需要梳理清楚系统屏幕(即frame buffer), <code>NDL_OpenCanvas()</code>打开的画布, 以及<code>NDL_DrawRect()</code>指示的绘制区域之间的位置关系.</li>
<li>让Nanos-lite运行<code>navy-apps/tests/bmp-test</code>, 如果实现正确, 你将会看到屏幕上显示Project-N的logo.</li>
</ul>
<ol>
<li><code>nanos-lite/src/fs.c</code> 中的 <code>init_fs()</code> 函数中对 <code>/dev/fb</code> 的大小进行初始化：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_fs</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> initialize the size of /dev/fb</span></span><br><span class="line">  <span class="comment">// 获取屏幕大小</span></span><br><span class="line">  <span class="type">int</span> width = io_read(AM_GPU_CONFIG).width;</span><br><span class="line">  <span class="type">int</span> height = io_read(AM_GPU_CONFIG).height;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 /dev/fb 的大小</span></span><br><span class="line">  file_table[FD_FB].size = width * height * <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在 <code>nanos-lite/src/device.c</code> 中实现 <code>fb_write()</code> 函数：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fb_write</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  <span class="type">int</span> width = io_read(AM_GPU_CONFIG).width;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算起始坐标</span></span><br><span class="line">  <span class="type">int</span> x = (offset / <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>)) % width;</span><br><span class="line">  <span class="type">int</span> y = (offset / <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>)) / width;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算写入的像素数</span></span><br><span class="line">  <span class="type">int</span> pixels = len / <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 IOE 绘图</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pixels; i++) &#123;</span><br><span class="line">    <span class="type">int</span> px = (x + i) % width;</span><br><span class="line">    <span class="type">int</span> py = y + (x + i) / width;</span><br><span class="line">    <span class="type">uint32_t</span> pixel = ((<span class="type">uint32_t</span> *)buf)[i];</span><br><span class="line">    io_write(AM_GPU_FBDRAW, px, py, &amp;pixel, <span class="number">1</span>, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在 <code>navy-apps/libs/libndl/NDL.c</code> 中实现 <code>NDL_DrawRect()</code> 函数：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NDL_DrawRect</span><span class="params">(<span class="type">uint32_t</span> *pixels, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/dev/fb&quot;</span>, O_WRONLY);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">    lseek(fd, ((y + i) * screen_w + x) * <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>), SEEK_SET);</span><br><span class="line">    write(fd, pixels + i * w, w * <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>成功！<br><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-7.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<hr>
<h1 id="精彩纷呈的应用程序"><a href="#精彩纷呈的应用程序" class="headerlink" title="精彩纷呈的应用程序"></a>精彩纷呈的应用程序</h1><h2 id="1-更丰富的运行时环境"><a href="#1-更丰富的运行时环境" class="headerlink" title="1. 更丰富的运行时环境"></a>1. 更丰富的运行时环境</h2><h3 id="多媒体库"><a href="#多媒体库" class="headerlink" title="多媒体库"></a>多媒体库</h3><ul>
<li>miniSDL的代码位于<code>navy-apps/libs/libminiSDL/</code>目录下, 它由6个模块组成:<ul>
<li>timer.c: 时钟管理</li>
<li>event.c: 事件处理</li>
<li>video.c: 绘图接口</li>
<li>file.c: 文件抽象</li>
<li>audio.c: 音频播放</li>
<li>general.c: 常规功能, 包括初始化, 错误管理等</li>
</ul>
</li>
</ul>
<h3 id="定点算术"><a href="#定点算术" class="headerlink" title="定点算术"></a>定点算术</h3><ul>
<li>定点数也可以实现实数!,而且定点数的运算可以通过整数运算来实现, 意味着我们可以通过整数运算指令来实现实数的逻辑, 而无需在硬件上引入FPU来运行这些程序. 这样的一个算术体系称为<strong>定点算术</strong>.</li>
<li>Navy中提供了一个fixedptc的库, 专门用于进行定点算术. fixedptc库默认采用32位整数来表示实数, 其具体格式为”24.8” (见<code>navy-apps/libs/libfixedptc/include/fixedptc.h</code>), 表示整数部分占24位, 小数部分占8位, 也可以认为实数的小数点总是固定位于第8位二进制数的左边.</li>
<li>fixedpt类型的常见运算<ul>
<li>加法可以直接用整数加法来进行</li>
<li>减法可以用整数减法来进行</li>
<li>乘法，相乘后将结果除以2^8</li>
<li>除法，结果再乘以2^8</li>
<li>关系运算，都可以用整数的关系运算来进行</li>
</ul>
</li>
</ul>
<h4 id="必做：实现更多的fixedptc-API"><a href="#必做：实现更多的fixedptc-API" class="headerlink" title="必做：实现更多的fixedptc API"></a>必做：实现更多的fixedptc API</h4><ul>
<li>为了让大家更好地理解定点数的表示, 我们在<code>fixedptc.h</code>中<strong>去掉了一些API的实现, 你需要实现它们</strong>. </li>
<li>关于<code>fixedpt_floor()</code>和<code>fixedpt_ceil()</code>, 你需要严格按照man中<code>floor()</code>和<code>ceil()</code>的语义来实现它们, 否则在程序中用<code>fixedpt_floor()</code>代替<code>floor()</code>之后行为会产生差异, 在类似仙剑奇侠传这种规模较大的程序中, 这种差异导致的现象是非常难以理解的. 因此你也最好自己编写一些测试用例来测试你的实现.</li>
</ul>
<ol>
<li>补充</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Multiplies a fixedpt number with an integer, returns the result. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_muli</span><span class="params">(fixedpt A, <span class="type">int</span> B)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> A * B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Divides a fixedpt number with an integer, returns the result. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_divi</span><span class="params">(fixedpt A, <span class="type">int</span> B)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> A / B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multiplies two fixedpt numbers, returns the result. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_mul</span><span class="params">(fixedpt A, fixedpt B)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (A * B) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Divides two fixedpt numbers, returns the result. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_div</span><span class="params">(fixedpt A, fixedpt B)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (A / B) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_abs</span><span class="params">(fixedpt A)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> A &lt; <span class="number">0</span> ? -A : A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_floor</span><span class="params">(fixedpt A)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> A &amp; ~FIXEDPT_FMASK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_ceil</span><span class="params">(fixedpt A)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (A &amp; FIXEDPT_FMASK) ? (A &amp; ~FIXEDPT_FMASK) + FIXEDPT_ONE : A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>编写测试用例</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../../libs/libfixedptc/include/fixedptc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_fixedpt_floor</span><span class="params">()</span> &#123;</span><br><span class="line">    fixedpt a = fixedpt_rconst(<span class="number">1.2</span>);</span><br><span class="line">    fixedpt b = fixedpt_rconst(<span class="number">-1.2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fixedpt_floor(1.2) = %d\n&quot;</span>, fixedpt_floor(a) &gt;&gt; FIXEDPT_FBITS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fixedpt_floor(-1.2) = %d\n&quot;</span>, fixedpt_floor(b) &gt;&gt; FIXEDPT_FBITS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_fixedpt_ceil</span><span class="params">()</span> &#123;</span><br><span class="line">    fixedpt a = fixedpt_rconst(<span class="number">1.2</span>);</span><br><span class="line">    fixedpt b = fixedpt_rconst(<span class="number">-1.2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fixedpt_ceil(1.2) = %d\n&quot;</span>, fixedpt_ceil(a) &gt;&gt; FIXEDPT_FBITS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fixedpt_ceil(-1.2) = %d\n&quot;</span>, fixedpt_ceil(b) &gt;&gt; FIXEDPT_FBITS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_fixedpt_abs</span><span class="params">()</span> &#123;</span><br><span class="line">    fixedpt b = fixedpt_rconst(<span class="number">-1.2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fixedpt_abs(-1.2) = %d\n&quot;</span>, fixedpt_abs(b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_fixedpt_muli</span><span class="params">()</span> &#123;</span><br><span class="line">    fixedpt a = fixedpt_rconst(<span class="number">1.2</span>);</span><br><span class="line">    <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fixedpt_muli(1.2, 3) = %d\n&quot;</span>, fixedpt_muli(a, c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_fixedpt_divi</span><span class="params">()</span> &#123;</span><br><span class="line">    fixedpt a = fixedpt_rconst(<span class="number">1.2</span>);</span><br><span class="line">    <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fixedpt_divi(1.2, 3) = %d\n&quot;</span>, fixedpt_divi(a, c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_fixedpt_mul</span><span class="params">()</span> &#123;</span><br><span class="line">    fixedpt a = fixedpt_rconst(<span class="number">1.2</span>);</span><br><span class="line">    fixedpt b = fixedpt_rconst(<span class="number">-1.2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fixedpt_mul(1.2, -1.2) = %d\n&quot;</span>, fixedpt_mul(a, b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_fixedpt_div</span><span class="params">()</span> &#123;</span><br><span class="line">    fixedpt a = fixedpt_rconst(<span class="number">1.2</span>);</span><br><span class="line">    fixedpt b = fixedpt_rconst(<span class="number">-1.2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fixedpt_div(1.2, -1.2) = %d\n&quot;</span>, fixedpt_div(a, b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    test_fixedpt_floor();</span><br><span class="line">    test_fixedpt_ceil();</span><br><span class="line">    test_fixedpt_abs();</span><br><span class="line">    test_fixedpt_muli();</span><br><span class="line">    test_fixedpt_divi();</span><br><span class="line">    test_fixedpt_mul();</span><br><span class="line">    test_fixedpt_div();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0xfffffe00 = %d\n&quot;</span>, <span class="number">0xfffffe00</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>测试结果,正确</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fixedpt_floor(1.2) = 1</span><br><span class="line">fixedpt_floor(-1.2) = -2</span><br><span class="line">fixedpt_ceil(1.2) = 2</span><br><span class="line">fixedpt_ceil(-1.2) = -1</span><br><span class="line">fixedpt_abs(-1.2) = 307</span><br><span class="line">fixedpt_muli(1.2, 3) = 921</span><br><span class="line">fixedpt_divi(1.2, 3) = 102</span><br><span class="line">fixedpt_mul(1.2, -1.2) = -369</span><br><span class="line">fixedpt_div(1.2, -1.2) = -256</span><br><span class="line">0xfffffe00 = -512</span><br></pre></td></tr></table></figure>
<h3 id="Navy作为基础设施"><a href="#Navy作为基础设施" class="headerlink" title="Navy作为基础设施"></a>Navy作为基础设施</h3><ul>
<li>你可以在bmp-test所在的目录下运行<code>make ISA=native run</code>, 来把bmp-test编译到Navy native上并直接运行, 还可以通过<code>make ISA=native gdb</code>对它进行调试. 这样你就可以在Linux native的环境下单独测试Navy中除了libos和Newlib之外的所有代码了(例如NDL和miniSDL). 一个例外是Navy中的dummy, 由于它通过_syscall_()直接触发系统调用, 这样的代码并不能直接在Linux native上直接运行, 因为Linux不存在这个系统调用(或者编号不同).</li>
</ul>
<h2 id="2-Navy中的应用程序"><a href="#2-Navy中的应用程序" class="headerlink" title="2. Navy中的应用程序"></a>2. Navy中的应用程序</h2><h3 id="NSlider-NJU-Slider"><a href="#NSlider-NJU-Slider" class="headerlink" title="NSlider (NJU Slider)"></a>NSlider (NJU Slider)</h3><ul>
<li>一个支持翻页的幻灯片播放器</li>
<li>需要实现以下两个与Surface相关的API:<ul>
<li><code>SDL_BlitSurface()</code>: 将一张画布中的指定矩形区域复制到另一张画布的指定位置</li>
<li><code>SDL_UpdateRect()</code>: 将画布中的指定矩形区域同步到屏幕上</li>
</ul>
</li>
</ul>
<h4 id="必做：运行NSlider"><a href="#必做：运行NSlider" class="headerlink" title="必做：运行NSlider"></a>必做：运行NSlider</h4><ul>
<li>我们提供了一个脚本来把PDF版本的, 比例为4:3的幻灯片转换成BMP图像, 并拷贝到<code>navy-apps/fsimg/</code>中. 你需要提供一个满足条件的PDF文件, 然后参考相应的README文件进行操作. 但你可能会在转换时遇到一些问题, 具体请自行解决.</li>
<li>然后在miniSDL中实现<code>SDL_BlitSurface()</code>和<code>SDL_UpdateRect()</code>. 如果你的实现正确, 运行NSlider时将会显示第一张幻灯片. 你很可能是第一次接触SDL的API, 为此你还需要RTFM, 并通过RTFSC来理解已有代码的行为.</li>
</ul>
<ol>
<li><code>SDL_BlitSurface()</code>用于将一张画布中的指定矩形区域复制到另一张画布的指定位置。我们需要确保源画布和目标画布的像素格式相同。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SDL_BlitSurface</span><span class="params">(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect)</span> &#123;</span><br><span class="line">  assert(dst &amp;&amp; src);</span><br><span class="line">  assert(dst-&gt;format-&gt;BitsPerPixel == src-&gt;format-&gt;BitsPerPixel);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> src_x = srcrect ? srcrect-&gt;x : <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> src_y = srcrect ? srcrect-&gt;y : <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> src_w = srcrect ? srcrect-&gt;w : src-&gt;w;</span><br><span class="line">  <span class="type">int</span> src_h = srcrect ? srcrect-&gt;h : src-&gt;h;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> dst_x = dstrect ? dstrect-&gt;x : <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> dst_y = dstrect ? dstrect-&gt;y : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; src_h; y++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; src_w; x++) &#123;</span><br><span class="line">      <span class="type">int</span> src_index = (src_y + y) * src-&gt;pitch + (src_x + x) * src-&gt;format-&gt;BytesPerPixel;</span><br><span class="line">      <span class="type">int</span> dst_index = (dst_y + y) * dst-&gt;pitch + (dst_x + x) * dst-&gt;format-&gt;BytesPerPixel;</span><br><span class="line">      <span class="built_in">memcpy</span>((<span class="type">uint8_t</span> *)dst-&gt;pixels + dst_index, (<span class="type">uint8_t</span> *)src-&gt;pixels + src_index, src-&gt;format-&gt;BytesPerPixel);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>SDL_UpdateRect()</code>用于将画布中的指定矩形区域同步到屏幕上。我们需要调用 <code>NDL_DrawRect()</code>来实现这一功能。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SDL_UpdateRect</span><span class="params">(SDL_Surface *s, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (w == <span class="number">0</span>) w = s-&gt;w;</span><br><span class="line">  <span class="keyword">if</span> (h == <span class="number">0</span>) h = s-&gt;h;</span><br><span class="line">  NDL_DrawRect((<span class="type">uint32_t</span> *)s-&gt;pixels, x, y, w, h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>查看nslider的readme<ul>
<li>将 slides.pdf 复制到 <code>slides/</code> 目录</li>
<li>运行 <code>convert.sh</code></li>
<li>修改 <code>src/main.cpp</code> 中的变量 <code>N</code> 为幻灯片的总数</li>
</ul>
</li>
<li>记得app：nslider</li>
</ol>
<h4 id="必做：运行NSlider-2"><a href="#必做：运行NSlider-2" class="headerlink" title="必做：运行NSlider(2)"></a>必做：运行NSlider(2)</h4><ul>
<li>在miniSDL中实现<code>SDL_WaitEvent()</code>, 它用于等待一个事件. 你需要将NDL中提供的事件封装成SDL事件返回给应用程序, 具体可以通过阅读NSlider的代码来理解SDL事件的格式. 实现正确后, 你就可以在NSlider中进行翻页了, 翻页的操作方式请RTFSC.</li>
</ul>
<ol>
<li>debug好久才发现是最后的\n没去掉！！！</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//event.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">SDL_WaitEvent</span><span class="params">(SDL_Event *event)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">  <span class="keyword">while</span> (NDL_PollEvent(buf, <span class="keyword">sizeof</span>(buf)) == <span class="number">0</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析事件</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buf, <span class="string">&quot;keydown &quot;</span>, <span class="number">8</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    event-&gt;type = SDL_KEYDOWN;</span><br><span class="line">      <span class="comment">// 调试输出</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;SDL Received event: %s\n&quot;</span>, buf);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buf, <span class="string">&quot;keyup &quot;</span>, <span class="number">6</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    event-&gt;type = SDL_KEYUP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取按键名称</span></span><br><span class="line">  <span class="type">char</span> *key = buf + (event-&gt;type == SDL_KEYDOWN ? <span class="number">8</span> : <span class="number">6</span>);</span><br><span class="line">  key = strtok(key,<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(keyname) / <span class="keyword">sizeof</span>(keyname[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(key, keyname[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">      event-&gt;key.keysym.sym = i;</span><br><span class="line">      <span class="comment">// 调试输出</span></span><br><span class="line">      <span class="comment">// printf(&quot;Parsed key: %s, keycode: %d\n&quot;, key, i);</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Unknown key: %s&quot;</span>, key);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>成功<br><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-9.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-8.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="MENU-开机菜单"><a href="#MENU-开机菜单" class="headerlink" title="MENU (开机菜单)"></a>MENU (开机菜单)</h3><ul>
<li>开机菜单是另一个行为比较简单的程序, 它会展示一个菜单, 用户可以选择运行哪一个程序. 为了运行它, 你还需要在miniSDL中实现<code>SDL_FillRect()</code>, 它用于往画布的指定矩形区域中填充指定的颜色.</li>
<li>开机菜单还会显示一些英文字体, 这些字体的信息以BDF格式存储, Navy中提供了一个libbdf库来解析BDF格式, 生成相应字符的像素信息, 并封装成SDL的Surface. 有了<code>SDL_BlitSurface()</code>之后, 我们就可以很方便地在屏幕上输出字符串的像素信息了.</li>
</ul>
<h4 id="必做：运行开机菜单"><a href="#必做：运行开机菜单" class="headerlink" title="必做：运行开机菜单"></a>必做：运行开机菜单</h4><ul>
<li>正确实现上述API后, 你将会看到一个可以翻页的开机菜单. 但你尝试选择菜单项的时候将会出现错误, 这是因为开机菜单的运行还需要一些系统调用的支持. 我们会在下文进行介绍, 目前通过开机菜单来测试miniSDL即可.</li>
</ul>
<ol>
<li>SDL_FillRect</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SDL_FillRect</span><span class="params">(SDL_Surface *dst, SDL_Rect *dstrect, <span class="type">uint32_t</span> color)</span> &#123;</span><br><span class="line">  assert(dst);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> x = dstrect ? dstrect-&gt;x : <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> y = dstrect ? dstrect-&gt;y : <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> w = dstrect ? dstrect-&gt;w : dst-&gt;w;</span><br><span class="line">  <span class="type">int</span> h = dstrect ? dstrect-&gt;h : dst-&gt;h;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">      <span class="type">int</span> index = (y + i) * dst-&gt;pitch + (x + j) * dst-&gt;format-&gt;BytesPerPixel;</span><br><span class="line">      <span class="built_in">memcpy</span>((<span class="type">uint8_t</span> *)dst-&gt;pixels + index, &amp;color, dst-&gt;format-&gt;BytesPerPixel);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>debug非常痛苦最后发现是<code>NDL_OpenCanvas</code>,</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (*w == <span class="number">0</span> &amp;&amp; *h == <span class="number">0</span>) &#123;</span><br><span class="line">  *w = screen_w;</span><br><span class="line">  *h = screen_h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>应该放在循环外</li>
</ul>
<ol start="3">
<li>终于成功TAT<br><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-11.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<h3 id="NTerm-NJU-Terminal"><a href="#NTerm-NJU-Terminal" class="headerlink" title="NTerm (NJU Terminal)"></a>NTerm (NJU Terminal)</h3><ul>
<li>NTerm是一个模拟终端, 它实现了终端的基本功能, 包括字符的键入和回退, 以及命令的获取等. 终端一般会和Shell配合使用, 从终端获取到的命令将会传递给Shell进行处理, Shell又会把信息输出到终端. NTerm自带一个非常简单的內建Shell(见<code>builtin-sh.cpp</code>), 它默认忽略所有的命令. NTerm也可以和外部程序进行通信, 但这超出了ICS的范围, 我们在PA中不会使用这个功能.</li>
<li>为了运行NTerm, 你还需要实现miniSDL的两个API:<ul>
<li><code>SDL_GetTicks()</code>: 它和<code>NDL_GetTicks()</code>的功能类似, 但有一个额外的小要求, 具体请RTFM</li>
<li><code>SDL_PollEvent()</code>: 它和<code>SDL_WaitEvent()</code>不同的是, 如果当前没有任何事件, 就会立即返回</li>
</ul>
</li>
</ul>
<h4 id="必做：运行NTerm"><a href="#必做：运行NTerm" class="headerlink" title="必做：运行NTerm"></a>必做：运行NTerm</h4><ul>
<li>正确实现上述API后, 你会看到NTerm的光标以每秒一次的频率闪烁, 并且可以键入字符. 为了让NTerm可以启动其它程序, 你还需要实现一些系统调用, 我们会在下文进行介绍.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> start_ticks = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">SDL_GetTicks</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (start_ticks == <span class="number">0</span>) &#123;</span><br><span class="line">    start_ticks = NDL_GetTicks();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> NDL_GetTicks() - start_ticks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SDL_PollEvent</span><span class="params">(SDL_Event *event)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">  <span class="keyword">if</span> (NDL_PollEvent(buf, <span class="keyword">sizeof</span>(buf)) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 没有事件</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析事件</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buf, <span class="string">&quot;keydown &quot;</span>, <span class="number">8</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    event-&gt;type = SDL_KEYDOWN;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SDL Received event: %s\n&quot;</span>, buf); <span class="comment">// 调试输出</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buf, <span class="string">&quot;keyup &quot;</span>, <span class="number">6</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    event-&gt;type = SDL_KEYUP;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 未知事件</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取按键名称</span></span><br><span class="line">  <span class="type">char</span> *key = buf + (event-&gt;type == SDL_KEYDOWN ? <span class="number">8</span> : <span class="number">6</span>);</span><br><span class="line">  key = strtok(key, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(keyname) / <span class="keyword">sizeof</span>(keyname[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(key, keyname[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">      event-&gt;key.keysym.sym = i;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Unknown key: %s\n&quot;</span>, key);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>成功！<br><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-10.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="Flappy-Bird"><a href="#Flappy-Bird" class="headerlink" title="Flappy Bird"></a>Flappy Bird</h3><ol>
<li>在<code>navy-apps/apps/bird/</code>目录下运行<code>make init</code>, 将会从github上克隆移植后的项目</li>
<li>为了在Navy中运行<code>Flappy Bird</code>, 你还需要实现另一个库SDL_image中的一个API: <code>IMG_Load()</code></li>
</ol>
<h4 id="必做：运行Flappy-Bird"><a href="#必做：运行Flappy-Bird" class="headerlink" title="必做：运行Flappy Bird"></a>必做：运行Flappy Bird</h4><ul>
<li>实现<code>IMG_Load()</code>, 在Navy中运行Flappy Bird. 这本质上是一个文件操作的练习. 另外, Flappy Bird<strong>默认使用400像素的屏幕高度</strong>, 但NEMU的屏幕高度默认为300像素, 为了在NEMU运行Flappy Bird, 你需要将<code>navy-apps/apps/bird/repo/include/Video.h</code>中的 <strong>SCREEN_HEIGHT修改为300</strong>.</li>
<li>Flappy Bird默认还会尝试打开声卡播放音效, miniSDL默认会让音频相关的API返回0或NULL, 程序会认为相应操作失败, 但仍然可以在无音效的情况下运行.</li>
</ul>
<ol>
<li>在对应目录下克隆</li>
</ol>
<h3 id="PAL（仙剑奇侠传）"><a href="#PAL（仙剑奇侠传）" class="headerlink" title="PAL（仙剑奇侠传）"></a>PAL（仙剑奇侠传）</h3><ol>
<li>在<code>navy-apps/apps/pal/</code>目录下运行<code>make init</code>, 将会从github上克隆移植后的项目.</li>
</ol>
<h4 id="必做：运行仙剑奇侠传"><a href="#必做：运行仙剑奇侠传" class="headerlink" title="必做：运行仙剑奇侠传"></a>必做：运行仙剑奇侠传</h4><ul>
<li>为miniSDL中的<strong>绘图API添加8位像素格式的支持</strong>. 实现正确之后, 你就可以看到游戏画面了. 为了操作, 你还需要实现其它的API, 具体要实现哪些API, 就交给你来寻找吧. 实现正确后, 你就可以在自己实现的NEMU中运行仙剑奇侠传了! </li>
<li>你可以在游戏中进行各种操作来对你的实现进行测试, 我们提供的数据文件中包含一些游戏存档, 5个存档中的场景分别如下, 可用于进行不同的测试:<ul>
<li>无敌人的机关迷宫</li>
<li>无动画的剧情</li>
<li>有动画的剧情</li>
<li>已进入敌人视野的迷宫</li>
<li>未进入敌人视野的迷宫</li>
</ul>
</li>
</ul>
<ol>
<li>为miniSDL中的*<em>绘图API添加8位像素格式的支持</em></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以及SDL_BlitSurface</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SDL_FillRect</span><span class="params">(SDL_Surface *dst, SDL_Rect *dstrect, <span class="type">uint32_t</span> color)</span> &#123;</span><br><span class="line">  assert(dst);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> x = dstrect ? dstrect-&gt;x : <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> y = dstrect ? dstrect-&gt;y : <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> w = dstrect ? dstrect-&gt;w : dst-&gt;w;</span><br><span class="line">  <span class="type">int</span> h = dstrect ? dstrect-&gt;h : dst-&gt;h;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (w &lt;= <span class="number">0</span> || h &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dst-&gt;format-&gt;BitsPerPixel == <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="type">uint8_t</span> *pixels = (<span class="type">uint8_t</span> *)dst-&gt;pixels;</span><br><span class="line">    <span class="type">uint8_t</span> palette_index = (<span class="type">uint8_t</span>)color; <span class="comment">// Assuming color is the palette index</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">        pixels[(y + i) * dst-&gt;w + (x + j)] = palette_index;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dst-&gt;format-&gt;BytesPerPixel == <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="type">uint32_t</span> *pixels = (<span class="type">uint32_t</span> *)dst-&gt;pixels;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">        pixels[(y + i) * dst-&gt;w + (x + j)] = color;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SDL_UpdateRect</span><span class="params">(SDL_Surface *s, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (w == <span class="number">0</span>) w = s-&gt;w;</span><br><span class="line">  <span class="keyword">if</span> (h == <span class="number">0</span>) h = s-&gt;h;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s-&gt;format-&gt;BitsPerPixel == <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="comment">// 8位像素格式，需要转换为32位颜色格式</span></span><br><span class="line">    <span class="type">uint32_t</span> *converted_pixels = (<span class="type">uint32_t</span> *)<span class="built_in">malloc</span>(w * h * <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> *src_pixels = (<span class="type">uint8_t</span> *)s-&gt;pixels;</span><br><span class="line">    SDL_Color *palette = s-&gt;format-&gt;palette-&gt;colors;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">        <span class="type">uint8_t</span> index = src_pixels[(y + i) * s-&gt;w + (x + j)];</span><br><span class="line">        SDL_Color color = palette[index];</span><br><span class="line">        converted_pixels[i * w + j] = (color.r &lt;&lt; <span class="number">16</span>) | (color.g &lt;&lt; <span class="number">8</span>) | color.b;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NDL_DrawRect(converted_pixels, x, y, w, h);</span><br><span class="line">    <span class="built_in">free</span>(converted_pixels);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s-&gt;format-&gt;BytesPerPixel == <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="comment">// 直接使用32位颜色格式</span></span><br><span class="line">    NDL_DrawRect((<span class="type">uint32_t</span> *)s-&gt;pixels, x, y, w, h);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>补充完善按键</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span>* <span class="title function_">SDL_GetKeyState</span><span class="params">(<span class="type">int</span> *numkeys)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (numkeys) &#123;</span><br><span class="line">    *numkeys = SDL_NUM_SCANCODES;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> keystate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以及SDL_PollEvent和SDL_WaitEvent部分</span></span><br></pre></td></tr></table></figure>
<ul>
<li>成功！！<br><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-12.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>画面是偏移的，修改一下</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NDL.h</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> canva_w = <span class="number">0</span>, canva_h =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">NDL_OpenCanvas</span><span class="params">(<span class="type">int</span> *w, <span class="type">int</span> *h)</span> &#123;</span><br><span class="line"></span><br><span class="line">  canva_w = *w;</span><br><span class="line">  canva_h = *h;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;NWM_APP&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d %d&quot;</span>, canva_w, canva_h);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">NDL_DrawRect</span><span class="params">(<span class="type">uint32_t</span> *pixels, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h)</span> &#123;</span><br><span class="line"></span><br><span class="line">  x += (screen_w - canva_w)/<span class="number">2</span>;</span><br><span class="line">  y += (screen_h - canva_h)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>画面成功到最中间啦！！<ul>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-13.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li>测试一下</li>
</ul>
<ol>
<li>无敌人的机关迷宫</li>
</ol>
<ul>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-14.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<ol start="2">
<li>无动画的剧情</li>
</ol>
<ul>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-15.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<ol start="3">
<li>有动画的剧情</li>
</ol>
<ul>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-16.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<ol start="4">
<li>已进入敌人视野的迷宫</li>
</ol>
<ul>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-17.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-18.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<ol start="5">
<li>未进入敌人视野的迷宫</li>
</ol>
<ul>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-19.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="3-展示你的批处理系统"><a href="#3-展示你的批处理系统" class="headerlink" title="3. 展示你的批处理系统"></a>3. 展示你的批处理系统</h2><ul>
<li>“执行其它程序”需要一个新的系统调用来支持, 这个系统调用就是<code>SYS_execve</code><ul>
<li>它的作用是结束当前程序的运行, 并启动一个指定的程序</li>
</ul>
</li>
<li>为了实现这个系统调用, 你只需要在相应的系统调用处理函数中调用<code>naive_uload()</code>就可以了. 目前我们只需要关心<code>filename</code>即可, <code>argv</code>和<code>envp</code>这两个参数可以暂时忽略.</li>
</ul>
<h4 id="必做：可以运行其它程序的开机菜单"><a href="#必做：可以运行其它程序的开机菜单" class="headerlink" title="必做：可以运行其它程序的开机菜单"></a>必做：可以运行其它程序的开机菜单</h4><ul>
<li>你需要实现<code>SYS_execve</code>系统调用, 然后通过开机菜单来运行其它程序. 你已经实现过很多系统调用了, 需要注意哪些细节, 这里就不啰嗦了.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//do_syscall()</span></span><br><span class="line"><span class="keyword">case</span> SYS_execve:</span><br><span class="line">      naive_uload(<span class="literal">NULL</span>, (<span class="type">const</span> <span class="type">char</span> *)a[<span class="number">1</span>]);</span><br><span class="line">      c-&gt;GPRx = <span class="number">0</span>; <span class="comment">// 如果成功，不会返回到当前程序</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _execve(<span class="type">const</span> <span class="type">char</span> *fname, <span class="type">char</span> * <span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[]) &#123;</span><br><span class="line">  <span class="comment">// _exit(SYS_execve);</span></span><br><span class="line">  <span class="comment">// return 0;</span></span><br><span class="line">  <span class="keyword">return</span> _syscall_(SYS_execve, (<span class="type">intptr_t</span>)fname, (<span class="type">intptr_t</span>)argv, (<span class="type">intptr_t</span>)envp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>成功<ul>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-20.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
<h4 id="必做：展示你的批处理系统"><a href="#必做：展示你的批处理系统" class="headerlink" title="必做：展示你的批处理系统"></a>必做：展示你的批处理系统</h4><ul>
<li>有了开机菜单程序之后, 就可以很容易地实现一个有点样子的批处理系统了. 你只需要修改<code>SYS_exit</code>的实现, 让它调用<code>SYS_execve</code>来再次运行<code>/bin/menu</code>, 而不是直接调用<code>halt()</code>来结束整个系统的运行. 这样以后, 在一个用户程序结束的时候, 操作系统就会<strong>自动再次运行开机菜单程序, 让用户选择一个新的程序来运行</strong>.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//do_syscall</span></span><br><span class="line">    <span class="keyword">case</span> SYS_exit:</span><br><span class="line">      naive_uload(<span class="literal">NULL</span>, <span class="string">&quot;/bin/menu&quot;</span>);</span><br><span class="line">      c-&gt;GPRx = <span class="number">0</span>; <span class="comment">// 如果成功，不会返回到当前程序</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>成功<ul>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-21.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-22.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
<h4 id="必做：展示你的批处理系统-2"><a href="#必做：展示你的批处理系统-2" class="headerlink" title="必做：展示你的批处理系统(2)"></a>必做：展示你的批处理系统(2)</h4><ul>
<li>在NTerm的<strong>內建Shell中实现命令解</strong>析, 把键入的命令作为参数调用<code>execve()</code>. 然后<strong>把NTerm作为Nanos-lite第一个启动的程序</strong>, 并修改<code>SYS_exit</code>的实现, 让它<strong>再次运行&#x2F;bin&#x2F;nterm</strong>. 目前我们暂不支持参数的传递, 你可以先忽略命令的参数.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//builtin-sh.cpp</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sh_handle_cmd</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd)</span> &#123;</span><br><span class="line">  <span class="comment">// 忽略命令的参数</span></span><br><span class="line">  <span class="type">char</span> *args[] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">  execve(cmd, args, <span class="literal">NULL</span>);</span><br><span class="line">  sh_printf(<span class="string">&quot;Command not found: %s\n&quot;</span>, cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//do_syscall</span></span><br><span class="line">  <span class="keyword">switch</span> (a[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> SYS_exit:</span><br><span class="line">      naive_uload(<span class="literal">NULL</span>, <span class="string">&quot;/bin/nterm&quot;</span>);</span><br><span class="line">      c-&gt;GPRx = <span class="number">0</span>; <span class="comment">// 如果成功，不会返回到当前程序</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>成功！<ul>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-23.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
<h4 id="必做：为NTerm中的內建Shell添加环境变量的支持"><a href="#必做：为NTerm中的內建Shell添加环境变量的支持" class="headerlink" title="必做：为NTerm中的內建Shell添加环境变量的支持"></a>必做：为NTerm中的內建Shell添加环境变量的支持</h4><ul>
<li>这是一个非常简单的任务, 你只需要RTFM了解<code>setenv()</code>和<code>execvp()</code>的行为, 并对內建Shell的代码进行少量修改, 就可以得到一个和你平时的使用体验非常相似的Shell了.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sh_handle_cmd</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd)</span> &#123;</span><br><span class="line">  <span class="type">char</span> tmp_cmd[<span class="number">64</span>];</span><br><span class="line">  <span class="built_in">strncpy</span>(tmp_cmd, cmd, <span class="keyword">sizeof</span>(tmp_cmd) - <span class="number">1</span>);</span><br><span class="line">  tmp_cmd[<span class="keyword">sizeof</span>(tmp_cmd) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 确保字符串以 &#x27;\0&#x27; 结尾</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 去掉命令末尾的换行符</span></span><br><span class="line">  <span class="type">char</span> *newline = <span class="built_in">strchr</span>(tmp_cmd, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (newline) *newline = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 PATH 环境变量</span></span><br><span class="line">  setenv(<span class="string">&quot;PATH&quot;</span>, <span class="string">&quot;/bin&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 忽略命令的参数</span></span><br><span class="line">  <span class="type">char</span> *args[] = &#123;tmp_cmd, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行命令</span></span><br><span class="line">  execvp(tmp_cmd, args);</span><br><span class="line">  sh_printf(<span class="string">&quot;Command not found: %s\n&quot;</span>, tmp_cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>成功！<ul>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-24.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li><img src="/2025/02/25/PA3%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/image-25.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
<hr>
<h3 id="必答题：理解计算机系统"><a href="#必答题：理解计算机系统" class="headerlink" title="必答题：理解计算机系统"></a>必答题：理解计算机系统</h3><ul>
<li>理解上下文结构体的前世今生 (见PA3.1阶段)</li>
<li>理解穿越时空的旅程 (见PA3.1阶段)</li>
<li>hello程序是什么, 它从而何来, 要到哪里去 (见PA3.2阶段)</li>
<li>仙剑奇侠传究竟如何运行 运行仙剑奇侠传时会播放启动动画, 动画里仙鹤在群山中飞过. 这一动画是通过navy-apps&#x2F;apps&#x2F;pal&#x2F;repo&#x2F;src&#x2F;main.c中的PAL_SplashScreen()函数播放的. 阅读这一函数, 可以得知仙鹤的像素信息存放在数据文件mgo.mkf中. 请回答以下问题: 库函数, libos, Nanos-lite, AM, NEMU是如何相互协助, 来帮助仙剑奇侠传的代码从mgo.mkf文件中读出仙鹤的像素信息, 并且更新到屏幕上? 换一种PA的经典问法: 这个过程究竟经历了些什么? (Hint: 合理使用各种trace工具, 可以帮助你更容易地理解仙剑奇侠传的行为)</li>
</ul>
<h4 id="理解上下文结构体的前世今生"><a href="#理解上下文结构体的前世今生" class="headerlink" title="理解上下文结构体的前世今生"></a>理解上下文结构体的前世今生</h4><ul>
<li>你会在__am_irq_handle()中看到有一个上下文结构指针c, c指向的上下文结构究竟在哪里? 这个上下文结构又是怎么来的? 具体地, 这个上下文结构有很多成员, 每一个成员究竟在哪里赋值的? $ISA-nemu.h, trap.S, 上述讲义文字, 以及你刚刚在NEMU中实现的新指令, 这四部分内容又有什么联系?</li>
<li>如果你不是脑袋足够灵光, 还是不要眼睁睁地盯着代码看了, 理解程序的细节行为还是要从状态机视角入手.</li>
</ul>
<ol>
<li>c指向的上下文结构的来源：<ul>
<li>上下文结构体<code>Context</code>是在异常处理过程中创建的。它包含了处理器的寄存器状态，包括通用寄存器、异常号、处理器状态和异常 PC 等。</li>
</ul>
</li>
<li>上下文结构体的创建过程<ol>
<li><strong>异常触发</strong>：当发生异常时，处理器会自动跳转到异常处理入口地址，该地址存储在<code>mtvec</code>寄存器中。ps:这个地址是<code>__am_asm_trap</code>。</li>
<li><strong>保存上下文</strong>：在 <code>__am_asm_trap</code> 中，使用汇编代码保存当前的处理器状态到栈中。具体来说，将所有通用寄存器、mcause、mstatus 和 mepc 寄存器的值保存到栈中。</li>
<li><strong>调用异常处理函数</strong>：保存完上下文后，我们将栈指针传递给 <code>__am_irq_handle</code> 函数，并调用它进行异常处理。</li>
</ol>
</li>
<li>上下文结构体的成员赋值:<ul>
<li>在 <code>trap.S</code> 中被赋值</li>
</ul>
<ol>
<li>保存<strong>通用寄存器</strong>：<code>MAP(REGS, PUSH)</code><ul>
<li>使用宏<code>PUSH</code>将所有通用寄存器的值保存到栈中。</li>
</ul>
</li>
<li>保存<strong>mcause、mstatus和mepc寄存器</strong>： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">csrr t0, mcause</span><br><span class="line">csrr t1, mstatus</span><br><span class="line">csrr t2, mepc</span><br><span class="line"></span><br><span class="line">STORE t0, OFFSET_CAUSE(sp)</span><br><span class="line">STORE t1, OFFSET_STATUS(sp)</span><br><span class="line">STORE t2, OFFSET_EPC(sp)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>csrr</code>指令将mcause、mstatus 和 mepc寄存器的值读取到临时寄存器t0、t1 和 t2，然后使用<code>STORE</code>宏将它们保存到栈中。</li>
</ul>
</li>
</ol>
</li>
<li>各部分内容的联系<ol>
<li><code>riscv.h</code>：定义了上下文结构体 Context，包括通用寄存器、mcause、mstatus 和 mepc 等成员。</li>
<li><code>trap.S</code>：在异常发生时，保存处理器的状态到栈中，并调用 __am_irq_handle 进行异常处理。</li>
<li><code>cte.c</code>：实现了异常处理函数 __am_irq_handle，通过指针 c 访问上下文结构体，并输出其成员的值。</li>
<li>新指令的实现：在 inst.c 中实现了 <code>csrr</code> 和 <code>csrw</code> 指令，用于读取和写入 CSR 寄存器的值。这些指令在 trap.S 中被使用，用于保存和恢复 mcause、mstatus 和 mepc 寄存器的值。</li>
</ol>
</li>
</ol>
<h4 id="理解穿越时空的旅程"><a href="#理解穿越时空的旅程" class="headerlink" title="理解穿越时空的旅程"></a>理解穿越时空的旅程</h4><ul>
<li>从<code>yield test</code>调用<code>yield()</code>开始, 到从<code>yield()</code>返回的期间, 这一趟旅程具体经历了什么? 软(AM, <code>yield test</code>)硬(NEMU)件是如何相互协助来完成这趟旅程的? 你需要解释这一过程中的每一处细节, 包括涉及的每一行汇编代码&#x2F;C代码的行为, 尤其是一些比较关键的指令&#x2F;变量. 事实上, 上文的必答题”理解上下文结构体的前世今生”已经涵盖了这趟旅程中的一部分, 你可以把它的回答包含进来.</li>
<li>别被”每一行代码”吓到了, 这个过程也就大约50行代码, 要完全理解透彻并不是不可能的. 我们之所以设置这道必答题, 是为了强迫你理解清楚这个过程中的每一处细节. 这一理解是如此重要, 以至于如果你缺少它, 接下来你面对bug几乎是束手无策.</li>
</ul>
<ol>
<li><code>yield()</code> 函数调用<ul>
<li>在 <code>yield test</code> 中，调用 <code>yield()</code> 函数：</li>
</ul>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">yield</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __riscv_e</span></span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;li a5, -1; ecall&quot;</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;li a7, -1; ecall&quot;</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这段代码使用内联汇编触发一个环境调用（ECALL）</li>
<li><code>li a7, -1</code>：将立即数 -1 加载到寄存器 a7 中</li>
<li><code>ecall</code>：触发一个环境调用异常。</li>
</ul>
</li>
<li>触发异常<ul>
<li><code>ecall</code>指令触发一个环境调用异常，处理器进入异常处理模式，并跳转到由 <code>mtvec</code> 寄存器指定的异常处理程序地址。</li>
</ul>
</li>
<li>异常处理程序(在 <code>trap.S</code> 文件中定义)：<ul>
<li><code>addi sp, sp, -CONTEXT_SIZE</code>： 为保存上下文分配空间。</li>
<li><code>MAP(REGS, PUSH)</code>： 保存所有通用寄存器的值。</li>
<li><code>csrr t0, mcause</code>： 读取 mcause 寄存器的值到 t0。</li>
<li><code>csrr t1, mstatus</code>： 读取 mstatus 寄存器的值到 t1。</li>
<li><code>csrr t2, mepc</code>： 读取 mepc 寄存器的值到 t2。</li>
<li><code>STORE t0, OFFSET_CAUSE(sp)</code>： 将 mcause 的值保存到栈中。</li>
<li><code>STORE t1, OFFSET_STATUS(sp)</code>： 将 mstatus 的值保存到栈中。</li>
<li><code>STORE t2, OFFSET_EPC(sp)</code>： 将 mepc 的值保存到栈中。</li>
<li><code>li a0, (1 &lt;&lt; 17)</code>： 将立即数 1 &lt;&lt; 17 加载到 a0 中。</li>
<li><code>or t1, t1, a0</code>： 将 t1 和 a0 进行或运算，结果存入 t1。</li>
<li><code>csrw mstatus, t1</code>： 将 t1 的值写入 mstatus 寄存器。</li>
<li><code>mv a0, sp</code>： 将栈指针的值移动到 a0。</li>
<li><code>call __am_irq_handle</code>： 调用 __am_irq_handle 函数。</li>
</ul>
</li>
<li><code>__am_irq_handle</code>函数(在 <code>cte.c</code> 文件中定义)：<ul>
<li><code>switch (c-&gt;mcause)</code>：根据 mcause 的值判断异常类型。</li>
<li><code>case 0: ev.event = EVENT_YIELD; break;</code>：如果 mcause 为 0，表示自陷异常，将事件类型设置为 EVENT_YIELD。</li>
<li><code>c = user_handler(ev, c);</code>：调用用户注册的事件处理程序 user_handler，并传递事件和上下文。</li>
</ul>
</li>
<li>用户事件处理程序(在 <code>intr.c</code> 文件中定义)：<ul>
<li><code>case EVENT_YIELD: putch(&#39;y&#39;); break;</code>：如果事件类型为 EVENT_YIELD，输出字符 y。</li>
</ul>
</li>
<li>恢复上下文并返回<ul>
<li>回到异常处理程序：</li>
<li><code>LOAD t1, OFFSET_STATUS(sp)</code>：从栈中恢复 mstatus 的值到 t1。</li>
<li><code>LOAD t2, OFFSET_EPC(sp)</code>：从栈中恢复 mepc 的值到 t2。</li>
<li><code>csrw mstatus, t1</code>：将 t1 的值写入 mstatus 寄存器。</li>
<li><code>csrw mepc, t2</code>：将 t2 的值写入 mepc 寄存器。</li>
<li><code>MAP(REGS, POP)</code>：恢复所有通用寄存器的值。</li>
<li><code>addi sp, sp, CONTEXT_SIZE</code>：释放为保存上下文分配的空间。</li>
<li><code>mret</code>：从异常处理程序返回，恢复程序的正常执行。</li>
</ul>
</li>
</ol>
<h4 id="hello程序是什么-它从而何来-要到哪里去"><a href="#hello程序是什么-它从而何来-要到哪里去" class="headerlink" title="hello程序是什么, 它从而何来, 要到哪里去"></a>hello程序是什么, 它从而何来, 要到哪里去</h4><ul>
<li>hello程序从C源文件到在终端上打印字符串，经历了编译、链接、加载、执行等多个步骤：</li>
</ul>
<ol>
<li>hello程序一开始在哪里?</li>
</ol>
<ul>
<li>一开始在源文件<code>navy-apps/tests/hello/hello.c</code>。这个源文件通过编译器（如GCC）编译成目标文件，然后通过链接器链接成一个可执行的ELF文件。</li>
</ul>
<ol start="2">
<li>它是怎么出现内存中的?</li>
</ol>
<ul>
<li>当我们运行hello程序时，操作系统的加载器会将ELF文件加载到内存中。加载器会解析ELF文件的头部信息，确定程序的入口点、代码段、数据段等信息，并将这些段加载到内存中的相应位置。</li>
</ul>
<ol start="3">
<li>为什么会出现在目前的内存位置?</li>
</ol>
<ul>
<li>ELF文件中包含了段表和程序头表，这些表格定义了各个段在内存中的位置。加载器根据这些信息将各个段加载到指定的内存地址。例如，代码段通常加载到一个固定的地址（如0x8048000），数据段加载到另一个地址。</li>
</ul>
<ol start="4">
<li>它的第一条指令在哪里?</li>
</ol>
<ul>
<li>hello程序的第一条指令位于ELF文件的入口点。入口点地址在ELF文件头中指定，通常是程序的<code>_start</code>函数的地址。加载器在加载完程序后，会将控制权转移到这个入口点，开始执行程序的第一条指令。</li>
</ul>
<ol start="5">
<li>究竟是怎么执行到它的第一条指令的?</li>
</ol>
<ul>
<li>加载器将程序加载到内存后，会设置CPU的程序计数器（PC）指向程序的入口点地址。然后，CPU开始从这个地址执行指令，逐条执行程序的代码。</li>
</ul>
<ol start="6">
<li>hello程序在不断地打印字符串, 每一个字符又是经历了什么才会最终出现在终端上?</li>
</ol>
<ul>
<li>hello程序使用<code>printf</code>函数打印字符串。<code>printf</code>函数会将字符串格式化后，通过系统调用（如<code>write</code>）将字符串写入标准输出（通常是终端）。系统调用会将数据从用户空间传递到内核空间，内核再将数据写入终端设备的缓冲区，最终显示在终端上。</li>
</ul>
<h4 id="仙剑奇侠传究竟如何运行"><a href="#仙剑奇侠传究竟如何运行" class="headerlink" title="仙剑奇侠传究竟如何运行"></a>仙剑奇侠传究竟如何运行</h4><ul>
<li>过程：</li>
</ul>
<ol>
<li><p>应用程序层（仙剑奇侠传）</p>
</li>
<li><p><strong>调用 <code>PAL_SplashScreen</code> 函数</strong>：<br>- 仙剑奇侠传的代码调用 <code>PAL_SplashScreen</code> 函数来播放启动动画。<br>- 该函数读取 <code>mgo.mkf</code> 文件中的数据，并将其解码为像素信息。</p>
</li>
<li><p><strong>读取文件</strong>：<br>- <code>PAL_SplashScreen</code> 函数调用 <code>PAL_MKFReadChunk</code> 函数来读取 <code>mgo.mkf</code> 文件中的数据。<br>- <code>PAL_MKFReadChunk</code> 函数通过标准库函数（如 <code>fopen</code>、<code>fread</code> 等）来读取文件数据。</p>
</li>
<li><p>库函数层</p>
</li>
<li><p><strong>标准库函数</strong>：<br>- 标准库函数（如 <code>fopen</code>、<code>fread</code> 等）被调用来读取文件数据。<br>- 这些函数最终会调用系统调用接口来执行实际的文件操作。</p>
</li>
<li><p>操作系统层（Nanos-lite）</p>
</li>
<li><p><strong>系统调用</strong>：<br>- 标准库函数通过系统调用接口（如 <code>SYS_open</code>、<code>SYS_read</code> 等）与操作系统交互。<br>- 这些系统调用由 Nanos-lite 实现。</p>
</li>
<li><p><strong>文件系统操作</strong>：<br>- Nanos-lite 的文件系统模块处理这些系统调用，执行实际的文件操作。<br>- 文件系统模块读取文件数据，并将其返回给应用程序。</p>
</li>
<li><p>抽象机器层（AM）</p>
</li>
<li><p><strong>硬件抽象</strong>：<br>- AM 提供硬件抽象层，处理底层硬件操作。<br>- AM 负责处理内存映射、设备 I&#x2F;O 等操作。</p>
</li>
<li><p>模拟器层（NEMU）</p>
</li>
<li><p><strong>指令模拟</strong>：<br>- NEMU 模拟 CPU 指令执行，处理应用程序和操作系统的指令。<br>- NEMU 负责模拟内存访问、设备 I&#x2F;O 等操作。</p>
</li>
<li><p>显示更新</p>
</li>
<li><p><strong>解码像素数据</strong>：<br>- <code>PAL_SplashScreen</code> 函数解码从 <code>mgo.mkf</code> 文件中读取的像素数据。<br>- 解码后的像素数据存储在内存中。</p>
</li>
<li><p><strong>更新屏幕</strong>：<br>- <code>PAL_SplashScreen</code> 函数调用显示更新函数（如 <code>VIDEO_UpdateScreen</code>）来更新屏幕。<br>- 显示更新函数通过系统调用接口与操作系统交互，执行实际的屏幕更新操作。</p>
</li>
<li><p>系统调用和硬件交互</p>
</li>
<li><p><strong>系统调用</strong>：<br>- 显示更新函数通过系统调用接口（如 <code>SYS_write</code>）与操作系统交互。<br>- 操作系统处理这些系统调用，执行实际的屏幕更新操作。</p>
</li>
<li><p><strong>硬件交互</strong>：<br>- 操作系统通过 AM 与底层硬件交互，执行屏幕更新操作。<br>- AM 负责处理内存映射、设备 I&#x2F;O 等操作，将像素数据写入帧缓冲区。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机系统基础实验</category>
      </categories>
      <tags>
        <tag>PA</tag>
      </tags>
  </entry>
  <entry>
    <title>PA4实验记录</title>
    <url>/2025/02/25/PA4%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="PA4-虚实交错的魔法-分时多任务"><a href="#PA4-虚实交错的魔法-分时多任务" class="headerlink" title="PA4 - 虚实交错的魔法: 分时多任务"></a>PA4 - 虚实交错的魔法: 分时多任务</h1><ul>
<li>首先进行分支整理</li>
<li>task PA4.1: 实现基本的多道程序系统, 支持带参数的仙剑奇侠传与Hello内核线程的分时运行</li>
<li>task PA4.2: 实现支持虚存管理的多道程序系统</li>
<li>task PA4.3: 实现抢占式分时多任务系统, 并提交完整的实验报告</li>
</ul>
<h1 id="PA4-1"><a href="#PA4-1" class="headerlink" title="PA4.1"></a>PA4.1</h1><h2 id="一、多道程序"><a href="#一、多道程序" class="headerlink" title="一、多道程序"></a>一、多道程序</h2><ol>
<li><strong>多道程序(multiprogramming)系统的基本思想</strong>：<ul>
<li>批处理系统的一个缺陷: 如果当前程序正在等待输入输出, 那么整个系统都会因此而停顿. <ul>
<li>不如用这些时间来进行一些有意义的工作</li>
</ul>
</li>
<li>在系统一开始的时候加载多个程序</li>
<li>然后运行第一个; </li>
<li>当第一个程序需要等待输入输出的时候, 就切换到第二个程序来运行;</li>
<li>当第二个程序也需要等待的时候, 就继续切换到下一个程序来运行</li>
<li>如此类推.</li>
</ul>
</li>
<li>实现一个多道程序操作系统<ul>
<li>在<strong>内存中</strong>可以<strong>同时存在多个进程</strong></li>
<li>在<strong>满足某些条件</strong>的情况下, 可以让<strong>执行流在这些进程之间切换</strong></li>
</ul>
</li>
</ol>
<h3 id="（一）上下文切换"><a href="#（一）上下文切换" class="headerlink" title="（一）上下文切换"></a>（一）上下文切换</h3><ol>
<li>“上下文”的概念: 上下文的本质就是<strong>进程的状态</strong>. <ul>
<li>现在需要考虑的是, 如何在多个用户进程之间进行上下文切换.</li>
</ul>
</li>
<li><code>am-kernels</code>中准备了一个约30行的操作系统<code>yield-os</code>, 它创建了两个执行流, 在<strong>CTE</strong>的支撑下<strong>交替输出A和B</strong>. 你可以在<code>native</code>上运行<code>yield-os</code>来查看它的行为</li>
</ol>
<h4 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1. 基本原理"></a>1. 基本原理</h4><ol>
<li><strong>上下文切换的实现</strong>：<ul>
<li>当进程 A 运行过程中触发系统调用时，通过自陷指令进入内核。</li>
<li>在内核中，<code>__am_asm_trap()</code> 函数会将进程 A 的上下文结构保存到 A 的栈上。</li>
<li>系统调用处理完毕后，<code>__am_asm_trap()</code> 会根据栈上保存的上下文结构恢复 A 的上下文。</li>
</ul>
</li>
<li><strong>进程切换的巧妙方式</strong>：<ul>
<li>如果在恢复 A 的上下文之前，将栈顶指针切换到另一个进程 B 的栈上。</li>
<li>由于 B 的栈上存放了之前 B 保存的上下文结构，接下来的操作会根据这一结构恢复 B 的上下文。</li>
<li>从 <code>__am_asm_trap()</code> 返回后，系统将开始运行进程 B。</li>
</ul>
</li>
<li><strong>进程挂起和唤醒</strong>：<ul>
<li>进程 A 并没有消失，而是被暂时挂起了。</li>
<li>在被挂起之前，A 已经将上下文结构保存到自己的栈上。</li>
<li>当某一时刻栈顶指针切换回 A 的栈上时，代码会根据栈上的上下文结构恢复 A 的上下文，A 将被唤醒并继续执行。</li>
</ul>
</li>
<li><strong>总结</strong>：<ul>
<li>上下文切换实际上就是不同进程之间的栈切换。</li>
<li>通过切换栈顶指针，操作系统可以在多个进程之间切换执行，确保每个进程都能得到公平的执行机会。</li>
</ul>
</li>
</ol>
<h4 id="2-进程控制块"><a href="#2-进程控制块" class="headerlink" title="2. 进程控制块"></a>2. 进程控制块</h4><ul>
<li>为了找到其他进程的上下文结构，我们需要使用一个**上下文指针（cp）**来记录上下文结构的位置。由于上下文结构保存在栈上，而栈空间受到函数调用形成的栈帧影响，每次保存的位置并不固定，因此需要 cp 指针来定位上下文结构。</li>
<li>操作系统使用**进程控制块（PCB）**来管理进程相关的信息。PCB 包含了上下文指针（cp）和栈空间等信息。以下是 <code>yield-os</code> 中定义的 PCB 结构：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">  <span class="type">uint8_t</span> <span class="built_in">stack</span>[STACK_SIZE];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Context *cp;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; PCB;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个联合体将进程堆栈和上下文指针放在一起。每个进程分配了一个 32KB 的堆栈，足够使用且不会出现栈溢出。在进行上下文切换时，只需<strong>将 PCB 中的 cp 指针返回给 CTE</strong>的 <code>__am_irq_handle()</code> 函数，剩余部分的代码会根据上下文结构恢复上下文。</li>
</ul>
<h4 id="3-内核线程"><a href="#3-内核线程" class="headerlink" title="3. 内核线程"></a>3. 内核线程</h4><h5 id="a-创建内核线程上下文"><a href="#a-创建内核线程上下文" class="headerlink" title="a. 创建内核线程上下文"></a>a. 创建内核线程上下文</h5><ul>
<li>对于刚刚加载完的进程, 我们要怎么切换到它来让它运行起来呢?<ul>
<li><strong>在进程的栈上人工创建一个上下文结构</strong>, 使得将来切换的时候可以根据这个结构来正确地恢复上下文即可.</li>
</ul>
</li>
<li><code>yield-os</code>提供了一个测试函数<code>f()</code>, 我们接下来的任务就是<strong>为它创建一个上下文, 然后切换到它来执行</strong>. 这样的执行流有一个专门的名称, 叫”<strong>内核线程</strong>“(kernel thread).</li>
<li>创建内核线程的上下文是通过<strong>CTE</strong>提供的<code>kcontext()</code>函数 (在<code>abstract-machine/am/src/$ISA/nemu/cte.c</code>中定义)来实现的, 其中的”k”代表内核. kcontext()的原型是</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Context* <span class="title function_">kcontext</span><span class="params">(Area kstack, <span class="type">void</span> (*entry)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中<ul>
<li>kstack是栈的范围</li>
<li>entry是内核线程的入口</li>
<li>arg则是内核线程的参数.</li>
</ul>
</li>
<li>此外, kcontext()要求<strong>内核线程不能从entry返回, 否则其行为是未定义的</strong>. 你需要<strong>在kstack的底部创建一个以entry为入口的上下文结构(目前你可以先忽略arg参数), 然后返回这一结构的指针.</strong></li>
</ul>
<h5 id="b-线程-进程调度"><a href="#b-线程-进程调度" class="headerlink" title="b. 线程&#x2F;进程调度"></a>b. 线程&#x2F;进程调度</h5><ul>
<li>上下文的创建和切换是由 CTE 负责的，而具体切换到哪个上下文则由操作系统决定，这项任务称为<strong>进程调度</strong>。进程调度由 <code>schedule()</code> 函数完成，它返回将要调度的进程上下文。</li>
<li>为了实现多任务调度，需要记录当前正在运行的进程，这通过 <code>current</code> 指针实现，它指向当前运行进程的 PCB。在 <code>schedule()</code> 中，通过 <code>current</code> 指针决定接下来要调度的进程。</li>
<li>在调度之前，需要将当前进程的上下文指针保存在 PCB 中：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// save the context pointer</span></span><br><span class="line">current-&gt;cp = prev;</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch between pcb[0] and pcb[1]</span></span><br><span class="line">current = (current == &amp;pcb[<span class="number">0</span>] ? &amp;pcb[<span class="number">1</span>] : &amp;pcb[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// then return the new context</span></span><br><span class="line"><span class="keyword">return</span> current-&gt;cp;</span><br></pre></td></tr></table></figure>
<ul>
<li>目前 <code>schedule()</code> 总是切换到另一个进程。所选进程的上下文通过 <code>kcontext()</code> 创建，在 <code>schedule()</code> 中决定切换到它，并在 CTE 的 <code>__am_asm_trap()</code> 中真正恢复这一上下文。</li>
</ul>
<h4 id="必做：实现上下文切换"><a href="#必做：实现上下文切换" class="headerlink" title="必做：实现上下文切换"></a>必做：实现上下文切换</h4><ul>
<li>根据讲义的上述内容, 实现以下功能:<ul>
<li>CTE的<code>kcontext()</code>函数</li>
<li>修改CTE中_<code>_am_asm_trap()</code>的实现, 使得从<code>__am_irq_handle()</code>返回后, 先将栈顶指针切换到新进程的上下文结构, 然后才恢复上下文, 从而完成上下文切换的本质操作</li>
</ul>
</li>
<li>正确实现后, 你将看到<code>yield-os</code>不断输出 <code>?</code> , 这是因为我们还没有为<code>kcontext()</code>实现参数功能, 不过这些输出的 <code>?</code> 至少说明了CTE目前可以正确地从<code>yield-os</code>的<code>main()</code>函数切换到其中一个内核线程.</li>
</ul>
<ol>
<li>在kstack底部创建一个上下文结构(返回地址是entry)，然后返回这个上下文结构的指针</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Context *<span class="title function_">kcontext</span><span class="params">(Area kstack, <span class="type">void</span> (*entry)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">  <span class="comment">// return NULL;</span></span><br><span class="line">  Context *ctx = (Context *)(kstack.end - <span class="keyword">sizeof</span>(Context));</span><br><span class="line">  ctx-&gt;mepc = (<span class="type">uintptr_t</span>)entry;</span><br><span class="line">  <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>修改CTE中<code>__am_asm_trap()</code></li>
</ol>
<ul>
<li>从<code>__am_irq_handle()</code>返回后, 先将栈顶指针切换到新进程的上下文结构, 然后才恢复上下文</li>
<li><code>abstract-machine/am/src/riscv/nemu/trap.S</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.align 3</span><br><span class="line">.globl __am_asm_trap</span><br><span class="line">__am_asm_trap:</span><br><span class="line">  addi sp, sp, -CONTEXT_SIZE</span><br><span class="line"></span><br><span class="line">  MAP(REGS, PUSH)</span><br><span class="line"></span><br><span class="line">  csrr t0, mcause</span><br><span class="line">  csrr t1, mstatus</span><br><span class="line">  csrr t2, mepc</span><br><span class="line"></span><br><span class="line">  STORE t0, OFFSET_CAUSE(sp)</span><br><span class="line">  STORE t1, OFFSET_STATUS(sp)</span><br><span class="line">  STORE t2, OFFSET_EPC(sp)</span><br><span class="line"></span><br><span class="line">  # set mstatus.MPRV to pass difftest</span><br><span class="line">  li a0, (1 &lt;&lt; 17)</span><br><span class="line">  or t1, t1, a0</span><br><span class="line">  csrw mstatus, t1</span><br><span class="line"></span><br><span class="line">  mv a0, sp</span><br><span class="line">  jal __am_irq_handle</span><br><span class="line"></span><br><span class="line">  # 切换到新进程的上下文结构</span><br><span class="line">  mv sp, a0</span><br><span class="line"></span><br><span class="line">  LOAD t1, OFFSET_STATUS(sp)</span><br><span class="line">  LOAD t2, OFFSET_EPC(sp)</span><br><span class="line">  csrw mstatus, t1</span><br><span class="line">  csrw mepc, t2</span><br><span class="line"></span><br><span class="line">  MAP(REGS, POP)</span><br><span class="line"></span><br><span class="line">  addi sp, sp, CONTEXT_SIZE</span><br><span class="line">  mret</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在<code>/ics2024/am-kernels/kernels/yield-os</code>目录下<code>make run ARCH=riscv32-nemu</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Welcome to riscv32-NEMU!</span><br><span class="line">For help, type &quot;help&quot;</span><br><span class="line">[src/monitor/monitor.c:36 welcome] Exercise: Please remove me in the source code and compile NEMU again.</span><br><span class="line">??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????[src/cpu/cpu-exec.c:147 statistic] host time spent = 10,105,245 us</span><br><span class="line">[src/cpu/cpu-exec.c:148 statistic] total guest instructions = 105,536,449</span><br><span class="line">[src/cpu/cpu-exec.c:149 statistic] simulation frequency = 10,443,729 inst/s</span><br><span class="line">make: *** [/home/xiaoyao/ics2024/abstract-machine/scripts/platform/nemu.mk:32: run] 中断</span><br></pre></td></tr></table></figure>
<ul>
<li>成功！</li>
</ul>
<hr>
<h5 id="c-内核线程的参数"><a href="#c-内核线程的参数" class="headerlink" title="c. 内核线程的参数"></a>c. 内核线程的参数</h5><ul>
<li>为了让<code>yield-os</code>的内核线程可以正确输出字符, 我们需要通过 <code>kcontext()</code> 给 <code>f()</code> <strong>传参</strong>. </li>
<li>只需要让<code>kcontext()</code>按照<strong>调用约定</strong>将 <code>arg</code> 放置在<strong>正确的位置</strong>, 将来f()执行的时候就可以获取正确的参数了.</li>
</ul>
<h4 id="必做：实现上下文切换-2"><a href="#必做：实现上下文切换-2" class="headerlink" title="必做：实现上下文切换(2)"></a>必做：实现上下文切换(2)</h4><ul>
<li>根据讲义的上述内容, 修改CTE的<code>kcontext()</code>函数, 使其<strong>支持参数arg的传递</strong>.</li>
<li>因为<code>f()</code>中每次输出完信息都会调用<code>yield()</code>, 因此只要我们正确实现内核线程的参数传递, 就可以观察到yield-os在两个内核线程之间来回切换的现象.</li>
</ul>
<ol>
<li>RISC-V调用约定:<ul>
<li>函数参数传递<ul>
<li>前 8 个函数参数通过寄存器 a0 到 a7 传递。</li>
<li>如果参数超过 8 个，多余的参数通过栈传递。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x0 (zero): 常数 0</span><br><span class="line">x1 (ra): 返回地址</span><br><span class="line">x2 (sp): 栈指针</span><br><span class="line">x3 (gp): 全局指针</span><br><span class="line">x4 (tp): 线程指针</span><br><span class="line">x5-x7 (t0-t2): 临时寄存器</span><br><span class="line">x8 (s0/fp): 保存寄存器/帧指针</span><br><span class="line">x9 (s1): 保存寄存器</span><br><span class="line">x10-x11 (a0-a1): 函数返回值/函数参数</span><br><span class="line">x12-x17 (a2-a7): 函数参数</span><br><span class="line">x18-x27 (s2-s11): 保存寄存器</span><br><span class="line">x28-x31 (t3-t6): 临时寄存器</span><br></pre></td></tr></table></figure>
<ul>
<li>根据调用约定，把arg放到<strong>a0寄存器</strong></li>
</ul>
<ol start="2">
<li>在CTE的<code>kcontext()</code>函数添加</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ctx-&gt;gpr[<span class="number">10</span>] = (<span class="type">uintptr_t</span>)arg;</span><br></pre></td></tr></table></figure>
<ul>
<li>成功！</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Welcome to riscv32-NEMU!</span><br><span class="line">For help, type &quot;help&quot;</span><br><span class="line">[src/monitor/monitor.c:36 welcome] Exercise: Please remove me in the source code and compile NEMU again.</span><br><span class="line">ABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABA[src/cpu/cpu-exec.c:147 statistic] host time spent = 4,025,540 us</span><br><span class="line">[src/cpu/cpu-exec.c:148 statistic] total guest instructions = 42,032,479</span><br><span class="line">[src/cpu/cpu-exec.c:149 statistic] simulation frequency = 10,441,451 inst/s</span><br><span class="line">make[1]: 离开目录“/home/xiaoyao/ics2024/nemu”</span><br></pre></td></tr></table></figure>

<h3 id="（二）OS中的上下文切换"><a href="#（二）OS中的上下文切换" class="headerlink" title="（二）OS中的上下文切换"></a>（二）OS中的上下文切换</h3><h4 id="Nanos-lite"><a href="#Nanos-lite" class="headerlink" title="Nanos-lite"></a>Nanos-lite</h4><ul>
<li>Nanos-lite<strong>上下文切换需要用到的函数和数据结构</strong>和yield-os非常类似, 只不过由于Nanos-lite的代码规模更大, 它们分散在不同的文件中, 你需要<strong>RTFSC</strong>找到它们. 此外, Nanos-lite的框架代码已经定义了PCB结构体, 其中还包含其他目前暂不使用的成员, 我们会在将来介绍它们.</li>
</ul>
<h4 id="必做：在Nanos-lite中实现上下文切换"><a href="#必做：在Nanos-lite中实现上下文切换" class="headerlink" title="必做：在Nanos-lite中实现上下文切换"></a>必做：在Nanos-lite中实现上下文切换</h4><ul>
<li>实现以下功能:<ul>
<li>Nanos-lite的<code>context_kload()</code>函数(框架代码<em>未给出该函数的原型</em>), 它进一步封装了创建内核上下文的过程: <strong>调用kcontext()来创建上下文, 并把返回的指针记录到PCB的cp中</strong></li>
<li>Nanos-lite的<code>schedule()</code>函数</li>
<li>在Nanos-lite<strong>收到EVENT_YIELD事件后, 调用schedule()并返回新的上下文</strong></li>
</ul>
</li>
<li>Nanos-lite提供了一个<code>测试函数 hello_fun()</code>(在<code>nanos-lite/src/proc.c</code>中定义), 你需要在<code>init_proc()</code>中<strong>创建两个以hello_fun为入口的上下文</strong>:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_proc</span><span class="params">()</span> &#123;</span><br><span class="line">  context_kload(&amp;pcb[<span class="number">0</span>], hello_fun, ???);</span><br><span class="line">  context_kload(&amp;pcb[<span class="number">1</span>], hello_fun, ???);</span><br><span class="line">  switch_boot_pcb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中调用<code>switch_boot_pcb()</code>是为了初始化current指针. 你可以自行约定用何种类型来解析参数arg(整数, 字符, 字符串, 指针等皆可), 然后修改hello_fun()中的输出代码, 来按照你约定的方式解析arg. 如果你的实现正确, 你将会看到hello_fun()会轮流输出不同参数的信息.</li>
</ul>
<ol>
<li><code>/ics2024/nanos-lite/src/proc.c</code>中实现 <strong>context_kload()</strong> 函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现 context_kload() 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">context_kload</span><span class="params">(PCB *pcb, <span class="type">void</span> (*entry)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">  Area kstack = (Area)&#123;.start = pcb-&gt;<span class="built_in">stack</span>, .end = pcb-&gt;<span class="built_in">stack</span> + <span class="keyword">sizeof</span>(pcb-&gt;<span class="built_in">stack</span>)&#125;;</span><br><span class="line">  pcb-&gt;cp = kcontext(kstack, entry, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>实现**schedule()**函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Context* <span class="title function_">schedule</span><span class="params">(Context *prev)</span> &#123;</span><br><span class="line">  <span class="comment">// return NULL;</span></span><br><span class="line">  current-&gt;cp = prev;</span><br><span class="line">  current = (current == &amp;pcb[<span class="number">0</span>] ? &amp;pcb[<span class="number">1</span>] : &amp;pcb[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">return</span> current-&gt;cp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在<code>init_proc()</code>中创建两个<strong>以hello_fun为入口的上下文</strong>:</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_proc</span><span class="params">()</span> &#123;</span><br><span class="line">  switch_boot_pcb();</span><br><span class="line"></span><br><span class="line">  Log(<span class="string">&quot;Initializing processes...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// load program here</span></span><br><span class="line">  <span class="comment">// naive_uload(NULL, NULL);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建两个以hello_fun为入口的上下文:</span></span><br><span class="line">  context_kload(&amp;pcb[<span class="number">0</span>], hello_fun, <span class="string">&quot; QAQ &quot;</span>);</span><br><span class="line">  context_kload(&amp;pcb[<span class="number">1</span>], hello_fun, <span class="string">&quot; TWT &quot;</span>);</span><br><span class="line">  switch_boot_pcb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在Nanos-lite<strong>收到EVENT_YIELD事件后, 调用schedule()并返回新的上下文</strong></li>
</ol>
<ul>
<li><p>报错<code>system panic: Unhandled event ID = 4</code></p>
</li>
<li><p>去把pa3做完了，继续看一下</p>
</li>
<li><p>后面准备不做了</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机系统基础实验</category>
      </categories>
      <tags>
        <tag>PA</tag>
      </tags>
  </entry>
  <entry>
    <title>七、路由和路由器</title>
    <url>/2025/02/24/%E4%B8%83.%E8%B7%AF%E7%94%B1%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="07-Routing-and-Routers"><a href="#07-Routing-and-Routers" class="headerlink" title="07. Routing and Routers"></a>07. Routing and Routers</h1><ul>
<li>Router Basics</li>
<li>Router Startup procedure</li>
<li>Routing</li>
<li>Router configuration</li>
</ul>
<h1 id="一、Router-Basics-路由器基础"><a href="#一、Router-Basics-路由器基础" class="headerlink" title="一、Router Basics 路由器基础"></a>一、Router Basics 路由器基础</h1><h2 id="1-内部组成"><a href="#1-内部组成" class="headerlink" title="1. 内部组成"></a>1. 内部组成</h2><p><img src="/2025/02/24/%E4%B8%83.%E8%B7%AF%E7%94%B1%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8/image.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><strong>RAM</strong> 随机存取存储器<ul>
<li>用于<strong>临时</strong>存储路由器<strong>配置文件</strong></li>
<li><strong>断电或重启</strong>时RAM内容会<strong>丢失</strong></li>
<li>存储内容包括：<ul>
<li><strong>路由表</strong></li>
<li>ARP缓存</li>
<li>快速交换缓存</li>
<li>数据包缓冲</li>
<li>数据包保持队列</li>
</ul>
</li>
</ul>
</li>
<li><strong>NVRAM</strong> 非易失性随机存取存储器<ul>
<li><strong>非易失性 Non-volatile</strong> 随机存取存储器</li>
<li>存储备份&#x2F;启动配置文件</li>
<li>路由器断电或重启时内容<strong>不会丢失</strong></li>
</ul>
</li>
<li><strong>Flash</strong><ul>
<li><strong>EEPROM</strong>（电子可擦除可编程只读存储器）<ul>
<li>Electronically Erasable Programmable Read-Only Memory</li>
</ul>
</li>
<li>存储Cisco IOS（互联网操作系统）</li>
<li>允许在不更换Flash芯片的情况下更新软件</li>
<li>可以存储多个版本的IOS</li>
<li>断电时内容<strong>不会丢失</strong></li>
</ul>
</li>
<li><strong>ROM</strong> 只读存储器 Read-Only Memory<ul>
<li>包含<strong>上电自检POST</strong>（Power On Self Test）</li>
<li><strong>启动程序</strong>（加载Cisco IOS）</li>
<li>操作系统软件</li>
<li>备份的精简版IOS</li>
<li>升级需要安装新的芯片组</li>
</ul>
</li>
<li><strong>Interface</strong> 接口<ul>
<li>网络连接，通过这些接口连接数据包进入和退出路由器</li>
<li>附加在主板上或作为独立模块</li>
</ul>
</li>
</ol>
<hr>
<h1 id="Router-Startup-Procedure-路由器启动步骤"><a href="#Router-Startup-Procedure-路由器启动步骤" class="headerlink" title="Router Startup Procedure 路由器启动步骤"></a>Router Startup Procedure 路由器启动步骤</h1><h2 id="1-系统启动过程-System-Startup-Procedure"><a href="#1-系统启动过程-System-Startup-Procedure" class="headerlink" title="1. 系统启动过程: System Startup Procedure"></a>1. 系统启动过程: System Startup Procedure</h2><ol>
<li><strong>执行上电自检（POST）</strong>：<ul>
<li>在自检过程中，路由器从<strong>ROM</strong>中执行诊断，检查所有硬件模块。</li>
</ul>
</li>
<li><strong>验证基本操作</strong>：<ul>
<li>验证CPU、内存和网络接口端口的基本操作。</li>
</ul>
</li>
<li><strong>软件初始化</strong>：<ul>
<li>初始化操作系统和其他软件组件。</li>
</ul>
</li>
</ol>
<h2 id="2-软件启动过程"><a href="#2-软件启动过程" class="headerlink" title="2. 软件启动过程:"></a>2. 软件启动过程:</h2><ol>
<li><strong>步骤1</strong>：通用引导加载程序在ROM中执行，在CPU卡上运行。</li>
<li><strong>步骤2</strong>：操作系统（Cisco IOS）可以在多个位置找到。位置在配置寄存器的引导字段中指定。</li>
<li><strong>步骤3</strong>：加载操作系统映像。</li>
<li><strong>步骤4</strong>：将保存在NVRAM中的配置文件加载到主内存中，并逐行执行。</li>
<li><strong>步骤5</strong>：如果NVRAM中没有有效的配置文件，则执行一个问题驱动的初始配置例程，称为系统配置对话，也称为设置模式。</li>
</ol>
<h2 id="3-检验基本的路由配置"><a href="#3-检验基本的路由配置" class="headerlink" title="3. 检验基本的路由配置"></a>3. 检验基本的路由配置</h2><ul>
<li>使用show running-config 命令</li>
<li>存储路由器基本配置copy running-config<br> startup-config</li>
</ul>
<hr>
<h1 id="三、Routing-路由"><a href="#三、Routing-路由" class="headerlink" title="三、Routing 路由"></a>三、Routing 路由</h1><h2 id="1-使用网络寻址进行路由"><a href="#1-使用网络寻址进行路由" class="headerlink" title="1. 使用网络寻址进行路由"></a>1. 使用网络寻址进行路由</h2><p><img src="/2025/02/24/%E4%B8%83.%E8%B7%AF%E7%94%B1%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8/image-1.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>路由器通常通过两个基本功能将数据包从一个数据链路中继到另一个数据链路：<ol>
<li><strong>path determination 路径确定功能</strong>：决定数据包的最佳传输路径。</li>
<li><strong>switching 交换功能</strong>：将数据包从<em>输入接口</em>转发到适当的<em>输出接口</em>。</li>
</ol>
</li>
<li><strong>交换功能</strong>允许路由器<strong>在一个接口上接受数据包</strong>并<strong>通过第二个接口转发</strong>。</li>
<li><strong>路径确定功能</strong>使路由器能够<strong>选择最合适的接口</strong>来<strong>转发数据包</strong>。</li>
<li>路由器使用地址的<strong>网络部分</strong>进行<em>路径选择</em>，以将数据包传递到<em>下一个路由器</em></li>
<li>地址的<strong>节点部分</strong>由<em>直接连接到目标网络的路由器</em> 使用，以将数据包传递到<em>正确的主机</em>。</li>
</ol>
<h2 id="2-Static-and-Dynamic-Route-静态和动态路由"><a href="#2-Static-and-Dynamic-Route-静态和动态路由" class="headerlink" title="2. Static and Dynamic Route 静态和动态路由"></a>2. Static and Dynamic Route 静态和动态路由</h2><p><img src="/2025/02/24/%E4%B8%83.%E8%B7%AF%E7%94%B1%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8/image-2.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="2-1-静态路由例子"><a href="#2-1-静态路由例子" class="headerlink" title="2.1. 静态路由例子"></a>2.1. 静态路由例子</h3><ul>
<li><img src="/2025/02/24/%E4%B8%83.%E8%B7%AF%E7%94%B1%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8/image-3.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>尽管（whereas）动态路由倾向于显示（reveal）有关互联网络的所有已知信息，但是出于安全原因，您可能<em>希望隐藏互联网络的某些部分</em>。</li>
<li>当<em>只有一条路径可访问网络时</em>，到网络的静态路由就足够了。</li>
<li>这种分区称为<strong>Stub Network</strong></li>
</ul>
<h3 id="2-2-静态路由配置Configuration"><a href="#2-2-静态路由配置Configuration" class="headerlink" title="2.2. 静态路由配置Configuration"></a>2.2. 静态路由配置Configuration</h3><p><img src="/2025/02/24/%E4%B8%83.%E8%B7%AF%E7%94%B1%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8/image-4.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><code>ip route network [mask] &#123;address | interface&#125; [distance]</code></p>
<ul>
<li><strong>network</strong>：目标网络或子网</li>
<li><strong>mask</strong>：子网掩码</li>
<li><strong>address</strong>：下一跳路由器的IP地址</li>
<li><strong>interface</strong>：到达目标网络所使用的接口</li>
<li><strong>distance</strong>：管理距离 administrative distance</li>
</ul>
<h4 id="管理距离-Administrative-Distance"><a href="#管理距离-Administrative-Distance" class="headerlink" title="管理距离 Administrative Distance"></a>管理距离 Administrative Distance</h4><ul>
<li>管理距离是对路由信息源<strong>可信度</strong>的评级，以0到255的数值表示。</li>
<li><strong>数值越高，可信度越低</strong>。</li>
<li>因此，<strong>静态路由的管理距离通常较低（默认值为1）</strong></li>
</ul>
<h2 id="3-动态路由"><a href="#3-动态路由" class="headerlink" title="3. 动态路由"></a>3. 动态路由</h2><ul>
<li>动态路由协议也可以在网络中的不同路径之间重定向流量 redirect traffic（或负载共享loadshare）。</li>
</ul>
<ol>
<li>动态路由依赖于路由协议在路由器之间共享知识。</li>
<li>动态路由<em>取决于</em>两个基本路由器功能：<ul>
<li><strong>维护（maintance）路由表</strong></li>
<li><strong>向其他路由器分发（distribution）路由信息</strong></li>
</ul>
</li>
</ol>
<h2 id="4-收敛时间-Time-to-Convergence"><a href="#4-收敛时间-Time-to-Convergence" class="headerlink" title="4. 收敛时间 Time to Convergence"></a>4. 收敛时间 Time to Convergence</h2><ol>
<li>收敛时间：<ul>
<li>从刚启动到网络达到稳定的时间</li>
<li>从（网络拓扑）发生变化到再次稳定的时间</li>
</ul>
</li>
<li>收敛时间越短，路由协议越强，网络的稳定性和可靠性也越高，需要路由器的基本硬件支持。</li>
</ol>
<h2 id="5-动态路由协议分类"><a href="#5-动态路由协议分类" class="headerlink" title="5. 动态路由协议分类"></a>5. 动态路由协议分类</h2><ul>
<li>距离矢量（DV,Distance Vector）</li>
<li>链路状态（LS,Link State）</li>
<li>混合路由（HR,Hybird Routing）</li>
</ul>
<h3 id="5-1-距离矢量协议-Distance-Vector-Protocol"><a href="#5-1-距离矢量协议-Distance-Vector-Protocol" class="headerlink" title="5.1 距离矢量协议 Distance-Vector Protocol"></a>5.1 距离矢量协议 Distance-Vector Protocol</h3><ul>
<li>距离矢量算法<strong>不允许</strong>路由器知道互联网络的<strong>确切拓扑</strong>结构。</li>
<li>基于距离矢量的路由算法（也称为<strong>Bellman-Ford算法</strong>）通过路由器之间定期传递路由表的副本来工作。<ul>
<li>大家交换 Routing Table</li>
<li>只知道可达，但是不知道怎么可达（知道 where,但是不知道 how），不知道整个网路的具体拓扑</li>
</ul>
</li>
</ul>
<h4 id="DVP导致问题"><a href="#DVP导致问题" class="headerlink" title="DVP导致问题"></a>DVP导致问题</h4><ol>
<li>问题1：<strong>路由环路 Routing loops</strong>:<ul>
<li>路由环路是指数据包在网络中不断循环，无法到达目的地。距离矢量协议由于缺乏全局拓扑信息，容易导致路由环路。</li>
</ul>
</li>
<li>问题2：<strong>计数到无穷大 Couting to Infinity</strong>：<ul>
<li>当网络中某条路径失效时，路由器可能会不断增加到该路径的距离，直到达到预设的最大值（无穷大）。这会导致网络收敛时间变长，影响网络性能。</li>
<li>当路由器在计数到无穷大时，无效信息会导致路由环路的存在。</li>
</ul>
</li>
</ol>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li><strong>定义最大值（最大跳数）</strong>：<ul>
<li>通过定义一个最大跳数（例如15跳），限制路由器可以传播的最大距离。当达到这个最大值时，路由器将认为路径不可达，从而避免计数到无穷大的问题。</li>
</ul>
</li>
<li><strong>路由毒化 Route Poisoning</strong>：<ul>
<li>当路由器检测到某条路径<em>失效</em>时，将该路径的距离<em>设置为无穷大</em>，并立即<em>通知其他路由器</em>，从而加速收敛。</li>
</ul>
</li>
<li><strong>水平分割 Split Horizon</strong>：<ul>
<li>路由器从某个端口收到的报文信息，不能再从该端口发送回去，从而防止路由环路。</li>
</ul>
</li>
<li><strong>持久计时器 Hold-Down Timers</strong>：<ul>
<li>在路径失效后，路由器会等待一段时间再接受关于该路径的更新信息，从而避免无效信息的传播。</li>
</ul>
</li>
</ol>
<h4 id="防止发送路由更新"><a href="#防止发送路由更新" class="headerlink" title="防止发送路由更新"></a>防止发送路由更新</h4><ul>
<li>为了防止接口发送任何路由更新信息，可以使用以下命令：</li>
</ul>
<p><code>Router(config-router)# passive-interface f0/0</code></p>
<ul>
<li>仅当使用距离矢量路由协议时，它才有效，因为链路状态路由协议不会直接从其邻接方的路由表中获取拓扑信息</li>
</ul>
<h3 id="5-2-链路状态协议-LSP-Link-state-Protocol"><a href="#5-2-链路状态协议-LSP-Link-state-Protocol" class="headerlink" title="5.2 链路状态协议 LSP Link-state Protocol"></a>5.2 链路状态协议 LSP Link-state Protocol</h3><ul>
<li>基于链路状态的路由算法（也称为<strong>SPF（最短路径优先）算法</strong>）维护一个复杂的拓扑信息数据库。</li>
<li>链路状态路由使用：<ul>
<li><strong>链路状态公告（LSAs）</strong></li>
<li><strong>拓扑数据库</strong></li>
<li><strong>SPF算法和生成的SPF树</strong></li>
<li><strong>到每个网络的路径和端口的路由表</strong></li>
</ul>
</li>
<li>RFC 1583包含了OSPF链路状态概念和操作的描述。</li>
<li>工作原理<ol>
<li><strong>交换LSAs</strong>：<ul>
<li>路由器之间交换链路状态公告（LSAs）。每个路由器从直接连接的网络开始。</li>
</ul>
</li>
<li><strong>构建拓扑数据库</strong>：<ul>
<li>每个路由器与其他路由器并行构建一个包含所有LSAs的拓扑数据库。</li>
</ul>
</li>
<li><strong>SPF算法计算网络可达性</strong>：<ul>
<li>SPF算法计算网络的可达性。路由器将这个逻辑拓扑构建为一棵树，以自身为根，包含到每个网络的所有可能路径。然后按最短路径优先（SPF）对这些路径进行排序。</li>
</ul>
</li>
<li><strong>更新路由表</strong>：<ul>
<li>路由器在路由表中列出其最佳路径和到这些目标网络的端口。它还维护其他拓扑元素和状态细节的数据库。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="LSP关注点"><a href="#LSP关注点" class="headerlink" title="LSP关注点"></a>LSP关注点</h4><ol>
<li><strong>处理和内存需求</strong>：<ul>
<li>运行链路状态路由协议通常需要路由器使用<strong>更多</strong>的内存和进行更多的处理，相比于距离矢量路由协议。</li>
</ul>
</li>
<li><strong>带宽需求</strong>：<ul>
<li>在初始链路状态数据包泛洪期间，所有使用链路状态路由协议的路由器会向其他所有路由器发送LSA数据包。这一行为会泛洪整个互联网络，<strong>增加带宽需求</strong>，并暂时减少用于传输用户数据的带宽。</li>
</ul>
</li>
</ol>
<h4 id="问题-链路状态更新-Link-State-Updates"><a href="#问题-链路状态更新-Link-State-Updates" class="headerlink" title="问题: 链路状态更新 Link-State Updates"></a>问题: 链路状态更新 Link-State Updates</h4><ul>
<li>链路状态路由必须确保<em>所有路由器</em>都获取到<em>所有必要的LSA数据包</em>。</li>
<li>拥有不同LSA集合的路由器会基于不同的拓扑数据计算路由。</li>
</ul>
<h3 id="比较：链路状态LSP和距离矢量DVP"><a href="#比较：链路状态LSP和距离矢量DVP" class="headerlink" title="比较：链路状态LSP和距离矢量DVP"></a>比较：链路状态LSP和距离矢量DVP</h3><ol>
<li>DV：距离矢量<ul>
<li>视野窄，代价小</li>
<li>基于<strong>跳数</strong></li>
<li>定期交换路由表，收敛慢</li>
<li>交换<strong>路由表</strong></li>
</ul>
</li>
<li>LS：链路状态<ul>
<li>视野宽，有一定代价</li>
<li>基于<strong>带宽</strong></li>
<li>初期充分交换，收敛快</li>
<li>交换 <strong>Linked State 的数据库</strong></li>
</ul>
</li>
</ol>
<h3 id="5-3-混合协议-Hybrid-Protocols"><a href="#5-3-混合协议-Hybrid-Protocols" class="headerlink" title="5.3 混合协议 Hybrid Protocols"></a>5.3 混合协议 Hybrid Protocols</h3><ol>
<li>混合协议结合了距离矢量协议DVP和链路状态协议LSP的特性。</li>
</ol>
<ul>
<li><strong>示例</strong>：<ul>
<li><strong>OSI的IS-IS（Intermediate System-to-Intermediate System）</strong></li>
<li><strong>Cisco的EIGRP（Enhanced Interior Gateway Routing Protocol）</strong></li>
</ul>
</li>
</ul>
<hr>
<h1 id="四、Routing-Protocols-主动路由协议"><a href="#四、Routing-Protocols-主动路由协议" class="headerlink" title="四、Routing Protocols 主动路由协议"></a>四、Routing Protocols 主动路由协议</h1><ol>
<li>IP路由协议示例<ul>
<li><strong>RIP</strong>：距离矢量路由协议</li>
<li><strong>IGRP</strong>：Cisco的距离矢量路由协议</li>
<li><strong>OSPF</strong>：链路状态路由协议</li>
<li><strong>EIGRP</strong>：平衡混合路由协议<br><img src="/2025/02/24/%E4%B8%83.%E8%B7%AF%E7%94%B1%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8/image-5.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li>工作在第3层——网络层</li>
<li>路由协议的主要目标<ul>
<li><strong>最佳路径</strong>：Optimal<ul>
<li>选择最佳路径</li>
</ul>
</li>
<li><strong>效率</strong>：Efficiency<ul>
<li>最小化带宽和路由器处理资源的使用</li>
</ul>
</li>
<li><strong>快速收敛</strong>：Rapid Convergence<ul>
<li>收敛速度越快越好。有些协议比其他协议收敛得更快。</li>
</ul>
</li>
<li><strong>灵活性</strong>：Flexibility<ul>
<li>能够处理各种情况，如高使用率和路由失败</li>
</ul>
</li>
</ul>
</li>
<li>动态路由配置 Dynamic Routing Configuration</li>
</ol>
<p><code>router protocol [keyword]</code> 定义一个IP路由协议<br><code>network network-number</code> network-number：指定一个直接连接的网络</p>
<ul>
<li>例如<ol>
<li>启动RIP：<code>router protocol [RIP...]</code></li>
</ol>
</li>
</ul>
<ol start="5">
<li>定义<strong>默认路由</strong></li>
</ol>
<ul>
<li><strong>默认路由</strong>：保持路由表简短。</li>
<li>当路由表中不存在目标网络的条目时，数据包将被发送到默认网络。<ol>
<li>用动态路由协议定义默认路由</li>
</ol>
<p>  <code>ip default-network [network-number]</code><br>  2. 用静态路由定义默认路由<br>  <code> ip route 0.0.0.0 0.0.0.0 [next-hop-ip address| exit-interface]</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>二、OSI第一层：物理层</title>
    <url>/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<h1 id="OSI第一层：物理层"><a href="#OSI第一层：物理层" class="headerlink" title="OSI第一层：物理层"></a>OSI第一层：物理层</h1><h1 id="一、网络连接类型"><a href="#一、网络连接类型" class="headerlink" title="一、网络连接类型"></a>一、网络连接类型</h1><p><img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image-4.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><strong>多路复用共享机制</strong></li>
</ol>
<ul>
<li><strong>多个主机可以访问同一介质</strong></li>
<li>它们都使用相同的传输介质—即使这个传输介质是<strong>非屏蔽双绞线（UTP）</strong>，它也包含四对线来传输数据。</li>
</ul>
<ol start="2">
<li><strong>点对点网络</strong></li>
</ol>
<ul>
<li><strong>一个设备通过链路连接到另一个设备</strong></li>
<li>最广泛地应用于拨号网络连接，也是你最熟悉的一种。使用电信号来完成传输。</li>
</ul>
<h1 id="二、LAN-Media局域网介质"><a href="#二、LAN-Media局域网介质" class="headerlink" title="二、LAN Media局域网介质"></a>二、LAN Media局域网介质</h1><p><img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image-5.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>功能是<strong>传输数据</strong></li>
<li>光信号、无线信号等传输过程称为<strong>编码</strong></li>
<li><strong>电缆类型</strong>包括<strong>STP(有屏蔽双绞线)、UTP(无屏蔽双绞线)、同轴电缆、光纤</strong></li>
<li>调节频率、电压、相位等方式来实现不同01编码</li>
</ol>
<h2 id="1-STP和ScTP-屏蔽双绞线-抗干扰能力强"><a href="#1-STP和ScTP-屏蔽双绞线-抗干扰能力强" class="headerlink" title="1. STP和ScTP: 屏蔽双绞线, 抗干扰能力强"></a>1. STP和ScTP: 屏蔽双绞线, 抗干扰能力强</h2><ul>
<li>STP:<code>Shielded Twisted Pair</code></li>
</ul>
<ol>
<li>4对线布线，结合了屏蔽和通过线缆扭绞实现的消除效应。</li>
<li>通常是一种150欧姆的电缆</li>
<li>能够减少串扰、EMI（电磁干扰）和RFI（射频干扰）</li>
<li>比UTP（非屏蔽双绞线）提供更好的<strong>对所有类型外部干扰的保护</strong>。</li>
</ol>
<ul>
<li>ScTP：<code>Screened Twisted Pair</code></li>
</ul>
<ol>
<li>包裹在金属箔屏蔽层或屏蔽网中</li>
<li>通常是100或120欧姆的电缆。</li>
<li>STP和ScTP都能防止外来的电磁波在数据线上产生噪声，并且还能最大限度地减少向外辐射的电磁波。</li>
</ol>
<ul>
<li>缺点: <ol>
<li>信号不被中继的情况下, 传输距离较近</li>
<li>绝缘大大增加了电缆的尺寸、重量和成本</li>
<li>屏蔽材料使端接更加困难，并且容易受到工艺不良的影响</li>
</ol>
</li>
</ul>
<h2 id="2-UTP-非屏蔽双绞线-Unshielded-Twisted-Pair"><a href="#2-UTP-非屏蔽双绞线-Unshielded-Twisted-Pair" class="headerlink" title="2. UTP (非屏蔽双绞线 Unshielded Twisted Pair)"></a>2. UTP (非屏蔽双绞线 Unshielded Twisted Pair)</h2><ul>
<li>由<strong>八根子线</strong>组成,<strong>两个线组合成一组</strong>，<strong>共四组</strong>，可以保证每一组电流抵消电磁波干扰（抗干扰能力有限）</li>
</ul>
<ol>
<li>仅（solely）依赖于消除效应，由双绞线对产生，以限制由 EMI 和 RFI 引起的信号退化</li>
<li>有四对铜线，阻抗（impedance）为 100 欧姆，频率低、接口小、布线更加方便</li>
<li>一般认为有效范围为 100m</li>
</ol>
<ul>
<li>优点<ul>
<li><em>易于安装且成本较低</em>，线薄接口小</li>
<li>每米成本低于任何其他类型的局域网布线</li>
<li>较小的外径不能像其他类型的电缆那样迅速地填满布线管道（duct）</li>
<li>使用 RJ 连接器安装，因此可以大大减少潜在的网络噪声源，并确保良好的可靠连接</li>
</ul>
</li>
<li>缺点：<ul>
<li>与其他类型的网络媒体相比，电缆更容易产生电噪声和干扰</li>
<li>双绞线的信号增强距离比同轴电缆（Coaxial）和光纤（Fiber-Optic）短</li>
</ul>
</li>
</ul>
<h2 id="3-同轴电缆-Coaxial-Cable"><a href="#3-同轴电缆-Coaxial-Cable" class="headerlink" title="3. 同轴电缆 Coaxial Cable"></a>3. 同轴电缆 Coaxial Cable</h2><ol>
<li><em>Thinnet&#x2F;thicknet</em></li>
<li>与双绞线twisted-pair相比，不使用中继器的网络运行时间更长</li>
<li>比光纤便宜但比双绞线贵</li>
</ol>
<h2 id="4-光纤-Fiber-Optic-Cable"><a href="#4-光纤-Fiber-Optic-Cable" class="headerlink" title="4. 光纤 Fiber Optic Cable"></a>4. 光纤 Fiber Optic Cable</h2><ol>
<li>传导调制（modulated）光传输</li>
<li>不易受到电磁干扰或射频干扰，并且能够比其他网络媒体更高的数据速率</li>
<li>电磁波（electromagnetic wave）通过光纤被引导</li>
<li>比较可靠，中间是二氧化硅（光导体），外面是塑料套，两个接口一个接收一个发送</li>
<li>成本比较高</li>
</ol>
<h3 id="模式1：单模光纤（Single-Mode-Fiber-SMF）"><a href="#模式1：单模光纤（Single-Mode-Fiber-SMF）" class="headerlink" title="模式1：单模光纤（Single-Mode Fiber, SMF）"></a>模式1：单模光纤（Single-Mode Fiber, SMF）</h3><ul>
<li>也称为轴向光纤axial：光沿着光纤的轴线传播。</li>
<li>比多模光纤更快：因为多模光纤中存在色散</li>
<li>通常用于<strong>广域网（WANs）</strong>：单模光纤常用于需要<strong>长距离、高速传输的广域网</strong>。</li>
<li>直径比多模光纤小：色散较少，因此信号传输更稳定。</li>
<li>使用激光二极管（ILD）最常见，但也使用发光二极管（LED）</li>
</ul>
<h3 id="模式2：多模光纤（Multi-Mode-Fiber-MMF）"><a href="#模式2：多模光纤（Multi-Mode-Fiber-MMF）" class="headerlink" title="模式2：多模光纤（Multi-Mode Fiber, MMF）"></a>模式2：多模光纤（Multi-Mode Fiber, MMF）</h3><ul>
<li>非轴向传播：光以不同角度进入玻璃管</li>
<li>直径比单模光纤大：多模光纤的直径比单模光纤大，通常用于<strong>局域网（LANs）</strong>。</li>
<li>更容易受到色散的影响</li>
</ul>
<h2 id="5-无线通信（Wireless-Communication）"><a href="#5-无线通信（Wireless-Communication）" class="headerlink" title="5. 无线通信（Wireless Communication）"></a>5. 无线通信（Wireless Communication）</h2><ul>
<li>区分不同电磁波的主要方法是通过它们的<strong>频率</strong>。（频率多路复用）</li>
<li>把信号编码成为电磁波的方式<ul>
<li>不同设备使用不同频段，可以互不干扰</li>
</ul>
</li>
</ul>
<h2 id="6-无线传输手段（Wireless-Transmission-Methods）"><a href="#6-无线传输手段（Wireless-Transmission-Methods）" class="headerlink" title="6. 无线传输手段（Wireless Transmission Methods）"></a>6. 无线传输手段（Wireless Transmission Methods）</h2><ol>
<li>激光：<ul>
<li>输出相干（coherent）电磁场：所有波的频率相同且相位对齐。</li>
</ul>
</li>
<li>红外线（Infrared）：激光通常使用红外线。<ul>
<li>通常是视距技术：激光通常需要视距传输，但可以通过反射或重定向来传输。</li>
<li>不能穿透不透明物体。</li>
</ul>
</li>
<li>无线电（Radio）：<ul>
<li>传输数据信号：无线电可以传输数据信号，并且这些信号可以穿透墙壁。</li>
<li>地面和卫星无线电技术：无线电技术包括地面无线电和卫星无线电两种。</li>
</ul>
</li>
</ol>
<h1 id="三、UTP-for-Ethernet-以太网中的非屏蔽双绞线"><a href="#三、UTP-for-Ethernet-以太网中的非屏蔽双绞线" class="headerlink" title="三、UTP for Ethernet 以太网中的非屏蔽双绞线"></a>三、UTP for Ethernet 以太网中的非屏蔽双绞线</h1><h2 id="1-非屏蔽双绞线的分类"><a href="#1-非屏蔽双绞线的分类" class="headerlink" title="1. 非屏蔽双绞线的分类"></a>1. 非屏蔽双绞线的分类</h2><ol>
<li>一类线：主要用于语音传输，不用于数据传输</li>
<li>二类线：传输频率1MHz，用于语音和最高4Mbps的数据传输，常见于令牌网</li>
<li><strong>三类线</strong>：EIA&#x2F;TIA568标准指定电缆，传输频率16MHz，用于语音传输及最高传输速率为10Mbps的数据传输，主要用于10BASE-T</li>
<li>四类线：传输频率为20MHz，用于语音传输和最高传输速率16Mbps的数据传输，主要用于令牌网和10BASE-T&#x2F;100BASE-T</li>
<li><strong>五类线</strong>：增加了绕线密度，外套高质量绝缘材料，用于语音和数据传输(主要为100&#x2F;1000BASE-T)，是最常用的以太网电缆</li>
<li><strong>超五类线</strong>：衰减小，串扰少，具有更高的衰减&#x2F;串扰比和信噪比、更小的时延误差，主要用于1000BASE-T</li>
<li><strong>六类线</strong>：传输频率为1MHz～250MHz，性能远高于超五类标准，适用于高于1Gbps的应用</li>
<li>七类线：带宽为600MHz，可能用于今后的10G比特以太网</li>
</ol>
<h2 id="2-Type-of-Cable-线的类型"><a href="#2-Type-of-Cable-线的类型" class="headerlink" title="2. Type of Cable 线的类型"></a>2. Type of Cable 线的类型</h2><ul>
<li><strong>直通线 Straight Cable</strong><ol>
<li><strong>用途</strong>：用于连接<strong>不同类型的设备</strong>，如计算机和交换机、计算机和路由器。</li>
<li>连接方式：直通电缆的两端使用<em>相同的线序标准</em>进行连接，常见的标准有T568A和T568B。</li>
</ol>
</li>
<li><strong>反转线 Rollover Cable</strong><ol>
<li><strong>用途</strong>：用于连接<strong>终端设备和控制台端口</strong>，通常用于配置路由器或交换机。</li>
<li><strong>连接方式</strong>：一端的线序完全反转，即1对8、2对7、3对6、4对5。</li>
</ol>
</li>
<li><strong>交叉线Crossover Cable</strong><ol>
<li><strong>用途</strong>：用于连接<strong>相同类型的设备</strong>，如计算机和计算机、交换机和交换机。</li>
<li><strong>连接方式</strong>：两端的线序<em>不同</em>，一端使用T568A标准，另一端使用T568B标准。</li>
</ol>
</li>
</ul>
<h1 id="四、Media-and-signal-Problems介质和信号问题"><a href="#四、Media-and-signal-Problems介质和信号问题" class="headerlink" title="四、Media and signal Problems介质和信号问题"></a>四、Media and signal Problems介质和信号问题</h1><h2 id="1-Collisions-and-Collision-Domains-碰撞和碰撞域"><a href="#1-Collisions-and-Collision-Domains-碰撞和碰撞域" class="headerlink" title="1. Collisions and Collision Domains 碰撞和碰撞域"></a>1. Collisions and Collision Domains 碰撞和碰撞域</h2><ol>
<li><strong>碰撞（Collisions）</strong><ul>
<li>在网络中，碰撞是指两个或多个设备<strong>同时尝试发送数据</strong>时，<strong>数据包在网络介质上相互干扰的现象</strong>。</li>
</ul>
</li>
<li><strong>碰撞域（Collision Domains）</strong><ul>
<li>碰撞域是指在网络中，数据包碰撞可能发生的范围或区域。在同一个碰撞域内，所有设备共享同一个通信介质，因此它们可能会发生碰撞。</li>
<li><strong>拓展碰撞域</strong>：添加<strong>中继器（repeaters）和集线器（hubs）</strong></li>
<li><strong>限制碰撞域</strong>：通过添加智能设备如<strong>网桥（bridges）、交换机（switches）和路由器（routers）</strong>，可以对网络进行<em>分段</em>。</li>
</ul>
</li>
</ol>
<ul>
<li>当网络中的延迟超过一定限制时，<em>晚碰撞</em>的数量会显著增加。</li>
<li>晚碰撞（<code>Late Collision</code>）：是指在帧的前64字节传输之后发生的碰撞。</li>
<li>消耗延迟（<code>Consumption Delay</code>）：这些晚碰撞帧会增加一种称为消耗延迟的延迟。<br>网络性能：</li>
<li>随着消耗延迟和延迟（Latency）的增加，网络性能会下降。</li>
</ul>
<h2 id="2-5-4-3-2-1规则"><a href="#2-5-4-3-2-1规则" class="headerlink" title="2. 5-4-3-2-1规则"></a>2. 5-4-3-2-1规则</h2><ul>
<li>5-4-3-2-1规则是以太网网络设计中的一个指导原则，用于确保网络性能和减少冲突。具体内容如下：</li>
</ul>
<ol>
<li><strong>5个网段</strong>：在一个以太网网络中，最多可以有5个网段。</li>
<li><strong>4个中继器&#x2F;集线器</strong>：在这5个网段之间，最多可以有4个repeaters或hubs。</li>
<li><strong>3个有源网段</strong>：在这5个网段中，最多可以有3个”mixing” sections（即连接了计算机或其他设备）。</li>
<li><strong>2个无源网段</strong>：其余的2个网段必须是link sections（即只用于信号传输，不连接任何设备）。</li>
<li><strong>1个冲突域</strong>：整个网络必须在一个冲突域内，确保所有设备都能检测到冲突。</li>
</ol>
<h1 id="五、-Basic-Knowledge-of-Data-Communication数据通信基本知识"><a href="#五、-Basic-Knowledge-of-Data-Communication数据通信基本知识" class="headerlink" title="五、 Basic Knowledge of Data Communication数据通信基本知识"></a>五、 Basic Knowledge of Data Communication数据通信基本知识</h1><h2 id="1-数据通信的理论基础"><a href="#1-数据通信的理论基础" class="headerlink" title="1. 数据通信的理论基础"></a>1. 数据通信的理论基础</h2><h3 id="1-1-基本术语"><a href="#1-1-基本术语" class="headerlink" title="1.1 基本术语"></a>1.1 基本术语</h3><ul>
<li>信号(signal)——数据的电气的或电磁的表现<ol>
<li>模拟的(analogous)——消息的参数的取值是连续的<ul>
<li>模拟信号是随时间变化而平稳变化的连续波形式</li>
</ul>
</li>
<li>数字的(digital)——消息的参数的取值是离散的<ul>
<li>数字信号是离散信号，可能包含有限的几个预定值</li>
</ul>
</li>
</ol>
</li>
<li>码元(code)——在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形</li>
</ul>
<h3 id="1-2-信号处理"><a href="#1-2-信号处理" class="headerlink" title="1.2 信号处理"></a>1.2 信号处理</h3><h3 id="1-3-波特率和比特率"><a href="#1-3-波特率和比特率" class="headerlink" title="1.3 波特率和比特率"></a>1.3 波特率和比特率</h3><ul>
<li>波特率（baud）和比特率（bit）<ul>
<li>波特率（调制速率）：信号每秒钟变化的次数</li>
<li>比特率：每秒钟传送的二进制位数</li>
</ul>
</li>
</ul>
<h2 id="2-数据通信技术"><a href="#2-数据通信技术" class="headerlink" title="2. 数据通信技术"></a>2. 数据通信技术</h2><h3 id="2-1-数据通信系统的模型"><a href="#2-1-数据通信系统的模型" class="headerlink" title="2.1 数据通信系统的模型"></a>2.1 数据通信系统的模型</h3><p><img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image-6.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="2-3-数字数据编码"><a href="#2-3-数字数据编码" class="headerlink" title="2.3 数字数据编码"></a>2.3 数字数据编码</h3><ul>
<li>将数字数据转换到模拟信号：调制</li>
<li>将数字数据转换到数字信号：线路编码, 线路编码是指将二进制数据转换为可以在物理通信链路上传播的形式，例如电线上的电脉冲、光纤上的光脉冲或太空中的电磁波</li>
</ul>
<h3 id="2-4-编码方式"><a href="#2-4-编码方式" class="headerlink" title="2.4 编码方式"></a>2.4 编码方式</h3><ul>
<li>可以分为三类</li>
</ul>
<ol>
<li>单极性编码<ul>
<li>用0电平表示”0”，正电平表示”1”</li>
</ul>
</li>
<li>极化编码<ol>
<li>不归零制码(NRZ: Non-Return to Zero)<ul>
<li>不归零电平编码：用负电平表示“0”，正电平表示“1”（或相反）</li>
<li>不归零反相编码：信号电平的一次翻转代表比特1，无电平变化代表0</li>
</ul>
</li>
<li>归零制码（RZ: Return to Zero）<ul>
<li>原理：用负电平表示“0”，正电平表示“1”（或相反），比特中位跳变到零电平，从而提供同步</li>
</ul>
</li>
<li></li>
</ol>
</li>
<li>双极性编码</li>
</ol>
<h3 id="2-5-数据通信技术：多路复用"><a href="#2-5-数据通信技术：多路复用" class="headerlink" title="2.5 数据通信技术：多路复用"></a>2.5 数据通信技术：多路复用</h3><ul>
<li>多路复用技术<ul>
<li>由于一条传输线路的能力远远超过传输一个用户信号所需的能力，为了提高线路利用率，经常让多个信号共用一条物理线路</li>
</ul>
</li>
</ul>
<h4 id="a-时分复用-TDM-（Time-Division-Multiplexing）"><a href="#a-时分复用-TDM-（Time-Division-Multiplexing）" class="headerlink" title="a. 时分复用 TDM （Time Division Multiplexing）"></a>a. 时分复用 TDM （Time Division Multiplexing）</h4><ul>
<li>时分复用是将时间划分为一段段等长的<strong>时分复用（TDM ）帧</strong>，每个时分复用的用户在每个TDM 帧中占用固定序号的时隙。</li>
<li>每一个用户所占用的时隙是周期性地出现</li>
<li>TDM 信号也称为<strong>等时(isochronous)信号</strong></li>
<li><strong>时分复用的所有用户在不同的时间占用同样的带宽资源</strong></li>
<li>可能会造成线路资源的浪费<br><img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image-7.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h4 id="b-频分复用-FDM（Frequency-Division-Multiplexing）"><a href="#b-频分复用-FDM（Frequency-Division-Multiplexing）" class="headerlink" title="b. 频分复用 FDM（Frequency Division Multiplexing）"></a>b. 频分复用 FDM（Frequency Division Multiplexing）</h4><ul>
<li>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带</li>
<li><strong>频分复用的所有用户在同样的时间占用不同的带宽资源</strong><br><img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image-1.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h4 id="c-波分复用-WDM-Wavelength-Division-Multiplexing"><a href="#c-波分复用-WDM-Wavelength-Division-Multiplexing" class="headerlink" title="c. 波分复用 WDM (Wavelength Division Multiplexing)"></a>c. 波分复用 WDM (Wavelength Division Multiplexing)</h4><ul>
<li>就是<strong>光的频分复用</strong><br><img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image-2.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image-3.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h4 id="d-码分复用-CDM-Code-Division-Multiplexing"><a href="#d-码分复用-CDM-Code-Division-Multiplexing" class="headerlink" title="d. 码分复用 CDM (Code Division Multiplexing)"></a>d. 码分复用 CDM (Code Division Multiplexing)</h4><ul>
<li>更常用的名词是<strong>码分多址 CDMA</strong> (Code Division<br>Multiple Access)</li>
<li>各用户使用经过特殊挑选的<strong>不同码型</strong>，因此<strong>各用户之间不会造成干扰</strong></li>
<li>有很强的<strong>抗干扰能力</strong>，其频谱类似于白噪声，不易被敌人发现</li>
</ul>
<h2 id="2-6-数据通信技术：通信方式"><a href="#2-6-数据通信技术：通信方式" class="headerlink" title="2.6 数据通信技术：通信方式"></a>2.6 数据通信技术：通信方式</h2><ul>
<li>分类：<ul>
<li>单工Simplex Transmission<ul>
<li>信号只能在一个方向传播</li>
</ul>
</li>
<li>半双工Half-Duplex Transmission<ul>
<li>可以双向传播，但不能同时</li>
</ul>
</li>
<li>全双工Full-Duplex Transmission<ul>
<li>可以双向同时传播</li>
</ul>
</li>
</ul>
</li>
<li>并行传输与串行传输<ul>
<li>并行传输：0、1组成的二进制数据。组成每组n比特的位组，同时发送这种位组（8根线一次发送01010101）</li>
<li>串行传输：每次传输1位比特（一根线8次发送01010101）<br>  <img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image-8.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>九、局域网交换和VLAN</title>
    <url>/2025/02/24/%E4%B9%9D.%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%92%8CVLAN/</url>
    <content><![CDATA[<h1 id="09-LAN-Switching-and-VLAN"><a href="#09-LAN-Switching-and-VLAN" class="headerlink" title="09 LAN Switching and VLAN"></a>09 LAN Switching and VLAN</h1><h1 id="一、Switching"><a href="#一、Switching" class="headerlink" title="一、Switching"></a>一、Switching</h1><ol>
<li>对称交换(Symmetric Switching)</li>
</ol>
<ul>
<li><strong>对称交换</strong>：<ul>
<li>提供<strong>带宽相同的端口</strong>之间的交换连接（如10&#x2F;10 Mbps或100&#x2F;100 Mbps）。</li>
<li>当用户尝试访问其他段上的服务器时，可能会导致瓶颈。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>非对称交换(Asymmetric Switching)</li>
</ol>
<ul>
<li><strong>非对称交换</strong>：<ul>
<li>通过将服务器所在的段<strong>连接到更高带宽的端口</strong>（如100 Mbps），减少潜在瓶颈的可能性。</li>
<li>非对称交换需要在交换机中进行内存缓冲。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>内存缓冲</strong>：<ul>
<li>交换机中的内存区域，用于存储目的地和传输数据，直到可以通过正确的端口交换出去。</li>
</ul>
<ol>
<li>基于端口的内存缓冲<ul>
<li>数据包存储在每个端口的队列中。</li>
<li>由于目标端口繁忙，可能导致一个数据包延迟其他数据包的传输。</li>
</ul>
</li>
<li>共享内存缓冲<ul>
<li>所有端口共享的公共内存缓冲。</li>
<li>允许数据包在一个端口接收（RX）并在另一个端口发送（TX），而无需更改到不同的队列。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="4-交换方式"><a href="#4-交换方式" class="headerlink" title="4. 交换方式"></a>4. 交换方式</h2><h3 id="1-存储转发（Store-and-Forward）"><a href="#1-存储转发（Store-and-Forward）" class="headerlink" title="1. 存储转发（Store-and-Forward）"></a>1. 存储转发（Store-and-Forward）</h3><ul>
<li>网桥、路由器等通过软件的设备</li>
</ul>
<ol>
<li>交换机<strong>接收整个帧</strong>，最后将其计算为CRC，然后再将其发送到目的地</li>
<li>接收后，<em>校验</em>，正确再发送</li>
</ol>
<h3 id="2-直通交换（Cut-through）"><a href="#2-直通交换（Cut-through）" class="headerlink" title="2. 直通交换（Cut-through）"></a>2. 直通交换（Cut-through）</h3><ul>
<li>交换机会增加延迟，可以通过使用直通交换方法来<em>减少延迟</em>。<ul>
<li><strong>快速转发交换（Fast Forward Switching）</strong>：仅检查<strong>目标MAC地址</strong>，然后立即转发帧。</li>
</ul>
</li>
</ul>
<h3 id="3-无碎片转发（Segment-free-Switching）"><a href="#3-无碎片转发（Segment-free-Switching）" class="headerlink" title="3. 无碎片转发（Segment-free Switching）"></a>3. 无碎片转发（Segment-free Switching）</h3><ul>
<li>碎片释放（Fragment Free）：在转发帧之前读取前 64 个字节以减少错误：避免碰撞和帧碎片</li>
</ul>
<h1 id="二、The-Spanning-Tree-Protocol-STP-生成树协议"><a href="#二、The-Spanning-Tree-Protocol-STP-生成树协议" class="headerlink" title="二、The Spanning-Tree Protocol (STP)生成树协议"></a>二、The Spanning-Tree Protocol (STP)生成树协议</h1><p>ISDN中</p>
<ul>
<li><p><strong>ISDN BRI服务</strong>：</p>
<ul>
<li>提供两个B信道和一个D信道。</li>
<li>ISDN BRI提供总带宽为144kbps（2B+D&#x3D;144kbps）的线路，分为三个独立的信道。</li>
<li>BRI的B信道服务以64kbps的速度运行，用于传输用户数据和语音通信。</li>
<li>第三个信道，D信道，是一个16kbps的信令信道，用于传输指令，告诉电话网络如何处理每个B信道。</li>
</ul>
</li>
<li><p><strong>ISDN PRI服务</strong></p>
</li>
<li><p>提供23或30个B信道和一个D信道</p>
</li>
<li><p>带宽：</p>
<ul>
<li>B信道 B Channal  64kbps</li>
<li>D信道 D Channal  16kbps</li>
</ul>
</li>
<li><p>what is the bandwidth of <strong>an</strong> ISDN BRI-B Channel? </p>
<ul>
<li>64kbps</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>五、OSI第四层:运输层</title>
    <url>/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h1 id="第五章-第四层-运输层-Transport-Layer"><a href="#第五章-第四层-运输层-Transport-Layer" class="headerlink" title="第五章 第四层:运输层 Transport Layer"></a>第五章 第四层:运输层 Transport Layer</h1><ul>
<li>第四层运输层主要是实现了主机之间的通信。</li>
<li>数据通信是服务于主机上的进程(Session)</li>
</ul>
<ol>
<li>An overview of layer 4</li>
<li>TCP (Transmission Control Protocol)</li>
<li>UDP(User Datagram Protocol)</li>
<li>An application: NAT and PAT</li>
</ol>
<h1 id="一、第四层综述"><a href="#一、第四层综述" class="headerlink" title="一、第四层综述"></a>一、第四层综述</h1><h2 id="1、第4层执行多项功能："><a href="#1、第4层执行多项功能：" class="headerlink" title="1、第4层执行多项功能："></a>1、第4层执行多项功能：</h2><ol>
<li>对上层应用数据进行分段（segmenting upper-layer application data）</li>
<li>建立<strong>端到端</strong>(end to end)的运营</li>
<li>将段从一个端主机发送到另一个端主机<ul>
<li>(第三层和第二层不进行可靠性检验，第四层完成可靠性检验，接受方认为数据错误，在第四层进行要求重传)</li>
</ul>
</li>
<li><strong>流量控制</strong>和<strong>可靠性</strong><ul>
<li>可以比喻为<em>与外国人交谈</em>:通常，您会要求外国人<em>重复他&#x2F;她的话(可靠性)</em> 并<em>慢声说话(流量控制)</em></li>
<li>双方主机的网络的处理能力不同，缓存能力不同</li>
</ul>
</li>
</ol>
<h2 id="2-两个特别重要的第4层协议："><a href="#2-两个特别重要的第4层协议：" class="headerlink" title="2. 两个特别重要的第4层协议："></a>2. 两个特别重要的第4层协议：</h2><ol>
<li><strong>传输控制协议</strong>(<strong>TCP</strong>, Transmission Control Protocol)</li>
<li><strong>用户数据报协议</strong>(<strong>UDP</strong>, User Datagram Protocol)</li>
</ol>
<h2 id="3-Layer-4-The-Transport-Layer"><a href="#3-Layer-4-The-Transport-Layer" class="headerlink" title="3. Layer 4:  The Transport Layer"></a>3. Layer 4:  The Transport Layer</h2><ol>
<li>将传出消息划分为多个<strong>段</strong> + 在目标站重新<strong>组合</strong>消息</li>
<li><strong>传输控制协议（TCP）</strong>：<ul>
<li><strong>可靠</strong></li>
<li><strong>面向连接 Connection -oriented</strong></li>
<li>软件<strong>检查</strong>段</li>
<li><strong>重新发送</strong>任何丢失或出错的段</li>
<li>使用<strong>确认 acknowledgments</strong></li>
<li>提供<strong>流量控制</strong></li>
</ul>
</li>
<li><strong>用户数据报协议（UDP）</strong>：<ul>
<li>不可靠</li>
<li>无连接 connectionless</li>
<li>不提供段的软件检查</li>
<li>（直接丢弃错误的报文，而不进行其他操作）</li>
<li>不使用确认</li>
<li>不提供流量控制</li>
</ul>
</li>
</ol>
<h2 id="4-服务模型"><a href="#4-服务模型" class="headerlink" title="4. 服务模型"></a>4. 服务模型</h2><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-1.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>TCP和UDP都使用<strong>端口 port</strong>来跟踪(track)同时穿越网络的不同会话</li>
<li>应用软件开发人员同意使用在RFC1700中定义的知名端口号。</li>
<li>端口号低于255的端口保留用于TCP和UDP公共应用程序。<ul>
<li>端口号<strong>0-255是public</strong>的，<strong>不可以随意分给其他的进程</strong>，如果分发则不符合规范</li>
</ul>
</li>
</ol>
<h2 id="5-套接字-Socket-第四层的单位"><a href="#5-套接字-Socket-第四层的单位" class="headerlink" title="5. 套接字(Socket, 第四层的单位)"></a>5. 套接字(Socket, 第四层的单位)</h2><ul>
<li>套接字<strong>表示为（IP地址，端口）</strong>。</li>
<li>每个<strong>连接</strong>表示为（<strong>源套接字，目标套接字</strong>），这是一个<strong>点对点</strong>的<strong>全双工</strong>通道。</li>
<li>TCP不支持多播和广播。</li>
</ul>
<hr>
<h1 id="二、-TCP-Transmission-Control-Protocol"><a href="#二、-TCP-Transmission-Control-Protocol" class="headerlink" title="二、 TCP (Transmission Control Protocol)"></a>二、 TCP (Transmission Control Protocol)</h1><ul>
<li><strong>传输控制协议</strong></li>
</ul>
<h2 id="1-TCP-服务模型"><a href="#1-TCP-服务模型" class="headerlink" title="1. TCP 服务模型"></a>1. TCP 服务模型</h2><h3 id="1-1-TCP必须解决的问题"><a href="#1-1-TCP必须解决的问题" class="headerlink" title="1.1 TCP必须解决的问题"></a>1.1 TCP必须解决的问题</h3><ol>
<li><strong>可靠传输</strong> Reliable transfer</li>
<li><strong>流量传输</strong> Flow control<ul>
<li>滑动窗口 Sliding window</li>
<li>避免拥塞 congestion avoidance</li>
</ul>
</li>
<li><strong>连接控制</strong> Connection management<ul>
<li>建立连接:三次握手</li>
<li>断开连接:四次握手</li>
</ul>
</li>
</ol>
<h3 id="1-2-TCP数据段的格式"><a href="#1-2-TCP数据段的格式" class="headerlink" title="1.2 TCP数据段的格式"></a>1.2 TCP数据段的格式</h3><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h4 id="1-2-1-首部情况"><a href="#1-2-1-首部情况" class="headerlink" title="1.2.1. 首部情况"></a>1.2.1. 首部情况</h4><ul>
<li>一行共计4字节，段首在前，<strong>固定首部长度为20字节</strong>。</li>
</ul>
<h4 id="1-2-2-源端口和目的端口"><a href="#1-2-2-源端口和目的端口" class="headerlink" title="1.2.2. 源端口和目的端口"></a>1.2.2. 源端口和目的端口</h4><ul>
<li>源端口和目的端口字段:各占 <strong>2 字节</strong></li>
</ul>
<ol>
<li>端口是运输层与<strong>应用层</strong>的服务接口</li>
<li>运输层的复用和分用功能都要通过端口才能实现</li>
</ol>
<h4 id="1-2-3-序号"><a href="#1-2-3-序号" class="headerlink" title="1.2.3. 序号"></a>1.2.3. 序号</h4><ul>
<li>序号字段：占<strong>4 字节</strong></li>
</ul>
<ol>
<li>TCP 传送的数据流中的每一个字节都编上一个序号</li>
<li>序号字段的值指本报文段所发送的数据的第一个字节的序号</li>
</ol>
<h4 id="1-2-4-确认号"><a href="#1-2-4-确认号" class="headerlink" title="1.2.4. 确认号"></a>1.2.4. 确认号</h4><ul>
<li>确认号字段：占 <strong>4 字节</strong>，是<strong>期望</strong>收到对方的<strong>下一个报文段的数据的第一个字节的序号</strong></li>
</ul>
<ol>
<li>确认对方的数据号(发送同时对上一次传输进行确认)</li>
<li>体现出了全双工通信的优点，比如上回收到最后序号是700，那么确认号就是701</li>
</ol>
<h4 id="1-2-5-数据偏移"><a href="#1-2-5-数据偏移" class="headerlink" title="1.2.5. 数据偏移"></a>1.2.5. 数据偏移</h4><ul>
<li>数据偏移(即<em>首部长度</em>)：占 <strong>4 位</strong></li>
</ul>
<ol>
<li>指出 TCP 报文段的<strong>数据起始处距 TCP 报文段的起始处的长度</strong><ul>
<li>(Data部分从什么地方开始算)</li>
</ul>
</li>
<li>单位是 32 位字(以 4 字节为计算单位)</li>
<li>不满足的话<strong>使用填充位保证为4字节的整数倍</strong>(保证对齐问题)</li>
</ol>
<h4 id="1-2-6-保留"><a href="#1-2-6-保留" class="headerlink" title="1.2.6. 保留"></a>1.2.6. 保留</h4><ul>
<li>保留字段：占 <strong>6 位</strong>，保留为今后使用，<strong>目前置 0</strong><ul>
<li>也就是说截止到现在也没有使用这部分的字段。</li>
</ul>
</li>
</ul>
<p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-2.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h4 id="1-2-7-URG"><a href="#1-2-7-URG" class="headerlink" title="1.2.7. URG"></a>1.2.7. URG</h4><ul>
<li><strong>紧急 URG &#x3D; 1 时</strong>，表明紧急指针字段有效。</li>
</ul>
<ol>
<li>告诉系统此报文段中<strong>有紧急数据</strong>，应尽快传送(相当于<strong>高优先级</strong>的数据)</li>
</ol>
<h4 id="1-2-8-ACK"><a href="#1-2-8-ACK" class="headerlink" title="1.2.8. ACK"></a>1.2.8. ACK</h4><ul>
<li>ACK &#x3D; 1 时<strong>确认号字段</strong>有效;</li>
<li>ACK &#x3D; 0 时确认号字段无效</li>
</ul>
<h4 id="1-2-9-PSH-PuSH-推送"><a href="#1-2-9-PSH-PuSH-推送" class="headerlink" title="1.2.9. PSH(PuSH) 推送"></a>1.2.9. PSH(PuSH) 推送</h4><ol>
<li>接收 TCP 收到 <strong>PSH &#x3D; 1</strong> 的报文段，就<strong>尽快地交付接收应用进程</strong>，而<strong>不再等到整个缓存都填满了后再向上交付</strong><ul>
<li>此时<strong>将缓存所有部分都传输</strong>，而<em>并不是只将这个报文段的信息进行传输</em>。</li>
<li>TCP在正常条件下并不是立马传输的，首先要缓存满了才发送，其次还有就是要保证网络可信的时候才发送</li>
</ul>
</li>
</ol>
<h4 id="1-2-10-RST-复位"><a href="#1-2-10-RST-复位" class="headerlink" title="1.2.10. RST 复位"></a>1.2.10. RST 复位</h4><ol>
<li><strong>ReSeT &#x3D; 1时</strong>，表明TCP连接中出现<strong>严重差错</strong>(如由于主机崩溃或其他原因)，<strong>必须释放连接，然后再重新建立运输连接</strong></li>
</ol>
<h4 id="1-2-11-SYN"><a href="#1-2-11-SYN" class="headerlink" title="1.2.11. SYN"></a>1.2.11. SYN</h4><ol>
<li>同步 <strong>SYN &#x3D; 1</strong>:表示<strong>这是一个连接请求或连接接受报文</strong><ul>
<li>(初始的时候才出现)</li>
</ul>
</li>
</ol>
<h4 id="1-2-12-FIN-FINis-终止"><a href="#1-2-12-FIN-FINis-终止" class="headerlink" title="1.2.12. FIN(FINis) 终止"></a>1.2.12. FIN(FINis) 终止</h4><ul>
<li>用来<strong>释放一个连接</strong>。</li>
<li><strong>FIN &#x3D; 1</strong> 表明<strong>此报文段的发送端的数据已发送完毕</strong>，并<em>要求释放运输连接</em>。 <ul>
<li>(发送方没有传输数据了)</li>
</ul>
</li>
</ul>
<p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-3.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h4 id="1-2-13-窗口"><a href="#1-2-13-窗口" class="headerlink" title="1.2.13. 窗口"></a>1.2.13. 窗口</h4><ul>
<li>占 <strong>2 字节</strong>，用来让对方设置发送窗口的依据，单位为字节。<ul>
<li>表示<strong>可以进行传输的窗口大小</strong>是多少。</li>
</ul>
</li>
</ul>
<h4 id="1-2-14-检验和"><a href="#1-2-14-检验和" class="headerlink" title="1.2.14. 检验和"></a>1.2.14. 检验和</h4><ul>
<li>检验和:占<strong>2字节</strong>。检验和字段检验的范围包括<strong>首部</strong>和<strong>数据</strong>这两部分</li>
</ul>
<h4 id="1-2-15-紧急指针字段"><a href="#1-2-15-紧急指针字段" class="headerlink" title="1.2.15. 紧急指针字段"></a>1.2.15. 紧急指针字段</h4><ul>
<li>紧急指针字段:占<strong>16位</strong>，指出在本报文段中<strong>紧急数据共有多少个字节</strong>（紧急数据放在本报文段数据的<strong>最前面</strong>）</li>
</ul>
<h4 id="1-2-16-选项（长度可变）"><a href="#1-2-16-选项（长度可变）" class="headerlink" title="1.2.16. 选项（长度可变）"></a>1.2.16. 选项（长度可变）</h4><ol>
<li>TCP 最初只有一种选项，即最大报文段长度 MSS(Maximum Segment Size)</li>
<li>MSS 告诉对方缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节</li>
<li>数据字段加上 TCP 首部才等于整个的 TCP 报文段</li>
</ol>
<h4 id="1-2-17-填充字段"><a href="#1-2-17-填充字段" class="headerlink" title="1.2.17. 填充字段"></a>1.2.17. 填充字段</h4><ul>
<li>填充字段：这是为了<strong>使整个首部长度是 4 字节的整数倍</strong>。</li>
</ul>
<hr>
<h2 id="2-TCP协议"><a href="#2-TCP协议" class="headerlink" title="2. TCP协议"></a>2. TCP协议</h2><ol>
<li>主机使用**段（TPDU传输层PDU）**交换数据</li>
<li>每个段都有：<ul>
<li>一个<strong>20字节的首部</strong>（不包括可选部分）</li>
<li><strong>0 或更多数据字节</strong>（请求连接的时候）</li>
</ul>
</li>
<li>段的大小必须与 IP 数据包匹配，并且还必须满足底层的需求<ul>
<li>例如，以太网的 MTU（最大传输单位）为 1500 字节</li>
</ul>
</li>
<li><strong>每个字节 byte</strong> 都有一个 32 位的序号<strong>seq</strong></li>
</ol>
<h3 id="2-1-Reliable-Connection-可靠连接"><a href="#2-1-Reliable-Connection-可靠连接" class="headerlink" title="2.1 Reliable Connection 可靠连接"></a>2.1 Reliable Connection 可靠连接</h3><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-4.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>“红蓝两军问题”是一个经典的计算机网络中的死锁（Deadlock）问题，或者说是资源竞争的一个类比。通常是用于阐述一些竞争、阻塞和同步问题。</li>
</ul>
<hr>
<h2 id="3-TCP-Establish-Connection"><a href="#3-TCP-Establish-Connection" class="headerlink" title="3. TCP:Establish Connection"></a>3. TCP:Establish Connection</h2><h3 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h3><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-6.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li><strong>服务器Server</strong>：执行LISTEN和ACCEPT原语，被动监听。</li>
<li><strong>客户端Client</strong>：执行CONNECT原语，生成一个<strong>SYN&#x3D;1和ACK&#x3D;0</strong>的TCP段，表示连<strong>接请求</strong>。<ul>
<li>SYN&#x3D;1：连接请求</li>
<li>ACK&#x3D;0：确认号无效</li>
</ul>
</li>
</ul>
<h3 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h3><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-7.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li><strong>服务器</strong>：检查<strong>是否有服务进程在监听端口</strong></li>
</ul>
<ol>
<li>如果<strong>没有</strong>进程，回复一个<strong>RST&#x3D;1</strong>的TCP段<ul>
<li>差错，要重连</li>
</ul>
</li>
<li>如果<strong>有</strong>进程，决定拒绝或接受请求</li>
<li>如果接受连接请求，发送一个SYN&#x3D;1和ACK&#x3D;1的TCP段<ul>
<li>连接请求</li>
<li>确认号有效</li>
</ul>
</li>
</ol>
<h3 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h3><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-8.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><p><strong>客户端</strong>：发送一个<strong>SYN&#x3D;0和ACK&#x3D;1</strong>的TCP段，以<strong>确认连接</strong>。</p>
</li>
<li><p><strong>服务器</strong>：接收到确认后，通知上层应用程序连接已建立。<br><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-5.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</li>
<li><p>默认三次握手就认为可靠了，之后就进行数据传输</p>
</li>
<li><p>有时候我们会选择，第三次握手的时候同时携带数据。</p>
</li>
</ol>
<ul>
<li>TCP头部中的<strong>SEQ（序列号）字段</strong>：<ul>
<li>32位，用来标识当前数据段的序列号。每发送一个数据段时，序列号会<strong>根据数据段的大小递增</strong>。</li>
<li>通过与ACK（确认号）一起使用，确保了数据的可靠性和完整性。<ul>
<li>此ACK指的是32位的那个</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-10.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>seq和ack的关系：<ul>
<li>在三次握手（TCP连接建立过程）中，序列号用于确保双方都准备好建立连接。</li>
<li>在数据传输过程中，SEQ标识发送的数据包的顺序，而ACK确认已收到的数据。</li>
<li>例如，客户端发送的数据包的SEQ为1000，服务器确认收到后返回ACK为1001，表示它已经成功接收到序列号为1000的数据包。</li>
</ul>
</li>
</ul>
<h2 id="建立连接实例"><a href="#建立连接实例" class="headerlink" title="建立连接实例"></a>建立连接实例</h2><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-9.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>基本的三次握手用于连接同步Synchronization</li>
<li>注意，<strong>ACK不占用序列号空间</strong>（如果占用，我们将最终确认ACK的ACK！）</li>
</ul>
<hr>
<h2 id="4-数据传输——停止等待协议-Data-transfer——stop-and-wait-protocol"><a href="#4-数据传输——停止等待协议-Data-transfer——stop-and-wait-protocol" class="headerlink" title="4. 数据传输——停止等待协议 Data transfer——stop-and-wait protocol"></a>4. 数据传输——停止等待协议 Data transfer——stop-and-wait protocol</h2><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-11.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>发送段后，<strong>暂时保留备份 backup</strong><ul>
<li>在发送后没有收到确认的时候，要保存备份来重传</li>
<li>收到确认的时候，抛弃备份</li>
<li><strong>超时</strong>计时器：如果对方的应答超过一定时间后则<strong>直接进行重发</strong>（时间要比正常往返时间稍微长一点）</li>
</ul>
</li>
<li>每个<strong>segment和 ACK 必须具有 ID</strong></li>
<li>重新发送时间必须大于<strong>平均传输时间 * 2</strong></li>
<li>停止等待协议是一个简单的协议，但是效率很低</li>
</ol>
<h2 id="5-数据传输——丢失-延迟-Lost-ACK-and-Late-ACK"><a href="#5-数据传输——丢失-延迟-Lost-ACK-and-Late-ACK" class="headerlink" title="5. 数据传输——丢失&#x2F;延迟 Lost ACK and Late ACK"></a>5. 数据传输——丢失&#x2F;延迟 Lost ACK and Late ACK</h2><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-12.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>丢失ACK情况:</li>
</ol>
<ul>
<li><strong>发送方</strong>：<strong>重新发送一份</strong>M1数据段</li>
<li><strong>接收方</strong>：如果<strong>接收到重复</strong>的M1数据段，接收方将<strong>丢弃</strong>重复的数据段。<ul>
<li>将<strong>重新发送ACK</strong>，以确认已经接收到的M1数据段。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>ACK迟到情况:</li>
</ol>
<ul>
<li><strong>发送方</strong>：<strong>重新发送一份</strong>M1数据段</li>
<li><strong>接收方</strong>：如果<strong>接收到重复</strong>的M1数据段，接收方将<strong>丢弃</strong>重复的数据段。<ul>
<li>将<strong>重新发送ACK</strong>，以确认已经接收到的M1数据段。</li>
</ul>
</li>
<li>发送方收到迟到的ACK不做理会<ul>
<li>晚到的应答直接丢弃（不做处理）</li>
</ul>
</li>
</ul>
<h2 id="6-可靠通信——自动重传请求（ARQ）"><a href="#6-可靠通信——自动重传请求（ARQ）" class="headerlink" title="6. 可靠通信——自动重传请求（ARQ）"></a>6. 可靠通信——自动重传请求（ARQ）</h2><ul>
<li><strong>ARQ (Automatic Repeat reQuest)</strong></li>
<li>这意味着“重传请求”是<strong>自动发送</strong>的，接收方<strong>无需请求发送方重传出错的数据段</strong>。</li>
</ul>
<h3 id="6-1-连续-ARQ-协议"><a href="#6-1-连续-ARQ-协议" class="headerlink" title="6.1 连续 ARQ 协议"></a>6.1 连续 ARQ 协议</h3><ul>
<li>连续 ARQ 协议（<strong>Contiguous ARQ Protocol</strong>）<br><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-13.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>ARQ的工作原理</li>
</ul>
<ol>
<li><strong>发送方维持发送窗口</strong></li>
<li>收到<strong>一个确认</strong>后，发送窗口<strong>向前滑动</strong></li>
<li>只可发送发送窗口内的数据</li>
</ol>
<h3 id="6-2-具体实例"><a href="#6-2-具体实例" class="headerlink" title="6.2 具体实例"></a>6.2 具体实例</h3><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-14.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>发送端要发送 900 字节长的数据，划分为 9 个 100 字节长的报文段，而<strong>发送窗口确定为 500 字节</strong>。</li>
<li><strong>发送端只要收到了对方的确认，发送窗口就可前移</strong>。</li>
<li>发送 TCP 要维护一个指针。每发送一个报文段，指针就向前移动一个报文段的距离。<br><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-15.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>发送端已发送了 400 字节的数据，但只收到对前 200 字节数据的确认，同时窗口大小不变。</li>
<li>现在发送端还可发送 300 字节。</li>
<li>发送端收到了对方对前 400 字节数据的确认，但对方<strong>通知发送端必须把窗口减小到 400 字节</strong>。</li>
<li>现在发送端最多还可发送 400 字节的数据。<br><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-16.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>利用可变窗口大小进行流量控制，双方确定的窗口值是 400<br><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-17.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<ul>
<li><strong>WIN：窗口的大小</strong>：双方动态协商，收到确认调整窗口</li>
<li>ACK：是指可以继续发送的数据的位置。</li>
<li>为什么 201 在 401 后面发送？<strong>超时重传</strong>（<strong>要超过两倍的平均传输时间后才进行重传</strong>）</li>
</ul>
<hr>
<h2 id="7-TCP-Release-Connection-中断连接"><a href="#7-TCP-Release-Connection-中断连接" class="headerlink" title="7. TCP: Release Connection 中断连接"></a>7. TCP: Release Connection 中断连接</h2><h3 id="第一次握手：A发起断开连接请求"><a href="#第一次握手：A发起断开连接请求" class="headerlink" title="第一次握手：A发起断开连接请求"></a>第一次握手：A发起断开连接请求</h3><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-18.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li><strong>客户端</strong>：发送一个<strong>FIN&#x3D;1</strong>的TCP段，表示<strong>请求中断连接</strong>。</li>
<li>这表示发送方已经没有数据要发送了，但仍然可以接收数据</li>
</ul>
<h3 id="第二次握手：B-Ack-1-允许断开"><a href="#第二次握手：B-Ack-1-允许断开" class="headerlink" title="第二次握手：B:Ack &#x3D; 1:允许断开"></a>第二次握手：B:Ack &#x3D; 1:允许断开</h3><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-21.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li><strong>服务器</strong>：发送一个ACK&#x3D;1的TCP段，表示确认接收到中断连接请求.</li>
<li>此时，<em>接收方可能还有未发送完的数据</em>，因此<strong>连接仍然保持</strong>，只是<strong>不再发送新的数据</strong>，此时我们需要完成之前未处理完成的数据的处理。(这里只是说我已经收到了你请求停止传输的请求)</li>
</ul>
<h3 id="第三次握手：B-FIN-1-数据处理完成"><a href="#第三次握手：B-FIN-1-数据处理完成" class="headerlink" title="第三次握手：B:FIN &#x3D; 1:数据处理完成"></a>第三次握手：B:FIN &#x3D; 1:数据处理完成</h3><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-22.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li><strong>服务器</strong>: 发送一个FIN&#x3D;1的TCP段, 表示它也没有数据要发送了，准备中断连接</li>
</ul>
<h3 id="第四次握手：A：ACK-1，确认收到B的断开信息"><a href="#第四次握手：A：ACK-1，确认收到B的断开信息" class="headerlink" title="第四次握手：A：ACK&#x3D;1，确认收到B的断开信息"></a>第四次握手：A：ACK&#x3D;1，确认收到B的断开信息</h3><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-23.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li><strong>客户端</strong>: 发送一个ACK&#x3D;1的TCP段, 表示确认中断连接. 此时<strong>连接正式关闭</strong></li>
</ul>
<h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-24.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>在<strong>释放连接之前</strong>，<strong>客户端</strong>必须等待<strong>2倍的最大报文段生存时间（2MSL）</strong></li>
</ul>
<h2 id="7-为什么要等待2MSL"><a href="#7-为什么要等待2MSL" class="headerlink" title="7. 为什么要等待2MSL"></a>7. 为什么要等待2MSL</h2><ul>
<li>确保A发送的最后一个ACK能够到达B</li>
<li>防止任何无效的连接请求段出现<ul>
<li>等待2MSL后，我们可以确保连接上的所有段都已消失</li>
</ul>
</li>
</ul>
<hr>
<h2 id="9-TCP的计时器"><a href="#9-TCP的计时器" class="headerlink" title="9. TCP的计时器"></a>9. TCP的计时器</h2><ol>
<li>重传计时器</li>
<li>坚持计时器<ul>
<li><strong>作用</strong>：用于解决TCP连接中的“零窗口”问题。当接收方的接收窗口为零时，发送方会停止发送数据，并启动坚持计时器。坚持计时器到期后，发送方会发送一个小的探测报文段（窗口探测），询问接收方的窗口大小是否已经更新。</li>
<li><strong>目的</strong>：防止发送方和接收方在“零窗口”状态下进入死锁。</li>
</ul>
</li>
<li>保持计时器<ul>
<li><strong>作用</strong>：用于检测TCP连接是否仍然有效。当一段时间内没有数据传输时，保持计时器会启动，并定期发送探测报文段。如果在多次探测后没有收到对方的响应，连接将被认为已经失效。</li>
<li><strong>目的</strong>：确保连接的有效性，及时发现和关闭失效的连接，释放资源。</li>
</ul>
</li>
<li>时间等待计时器</li>
</ol>
<h2 id="10-TCP的有限状态机"><a href="#10-TCP的有限状态机" class="headerlink" title="10. TCP的有限状态机"></a>10. TCP的有限状态机</h2><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-25.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>粗线：正常的服务器端</li>
<li>虚线：正常客户端</li>
<li>细线：异常状态的问题</li>
</ul>
<hr>
<h1 id="三、UDP-User-Datagram-Protocol"><a href="#三、UDP-User-Datagram-Protocol" class="headerlink" title="三、UDP (User Datagram Protocol)"></a>三、UDP (User Datagram Protocol)</h1><ul>
<li><strong>用户数据报协议</strong></li>
</ul>
<h2 id="1-为什么需要UDP"><a href="#1-为什么需要UDP" class="headerlink" title="1. 为什么需要UDP"></a>1. 为什么需要UDP</h2><ul>
<li><strong>无需连接建立</strong>：不需要连接建立过程（比如TCP三次握手，这可能会增加<strong>延迟</strong>）。</li>
<li><strong>简单</strong>：发送方和接收方<strong>没有连接状态</strong>。</li>
<li><strong>小的段头部</strong>：段头部较小，只有<strong>8个字节</strong>。</li>
<li><strong>无拥塞控制</strong>：UDP可以根据需要快速发送数据。</li>
</ul>
<h2 id="2-介绍（特点与应用）"><a href="#2-介绍（特点与应用）" class="headerlink" title="2. 介绍（特点与应用）"></a>2. 介绍（特点与应用）</h2><ol>
<li>无连接 Connectionless：<ul>
<li><strong>无握手</strong>：UDP发送方sender和接收方receiver之间没有握手过程。</li>
<li><strong>独立处理</strong>：UDP中的每个数据报文（Datagram）是独立处理的</li>
</ul>
</li>
<li>常用于流媒体应用 streaming multimedia applications：<ul>
<li><strong>容错</strong>：对丢失容忍。loss tolerant</li>
<li><strong>速率敏感</strong>：对传输速率敏感，而UDP允许尽可能快。rate sensitive</li>
<li>流媒体应用eg：音频、视频</li>
</ul>
</li>
<li>UDP的应用：<ul>
<li><strong>RIP（路由信息协议）</strong>：定期发送路由信息。<ul>
<li>由于RIP的数据包较小且定期发送，使用UDP可以避免TCP的连接建立和关闭带来的延迟。</li>
</ul>
</li>
<li><strong>DNS（域名系统）</strong>：DNS查询通常使用UDP<ul>
<li>因为DNS查询通常是短小的请求和响应，且不需要建立连接，使用UDP可以避免TCP建立连接时的延迟。</li>
</ul>
</li>
<li><strong>SNMP（简单网络管理协议）</strong>：SNMP用于网络设备的监控和管理<ul>
<li>尤其是在拥塞的情况下，UDP能够比TCP提供更高的性能，因为TCP在拥塞情况下会出现重传和延迟。</li>
</ul>
</li>
<li><strong>其他协议</strong>：包括TFTP（简单文件传输协议）、DHCP（动态主机配置协议）等不需要建立可靠连接的协议。</li>
</ul>
</li>
<li>必要时在应用层添加可靠性<ul>
<li>由于UDP本身不提供可靠性，应用层可以根据需要自己实现数据的可靠性控制。</li>
</ul>
</li>
</ol>
<h2 id="3-UDP段格式"><a href="#3-UDP段格式" class="headerlink" title="3. UDP段格式"></a>3. UDP段格式</h2><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-26.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>UDP 的数据段很简单</li>
<li>UDP 只有 <strong>8 个字节的首部</strong>，所以 <strong>UDP 报文最少是 8 个字节</strong></li>
</ul>
<ol>
<li>源端口（Source Port）：16位，发送方的端口号。</li>
<li>目的端口（Destination Port）：16位，接收方的端口号。</li>
<li>长度（Length）：16位，UDP数据报的总长度（包括头部和数据部分）。</li>
<li>校验和（Checksum）：16位，UDP数据的校验和，用于检验数据在传输过程中是否出错。校验和覆盖数据部分，如果发生错误，接收方会丢弃数据报。</li>
</ol>
<ul>
<li><strong>校验</strong>也要对 data 一并校验，如果出现错误，直接丢弃。</li>
<li>数据：UDP 直接发送，UDP 不会再自己分片了；应用层根据需要决定如何将数据分割成适合传输的大小。</li>
</ul>
<h2 id="TCP和UDP对比"><a href="#TCP和UDP对比" class="headerlink" title="TCP和UDP对比"></a>TCP和UDP对比</h2><h2 id><a href="#" class="headerlink" title></a><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-27.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></h2><h1 id="四、An-application-NAT-and-PAT"><a href="#四、An-application-NAT-and-PAT" class="headerlink" title="四、An application: NAT and PAT"></a>四、An application: NAT and PAT</h1><h2 id="1-什么是NAT（Network-Address-Translation）"><a href="#1-什么是NAT（Network-Address-Translation）" class="headerlink" title="1. 什么是NAT（Network Address Translation）"></a>1. 什么是NAT（Network Address Translation）</h2><ol>
<li><strong>定义</strong>：NAT（<strong>网络地址转换</strong>）是将<strong>IP数据包头中</strong>的<strong>一个地址</strong>替换为<strong>另一个地址</strong>的过程。</li>
<li><strong>用途</strong>：NAT用于允许<strong>使用私有地址的主机</strong> <strong>访问互联网</strong>。</li>
<li><strong>解决IP地址耗尽的方案之一</strong>：<ul>
<li>节省注册（合法）地址</li>
<li>增加连接互联网的灵活性</li>
</ul>
</li>
<li><strong>相关标准</strong>：RFC 1631 - 网络地址转换器（NAT）</li>
</ol>
<h2 id="2-NAT-a-simple-concept"><a href="#2-NAT-a-simple-concept" class="headerlink" title="2. NAT a simple concept"></a>2. NAT a simple concept</h2><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-28.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="3-NAT-类型"><a href="#3-NAT-类型" class="headerlink" title="3. NAT 类型"></a>3. NAT 类型</h2><ol>
<li><strong>静态NAT</strong>：Static NAT<ul>
<li>固定映射：一个内部地址到一个注册地址。</li>
</ul>
</li>
<li><strong>动态NAT</strong>：Dynamic NAT<ul>
<li>映射是动态完成的，基于<strong>先到先得</strong>的原则。</li>
</ul>
</li>
<li><strong>PAT（端口地址转换&#x2F;重载）</strong>： PAT (Overload)<ul>
<li>使用端口地址转换允许<strong>多个内部用户共享一个“内部全局”地址</strong>。</li>
</ul>
</li>
</ol>
<h2 id="4-NAT中的地址类型"><a href="#4-NAT中的地址类型" class="headerlink" title="4. NAT中的地址类型"></a>4. NAT中的地址类型</h2><ol>
<li>Inside Local address 内部本地地址: <strong>内网IP地址</strong></li>
<li>Inside Global address 内部全局地址: <strong>注册IP地址</strong>, 对外部展示的内部地址</li>
<li>Outside Global address外部全局地址: 由<strong>主机所有者分配</strong>的IP地址, 通常是<strong>注册地址</strong>。<br><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-29.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<ul>
<li>内部主机发送报文给网关，网关根据 NAT Table 进行翻译，转换成内部全局地址，然后进行转发</li>
</ul>
<h2 id="5-Static-NAT-例子"><a href="#5-Static-NAT-例子" class="headerlink" title="5. Static NAT 例子"></a>5. Static NAT 例子</h2><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-30.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><strong>静态映射</strong>：静态NAT通过<strong>手动配置</strong>，将每个内部私有IP地址<strong>固定映射</strong>到一个公网IP地址。</li>
<li><strong>转换表</strong>：NAT设备维护一个<strong>静态转换表</strong>，记录内部私有IP地址和对应的公网IP地址之间的映射关系。</li>
<li><strong>地址转换</strong>：当内部主机发起连接请求时，NAT设备根据静态转换表，将内部私有IP地址替换为对应的公网IP地址。</li>
<li><strong>固定映射</strong>：映射关系是固定的，不会随时间变化，确保每个内部主机始终使用相同的公网IP地址进行通信。</li>
</ol>
<h2 id="6-Dynamic-NAT-例子"><a href="#6-Dynamic-NAT-例子" class="headerlink" title="6. Dynamic NAT 例子"></a>6. Dynamic NAT 例子</h2><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-31.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><strong>地址池</strong>：动态NAT使用一个公网IP地址池来动态映射内部私有IP地址。</li>
<li><strong>请求映射</strong>：当内部主机发起连接请求时，NAT设备从地址池中选择一个未使用的公网IP地址，并将其映射到内部私有IP地址。</li>
<li><strong>建立映射</strong>：NAT设备在内部私有IP地址和选定的公网IP地址之间建立临时映射。</li>
<li><strong>释放映射</strong>：当连接结束或超时时，NAT设备释放该映射，使公网IP地址返回地址池供其他内部主机使用。</li>
</ol>
<ul>
<li>先到先得</li>
</ul>
<h2 id="7-NAT-的优缺点"><a href="#7-NAT-的优缺点" class="headerlink" title="7. NAT 的优缺点"></a>7. NAT 的优缺点</h2><ol>
<li><strong>优点</strong>：<ul>
<li>由于<strong>并非每个内部主机同时需要外部访问</strong>，可以使用一个较小的公网IP地址池来服务相对较多的私有地址主机。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>一对一映射 one-to-one mapping</strong>。</li>
<li>例如，如果私有地址空间是&#x2F;8，但公网地址是&#x2F;24，则只有254个主机可以同时访问互联网。</li>
</ul>
</li>
</ol>
<h2 id="8-PAT-端口地址转换-Port-Address-Translation"><a href="#8-PAT-端口地址转换-Port-Address-Translation" class="headerlink" title="8. PAT 端口地址转换 Port Address Translation"></a>8. PAT 端口地址转换 Port Address Translation</h2><ul>
<li>一种特殊类型的动态NAT</li>
<li>将<strong>私有IP地址</strong>和<strong>公网IP地址</strong>映射到<strong>不同的端口号</strong>来实现<strong>多个私有IP地址共享一个公网IP地址</strong>。</li>
<li>每个私有IP地址的每个连接都通过<strong>不同的端口号</strong>进行区分。</li>
</ul>
<h2 id="9-PAT-工作原理"><a href="#9-PAT-工作原理" class="headerlink" title="9. PAT 工作原理"></a>9. PAT 工作原理</h2><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-32.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><strong>端口重载</strong>：PAT使用一个公网IP地址，并通过<strong>不同的端口号</strong>来区分内部主机的连接请求。</li>
<li><strong>端口映射</strong>：当内部主机发起连接请求时，NAT设备将内部私有IP地址和端口号映射到<strong>公网IP地址和唯一的端口号</strong>。</li>
<li><strong>建立映射</strong>：NAT设备在内部私有IP地址和端口号与公网IP地址和唯一端口号之间建立临时映射。</li>
<li><strong>转换表</strong>：NAT设备维护一个转换表，记录内部私有IP地址和端口号与公网IP地址和唯一端口号之间的映射关系。</li>
<li><strong>地址转换</strong>：当数据包通过NAT设备时，NAT设备根据转换表将内部私有IP地址和端口号替换为公网IP地址和唯一端口号，反之亦然。</li>
<li><strong>释放映射</strong>：当连接结束或超时时，NAT设备释放该映射，使端口号返回端口池供其他内部主机使用。</li>
</ol>
<h2 id="10-PAT-操作"><a href="#10-PAT-操作" class="headerlink" title="10. PAT 操作"></a>10. PAT 操作</h2><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-33.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>六、OSI第567层：会话、表示、应用层</title>
    <url>/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/</url>
    <content><![CDATA[<h1 id="06-会话、表示、应用层"><a href="#06-会话、表示、应用层" class="headerlink" title="06 会话、表示、应用层"></a>06 会话、表示、应用层</h1><ul>
<li>The Session Layer</li>
<li>The Presentation Layer</li>
<li>The Application Layer</li>
</ul>
<h1 id="一、第5层：会话层"><a href="#一、第5层：会话层" class="headerlink" title="一、第5层：会话层"></a>一、第5层：会话层</h1><ul>
<li>负责管理不同计算机之间的会话和数据交换。会话层主要关注如何建立、管理、终止会话以及如何确保数据传输的完整性和有效性。</li>
</ul>
<h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h2><p><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>会话层的核心作用是负责会话的<strong>建立、管理和终止</strong>，确保<strong>数据传输在不同设备间顺畅进行</strong>。主要包括：</li>
</ul>
<ol>
<li>基于令牌（Token）进行交互发言，通过数据同步保证数据完整性(应用逻辑)</li>
<li>进行数据分段、拼接，保证传输的有效。</li>
<li>同步技术，保证故障恢复</li>
</ol>
<h2 id="2-服务"><a href="#2-服务" class="headerlink" title="2. 服务"></a>2. 服务</h2><p><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-1.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><strong>双向同步通讯 TWA</strong>(Two-Way Alternate)<ul>
<li>全双工通信</li>
<li>半双工通信</li>
<li>单工通信</li>
</ul>
</li>
<li><strong>双向交替控制 TWS</strong>(Two-Way Simultaneous)<ul>
<li>会话连接、活动开始、数据校验（同步）</li>
<li>令牌转换等</li>
</ul>
</li>
<li>是否同步 synchronized 了您的会话的主题？<br><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-2.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<h2 id="3-同步点-CheckPoint"><a href="#3-同步点-CheckPoint" class="headerlink" title="3. 同步点 CheckPoint"></a>3. 同步点 CheckPoint</h2><ol>
<li>**同步点（CheckPoint）**用于分隔会话session的各个部分，以前称为对话（dialogues）<ul>
<li>同步点：发送一定数据后设置同步点</li>
<li>次同步点：作为同步点的一个子集，进行数据校验</li>
<li>主同步点：按照主同步点进行校验确认</li>
<li>如果错误，恢复到上次都已经同步的主同步点</li>
</ul>
</li>
<li>对话分隔（Seperation）：会话层通过同步点分隔不同的对话（会话段），确保各个会话部分的有序启动、进行与终止。尽量保证了数据交换的效率和可靠性。</li>
</ol>
<h2 id="4-Some-Applications-of-Layer-5"><a href="#4-Some-Applications-of-Layer-5" class="headerlink" title="4. Some Applications of Layer 5"></a>4. Some Applications of Layer 5</h2><p><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-3.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>NFS</li>
<li>SQL</li>
<li>RPC</li>
<li>X Window System</li>
<li>ASP</li>
<li>SCP</li>
</ol>
<hr>
<h1 id="二、第6层：表示层"><a href="#二、第6层：表示层" class="headerlink" title="二、第6层：表示层"></a>二、第6层：表示层</h1><ul>
<li>The Presentation Layer</li>
</ul>
<ol>
<li>表示层负责以<strong>接收设备可以理解的形式</strong>表示数据。<ul>
<li>传送语法协商</li>
<li>接受语法协商</li>
</ul>
</li>
<li>表示层具有 3 个<strong>主要功能</strong>：<ul>
<li><strong>数据格式化</strong>（formatting）</li>
<li><strong>数据压缩</strong>（compression）：早期网络比较慢，倾向于先压缩在发送</li>
<li><strong>数据加密</strong>（encryption）</li>
</ul>
</li>
</ol>
<h2 id="1-Data-Formatting-数据格式化"><a href="#1-Data-Formatting-数据格式化" class="headerlink" title="1. Data Formatting 数据格式化"></a>1. Data Formatting 数据格式化</h2><ol>
<li>想象两个不同（dissimilar）的系统。<ul>
<li>一种使用扩展二进制编码的十进制交换码（EBCDIC,Extended Binary Coded Decimal Interchange Code）格式化文本</li>
<li>另一种使用美国信息交换标准码（ASCII）格式化文本</li>
</ul>
</li>
<li>第六层提供了<strong>这两种</strong>不同类型的代码之间的<strong>转换</strong></li>
</ol>
<h3 id="1-1-Graphic-File-Formats-图形文件格式"><a href="#1-1-Graphic-File-Formats-图形文件格式" class="headerlink" title="1.1 Graphic File Formats 图形文件格式"></a>1.1 Graphic File Formats 图形文件格式</h3><ul>
<li>互联网通常使用两种<strong>二进制</strong>文件格式来显示图像：<ul>
<li>图形交换格式（GIF）</li>
<li>联合图像专家组（JPEG）</li>
</ul>
</li>
<li>任何具有GIF和JPEG文件格式阅读器的计算机都可以读取这些文件类型，无论计算机类型如何。</li>
</ul>
<h3 id="1-2-Multimedia-File-Format-多媒体文件格式"><a href="#1-2-Multimedia-File-Format-多媒体文件格式" class="headerlink" title="1.2 Multimedia File Format 多媒体文件格式"></a>1.2 Multimedia File Format 多媒体文件格式</h3><ul>
<li>多媒体文件格式是另一种类型的<strong>二进制</strong>文件，用于存储声音、音乐和视频。<ul>
<li>这些文件可以完全下载后播放，或者在下载的同时播放。</li>
<li>后一种方法称为流式音频。</li>
</ul>
</li>
</ul>
<h2 id="2-Encryption-Compression-数据加密-压缩"><a href="#2-Encryption-Compression-数据加密-压缩" class="headerlink" title="2. Encryption &amp; Compression 数据加密&amp;压缩"></a>2. Encryption &amp; Compression 数据加密&amp;压缩</h2><ul>
<li>第六层负责<strong>数据加密</strong>：<ul>
<li>数据加密可<strong>在信息传输过程中保护信息</strong>。</li>
</ul>
</li>
<li>表示层还负责文件的压缩。</li>
</ul>
<hr>
<h1 id="三、第7层：应用层"><a href="#三、第7层：应用层" class="headerlink" title="三、第7层：应用层"></a>三、第7层：应用层</h1><ul>
<li>The Application Layer<br><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-4.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>上图中各层的一些协议和使用：会话层对端口进行管理</li>
<li>第七层对应了应用界面，第六层对应了各种协议</li>
</ul>
<h2 id="1-职责"><a href="#1-职责" class="headerlink" title="1. 职责"></a>1. 职责</h2><ol>
<li>应用层（最接近用户）支持应用程序的<strong>通信组件</strong>。</li>
</ol>
<ul>
<li><strong>应用层</strong>：<ul>
<li>识别并建立预期通信伙伴的可用性</li>
<li>同步协作应用程序Synchronizes cooperating applications</li>
<li>就错误恢复程序达成一致</li>
<li>控制数据完整性 data integrity</li>
</ul>
</li>
</ul>
<h2 id="2-HTTP-超文本传输协议"><a href="#2-HTTP-超文本传输协议" class="headerlink" title="2. HTTP 超文本传输协议"></a>2. HTTP 超文本传输协议</h2><ul>
<li><strong>HyperText Transfer Protocol</strong><br><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-5.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="2-1-统一资源定位符URL-Uniform-Resource-Locator"><a href="#2-1-统一资源定位符URL-Uniform-Resource-Locator" class="headerlink" title="2.1 统一资源定位符URL (Uniform Resource Locator)"></a>2.1 统一资源定位符URL (Uniform Resource Locator)</h3><ul>
<li>统一资源定位符URL 是对可以从因特网上得到的资源的<strong>位置</strong>和<strong>访问方法</strong>的一种简洁的表示</li>
<li>URL 给<strong>资源的位置</strong>提供一种抽象的识别方法，并用这种方法给资源<strong>定位</strong></li>
<li>只要能够对资源定位，系统就可以对资源进行各种<strong>操作</strong>，如存取、更新、替换和查找其属性</li>
<li>URL 相当于<strong>一个文件名在网络范围的扩展</strong>。因此URL 是<strong>与因特网相连的机器上的任何可访问对象的一个指针</strong></li>
<li><code>&lt;URL的访问方式&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</code><ol>
<li>访问方式：协议 HTTPS 或者 HTTP</li>
<li>主机：域名的方式</li>
<li>端口对应进程</li>
<li>路径对应具体的文件</li>
</ol>
</li>
</ul>
<h3 id="2-2-HTTP"><a href="#2-2-HTTP" class="headerlink" title="2.2 HTTP"></a>2.2 HTTP</h3><ul>
<li>HTTP 是<strong>面向事务</strong>的客户服务器协议</li>
<li>HTTP 1.0 协议是<strong>无状态</strong>的(stateless)</li>
<li>HTTP 协议本身也是<strong>无连接</strong>的，虽然它使用了面向连接的TCP 向上提供的服务</li>
<li>万维网浏览器就是一个HTTP 客户，而在万维网服务器等待HTTP 请求的进程常称为HTTP daemon，有的文献将它缩写为HTTPD</li>
<li>HTTP daemon 在收到 HTTP 客户的请求后，把所需的文件返回给HTTP 客户</li>
</ul>
<h3 id="2-3-HTTP的报文结构-请求报文"><a href="#2-3-HTTP的报文结构-请求报文" class="headerlink" title="2.3 HTTP的报文结构(请求报文)"></a>2.3 HTTP的报文结构(请求报文)</h3><p><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-6.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>报文由三个部分组成，即<strong>开始行</strong>、<strong>首部行</strong>和<strong>实体主体</strong>。</li>
<li>在请求报文中，<strong>开始行就是请求行</strong>。</li>
</ol>
<h3 id="2-4-HTTP-请求报文的一些方法"><a href="#2-4-HTTP-请求报文的一些方法" class="headerlink" title="2.4 HTTP 请求报文的一些方法"></a>2.4 HTTP 请求报文的一些方法</h3><p><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-7.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="2-5-HTML-HyperText-Markup-Language-超文本标记语言"><a href="#2-5-HTML-HyperText-Markup-Language-超文本标记语言" class="headerlink" title="2.5 HTML(HyperText Markup Language) 超文本标记语言"></a>2.5 HTML(HyperText Markup Language) 超文本标记语言</h3><ul>
<li>定义了许多用于排版的命令（标签）</li>
<li>HTML 文档是一种可以用任何文本编辑器创建的ASCII 码文件</li>
<li>仅当HTML 文档是以.html 或.htm 为后缀时，浏览器才对此文档的各种标签进行解释</li>
<li>当浏览器从服务器读取HTML 文档，针对HTML 文档中的各种标签，根据浏览器所使用的显示器的尺寸和分辨率大小，重新进行排版并恢复出所读取的页面</li>
<li>HTML 用一对标签（一个开始标签和一个结束标签）或几对标签来标识一个元素</li>
</ul>
<h2 id="3-FTP-and-TFTP-文件传输协议"><a href="#3-FTP-and-TFTP-文件传输协议" class="headerlink" title="3. FTP and TFTP 文件传输协议"></a>3. FTP and TFTP 文件传输协议</h2><ul>
<li>File Transfer Protocol</li>
<li><strong>Trivial</strong> File Transfer Protocol 简单文件传输协议</li>
</ul>
<ol>
<li><strong>FTP</strong>： 是一种<em>可</em>靠的、面向连接<strong>的服务，使用</strong>TCP**传输文件。<ul>
<li>FTP首先在<strong>客户端和服务器</strong>之间建立<strong>控制连接</strong>（端口21）。</li>
<li>然后建立第二个连接，通过该连接在<strong>计算机之间传输数据</strong>（端口20）。</li>
</ul>
</li>
</ol>
<ul>
<li>Trivial File Transfer Protocol</li>
</ul>
<ol start="2">
<li><strong>TFTP</strong>：是一种<strong>无连接</strong>的服务，使用<strong>UDP</strong>。<ul>
<li>小巧且易于实现。</li>
<li>例如，TFTP用于路由器传输配置文件和Cisco IOS镜像。</li>
</ul>
</li>
</ol>
<h3 id="3-1-FTP主进程工作步骤"><a href="#3-1-FTP主进程工作步骤" class="headerlink" title="3.1 FTP主进程工作步骤"></a>3.1 FTP主进程工作步骤</h3><ol>
<li><strong>打开熟知端口</strong>（端口号为21），使客户进程能够连接上</li>
<li><strong>等待客户进程发出连接请求</strong></li>
<li>启动<strong>从属进程</strong>来处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程</li>
<li>回到<strong>等待</strong>状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是<strong>并发地进行</strong></li>
</ol>
<h3 id="3-2-FTP的屏幕信息举例"><a href="#3-2-FTP的屏幕信息举例" class="headerlink" title="3.2 FTP的屏幕信息举例"></a>3.2 FTP的屏幕信息举例</h3><ul>
<li>[01] ftp nic.ddn.mil<ul>
<li>用户要用 FTP 和远地主机（网络信息中心 NIC 上的主机）建立连接。域名：nic.ddn.mil</li>
</ul>
</li>
<li>[02] connected to nic.ddn.mil<ul>
<li>本地 FTP 发送的连接成功信息</li>
</ul>
</li>
<li>[03] 220 nic FTP server（Sunos 4.1）ready.<ul>
<li>从远地服务器返回的信息，220 表示“服务就绪”</li>
</ul>
</li>
<li>[04] Name： anonymous<ul>
<li>本地 FTP 提示用户键入名字。用户键入的名字表示“匿名”。用户只需键入 anonymous 即可（匿名）</li>
</ul>
</li>
<li>[05] 331 Guest login ok, send ident as password.<ul>
<li>数字 331 表示“用户名正确”，需要口令</li>
</ul>
</li>
<li>[06] Password： <a href="mailto:&#x61;&#98;&#x63;&#x40;&#120;&#121;&#122;&#x2e;&#109;&#97;&#116;&#x68;&#x2e;&#121;&#97;&#x6c;&#101;&#x2e;&#x65;&#x64;&#117;">abc@xyz.math.yale.edu</a><ul>
<li>本地 FTP 提示用户键入口令。用户这时可键入 guest 作为匿名的口令，也可以键入自己的电子邮件地址，即耶鲁大学数学系名为 xyz 的主机上的 abd（匿名密码是随意输入的）</li>
</ul>
</li>
<li>[07] 230 Guest login ok, access restrictions apply.<ul>
<li>数字 230 表示用户已经注册完毕</li>
</ul>
</li>
<li>[08] ftp&gt; cd rfc<ul>
<li>“ftp&gt;”是 FTP 的提示信息。用户键入的是将目录改变为包含 RFC 文件的目录</li>
</ul>
</li>
<li>[09] 250 CWD command successful.<ul>
<li>字符”CWD”是 FTP 的标准命令，表示 Change Working Directory</li>
</ul>
</li>
<li>[10] ftp&gt; get rfc1261.txt nicinfo<ul>
<li>用户要求将名为 rfc1261.txt 的文件复制到本地主机上，并改名为 nicinfo（get 获取到本地）</li>
</ul>
</li>
<li>[11] 200 PORT command successful.<ul>
<li>字符 PORT 是 FTP 的标准命令，表示要建立数据连接。200 表示“命令正确”</li>
</ul>
</li>
<li>[12] 150 ASCII data connection for rfc1261.txt（128.36.12.27,1401）（4318 bytes）.<ul>
<li>数字 150 表示”文件状态正确，即将建立数据连接”</li>
</ul>
</li>
<li>[13] 226 ASCII Transfer complete. local： nicinfo remote： rfc1261.txt 4488 bytes received in 15 seconds（0.3 Kbytes&#x2F;s）.<ul>
<li>数字 226 是“释放数据连接”，现在一个新的本地文件已经生成。</li>
</ul>
</li>
<li>[14] ftp&gt; quit<ul>
<li>用户键入退出命令。</li>
</ul>
</li>
<li>[15] 221 Goodbye.<ul>
<li>表示 FTP 工作结束</li>
</ul>
</li>
</ul>
<h2 id="4-Telnet-远程终端协议"><a href="#4-Telnet-远程终端协议" class="headerlink" title="4. Telnet 远程终端协议"></a>4. Telnet 远程终端协议</h2><ul>
<li>用于通过网络远程访问和控制另一台计算机</li>
<li>Telnet客户端软件提供“<strong>登录</strong>到<strong>运行Telnet服务器应用程序</strong>的<strong>远程互联网主机</strong>”的能力，然后从命令行执行命令。</li>
</ul>
<h2 id="5-SMTP-and-POP-收发邮件协议"><a href="#5-SMTP-and-POP-收发邮件协议" class="headerlink" title="5. SMTP and POP 收发邮件协议"></a>5. SMTP and POP 收发邮件协议</h2><ul>
<li>电子邮件服务器相互通信，使用<strong>SMTP</strong>协议<strong>发送</strong>邮件，使用<strong>POP3</strong>协议<strong>接收</strong>邮件。</li>
<li><strong>SMTP（Simple Mail Transfer Protocol）</strong>：邮件发送</li>
<li><strong>POP3（Post Office Protocol version 3）</strong>：邮件接收<br><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-8.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>发送者先登录到服务器，通过服务器根据SMTP传输到对应的服务器，然后用户登录后通过POP3协议收邮件到本地</li>
</ul>
<h3 id="5-1-MIME-和-SMTP-的关系"><a href="#5-1-MIME-和-SMTP-的关系" class="headerlink" title="5.1 MIME 和 SMTP 的关系"></a>5.1 MIME 和 SMTP 的关系</h3><ul>
<li>MIME（Multipurpose Internet Mail Extensions）<ul>
<li>是一种扩展了电子邮件格式的标准，它允许邮件发送<strong>非ASCII字符</strong>（如图像、音频、视频等二进制文件），并使邮件能够包含多种类型的内容。</li>
</ul>
</li>
<li>MIME 是通过<strong>对非 ASCII 内容进行编码</strong>，使其能够通过原本**仅支持 ASCII 的协议（如 SMTP）**进行传输。<br><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-10.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="5-2-MIME-增加-5-个新的邮件首部"><a href="#5-2-MIME-增加-5-个新的邮件首部" class="headerlink" title="5.2 MIME 增加 5 个新的邮件首部"></a>5.2 MIME 增加 5 个新的邮件首部</h3><ol>
<li>MIME-Version: 标志 MIME 的版本。现在的版本号是1.0。若无此行，则为英文文本<ul>
<li><code>MIME-Version: 1.0</code></li>
</ul>
</li>
<li>Content-Description: 这是可读字符串，说明此邮件主体是否是图像、音频或视频<ul>
<li><code>Content-Description: This is a picture of a cat</code></li>
</ul>
</li>
<li>Content-Id: 邮件的惟一标识符<ul>
<li><code>Content-Id: &lt;image1234@domain.com&gt;</code></li>
</ul>
</li>
<li>Content-Transfer-Encoding: 在传送时邮件的主体是如何编码的<ul>
<li><code>Content-Transfer-Encoding: base64</code></li>
</ul>
</li>
<li>Content-Type:说明邮件主体的数据类型和子类型<ul>
<li><code>Content-Type: text/plain; charset=&quot;UTF-8&quot;</code> 或 <code>Content-Type: image/jpeg</code></li>
</ul>
</li>
</ol>
<h2 id="6-SNMP-简单网络管理协议"><a href="#6-SNMP-简单网络管理协议" class="headerlink" title="6. SNMP 简单网络管理协议"></a>6. SNMP 简单网络管理协议</h2><ul>
<li><strong>Simple Network Management Protocol</strong><br><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-11.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>简单网络管理协议（SNMP）是一种<strong>应用层协议</strong>，促进网络设备之间管理信息的交换。</li>
<li><strong>NMS（Network Management System）：网管</strong>,通过下发请求对上网的所有的主机关于流量等等信息进行管理（监控）</li>
</ul>
<h2 id="7-DNS-域名系统-Domain-Name-System"><a href="#7-DNS-域名系统-Domain-Name-System" class="headerlink" title="7. DNS 域名系统 Domain Name System"></a>7. DNS 域名系统 Domain Name System</h2><ul>
<li>域名系统（DNS）是一种<strong>网络服务</strong>，<strong>管理域名</strong>并响应<strong>客户端请求——将域名转换为相应的IP地址</strong></li>
</ul>
<h3 id="7-1-Dnmain-Name-域名"><a href="#7-1-Dnmain-Name-域名" class="headerlink" title="7.1 Dnmain Name 域名"></a>7.1 Dnmain Name 域名</h3><p><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-12.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><p>使用圆点 <code>.</code> 将字符串进行分隔开，字符串不应该太长</p>
</li>
<li><p>越靠后域名级别越高</p>
</li>
<li><p>www 就是对应到主机群</p>
</li>
<li><p><strong>根域（Root Domain）</strong>：</p>
<ul>
<li>位于域名层次结构的顶端，表示为空字符串。</li>
<li>由一组根服务器管理，负责顶级域名的解析。</li>
</ul>
</li>
<li><p><strong>顶级域（Top-Level Domain, TLD）</strong>：</p>
<ul>
<li>位于根域之下，分为通用顶级域（gTLD）和国家顶级域（ccTLD）。</li>
<li>例如：.com、.org、.net（通用顶级域），.cn、.us、.uk（国家顶级域）。</li>
<li><strong>唯一的基础设施域</strong>：arpa，用于反向解析域名</li>
</ul>
</li>
<li><p><strong>二级域（Second-Level Domain, SLD）</strong>：</p>
<ul>
<li>位于顶级域之下，通常由组织或个人注册。</li>
<li>例如：example.com中的example。</li>
</ul>
</li>
<li><p><strong>子域（Subdomain）</strong>：</p>
<ul>
<li>位于二级域之下，可以由域名所有者自由创建。</li>
<li>例如：mail.example.com中的mail。</li>
</ul>
</li>
<li><p><strong>主机名（Hostname）</strong>：</p>
<ul>
<li>最具体的层次，指向具体的设备或服务。</li>
<li>例如：<a href="http://www.example.com中的www./">www.example.com中的www。</a></li>
</ul>
</li>
</ol>
<h3 id="7-2-TLD-顶级域-Top-Level-Domain"><a href="#7-2-TLD-顶级域-Top-Level-Domain" class="headerlink" title="7.2 TLD 顶级域 Top Level Domain"></a>7.2 TLD 顶级域 Top Level Domain</h3><ol>
<li>国家 TLD（nTLD）<ul>
<li>.cn（CHINA） 中国</li>
<li>.us（United States） 美国</li>
<li>.uk（United kingdom）, etc. 英国等等</li>
</ul>
</li>
<li>通用 TLD（gTLD），最早的域包括：<ul>
<li>.com Enterprises and companies 企业和公司</li>
<li>.net Network services providers 网络服务提供者</li>
<li>.org Nonprofit organizations 非盈利组织</li>
<li>.edu Educational facilities 教育机构</li>
</ul>
</li>
<li>基础设施领域（Infrastructure domain）<ul>
<li>Only one： <strong>arpa</strong>, for resolving domain names reversely 仅一个：arpa，用于<strong>反向解析域名</strong></li>
</ul>
</li>
<li>Recently, new TLD domain added：<ul>
<li>.aero（航空运输企业）</li>
<li>.biz（公司和企业）</li>
<li>.coop（合作团体）</li>
<li>.info（各种资讯）</li>
<li>.jobs（人力资源管理者）</li>
<li>.mobi（移动产品与服务的用户和提供者）</li>
<li>.museum（博物馆）</li>
<li>.name（个人）</li>
<li>.pro（经过认证的专业人员）</li>
<li>.travel（旅游业）</li>
</ul>
</li>
</ol>
<h3 id="7-3-域名服务器Domain-Name-Server-DNS"><a href="#7-3-域名服务器Domain-Name-Server-DNS" class="headerlink" title="7.3 域名服务器Domain Name Server (DNS)"></a>7.3 域名服务器Domain Name Server (DNS)</h3><p><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-13.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>顶级域名底下的域名就是由顶级域名下面进行管理</li>
<li>根域名服务器存储位置，所以子服务器知道根服务器的地址即可</li>
</ul>
<h3 id="7-4-结合域名服务器查找-IP-地址"><a href="#7-4-结合域名服务器查找-IP-地址" class="headerlink" title="7.4 结合域名服务器查找 IP 地址"></a>7.4 结合域名服务器查找 IP 地址</h3><ul>
<li>DNS 系统以层次（hierarchy）结构设置，该层次结构创建<strong>不同级别的 DNS 服务器</strong>。</li>
<li>此级别的 DNS 服务器<strong>判断其自身</strong>是否能够将<strong>域名</strong>转换为<strong>关联的 IP 地址</strong>：<ol>
<li>如果<strong>可以</strong>，则将<strong>结果返回给客户端</strong></li>
<li>如果<strong>没有</strong>，它将请求发送到更高级别。（<strong>向上级请求</strong>）<br><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-14.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
</li>
<li>请求分为两种：<ul>
<li>能够应答</li>
<li>不能够应答</li>
</ul>
</li>
<li>递归地进行查找：具体过程在上图</li>
<li>下面递归，上面迭代</li>
</ul>
<h2 id="8-应用层通信处理的两种方式"><a href="#8-应用层通信处理的两种方式" class="headerlink" title="8. 应用层通信处理的两种方式"></a>8. 应用层通信处理的两种方式</h2><ol>
<li><strong>第一种方式</strong>：（短连接）<ul>
<li>在这种模式下，客户端每次向服务器请求资源时，都会建立一次新的连接，并且在请求处理完成后，连接会立即断开。</li>
<li>当浏览器打开时，它连接到<strong>默认页面</strong>，并将<em>页面的文件传输到客户端</em>。</li>
<li>处理完成后，连接断开。</li>
</ul>
</li>
<li><strong>第二种方式</strong>：（长连接&#x2F;持久连接）<ul>
<li>长连接（也称持久连接）会在客户端和服务器之间建立一个持久的连接，在整个会话期间保持连接，直到客户端显式地断开连接。通常用于需要持续<strong>交互</strong>的应用。</li>
<li>如Telnet（远程登录）和FTP（文件传输），建立与服务器的连接，并保持该连接直到所有处理完成。</li>
<li>当用户确定已完成时，客户端终止连接。</li>
</ul>
</li>
</ol>
<ul>
<li>所有通信活动都属于这两种类别之一。<br><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-15.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>一、计算机网络及其参考模型</title>
    <url>/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="互联网计算"><a href="#互联网计算" class="headerlink" title="互联网计算"></a>互联网计算</h1><h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p> 10% 大作业 + 40% 上机 + 50% 期末</p>
<h2 id="课程资料"><a href="#课程资料" class="headerlink" title="课程资料"></a>课程资料</h2><p>219.219.113.233<br>用户:net<br>密码:net</p>
<h1 id="一、计算机网络概述"><a href="#一、计算机网络概述" class="headerlink" title="一、计算机网络概述"></a>一、计算机网络概述</h1><h3 id="1-What-is-a-network"><a href="#1-What-is-a-network" class="headerlink" title="1. What is a network?"></a>1. What is a network?</h3><ul>
<li>物体,事物,设备,人的连接</li>
<li><strong>LAN</strong>(Local Area Networks) 局域网</li>
<li><strong>WAN</strong>(Wide Area Networks) 广域网</li>
</ul>
<h2 id="2-数据网络分类：LAN-WAN"><a href="#2-数据网络分类：LAN-WAN" class="headerlink" title="2. 数据网络分类：LAN&#x2F;WAN"></a>2. 数据网络分类：LAN&#x2F;WAN</h2><ol>
<li>LANs 局域网 广播方式通信<ol>
<li>Operate locally</li>
<li>Multi-user access 连接可以被共享</li>
<li>High speeds expected 最高达到800G (距离短)</li>
<li>Error rate is easily controlled 因为范围小好判断出错</li>
</ol>
</li>
<li>WANs 广域网<ul>
<li>先于 LAN 网络产生</li>
</ul>
<ol>
<li>Operate over larger areas 现在主要使用光纤</li>
<li>Access over serial links, optical links, etc. <strong>点对点的连接</strong></li>
<li>Traditionally, have <strong>lower</strong> speeds</li>
<li>Error rate can <strong>not</strong> be easily controlled</li>
</ol>
</li>
<li>网络抽象模型<ul>
<li>node：节点</li>
<li>link：链路</li>
</ul>
</li>
</ol>
<h3 id="2-1-局域网和广域网差别"><a href="#2-1-局域网和广域网差别" class="headerlink" title="2.1 局域网和广域网差别"></a>2.1 局域网和广域网差别</h3><ol>
<li>局域网<ul>
<li>作用<strong>范围比较窄</strong></li>
<li>多用户<strong>同时复用链路介质</strong></li>
<li>网络<strong>性能比较高</strong>（一般是一个公司来管理处理，可以达到 GPS 甚至是 10GPS）</li>
<li><strong>出错率</strong>相对比较容易控制（<strong>低</strong>）</li>
</ul>
</li>
<li>广域网<ul>
<li>在比较<strong>大的地理范围</strong>上进行连接</li>
<li>要么<strong>串行连接（serial links）</strong>，要么<strong>光链路连接（optical links）</strong></li>
<li>传统上，<strong>传输速率比较低</strong>，因为一般是多公司管理，标准和介质等都不同</li>
<li><strong>出错率</strong>相对比较<strong>高</strong></li>
</ul>
</li>
</ol>
<h3 id="2-2-LAN-Devices-局域网设备"><a href="#2-2-LAN-Devices-局域网设备" class="headerlink" title="2.2 LAN Devices 局域网设备"></a>2.2 LAN Devices 局域网设备</h3><ol>
<li>Hub 集线器：工作在第一层<ul>
<li>多端口中继器（Reapter），连接 PC</li>
<li>重复信号</li>
</ul>
</li>
<li>Bridge 网桥：工作在第二层<ul>
<li>将局域网分段</li>
<li>进行 MAC 地址的计算</li>
</ul>
</li>
<li>Switch 交换机，多端口网桥：工作在第二层<ul>
<li>多端口网桥</li>
<li>全带宽（满带宽）</li>
<li>大规模集成电路实现：相对于网桥的优点</li>
</ul>
</li>
<li>Router 路由器 ：工作在第三层<ul>
<li>路径选择</li>
<li>分组交换<br><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-1.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ol>
<h3 id="2-3-WAN-Devices-广域网设备"><a href="#2-3-WAN-Devices-广域网设备" class="headerlink" title="2.3 WAN Devices 广域网设备"></a>2.3 WAN Devices 广域网设备</h3><ol>
<li>Router 路由器<ul>
<li>路径选择</li>
<li>分组交换</li>
</ul>
</li>
<li>Modem: 调制解调器</li>
<li>CSU&#x2F;DSU: 通道服务单元&#x2F;数据服务单元</li>
<li>TA&#x2F;NT1: 终端适配器&#x2F;网络终端1</li>
</ol>
<ul>
<li>234都是将<em>模拟信号转换为数字信号</em>, 还可以进行<em>远程局域网连接</em></li>
</ul>
<h3 id="2-4-LAN-Services-and-WAN-Services"><a href="#2-4-LAN-Services-and-WAN-Services" class="headerlink" title="2.4 LAN Services and WAN Services"></a>2.4 LAN Services and WAN Services</h3><ol>
<li>LAN Service: <strong>Ethernet</strong> (以太网) 最流行的局域网服务</li>
<li>WAN Service: 有很多,不是本节课重点</li>
</ol>
<h2 id="3-Internet-互联网"><a href="#3-Internet-互联网" class="headerlink" title="3. Internet 互联网"></a>3. Internet 互联网</h2><ol>
<li>简介</li>
</ol>
<ul>
<li>互联网, 全球性的计算机网络系统, 将世界各地的局域网（LAN）,广域网（WAN）和其他类型的网络连接在一起</li>
<li>全球最大的开放性广域网</li>
<li>TCP&#x2F;IP 作为参考标准</li>
<li>从 ARPNET 发展出来</li>
</ul>
<h3 id="3-1-Internet-with-Multi-layer-ISP-structure（多层-ISP-结构的-Internet"><a href="#3-1-Internet-with-Multi-layer-ISP-structure（多层-ISP-结构的-Internet" class="headerlink" title="3.1 Internet with Multi-layer ISP structure（多层 ISP 结构的 Internet"></a>3.1 Internet with Multi-layer ISP structure（多层 ISP 结构的 Internet</h3><ol>
<li><strong>Internet Service Providers（ISP）：互联网服务提供商</strong><ul>
<li>user——ISP——Internet</li>
</ul>
</li>
<li>具有多层 ISP 结构的 Internet<ul>
<li>主机A → 本地 ISP → 第二层 ISP → NAP → 第一层 ISP → NAP → 第二层 ISP → 本地 ISP → 主机B<br><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-2.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ol>
<ul>
<li><strong>第一层 ISP 是核心层</strong>，主要负责<strong>远距离连通。</strong></li>
<li>这种多层 ISP 结构可以将大量的流量本地化</li>
<li>NAP（Network Access Point）：第一二层之间的接入点，也可以是 google（大公司）直接和第一层 ISP 进行链接</li>
<li>ICP（Internet Content Provider）：互联网内容提供商，不提供接入服务</li>
<li>在低层次的 ISP 可以解决的问题就不进入上一层进行解决，将大量的流量分流。</li>
</ul>
<h1 id="二、计算机网络基本概念"><a href="#二、计算机网络基本概念" class="headerlink" title="二、计算机网络基本概念"></a>二、计算机网络基本概念</h1><h2 id="1-Data数据"><a href="#1-Data数据" class="headerlink" title="1. Data数据"></a>1. Data数据</h2><ul>
<li>Data is sent in bits, 1s and 0s.<ul>
<li><strong>数据按位（1 和 0）为单位发送</strong></li>
</ul>
</li>
<li>Data is not the information itself.<ul>
<li><strong>数据不是信息本身</strong>，不同方式解析数据会是不同信息<ul>
<li>数据都是 0-1 序列，需要按照一定编码格式翻译转码才成为信息</li>
</ul>
</li>
</ul>
</li>
<li>Data is an encoded form of information which is a series of electrical impulses&#x2F;optical signals into which information is transmitted for sending.<ul>
<li><strong>数据是信息的一种编码形式</strong>，它是一系列电脉冲&#x2F;光信号，信息被传输到其中进行发送</li>
</ul>
</li>
</ul>
<h3 id="1-1-Data-Packets数据包"><a href="#1-1-Data-Packets数据包" class="headerlink" title="1.1 Data Packets数据包"></a>1.1 Data Packets数据包</h3><ol>
<li>为了传输，计算机数据通常被分解成<strong>小的、易于传输的单元</strong><ul>
<li>使用 OSI 模型</li>
<li>这些单元可以称为：包packets、帧frames、段segments</li>
<li>具体取决于OSI模型的不同层次<ul>
<li>网络层称为 packets 报文，数据链路层称为 frames 帧，数据段层称为 segments 段</li>
</ul>
</li>
</ul>
</li>
<li>why data packets? 为什么使用数据包？<ul>
<li>Computers can take turns sending packets<ul>
<li><strong>计算机可以轮流发送数据包</strong>，分时段处理不同报文，使得<em>多进程</em>处理事务。</li>
</ul>
</li>
<li>If packet is lost, only small amount of data must be retransmitted重新传输.<ul>
<li>如果数据包<strong>丢失，则只需重新传输少量数据</strong></li>
</ul>
</li>
<li>Data can take different paths.<ul>
<li>数据可以采用<strong>不同的路径</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="1-2-Protocol协议"><a href="#1-2-Protocol协议" class="headerlink" title="1.2 Protocol协议"></a>1.2 Protocol协议</h3><ol>
<li>It is possible for different types of computer systems to communicate<ul>
<li><strong>不同类型的计算机系统可</strong>以进行<strong>通信</strong></li>
</ul>
</li>
<li>All devices must speak the same “language” or use the same <strong>protocol</strong> (use same set of rules).<ul>
<li>所有设备必须使用<strong>相同的“语言”或使用相同的协议</strong>（使用同一套规则）。</li>
</ul>
</li>
</ol>
<h3 id="1-3-Source-and-Destination源地址和目标地址"><a href="#1-3-Source-and-Destination源地址和目标地址" class="headerlink" title="1.3 Source and Destination源地址和目标地址"></a>1.3 Source and Destination源地址和目标地址</h3><ul>
<li><strong>源地址</strong> Source address specifies the identity of the computer sending the packet.<ul>
<li><strong>发送数据包</strong>的计算机的身份</li>
</ul>
</li>
<li><strong>目标地址</strong> Destination address specifies the identity of the computer designated to receive the packet.<ul>
<li><strong>接收数据包</strong>的计算机的身份</li>
</ul>
</li>
</ul>
<h3 id="1-4-传输介质-Media-Types"><a href="#1-4-传输介质-Media-Types" class="headerlink" title="1.4 传输介质 Media Types"></a>1.4 传输介质 Media Types</h3><ol>
<li>Media—material through which data packets travel<ul>
<li>介质是数据包传输所通过的介质。</li>
</ul>
</li>
<li><strong>带宽 Bandwidth</strong>：<ul>
<li>is the measure of how much information can flow from one place to another in a given amount of time.带宽是指在单位时间内可以传输的最大数据量</li>
<li>Measured in: bits&#x2F;second (bps)通常以比特每秒（bps）为单位。<ul>
<li>单位：bps，计算时注意要<strong>将字转换为位</strong></li>
</ul>
</li>
<li>作用: 带宽决定了网络的最大传输能力。带宽越高，网络能够传输的数据量就越大。</li>
<li>类比: 可以将带宽类比为高速公路的车道数，车道越多，能够同时通过的车辆就越多。</li>
</ul>
</li>
<li>通量 Throughput：<ul>
<li>Actual measured bandwidth at a specific time <em>单位时间</em>内<strong>实际</strong>传输的数据量，也以*比特每秒（bps）*为单位。</li>
<li><strong>Throughput &lt;&#x3D; Bandwidth</strong></li>
<li>作用: 通量反映了网络的实际性能，通常会受到网络拥塞、延迟、丢包等因素的影响。</li>
<li>类比: 通量可以类比为高速公路上实际通过的车辆数，即使高速公路有很多车道，但如果有交通堵塞，实际通过的车辆数也会减少。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="三、OSI-参考模型"><a href="#三、OSI-参考模型" class="headerlink" title="三、OSI 参考模型"></a>三、OSI 参考模型</h1><h2 id="1-OSI-Open-System-Interconnection-Model开放系统互连参考模型"><a href="#1-OSI-Open-System-Interconnection-Model开放系统互连参考模型" class="headerlink" title="1. OSI (Open System Interconnection) Model开放系统互连参考模型"></a>1. OSI (Open System Interconnection) Model开放系统互连参考模型</h2><ul>
<li>由国际标准化组织 （ISO） 提议 </li>
<li>是一个<strong>分层的网络架构模型</strong>，用于<em>标准化网络通信的功能</em></li>
<li>帮助网络构建者实现<strong>可以通信和协同工作</strong>的网络模型 </li>
<li>描述<em>信息或数据</em>如何<em>通过网络</em>从一台计算机<em>移动到另一台计算机</em> </li>
<li><strong>分层通信</strong>过程：每一层执行一项特定任务</li>
</ul>
<h2 id="2-The-OSI-Reference-Model层次模型"><a href="#2-The-OSI-Reference-Model层次模型" class="headerlink" title="2. The OSI Reference Model层次模型"></a>2. The OSI Reference Model层次模型</h2><p>+——————-+<br>|   应用层 (Layer 7)<br>|   Application<br>+——————-+<br>|   表示层 (Layer 6)<br>|   Presentation<br>+——————-+<br>|   会话层 (Layer 5)<br>|   Session<br>+——————-+<br>|   传输层 (Layer 4)<br>|   Transport<br>+——————-+<br>|   网络层 (Layer 3)<br>|   Network<br>+——————-+<br>|   数据链路层 (Layer 2)<br>|   Data Link<br>+——————-+<br>|   物理层 (Layer 1)<br>|   Physical<br>+——————-+</p>
<h2 id="3-OSI模型的七层结构"><a href="#3-OSI模型的七层结构" class="headerlink" title="3. OSI模型的七层结构"></a>3. OSI模型的七层结构</h2><ul>
<li><ol>
<li><strong>物理层</strong> (Physical Layer)</li>
</ol>
<ul>
<li>Keywords: <strong>Signal and Media 信号和介质</strong></li>
<li>Binary transmission 二进制传输</li>
<li>功能: 负责传输原始的比特流。</li>
</ul>
</li>
<li><ol start="2">
<li><strong>数据链路层</strong> (Data Link Layer)</li>
</ol>
<ul>
<li>Keywords: <strong>frame, media access control 帧和介质访问控制</strong></li>
<li>Access to media 介质访问</li>
<li>功能: 负责节点之间的可靠传输。负责帧的创建、传输和错误检测。</li>
</ul>
</li>
<li><ol start="3">
<li><strong>网络层</strong> (Network Layer)</li>
</ol>
<ul>
<li>Keywords: <strong>Path selection路径选择, Routing路由, Addressing寻址</strong></li>
<li>Addresses and best path <strong>路径选择，最优路径</strong></li>
<li>功能: 在进行路由的两个终端系统之间提供连接和路径选择</li>
</ul>
</li>
<li><ol start="4">
<li><strong>传输层</strong> (Transport Layer)</li>
</ol>
<ul>
<li>Keywords: <strong>Reliability可靠性, Flow control流量控制, Error correction纠错</strong></li>
<li>End-to-end connections 终端到终端通信</li>
<li>功能: 负责终端节点之间的可靠网络通信，负责数据传输的流量控制，并为虚拟电路的建立、维护和终止、传输故障检测和恢复提供机制</li>
</ul>
</li>
<li><ol start="5">
<li><strong>会话层</strong> (Session Layer)</li>
</ol>
<ul>
<li>Keywords: <strong>Dialog and Conversations 对话和交流</strong></li>
<li>Inter-host connection 进程之间通信如何用户交流</li>
<li>功能: 管理和控制（建立、维护和终止）应用程序之间的会话；manages data exchange between presentation layer entities管理表示层实体之间的数据交换。</li>
</ul>
</li>
<li><ol start="6">
<li><strong>表示层</strong> (Presentation Layer)</li>
</ol>
<ul>
<li>Keywords:<strong>Common Format 标准</strong></li>
<li>Data presentation and encryption 展示</li>
<li>功能: 负责数据的格式化、加密和解密，确保数据的语法和语义正确。</li>
</ul>
</li>
<li><ol start="7">
<li><strong>应用层</strong> (Application Layer)</li>
</ol>
<ul>
<li>Keyword: <strong>Browser 浏览</strong></li>
<li>User interface 给用户展示交互接口</li>
<li>功能: 提供网络服务和应用程序接口，直接为用户和应用程序提供服务。</li>
</ul>
</li>
</ul>
<h2 id="4-分组"><a href="#4-分组" class="headerlink" title="4. 分组"></a>4. 分组</h2><ul>
<li>（1）application layers<strong>应用层</strong><ul>
<li>Application应用</li>
<li>Presentation展示</li>
<li>Session会话</li>
<li>deal with the user interface, data formatting, and the application access<ul>
<li>处理了用户接口，数据格式和应用权限</li>
</ul>
</li>
</ul>
</li>
<li>（2）data flow layers<strong>数据流层</strong><ul>
<li>Transport传输<br> Network网络<br> Data Link数据链路<br> Physical物理</li>
<li>control the physical delivery of messages over the network.<ul>
<li>控制着通过网络传输的数据信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-Data-Encapsulation数据封装"><a href="#5-Data-Encapsulation数据封装" class="headerlink" title="5. Data Encapsulation数据封装"></a>5. Data Encapsulation数据封装</h2><ul>
<li><p>定义：<br>数据封装是指在网络通信中，数据在传输过程中<code>通过各层协议逐层添加协议头（header）和协议尾（trailer）</code>的过程。每一层协议都在数据包的<code>前面或后面添加特定的信息</code>，以便在接收端能够正确地解析和处理数据。</p>
</li>
<li><p>基本步骤：</p>
<ol start="7">
<li>应用层（Application Layer）：<br> 数据生成并准备传输。</li>
<li>表示层（Presentation Layer）：<br> 数据格式化和加密。</li>
<li>会话层（Session Layer）：<br> 管理会话和数据交换。</li>
<li>传输层（Transport Layer）：<br> 添加<strong>传输层头部</strong>（如TCP&#x2F;UDP头），用于数据分段和重组。</li>
<li>网络层（Network Layer）：<br> 添加网<strong>络层头部</strong>（如IP头），用于路由和寻址。</li>
<li>数据链路层（Data Link Layer）：<br> 添加<strong>数据链路层头部和尾部</strong>（如MAC地址和帧<em>校验</em>序列），用于帧的传输和错误检测。</li>
<li>物理层（Physical Layer）：<br> 将数据转换为电信号或光信号，通过物理介质传输。</li>
</ol>
</li>
<li><p>数据封装过程</p>
<ul>
<li>5-&gt;4：添加首部 H5，应用程序数据作为数据部分</li>
<li>4-&gt;3：添加首部 H4，第五层的作为数据部分</li>
<li>3-&gt;2：添加首部 H3，第四层的作为数据部分</li>
<li>2-&gt;1：添加首部 H2 和尾部 T2（校验位），第三层的作为数据部分</li>
<li>1：转成比特流进行发送</li>
</ul>
</li>
<li><p>在接收端，数据封装的过程将逆向进行，即逐层剥离协议头和协议尾，直到还原出原始数据。</p>
</li>
</ul>
<h2 id="6-Peer-to-Peer-Communications-点对点通信"><a href="#6-Peer-to-Peer-Communications-点对点通信" class="headerlink" title="6. Peer-to-Peer Communications 点对点通信"></a>6. Peer-to-Peer Communications 点对点通信</h2><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/peertopeer%20communications.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h1 id="四、TCP-IP-Model"><a href="#四、TCP-IP-Model" class="headerlink" title="四、TCP&#x2F;IP Model"></a>四、TCP&#x2F;IP Model</h1><h2 id="1-组成"><a href="#1-组成" class="headerlink" title="1. 组成"></a>1. 组成</h2><ul>
<li>含有<strong>四层</strong><ul>
<li>应用层Application</li>
<li>传输层Transport</li>
<li>网络层Internet</li>
<li>网络访问层Network Access</li>
</ul>
</li>
</ul>
<h2 id="2-功能"><a href="#2-功能" class="headerlink" title="2.功能"></a>2.功能</h2><ul>
<li>（1）<strong>Application Layer 应用层</strong><ul>
<li>处理高级协议、表示、编码和会话控制问题<ul>
<li>包含[OSI]中上三层（应用层、表示层、会话层）的全部功能</li>
</ul>
</li>
<li>Handles <strong>high-level protocols</strong>, issues of <strong>representation, encoding, and session control</strong></li>
<li>TCP&#x2F;IP将所有与应用程序相关的问题合并到一个层中，并确保这些数据被正确打包到下一层。</li>
</ul>
</li>
<li>（2）<strong>Transport Layer 传输层</strong><ul>
<li>处理服务质量问题，如可靠性、流量控制和错误校正 <ul>
<li>对应[OSI]中第4层：传输层</li>
</ul>
</li>
<li>Deals with the quality-of-service issues of <strong>reliability, flow control, and error correction</strong>.</li>
</ul>
</li>
<li>（3）<strong>Internet Layer 网络层</strong><ul>
<li>最优路径的选择（报文从一方发送给另一方，报文传输经过<em>路由器</em>进行路径选择）<ul>
<li>对应[OSI]中第3层：网络层</li>
</ul>
</li>
<li><strong>Best path determination and packet switching</strong></li>
</ul>
</li>
<li>（4）<strong>Network Access 网络接入层</strong><ul>
<li>也称为<strong>host-to-network layer 主机到网络层</strong>。 <ul>
<li>包含[OSI]中下两层：物理层和数据链路层</li>
</ul>
</li>
<li>它关注 IP 分组实际建立物理链路，然后建立另一个物理链路所需的所有问题。</li>
<li>它包括 LAN 和 WAN 技术的细节，以及 OSI 物理和数据链路层中的所有细节。</li>
</ul>
</li>
</ul>
<h2 id="3-名词解释——常见的TCP-IP协议"><a href="#3-名词解释——常见的TCP-IP协议" class="headerlink" title="3.名词解释——常见的TCP&#x2F;IP协议"></a>3.名词解释——常见的TCP&#x2F;IP协议</h2><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-3.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>FTP <ul>
<li>File Transfer Protocol 文件传输协议</li>
</ul>
</li>
<li>HTTP <ul>
<li>Hypertext Transfer Protocol 超文本传输协议</li>
<li>主要用于浏览器</li>
</ul>
</li>
<li>SMTP <ul>
<li>Simple Mail Transfer protocol 简单邮件传输协议</li>
</ul>
</li>
<li>DNS <ul>
<li>Domain Name System 域名解析系统</li>
<li>将域名解析成IP地址</li>
</ul>
</li>
<li>TFTP <ul>
<li>Trivial File Transfer Protocol 简单文件传输协议</li>
<li>基于UDP，在局域网发送较小文件</li>
</ul>
</li>
</ul>
<h2 id="4-TCP-IP-和-OSI-的相似点"><a href="#4-TCP-IP-和-OSI-的相似点" class="headerlink" title="4. TCP&#x2F;IP 和 OSI 的相似点"></a>4. TCP&#x2F;IP 和 OSI 的相似点</h2><ul>
<li>both have layers, networking professionals need to know both<ul>
<li>层次</li>
</ul>
</li>
<li>both have application layers, though they include very different services <ul>
<li>应用层（虽然服务不同）</li>
</ul>
</li>
<li>both have comparable transport and network layers <ul>
<li>相同的传输层和网络层</li>
</ul>
</li>
<li>packet-switched (not circuit-switched) technology is assumed <ul>
<li>假设采用<strong>分组交换（非电路交换）技术</strong></li>
</ul>
</li>
<li>OSI 是<strong>基于报文交换</strong>来进行实现的，TCP&#x2F;IP 也是基于报文交换来完成实现的。</li>
</ul>
<h2 id="5-TCP-IP-和-OSI-的不同点"><a href="#5-TCP-IP-和-OSI-的不同点" class="headerlink" title="5.TCP&#x2F;IP 和 OSI 的不同点"></a>5.TCP&#x2F;IP 和 OSI 的不同点</h2><ol>
<li>TCP&#x2F;IP 看起来更简单，因为它有更少的层</li>
<li><strong>TCP&#x2F;IP 协议是因特网发展的标准，因此 TCP&#x2F;IP 模型正是因为它的协议才获得了可信性</strong>。</li>
<li>通常网络不是建立在 OSI 协议之上的，即使 OSI 模型被用作指南。</li>
<li><strong>TCP&#x2F;IP 标准是大家都在使用的标准（实施标准）</strong>，5 层和 7 层都只是讲课使用的</li>
<li>本课程我们一般使用<strong>5 层</strong>来进行分割讲解。<br><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-4.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<hr>
<h1 id="五-Network-Topology-网络拓扑"><a href="#五-Network-Topology-网络拓扑" class="headerlink" title="五.Network Topology 网络拓扑"></a>五.Network Topology 网络拓扑</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><ul>
<li>网络拓扑是指<strong>网络中各个节点</strong>（如计算机、路由器、交换机等）之间的<strong>物理或逻辑连接方式</strong>。不同的网络拓扑结构有不同的特点和适用场景。</li>
</ul>
<h2 id="2-常见的网络拓扑结构包括："><a href="#2-常见的网络拓扑结构包括：" class="headerlink" title="2.常见的网络拓扑结构包括："></a>2.常见的网络拓扑结构包括：</h2><ul>
<li>物理拓扑：导线（介质）的实际布局<ul>
<li>总线、星形、环形、扩展星形、分层（树形）、渔网型（mesh）</li>
<li>如何把节点具体连接起来<br><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-5.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li>逻辑拓扑：定义主机如何访问媒体<ul>
<li>令牌传递，使用 token 来获取通信的权利</li>
<li>主要涉及到管理介质如何被访问</li>
</ul>
</li>
<li>逻辑拓扑：主要是指如何在逻辑上如何控制网络</li>
</ul>
<h3 id="1-总线拓扑（Bus-Topology）"><a href="#1-总线拓扑（Bus-Topology）" class="headerlink" title="1. 总线拓扑（Bus Topology）"></a>1. 总线拓扑（Bus Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-6.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Physical Perspective：<ul>
<li><strong>所有节点通过一条主干电缆连接</strong>。</li>
<li>数据在主干电缆上传输，所有节点都能接收到数据。</li>
<li>优点：<ul>
<li>所有主机都可以直接通信。</li>
</ul>
</li>
<li>缺点：<ul>
<li>主干电缆故障会导致整个网络瘫痪，断开主机之间的连接。</li>
</ul>
</li>
</ul>
</li>
<li>Logical Perspective：<ul>
<li>Every networking device to see all signals from all other devices</li>
<li><strong>每个网络设备都可以看到来自所有其他设备的所有信号</strong>，实际上是广播式传播</li>
<li>优点：比较简单，所有的设备都可以监听到总线的信号。</li>
<li>缺点：<ul>
<li>信号冲突，需要进行复杂的介质访问权限控制来保证通信正常</li>
<li>如果<strong>一处断开，则全部无法</strong>进行网络传输</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-环形拓扑（Ring-Topology）"><a href="#2-环形拓扑（Ring-Topology）" class="headerlink" title="2. 环形拓扑（Ring Topology）"></a>2. 环形拓扑（Ring Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-7.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Physical Perspective：<ul>
<li><strong>所有的设备直接首尾相连，组成一个菊花链（daisy-chain）</strong></li>
<li>数据沿着环路单向或双向传输。</li>
<li>优点：<ul>
<li>数据传输延迟较小。</li>
<li>适用于负载均衡。</li>
</ul>
</li>
<li>缺点：<ul>
<li><strong>任意一个节点或连接故障都会影响整个网络</strong>。</li>
<li>故障定位和修复较为复杂。</li>
</ul>
</li>
</ul>
</li>
<li>Logical Perspective<ul>
<li>为了使信息流动，每个站点必须将信息传递给其相邻的站点。</li>
<li>我们需要对于链路进行访问控制，防止很多设备同时使用环，我们使用 token 来进行控制访问权力</li>
</ul>
</li>
</ul>
<h3 id="3-双环拓扑（Dual-Ring-Topology）"><a href="#3-双环拓扑（Dual-Ring-Topology）" class="headerlink" title="3. 双环拓扑（Dual Ring Topology）"></a>3. 双环拓扑（Dual Ring Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-8.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Physical Perspective<ul>
<li>每个节点通过两条环形链路连接到相邻节点，形成<code>两个</code>独立的环。</li>
<li>双环拓扑是指一个节点有两个点，同时只能一个环在传输信息，两个环的传输时的方向是不能确定的。</li>
</ul>
</li>
<li>Logical Perspective<ul>
<li>双环拓扑就像两个独立的环，<strong>同一时间只有一个环被应用</strong>。</li>
<li>有 token 令牌才有发送权力发送信息（使用总线）</li>
</ul>
</li>
<li>优点:<ul>
<li>提供可靠性和灵活性</li>
<li>容错性：一个环出现故障时，数据可以通过另一个环继续传输，确保网络的可靠性。</li>
</ul>
</li>
<li>Eg.优先使用外环，如果外环出现物理错误，则切换到内环上使用，并且对外环进行物理修复。</li>
</ul>
<h3 id="4-星型拓扑（Star-Topology）"><a href="#4-星型拓扑（Star-Topology）" class="headerlink" title="4. 星型拓扑（Star Topology）"></a>4. 星型拓扑（Star Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-9.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Physical Perspective：<ul>
<li>星型拓扑结构有一个<strong>中心节点</strong>，所有的链路都从它辐射（radiating）出去。</li>
</ul>
</li>
<li>Logical Perspective<ul>
<li><strong>所有信息的流动将通过一个设备</strong>。</li>
</ul>
</li>
<li>优点：<ul>
<li>它允许所有其他节点相互通信，方便。出于安全或限制访问的原因，它也可能是可取的</li>
</ul>
</li>
<li>缺点：<ul>
<li><strong>中央节点故障会导致整个网络瘫痪</strong>。</li>
<li>根据使用的网络设备类型，冲突可能是一个问题，中心点会有很大的负担，并且容易造成通信阻塞</li>
</ul>
</li>
</ul>
<h3 id="5-树形拓扑（Tree-Topology）"><a href="#5-树形拓扑（Tree-Topology）" class="headerlink" title="5. 树形拓扑（Tree Topology）"></a>5. 树形拓扑（Tree Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-10.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>树拓扑使用一个主干节点（Trunk Node），从该节点分支到其他节点。</li>
<li>物理观点：主干是一条有几层分支的电线。</li>
<li>逻辑观点：信息流是层次性的。</li>
<li>在根一级数据节点可以对数据进行汇总和统计</li>
</ul>
<h3 id="6-渔网状拓扑（Mesh-Topology）"><a href="#6-渔网状拓扑（Mesh-Topology）" class="headerlink" title="6. 渔网状拓扑（Mesh Topology）"></a>6. 渔网状拓扑（Mesh Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-11.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Physical Perspective：</li>
<li><strong>每个节点</strong>与网络中的<strong>其他节点直接相连</strong>。<ul>
<li>优点：<ul>
<li>高度冗余，任意节点或连接故障不会影响网络整体。</li>
<li>高可靠性和稳定性。 the maximum connectivity and reliability.</li>
</ul>
</li>
<li>缺点：<ul>
<li>结构复杂，成本高。</li>
<li>需要大量的电缆和端口。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-蜂窝拓扑（Cellular-Topology）"><a href="#7-蜂窝拓扑（Cellular-Topology）" class="headerlink" title="7. 蜂窝拓扑（Cellular Topology）"></a>7. 蜂窝拓扑（Cellular Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-12.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>物理视角（Physical Perspective）<ul>
<li>蜂窝拓扑结构是用于<strong>无线技术</strong>的拓扑结构</li>
<li>有时接收节点移动（如<em>手机</em>），有时发送节点移动（如<em>卫星</em>）</li>
</ul>
</li>
<li>逻辑视角（Logical Perspective）<ul>
<li>节点之间直接通信（尽管有时非常困难），或者只与相邻的单元通信，这是<strong>非常低效</strong>的。</li>
<li>每一个节点都是无线的连通方式：远节点需要进行转发。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="六-Network-Devices-网络设备"><a href="#六-Network-Devices-网络设备" class="headerlink" title="六.Network Devices 网络设备"></a>六.Network Devices 网络设备</h1><h2 id="1-LAN-Devices-in-a-Topology"><a href="#1-LAN-Devices-in-a-Topology" class="headerlink" title="1.LAN Devices in a Topology"></a>1.LAN Devices in a Topology</h2><ul>
<li>主机<strong>Hosts</strong> （网络终端设备）：<ul>
<li><strong>直接连接到网段的设备</strong></li>
<li>打印机、计算机、服务器、传真机、复印机</li>
</ul>
</li>
<li>Hosts（网络中间设备）<ul>
<li><strong>主机不属于任何层</strong>，但 OSI 模型的功能在主机内部的软件中执行</li>
</ul>
</li>
</ul>
<h2 id="2-NIC-网络接口卡-–-Layer-2（Data-Link数据链路层）"><a href="#2-NIC-网络接口卡-–-Layer-2（Data-Link数据链路层）" class="headerlink" title="2.NIC 网络接口卡 – Layer 2（Data Link数据链路层）"></a>2.NIC 网络接口卡 – Layer 2（Data Link数据链路层）</h2><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-13.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>NIC，第二层，网卡（Network Interface Controller），<strong>网络终端设备</strong></li>
<li>携带称为 MAC 地址的唯一代码，固定地址，在芯片上</li>
<li>用于控制网络上主机的数据通信</li>
<li>将计算机产生的并行信号转换成串行格式通过网络发送</li>
<li>用于转换信号以及发送和接收比特的收发器</li>
<li>提供主机对媒体的访问权限</li>
<li>为什么是第二层的设备：<ul>
<li>可以识别帧</li>
<li>帮助主机接入网络</li>
</ul>
</li>
<li>计算机母线：并行通信；网卡总线：串行通信<ul>
<li>所以网卡需要完成两者之间的交换。</li>
</ul>
</li>
<li>也是可以完成第一层的工作的</li>
</ul>
<h2 id="3-Media介质-–-Layer-1"><a href="#3-Media介质-–-Layer-1" class="headerlink" title="3.Media介质 – Layer 1"></a>3.Media介质 – Layer 1</h2><ul>
<li>网络中间设备，第一层</li>
</ul>
<ol>
<li><strong>以位为单位携带信息流</strong></li>
<li>信号从一个网络设备传送到另一个网络设备的方式</li>
<li>0-1 信号变为电信号或者无线电波光信号等。</li>
</ol>
<h2 id="4-Repeaters中继器-Layer-1（物理层）"><a href="#4-Repeaters中继器-Layer-1（物理层）" class="headerlink" title="4.Repeaters中继器 - Layer 1（物理层）"></a>4.Repeaters中继器 - Layer 1（物理层）</h2><ul>
<li>网络中间设备</li>
<li>主要功能：<ul>
<li><strong>延长网络长度</strong>：<ul>
<li>用于延长网络的物理长度，实现传输超出一段介质传输的介质</li>
</ul>
</li>
<li>清理、放大和重发信号：<ul>
<li>清理、放大和重发由于长电缆传输而减弱的信号。</li>
</ul>
</li>
<li>信号再生和重定时：<ul>
<li>在<em>比特级别</em>重新生成（放大）和重定时网络信号（<strong>数字信号</strong>），以允许它们在媒体上传播更长的距离</li>
</ul>
</li>
<li>不进行过滤：<ul>
<li>中继器不对数据包进行任何过滤或处理，只是简单地转发信号。</li>
</ul>
</li>
</ul>
</li>
<li>这些功能确保了信号在长距离传输中的完整性和可靠性。</li>
</ul>
<h2 id="5-Hubs（集线器）-–-Layer-1"><a href="#5-Hubs（集线器）-–-Layer-1" class="headerlink" title="5.Hubs（集线器） – Layer 1"></a>5.Hubs（集线器） – Layer 1</h2><ul>
<li>网络中间设备</li>
<li>信号再生和重定时：用于重新生成和重定时网络信号，连接多个端口，可以比中继器做更多的事情</li>
<li>传播信号propagate signals<ul>
<li><code>不能过滤流量</code>cannot filter traffic</li>
<li><code>不能确定最佳路径</code>cannot determine the best path</li>
<li>网络中心节点used as network concentration points</li>
<li>有时称为多端口中继器sometimes called multiport repeaters</li>
</ul>
</li>
<li>逻辑拓扑：<strong>总线方式连接</strong>，一个端口入，所有端口出</li>
<li>不允许总线上同时有两路信号进行传输</li>
<li>冲突域：可能出现冲突的区域，但是集线器不进行这些控制，而是由交换机或者路由器来完成控制，不能降低冲突概率</li>
<li>而放大器方法的是模拟信号。</li>
</ul>
<h3 id="Repeaters-Hubs-Difference中继器和集线器的不同"><a href="#Repeaters-Hubs-Difference中继器和集线器的不同" class="headerlink" title="Repeaters&#x2F;Hubs - Difference中继器和集线器的不同"></a>Repeaters&#x2F;Hubs - Difference中继器和集线器的不同</h3><ul>
<li>中继器通常只有两个端口，而集线器通常有4个到20个或更多端口。</li>
<li>中继器在<strong>一个端口接收</strong>信号，并在<strong>另一个端口重复</strong>信号，而集线器在<strong>一个端口接收</strong>信号并在<strong>所有其他端口传输</strong>信号。</li>
<li>集线器最常见于以太网10Base-T或100Base-T网络中。</li>
<li>都是转发，<strong>都不做过滤功能</strong></li>
<li>两个设备之间最多有 4 个集线器和网桥</li>
</ul>
<h2 id="6-Bridges（网桥）-–-Layer-2（数据链路层）"><a href="#6-Bridges（网桥）-–-Layer-2（数据链路层）" class="headerlink" title="6.Bridges（网桥） – Layer 2（数据链路层）"></a>6.Bridges（网桥） – Layer 2（数据链路层）</h2><ul>
<li>网络中间设备</li>
</ul>
<ol>
<li>目的是在 LAN 上过滤流量，以保持本地流量，但允许连接到 LAN 的其他部分以定向到那里的流量</li>
<li>跟踪网桥两侧的 MAC 地址，并根据此 MAC 地址列表进行决策<ul>
<li>目的地址如果在同一端，就不进行转发（不必进行转发，MAC Table）</li>
<li>而在不同侧（不同的 segments）就进行尽量向外转发</li>
</ul>
</li>
<li>比集线器更智能</li>
<li>收集并在段之间传递数据包</li>
<li>创建冲突域<ul>
<li>通过网桥划分冲突域</li>
<li>每个冲突域中都有一定的主机</li>
<li>第一层以上的设备才能划分冲突域</li>
</ul>
</li>
<li>维护地址表</li>
</ol>
<ul>
<li>这些功能使得网桥在局域网中能够有效地管理和优化流量，提高网络的整体性能和效率。</li>
</ul>
<h2 id="7-Switches（交换机）-–-Layer-2"><a href="#7-Switches（交换机）-–-Layer-2" class="headerlink" title="7.Switches（交换机） – Layer 2"></a>7.Switches（交换机） – Layer 2</h2><ul>
<li>网络中间设备</li>
<li>集中连接 used to concentrate connectivity</li>
<li>结合集线器的连接性和网桥的流量调节 combine the connectivity of a hub with the traffic regulation of a bridge</li>
<li>switch frames from incoming ports to outgoing ports providing each port with full bandwidth 根据MAC地址表将帧从输入端口切换到相应的输出端口，为每个端口提供全带宽。</li>
<li>provide separate data paths 为每个连接的设备提供独立的数据路径，避免冲突，提高网络性能。</li>
</ul>
<h2 id="8-Routers路由器-–-Layer-3"><a href="#8-Routers路由器-–-Layer-3" class="headerlink" title="8.Routers路由器 – Layer 3"></a>8.Routers路由器 – Layer 3</h2><ul>
<li>网络中间设备</li>
<li>在大型网络中调节流量。</li>
<li>基于网络地址（如IP地址）做出转发决策。<ul>
<li>主要是进行网段的划分，根据网络地址（包含在 IP 地址中）进行转化</li>
</ul>
</li>
<li>检查数据包的第三层数据，选择最佳路径，并通过适当的输出端口转发数据包。</li>
<li><code>主要目的</code>：<ul>
<li>用于<strong>路径选择</strong>和<strong>将数据包切换到最佳路由</strong>。</li>
</ul>
</li>
</ul>
<h2 id="9-Evolution-of-Networking-Devices-and-the-OSI-Layers"><a href="#9-Evolution-of-Networking-Devices-and-the-OSI-Layers" class="headerlink" title="9.Evolution of Networking Devices and the OSI Layers"></a>9.Evolution of Networking Devices and the OSI Layers</h2><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>网络设备的工作层次和主机情况<ul>
<li>物理层：<strong>介质、中继器、集线器</strong></li>
<li>数据链路层：<strong>网桥、交换机、电路交换设备</strong></li>
<li>网络层：<strong>路由器</strong></li>
</ul>
</li>
</ol>
<ul>
<li>高层设备可以识别低层设备的信号，但是低层设备不能识别高层次的数据逻辑</li>
<li>Host 下层通过网卡进行实现，上层通过网络操作系统、应用实现</li>
</ul>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>八、RIP&amp;OSPF</title>
    <url>/2025/02/24/%E5%85%AB.RIP&amp;OSPF/</url>
    <content><![CDATA[<h1 id="08-Routing-Protocols：RIP-and-OSPF"><a href="#08-Routing-Protocols：RIP-and-OSPF" class="headerlink" title="08 Routing Protocols：RIP and OSPF"></a>08 Routing Protocols：RIP and OSPF</h1><ul>
<li>RIPv1&#x2F;RIPv2<ul>
<li>RIP History </li>
<li>Differences Between RIP v1 and RIP v2 </li>
<li>Configuration of RIP v2</li>
</ul>
</li>
<li>OSPF(single area)<ul>
<li>Link-state routing protocol</li>
<li>Single-area OSPF concepts</li>
<li>Single-area OSPF configuration</li>
</ul>
</li>
</ul>
<h1 id="一、RIPv1-RIPv2"><a href="#一、RIPv1-RIPv2" class="headerlink" title="一、RIPv1&#x2F;RIPv2"></a>一、RIPv1&#x2F;RIPv2</h1><h2 id="（一）RIP-History"><a href="#（一）RIP-History" class="headerlink" title="（一）RIP History"></a>（一）RIP History</h2><h2 id="1-RIP的历史"><a href="#1-RIP的历史" class="headerlink" title="1. RIP的历史"></a>1. RIP的历史</h2><ol>
<li><strong>RIP v1</strong>被认为是一种无类别的<strong>内部网关协议（IGP）</strong>。<ul>
<li><strong>距离矢量协议 DVP</strong>：RIP v1是一种距离矢量协议，它以预定的间隔向每个邻居路由器广播其整个路由表。默认间隔为<strong>30秒</strong>。</li>
<li><strong>跳数作为度量</strong>：RIP使用跳数作为度量，最大跳数为<strong>15</strong>。<ul>
<li>如果目的地的跳数超过15，则认为该目的地不可达。</li>
</ul>
</li>
</ul>
</li>
<li><strong>负载均衡 load balancing</strong>：RIP v1能够在多达<strong>6条</strong>等成本路径上进行负载均衡，默认情况下为<strong>4条</strong>路径。</li>
<li><strong>规范</strong>：RIP最初在RFC 1058中指定。</li>
</ol>
<ul>
<li>RIP v1的局限性<ul>
<li><strong>不发送子网掩码信息</strong>：RIP v1在更新中不发送子网掩码信息。<ul>
<li>意味着只能支持类网络，必须用同样的子网掩码</li>
</ul>
</li>
<li><strong>广播更新</strong>：RIP v1以广播形式发送更新，地址为255.255.255.255。<ul>
<li>只能发给邻居，不能通过路由器转发</li>
</ul>
</li>
<li><strong>不支持身份验证（authentication）</strong>：RIP v1不支持认证。<ul>
<li>安全隐患</li>
</ul>
</li>
<li><strong>不支持VLSM或CIDR</strong>：RIP v1无法支持可变长子网掩码（VLSM）或无类别域间路由（CIDR）。</li>
</ul>
</li>
</ul>
<h2 id="2-RIP的配置Configuration"><a href="#2-RIP的配置Configuration" class="headerlink" title="2. RIP的配置Configuration"></a>2. RIP的配置Configuration</h2><ul>
<li><code>router rip</code> 开始RIP路由过程(<strong>选择 RIP 作为路由协议</strong>)</li>
<li><code>network network-number</code> 分配基于 NIC（Network Interface Card）的网络地址，也就是说，路由器与哪些网络直接连接，就要配置对应的网络地址。</li>
<li>例子：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router rip</span><br><span class="line">network 1.0.0.0</span><br><span class="line">network 2.0.0.0</span><br><span class="line">//路由器是直接连接到 1.0.0.0 和 2.0.0.0 这两个网络的，且这两个网络会启用RIP协议</span><br></pre></td></tr></table></figure>

<ul>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="（二）Configuration-of-RIP-v2"><a href="#（二）Configuration-of-RIP-v2" class="headerlink" title="（二）Configuration of RIP v2"></a>（二）Configuration of RIP v2</h2><h2 id="1-RIP-v2"><a href="#1-RIP-v2" class="headerlink" title="1. RIP v2"></a>1. RIP v2</h2><ul>
<li>RIP v2是RIP v1的改进版本，具有以下特性：<ul>
<li><strong>距离矢量协议</strong>：使用<strong>跳数</strong>作为度量。</li>
<li><strong>保持定时器</strong>：使用holddown timers防止路由环路，默认时间为<strong>180秒</strong>。<ul>
<li>如果路由器在180s内没有接收到路由更新，它会认为路由不可用。</li>
</ul>
</li>
<li><strong>水平分割</strong>：使用split horizons防止路由环路。</li>
<li><strong>无限距离</strong>：使用<strong>16跳</strong>作为<strong>无限距离的度量</strong>。<ul>
<li>15 跳及以内可达；否则认为目标不可达</li>
</ul>
</li>
<li><strong>支持CIDR和VLSM</strong></li>
<li>支持<strong>认证</strong>（Authentication）</li>
<li>使用<strong>多播</strong>而不是广播, 地址<strong>224.0.0.9</strong></li>
<li>会发送<strong>子网掩码</strong>信息</li>
</ul>
</li>
</ul>
<h2 id="2-RIP-v2-的配置"><a href="#2-RIP-v2-的配置" class="headerlink" title="2. RIP v2 的配置"></a>2. RIP v2 的配置</h2><ol>
<li><code>router</code>命令启动路由过程。</li>
<li><code>version 2</code>：表示启动 RIPv2<ul>
<li>直接使用 router rip <strong>默认为 v1</strong>，一定要输入这个命令才能启动 RIPv2</li>
</ul>
</li>
<li><code>network</code>配置网络，命令实现以下三个功能：<ul>
<li><strong>路由更新</strong>通过该命令指定的<strong>网络接口</strong>进行<strong>多播</strong> multicast。<ul>
<li>并将路由更新通过该接口发送到多播地址（224.0.0.9），发送给同一网络上的其他 RIP 路由器。</li>
</ul>
</li>
<li>如果路由更新进入<strong>同一接口</strong>，则进行<strong>处理</strong>。<ul>
<li>同一接口（即该接口本身已配置为 RIP 网络接口）</li>
<li>路由器会处理该更新并更新自己的路由表</li>
</ul>
</li>
<li>广播直接连接到该接口的子网。<ul>
<li>路由器会在指定网络接口上广播或多播该接口直接连接的子网信息</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-1.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="3-验证与故障排除"><a href="#3-验证与故障排除" class="headerlink" title="3. 验证与故障排除"></a>3. 验证与故障排除</h2><ol>
<li>验证 RIPv2：</li>
</ol>
<ul>
<li>Router#<strong>show ip protocols</strong>    #查看当前启用的路由协议，以及其配置和相关信息</li>
<li>Router#<strong>show ip route</strong>    #显示 IP 路由表</li>
</ul>
<ol start="2">
<li>故障排除 RIPv2：</li>
</ol>
<ul>
<li>Router#<strong>debug ip rip</strong>   #显示RIP 路由更新的发送和接收过程</li>
<li>Router#<strong>undebug all</strong>    #（或 <strong>no debug all</strong>）：停止debug调试</li>
</ul>
<ol start="3">
<li><code>show ip protocols</code>实例</li>
</ol>
<ul>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-2.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<ol start="4">
<li><code>debug ip rip</code>命令<ol>
<li><code>debug ip rip</code>命令显示 <strong>RIP 路由更新的发送和接收</strong>。在本示例中，更新是通过 183.8.128.130 发送的</li>
<li>它报告了三台路由器，其中一台<strong>无法访问</strong>，因为其跳数大于 15。然后通过 183.8.128.2 广播了更新</li>
</ol>
</li>
</ol>
<ul>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-3.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<ol start="5">
<li><code>show ip route</code>查看路由表</li>
</ol>
<ul>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-5.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>Codes：表示对于路由协议类型的描述</li>
<li>每个路由的格式为：<strong>&lt;协议类型&gt;&#x2F;&lt;跳数&gt;</strong></li>
<li>120&#x2F;1：表示该路由通过 RIP 协议获取, 1 跳到达，120&#x2F;2：表示 2 跳到达</li>
</ul>
<h2 id="（三）RIPv1-和-RIPv2-之间的区别"><a href="#（三）RIPv1-和-RIPv2-之间的区别" class="headerlink" title="（三）RIPv1 和 RIPv2 之间的区别"></a>（三）RIPv1 和 RIPv2 之间的区别</h2><p><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-6.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>支持有类路由：可以携带子网掩码</li>
<li>使用多播地址进行发送广播：特定给 RIP 接受，避免了接受后发现没有启动 RIP 进程耽误时间</li>
<li>需要身份认证才确定是否继续进行接收</li>
</ul>
<hr>
<h1 id="OSPF-single-area"><a href="#OSPF-single-area" class="headerlink" title="OSPF(single area)"></a>OSPF(single area)</h1><ul>
<li>介绍单个区域（single-srea）OSPF 协议</li>
</ul>
<h2 id="1-OSPF概述"><a href="#1-OSPF概述" class="headerlink" title="1. OSPF概述"></a>1. OSPF概述</h2><ul>
<li><strong>Open Shortest Path First</strong></li>
</ul>
<ol>
<li>开放最短路径优先（OSPF）是一种基于开放标准的<strong>链路状态link-state</strong>路由协议。</li>
<li>标准描述：OSPF在多个互联网工程任务组（IETF）的标准中有所描述，最新的描述在RFC 2328中。</li>
<li><strong>可扩展性</strong>：与RIPv1和RIPv2相比，OSPF因其可扩展性而成为首选的<strong>内部网关协议（IGP）</strong>。</li>
</ol>
<h2 id="2-路由信息-Routing-information"><a href="#2-路由信息-Routing-information" class="headerlink" title="2. 路由信息 Routing information"></a>2. 路由信息 Routing information</h2><ul>
<li><strong>链路状态</strong>：The state of the link是<strong>对接口及其与邻居路由器关系的描述</strong>。</li>
<li><strong>链路状态数据库</strong>：链路状态的集合形成 link-state database，有时也称为<strong>拓扑数据库 topological database</strong>。</li>
<li><strong>SPF算法</strong>：路由器应用<strong>Dijkstra最短路径优先（SPF）算法</strong>来构建SPF树，以自身为根。</li>
<li><strong>路径计算</strong>：路由器通过SPF树计算最佳路径，然后选择最佳路径并将其放入<strong>路由表</strong>中。</li>
</ul>
<h2 id="3-OSPF-vs-RIP"><a href="#3-OSPF-vs-RIP" class="headerlink" title="3. OSPF vs. RIP"></a>3. OSPF vs. RIP</h2><p><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-7.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>OSPF使用带宽作为评价指标, 而RIP使用跳数</li>
<li>OSPF适合大型网络, 而RIP是为小型网络设计的</li>
<li>OSPF可以进一步把网络划分为小区域</li>
<li>OSPF支持VLSM，RIP v1不支持</li>
<li>OSPF快速收敛</li>
<li>OSPF支持多条等价的路径（多路负载均衡）</li>
</ol>
<ul>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-8.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>What is the Best Path from A to B?<ul>
<li>上面带宽大，2 跳达到，下面带宽小，1 跳到达。</li>
<li>OSPF 从上面走，RIP 从下面走，但是上面会快一些，因此 OSPF 选择的路径是更加优越的</li>
</ul>
</li>
</ul>
<h2 id="4-OSPF的特点"><a href="#4-OSPF的特点" class="headerlink" title="4. OSPF的特点"></a>4. OSPF的特点</h2><ul>
<li>More robust更健壮</li>
<li>更好的可扩展性 scalable</li>
<li><strong>分层设计 hierarchical design</strong>：大型OSPF网络使用分层设计</li>
</ul>
<h2 id="5-OSPF中的一些术语-Terminology"><a href="#5-OSPF中的一些术语-Terminology" class="headerlink" title="5. OSPF中的一些术语 Terminology"></a>5. OSPF中的一些术语 Terminology</h2><ol>
<li><strong>链路&#x2F;连接（Link）</strong>：<ul>
<li>两个网络设备之间的物理连接</li>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-9.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li><strong>链路状态（Link-State）</strong>：<ul>
<li>两个路由器之间的链路状态，包括路由器接口的信息及其与邻居路由器的关系、网络类型（点对点、多路复用）等</li>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-10.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ol>
<ul>
<li><strong>邻居（Neighbors）</strong>：相邻的路由器</li>
</ul>
<ol start="3">
<li><strong>开销（Cost）</strong>：<ul>
<li>不同网络链路处理的时候的代价，和链路带宽相关，成反比关系，一般是固定值除以带宽</li>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-11.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li><strong>区域（Area）</strong>：<ul>
<li>具有相同区域ID的网络&#x2F;路由器的集合</li>
<li>区域内的每个路由器都具有相同的链路状态信息</li>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-12.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li><strong>自治系统（Autonomous System，AS）</strong>：<ul>
<li>多个 Area 形成一个自治系统</li>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-14.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li><strong>邻接关系数据库（Neighborship Database）</strong>：<ul>
<li>列出路由器已建立双向通信的所有邻居</li>
</ul>
</li>
<li><strong>拓扑数据库（Topology Database）</strong>：<ul>
<li>列出所有路由 link-state</li>
<li>包含关于互联网络中所有其他路由器的信息，显示互联网络的拓扑结构</li>
</ul>
</li>
<li><strong>路由表（Routing Table）</strong>：<ul>
<li>列出最佳路由</li>
<li>有时称为转发数据库</li>
<li>每个路由器的路由表都是唯一的</li>
</ul>
</li>
<li><strong>指定路由器（Designated Router, DR）</strong>：<ul>
<li>在OSPF多访问网络中选举出的一个路由器，代表该网络中的所有路由器</li>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-15.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li><strong>备份指定路由器（Backup Designated Router, BDR）</strong>：</li>
</ol>
<ul>
<li>备用路由器，如果原始DR失效，它将成为DR</li>
</ul>
<hr>
<h2 id="6-OSPF-Area"><a href="#6-OSPF-Area" class="headerlink" title="6. OSPF Area"></a>6. OSPF Area</h2><ul>
<li><strong>区域定义</strong>：区域使用32位数字定义<ul>
<li>可以是 IP格式 或 单个十进制值</li>
<li>例如：Area 0 或 Area 0.0.0.0</li>
</ul>
</li>
<li><strong>区域 0</strong>：区域编号为0的单一区域</li>
<li><strong>分层模型</strong>：OSPF使用<strong>2 level hierarchical model</strong></li>
<li>在<strong>多区域OSPF网络</strong>中，所有区域都需要<strong>连接到区域0</strong>（主干）<br><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-16.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="7-OSPF操作步骤"><a href="#7-OSPF操作步骤" class="headerlink" title="7. OSPF操作步骤"></a>7. OSPF操作步骤</h2><ul>
<li>OSPF使用<em>邻居关系</em>来获取网络的完整信息。</li>
<li><strong>操作步骤</strong>：<ol>
<li>建立邻接关系 <strong>adjacency relationships</strong></li>
<li>选举DR和BDR（如果需要）（多路复用的时候才需要）</li>
<li>发现路由（路线 routes）</li>
<li>选择合适的路由</li>
<li>维护路由信息</li>
</ol>
</li>
<li><strong>OSPF的七个状态</strong>：<ul>
<li>Init 初始化</li>
<li>2Way 双向操作</li>
<li>ExStart 预先启动</li>
<li>Exchange 交换</li>
<li>Loading 加载</li>
<li>Full 完成</li>
</ul>
</li>
</ul>
<h2 id="8-最短路径算法"><a href="#8-最短路径算法" class="headerlink" title="8. 最短路径算法"></a>8. 最短路径算法</h2><ul>
<li>最短路径算法使用节点作为起点，依次检查其关于相邻节点的信息，计算出无环拓扑结构。</li>
<li>不根据跳数来进行选择，而是根据最小权和来寻找</li>
</ul>
<h2 id="9-选择-DR-和-BDR"><a href="#9-选择-DR-和-BDR" class="headerlink" title="9. 选择 DR 和 BDR"></a>9. 选择 DR 和 BDR</h2><ul>
<li><strong>OSPF网络类型</strong>：<ul>
<li>广播多访问网络，如以太网    需要选举DR</li>
<li>点对点网络                 不需要选举DR</li>
<li>非广播多访问网络（NBMA）    需要选举DR</li>
</ul>
</li>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-17.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>只有多路复用的实现方式需要 DR 和 BDR</li>
</ul>
<ol>
<li>然后，每个路由器与 DR 和 BDR 形成<strong>邻接关系</strong></li>
<li>对于所有 OSPF 路由器，DR 使用 224.0.0.5（自己的 IP）的<strong>主播地址</strong>向该网段上的所有其他路由器发送<strong>链接状态信息</strong></li>
<li>为确保 DR&#x2F;BDR 看到所有路由器在网段上发送的链接状态，<strong>使用了所有 DR&#x2F;BDR 的多播地址</strong> 224.0.0.6（DR 和 BDR 之间）</li>
</ol>
<h2 id="10-多路复用（Multi-Access-media）中的OSPF"><a href="#10-多路复用（Multi-Access-media）中的OSPF" class="headerlink" title="10. 多路复用（Multi-Access media）中的OSPF"></a>10. 多路复用（Multi-Access media）中的OSPF</h2><ol>
<li>Giga&#x2F;Fast&#x2F;Ethernet，FDDI，Token Ring<ul>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-18.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li><strong>几个 Area 有几个 DR 和 BDR</strong>（是在不同 Area 上）</li>
<li>DR 和 BDR 归属于区域</li>
</ol>
<h2 id="11-OSPF-Packets"><a href="#11-OSPF-Packets" class="headerlink" title="11. OSPF Packets"></a>11. OSPF Packets</h2><ul>
<li>OSPF路由协议有5种类型的数据包：<br><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-19.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li><strong>Hello</strong>：用于<strong>建立和维护邻接关系</strong></li>
<li><strong>数据库描述（DBD）</strong>：用于描述链路状态数据库的内容</li>
<li><strong>链路状态请求（LSR）</strong>：用于请求特定的链路状态信息</li>
<li><strong>链路状态更新（LSU）</strong>：用于发送链路状态信息</li>
<li><strong>链路状态确认（LSAck）</strong>：用于确认接收到的链路状态信息</li>
</ul>
<h3 id="1-Hello-协议"><a href="#1-Hello-协议" class="headerlink" title="1. Hello 协议"></a>1. Hello 协议</h3><ul>
<li>当路由器在接口上启动OSPF路由进程时，它会发送一个Hello数据包，并继续定期发送Hello数据包。</li>
<li>管理OSPF Hello数据包交换的规则称为Hello协议。</li>
<li>Hello数据包的地址是<strong>224.0.0.5</strong>。</li>
<li>在广播多访问和点对点网络上，默认<strong>每10秒</strong>发送一次Hello数据包。</li>
<li>在连接到非广播多访问（NBMA）网络（如帧中继）的接口上，默认时间为<strong>30秒</strong>。</li>
</ul>
<h3 id="2-OSPF-报文头部"><a href="#2-OSPF-报文头部" class="headerlink" title="2. OSPF 报文头部"></a>2. OSPF 报文头部</h3><p><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-20.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Hello 报文的 Type 字段设置为 1</li>
</ul>
<h3 id="3-哪个路由器将成为-DR？"><a href="#3-哪个路由器将成为-DR？" class="headerlink" title="3. 哪个路由器将成为 DR？"></a>3. 哪个路由器将成为 DR？</h3><ul>
<li><strong>优先级 + 路由器ID 最大</strong>：优先级和路由器ID<strong>最大</strong>的路由器成为DR，第二大的成为BDR。</li>
<li><strong>优先级</strong>：范围为1-255，默认值为1。</li>
<li><strong>路由器ID</strong>：<ul>
<li>使用回环IP地址作为路由器ID。</li>
<li>如果没有回环IP地址，则使用最高值的接口IP地址。</li>
</ul>
</li>
<li><strong>接口失效</strong>：如果接口失效，路由器必须重新建立邻接关系并重新发布LSA。</li>
</ul>
<h2 id="12-OSPF-操作的完整步骤"><a href="#12-OSPF-操作的完整步骤" class="headerlink" title="12. OSPF 操作的完整步骤"></a>12. OSPF 操作的完整步骤</h2><p><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-21.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>一开始的状态是 Down State</li>
<li>发送 <strong>Hello 报文</strong>（Init State）</li>
<li>B 收到 A 的报文（收到报文一定是邻居）：Hello 报文的 TTL 是 1，所以不会跨路由器传播，收到即丢弃</li>
<li>收到后，B 也会发送自己的 Hello，然后 A 收到后进入 Two Way 状态<br><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-22.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>准备交换数据库（Exstart Starts）</li>
<li>首先确认<strong>主方（发送方）、从方（接受方）</strong>，保证数据有序，简单就是谁的 Router ID <strong>高</strong></li>
<li>Router ID 高的（主方）发送自己 <strong>DBD 报文</strong>，从方对主方发送的 DBD 接受处理并发送（Exchange State）<br><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-23.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>交换完成后，各自检查自己是不是有全部的信息<ul>
<li>如果发现有没有的，则发送 <strong>LSR</strong>，等待 <strong>LSU</strong>（整个链路的详细信息，不是 LSA）来进行学习，之后收到完成后发送 <strong>LSAck</strong>（Loading State）</li>
<li>如果有完整的信息，则发送 <strong>LSAck</strong>（Full State）</li>
</ul>
</li>
</ol>
<h2 id="13-总结：OSPF操作"><a href="#13-总结：OSPF操作" class="headerlink" title="13. 总结：OSPF操作"></a>13. 总结：OSPF操作</h2><ol>
<li>Set up the adjacency relationships邻居关系</li>
<li>Elect DR and BDR（if needed）选举DR</li>
<li>Discover the routes 发路由</li>
<li>Choose appropriate routes 选路由</li>
<li>Maintain the route information 维持路由信息</li>
</ol>
<h3 id="步骤-1：建立邻居关系"><a href="#步骤-1：建立邻居关系" class="headerlink" title="步骤 1：建立邻居关系"></a>步骤 1：建立邻居关系</h3><ul>
<li>路由器按间隔发送Hello数据包。<ul>
<li>如果发现<strong>邻居</strong>：<ul>
<li>将邻居添加到邻接关系数据库。</li>
</ul>
</li>
<li>发现<strong>网络类型</strong>：<ul>
<li>如果是<strong>多访问网络</strong>，进入DR&#x2F;BDR选举过程并进入步骤2。</li>
<li>如果是<strong>点对点或点对多点网络</strong>，不选举DR&#x2F;BDR，跳过步骤2。</li>
<li>如果<strong>Hello数据包头中的DR&#x2F;BDR字段已被占用</strong>（即已存在DR&#x2F;BDR对），则不进行DR&#x2F;BDR选举，跳过步骤2。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="步骤-2：选举DR-BDR"><a href="#步骤-2：选举DR-BDR" class="headerlink" title="步骤 2：选举DR&#x2F;BDR"></a>步骤 2：选举DR&#x2F;BDR</h3><ul>
<li>如果没有其他路由器在线，该路由器成为DR。下一个上线的路由器将成为BDR。</li>
<li>如果有多个路由器（两个或更多）同时上线，则：<ul>
<li><strong>优先级</strong>最高的路由器成为DR。<ul>
<li>优先级为零表示“永不成为DR”。</li>
</ul>
</li>
<li>如果<strong>优先级相同</strong>，则<strong>路由器ID</strong>最高的路由器成为DR。<ul>
<li>路由器ID是最高的回环地址或接口IP地址。</li>
</ul>
</li>
<li>优先级或路由器ID第二高的路由器成为BDR。</li>
</ul>
</li>
<li>如果DR失效，BDR成为DR。</li>
<li>【注意！】但是，如果一个<strong>新的OSPF路由器加入</strong>网络，且其<strong>优先级或路由器ID更高</strong>，当前的DR和BDR<strong>不会改变</strong>。<ul>
<li>只有在当前DR失效时，它才会成为新的<em>BDR</em>；</li>
<li>或者在当前DR和BDR<strong>都失效</strong>时，它才会成为新的<em>DR</em>。</li>
</ul>
</li>
</ul>
<h3 id="步骤-3：发现路由"><a href="#步骤-3：发现路由" class="headerlink" title="步骤 3：发现路由"></a>步骤 3：发现路由</h3><ul>
<li>之前在ExStart到Full状态中解释过<ul>
<li>路由器确定“<strong>主&#x2F;从</strong>”关系</li>
<li>在多路复用网络中，<strong>DR&#x2F;BDR交换LSA</strong>，所有<strong>其他路由器</strong>将<strong>类型2的DBD发送给DR&#x2F;BDR</strong></li>
<li>如果需要，路由器可以通过发送<strong>LSR请求更多信息</strong>进入加载状态<ul>
<li>所有路由器必须在加载状态中等待，直到请求路由器完全更新</li>
</ul>
</li>
<li>路由器现在进入Full状态</li>
</ul>
</li>
</ul>
<h3 id="步骤-4：选择最佳路由"><a href="#步骤-4：选择最佳路由" class="headerlink" title="步骤 4：选择最佳路由"></a>步骤 4：选择最佳路由</h3><ul>
<li>现在网络上的所有路由器并行计算SPF算法。<ul>
<li>记住：<strong>在此之前</strong>，所有路由器必须具有<strong>相同的链路状态数据库</strong>。</li>
<li>SPF使用<strong>Cost作为度量</strong>。</li>
<li>SPF为每条从自身到目的地的路径累加开销，构建以路由器为根的树。</li>
<li>OSPF然后将最小开销路径安装到路由表中。</li>
<li><em>最多可以安装4条等成本路径进行负载共享</em>。</li>
</ul>
</li>
</ul>
<h3 id="步骤-5：维护路由信息"><a href="#步骤-5：维护路由信息" class="headerlink" title="步骤 5：维护路由信息"></a>步骤 5：维护路由信息</h3><ul>
<li>OSPF通过<strong>定期交换Hello数据包</strong>来检测<strong>新邻居或失效邻居</strong>。<ul>
<li><strong>根据网络类型</strong>，Hello数据包在<strong>不同的默认间隔</strong>发送。<ul>
<li>对于速度为T1（1.544 Mbps）或更高的链路，<strong>每10秒发送一次：广播多访问和点对点链路</strong>。</li>
<li>对于低于T1的链路，<strong>每30秒发送一次：非广播多访问链路</strong>。</li>
</ul>
</li>
<li>“失效间隔”是Hello间隔的四倍。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="14-Basic-OSPF-配置Configuration"><a href="#14-Basic-OSPF-配置Configuration" class="headerlink" title="14. Basic OSPF 配置Configuration"></a>14. Basic OSPF 配置Configuration</h2><ol>
<li>在<strong>路由器上启用OSPF</strong><ul>
<li><code>router ospf process-id</code></li>
<li>进程号 <strong>process-id</strong>：<ul>
<li>值范围为1到65535</li>
<li>用于标识路由器上的多个OSPF进程</li>
<li>通常在整个自治系统（AS）中保持相同的进程ID。</li>
</ul>
</li>
</ul>
</li>
<li><strong>标识路由器上的IP网络</strong><ul>
<li><code>network network-id wildcard-mask area area-id</code></li>
<li>network-id：网络地址，可以是整个网络、子网或接口地址。</li>
<li>wildcard-mask：通配符掩码。<ul>
<li>wildcardmask 和 subnet mask 相反</li>
<li>子网掩码是 255.255.255.0，则 Wild-card Address 就是 0.0.0.255</li>
</ul>
</li>
<li>area-id：区域ID，标识网络所属的OSPF区域<ul>
<li>只有一个 Area，则为 area0</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-24.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="15-配置回环地址-Loopback-Address"><a href="#15-配置回环地址-Loopback-Address" class="headerlink" title="15. 配置回环地址 Loopback Address"></a>15. 配置回环地址 Loopback Address</h2><ul>
<li>配置回环地址以增加OSPF路由器ID的稳定性<br>  <code>interface loopback number</code><br>  <code>ip address address subnet-mask</code><ul>
<li>number：回环接口编号。</li>
<li>address：回环接口的IP地址。</li>
<li>subnet-mask：子网掩码，建议使用&#x2F;32掩码以避免潜在的路由问题。</li>
</ul>
</li>
<li>回环接口必须在OSPF进程<strong>启动之前</strong>配置。</li>
<li>建议在基于OSPF的网络中的<strong>所有关键路由器上</strong>使用回环地址（私有或公共地址）。</li>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-25.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="16-更改OSPF路由器的优先级"><a href="#16-更改OSPF路由器的优先级" class="headerlink" title="16. 更改OSPF路由器的优先级"></a>16. 更改OSPF路由器的优先级</h2><ol>
<li><strong>操纵 DR&#x2F;BDR 选举</strong></li>
</ol>
<p><code>ip ospf priority number</code></p>
<ul>
<li>优先级越大越高</li>
<li>值范围：0 ~ 255，默认值为1</li>
<li>优先级为0表示接口不能被选为DR或BDR</li>
</ul>
<ol start="2">
<li><strong>监控OSPF接口优先级</strong></li>
</ol>
<p><code>show ip ospf [interface type number]</code></p>
<h2 id="17-OSPF-开销（Cost）-度量（Metric）"><a href="#17-OSPF-开销（Cost）-度量（Metric）" class="headerlink" title="17. OSPF 开销（Cost）&#x3D; 度量（Metric）"></a>17. OSPF 开销（Cost）&#x3D; 度量（Metric）</h2><ul>
<li><strong>开销应用于所有路由器链路路径</strong></li>
<li><strong>16位数字（1 – 65,535）</strong></li>
<li><strong>开销越低，路径越理想</strong></li>
<li><strong>路由决策基于路径的总开销</strong></li>
<li><strong>开销由带宽派生</strong><ul>
<li>公式：COST &#x3D; 100,000,000 &#x2F; 带宽</li>
<li>例如，T1链路的OSPF开销：100,000,000 &#x2F; 1,544,000 &#x3D; 64</li>
</ul>
</li>
</ul>
<h3 id="1-OSPF路径开销"><a href="#1-OSPF路径开销" class="headerlink" title="1. OSPF路径开销"></a>1. OSPF路径开销</h3><ul>
<li><strong>所有连接到同一链路的接口必须同意该链路的开销</strong>，否则链路将被视为断开。<ul>
<li>Cisco路由器的串行链路默认开销为1784（56Kbps带宽）。</li>
<li>开销范围：1 ~ 65535。</li>
</ul>
</li>
<li>配置OSPF开销</li>
</ul>
<p><code>ip ospf cost number</code></p>
<ul>
<li>如果线路速度较慢，必须指定实际链路速度</li>
</ul>
<p><code>bandwidth number</code></p>
<ul>
<li>在多供应商路由环境中，常见的需要更改开销的情况是确保一个供应商的开销值与另一个供应商的开销值匹配。</li>
<li>另一种情况是使用千兆以太网时。默认开销将最低开销值1分配给100 Mbps链路</li>
</ul>
<h3 id="2-配置OSPF计时器"><a href="#2-配置OSPF计时器" class="headerlink" title="2. 配置OSPF计时器"></a>2. 配置OSPF计时器</h3><ul>
<li><strong>所有OSPF区域内的路由器必须达成相同的Hello间隔和失效间隔</strong>，默认值：<ul>
<li>T1或更高带宽的链路（广播）：<strong>10秒</strong><ul>
<li>广播多访问和点对点链路</li>
</ul>
</li>
<li>低于T1的链路（非广播）：<strong>30秒</strong><ul>
<li>非广播多访问</li>
</ul>
</li>
<li><strong>失效间隔 &#x3D; 4 * Hello间隔</strong></li>
</ul>
</li>
<li>更改间隔的命令：</li>
</ul>
<p><code>ip ospf hello-interval seconds</code><br><code>ip ospf dead-interval seconds</code></p>
<ul>
<li>注意：失效间隔会自动调整为新的Hello间隔的四倍</li>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-26.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>四、OSI第三层：数据链路层</title>
    <url>/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/</url>
    <content><![CDATA[<h1 id="第三层：网络层"><a href="#第三层：网络层" class="headerlink" title="第三层：网络层"></a>第三层：网络层</h1><ul>
<li>Overview of the Network Layer</li>
<li>IP Addresses and Subnets</li>
<li>Layer 3 Devices </li>
<li>ARP Protocol</li>
<li>Network Layer Services</li>
<li>Routed and Routing Protocols</li>
<li>VLSM</li>
<li>ICMP</li>
<li>为什么我们不用硬件地址进行通信?<ol>
<li>(设备数量问题)因为设备比较多，供应商也比较多</li>
<li>(规格问题)不同供应商的解决方案不同，所以使用硬件地址进行通信的通用性比较低。</li>
<li>(寻址问题)全球设备太多，如果使用硬件设备，那么进行定位比较复杂</li>
</ol>
<ul>
<li>因为如上情况我们选择使用IP地址(逻辑地址)。</li>
</ul>
</li>
</ul>
<h1 id="一、网络层概述"><a href="#一、网络层概述" class="headerlink" title="一、网络层概述"></a>一、网络层概述</h1><h2 id="1-第三层职责"><a href="#1-第三层职责" class="headerlink" title="1. 第三层职责"></a>1. 第三层职责</h2><ol>
<li><strong>通过网络移动数据</strong></li>
<li>使用<strong>分层寻址 hierarchical addressing</strong>方案(与MAC寻址相反，后者平坦)<ul>
<li>分层寻址（Hierarchical Addressing）是一种网络地址分配和管理方法，它将地址空间划分为多个层次，每个层次都有不同的作用和范围（网络+子网+主机）。</li>
</ul>
</li>
<li><strong>分段网络</strong>（segment network）和<strong>控制流量</strong>（control flow of traffic）<ul>
<li>根据网络的大小和流量需求，将大型网络分割成多个较小的子网络（子网）。这些子网通常使用子网掩码来划分。</li>
</ul>
</li>
<li><strong>减少交通拥堵</strong>（Reduce congestion）</li>
<li><strong>与其它网络通信</strong></li>
</ol>
<h2 id="2-Devices"><a href="#2-Devices" class="headerlink" title="2. Devices"></a>2. Devices</h2><ul>
<li><strong>Routers</strong>（重点！）<ul>
<li><strong>互连</strong>网段或网络(不同网段的分割)</li>
<li>根据<strong>IP地址</strong>做出合理的<strong>决定</strong></li>
<li>确定<strong>最佳路径</strong>（根据<strong>路由表</strong>）</li>
<li>将<strong>数据包</strong>从入站端口切换到<strong>出站端口</strong></li>
</ul>
</li>
</ul>
<h1 id="二、IP地址和子网划分-IP-Addresses-and-Subnets"><a href="#二、IP地址和子网划分-IP-Addresses-and-Subnets" class="headerlink" title="二、IP地址和子网划分(IP Addresses and Subnets)"></a>二、IP地址和子网划分(IP Addresses and Subnets)</h1><h2 id="1-Layer-3-Packet-Datagram-第三层数据报格式"><a href="#1-Layer-3-Packet-Datagram-第三层数据报格式" class="headerlink" title="1. Layer 3 Packet&#x2F;Datagram 第三层数据报格式"></a>1. Layer 3 Packet&#x2F;Datagram 第三层数据报格式</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-7.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>IP地址在报文中占据一部分(一个IP地址32bit)</li>
</ul>
<h2 id="2-IPv4报文主要结构"><a href="#2-IPv4报文主要结构" class="headerlink" title="2. IPv4报文主要结构"></a>2. IPv4报文主要结构</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><strong>首部部分</strong>：上面蓝框部分的整体<ul>
<li><strong>固定部分+可变部分</strong></li>
</ul>
</li>
<li><strong>版本号</strong>:占 <strong>4 bit</strong>，指IP协议的版本。目前的 IP 协议版本号为 <strong>4</strong> (即 IPv4)(6也就对应IPv6)</li>
<li><strong>首部长度</strong>:占 <strong>4 bit</strong>，可表示的最大数值是15个单位(一个单位为 4 字节)， 因此IP的首部长度的最大值是<strong>60字节（15个单位）</strong>。<ul>
<li>首部长度不确定，所以需要进行标识</li>
<li>4bit-&gt;15个单位；</li>
<li>首部长度的32 bit为一行，也就是4个字节为一个单位</li>
</ul>
</li>
<li><strong>服务类型</strong>:占<strong>8 bit</strong>，用来获得更好的服务，这个字段以前一直没有被人们使用。</li>
<li><strong>总长度</strong>:占 <strong>16 bit</strong>，指<strong>首部和数据之和</strong>的长度，单位为字节，因此数据报的最大长度为 <strong>65535 字节</strong>(由于放到帧里面，所以大多数不比1500字节长)。总长度必须不超过最大传送单元 MTU。</li>
<li><strong>标识</strong>(identification):占 <strong>16 bit</strong>，它是一个计数器，用来产生数据报的标识。</li>
<li><strong>标志</strong>：占 <strong>3 bit</strong>，最高位为 0;<ul>
<li>MF（More fragement）：MF 为 0 表示最后一个分片；1 是指后面还有分片</li>
<li>DF（Don’t fragement）：是否允许做分片，0 允许做分片，1 不允许做分片</li>
</ul>
</li>
<li><strong>片偏移</strong> (<strong>13 bit</strong>) 指出：较长的分组在分片后某片<em>在原分组中的相对位置</em>。<ul>
<li>片偏移以<strong>8个字节</strong>为<strong>偏移单位</strong><ul>
<li>分片：由于网络中传输的数据报可能会超过某些网络的最大传输单元（MTU），因此需要将较大的数据报分成多个较小的片段进行传输。</li>
<li>片偏移字段帮助接收方正确地<em>重组</em>这些片段。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>报文分片举例<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-8.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-9.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<ol start="9">
<li><strong>生存时间</strong>：<strong>8 bit</strong>，记为 TTL (Time To Live)，表示<strong>数据报在网络中可通过的路由器数的最大值</strong>。<ul>
<li>是通过计数的方式来进行统计</li>
<li>最大值是255(最多经过255个路由器)</li>
<li>路由器每转发一次，就会对生存时间-1</li>
<li>减小为0后，就会丢弃掉，并且通知给发送方我已经丢弃掉这个报文。</li>
<li>防止在环上进行传输，避免由于回路问题，造成过大的网络资源浪费</li>
</ul>
</li>
<li><strong>协议</strong>：<strong>8 bit</strong>，协议字段指出此数据报<em>携带的数据使用何种协议</em> ，以便目的主机的IP层将数据部分上交给哪个处理过程<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-1.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li><strong>首部检验和</strong>:<strong>(16 bit)<strong>只检验数据报的</strong>首部</strong>，不包括数据部分。<ul>
<li>这里不采用 CRC 检验码而采用简单的计算方法。算法过程如下(比较形式化的问题，并不能解决数据报错误的形式)<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-2.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li><strong>源地址和目的地址</strong>都各占 4 字节（32 bit）</li>
</ol>
<h2 id="3-网络层地址-Network-Layer-Addresses"><a href="#3-网络层地址-Network-Layer-Addresses" class="headerlink" title="3. 网络层地址 Network Layer Addresses"></a>3. 网络层地址 Network Layer Addresses</h2><ol>
<li><strong>IP地址</strong>为<strong>32位长</strong>（32 bits long）</li>
<li>它们以<em>点分十进制格式</em>表示为<strong>四个(八位)字节</strong>：133.14.17.0<ul>
<li>点分十进制：用十进制表示每个字节的值，然后用点（.）分隔这些字节</li>
</ul>
</li>
<li>IP地址包含两个组成部分：<ul>
<li><strong>网络ID(The network ID)</strong><ul>
<li>由ARIN（American Registry for Internet Numbers，<a href="http://www.arin.net)分配/">www.arin.net）分配</a></li>
<li>标识设备所连接(attached)的网络</li>
<li>可以由前三个八位位组(octets)中的一个，两个或三个来标识</li>
</ul>
</li>
<li><strong>主机ID(The host ID)</strong><ul>
<li>由网络管理员分配</li>
<li>识别该网络上的特定设备</li>
<li>可以由最后三个八位位组中的一个，两个或三个来标识</li>
</ul>
</li>
<li><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-3.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ol>
<h2 id="4-IP地址"><a href="#4-IP地址" class="headerlink" title="4. IP地址"></a>4. IP地址</h2><ol>
<li>不同的类地址为地址的网络部分和主机部分保留不同数量的位<ul>
<li>N是Net ID,H 是 Host ID</li>
</ul>
<ol>
<li>A: NHHH</li>
<li>B: NNHH</li>
<li>C: NNNH<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-4.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
</li>
</ol>
<h3 id="4-1-分类"><a href="#4-1-分类" class="headerlink" title="4.1 分类"></a>4.1 分类</h3><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-10.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>IP 地址主要通过<strong>第一个字节</strong>进行划分</li>
</ul>
<ol>
<li><strong>0–127</strong> （0xxxxxxx）：Class A address</li>
<li><strong>128-191</strong> （10xxxxxx）：Class B address</li>
<li><strong>192–223</strong> （110xxxxx）：Class C address</li>
<li>224–239 （1110xxxx）：Class D – Multicast 多播地址</li>
<li>240–255 （1111xxxx）：Class E - Research 研究地址</li>
</ol>
<ul>
<li><strong>host 不能全取 0，也不能全取 1</strong>。<ul>
<li>全取 0 时用来标识网段地址</li>
<li>全取 1 时用来标识网段的广播地址</li>
</ul>
</li>
</ul>
<h3 id="4-2-主机-Hosts-的数量"><a href="#4-2-主机-Hosts-的数量" class="headerlink" title="4.2 主机(Hosts)的数量"></a>4.2 主机(Hosts)的数量</h3><ul>
<li>每个类别的最大主机数量各不相同。（不包含网络号）</li>
</ul>
<ol>
<li>A 类拥有 16,777,214 个可用主机（<strong>2^24 - 2</strong>）</li>
<li>B 类具有 65,534 个可用主机（<strong>2^16 - 2</strong>）</li>
<li>C 类具有 254 个可用主机（<strong>2^8 -2</strong>）</li>
</ol>
<ul>
<li>为什么每一类地址中都要减去 2？<ul>
<li>每个网络中的<strong>第一个地址</strong>都保留用于<strong>该网络地址</strong>（全取1）<ul>
<li><strong>最后是.0</strong></li>
</ul>
</li>
<li><strong>最后一个地址</strong>是为<strong>广播地址</strong>保留的（全取1）。<ul>
<li><strong>最后是.255</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-3-保留-Reserved-地址"><a href="#4-3-保留-Reserved-地址" class="headerlink" title="4.3 保留(Reserved)地址"></a>4.3 保留(Reserved)地址</h3><ol>
<li><strong>网络地址</strong>：在地址的<strong>主机部分</strong>中<strong>以二进制 0 结尾</strong>的 IP 地址<ul>
<li>A 类网络地址示例：113.0.0.0</li>
<li>网络上的主机只有具有相同网络 ID 的其他主机才能直接通信。（用来确定是不是在一个网段里面）</li>
</ul>
</li>
<li><strong>广播地址</strong>：用于将数据发送到网络上的所有设备。（一般是一个网段之间的）<ul>
<li>广播 IP 地址在地址的<strong>主机部分</strong>中<strong>以二进制 1 结尾</strong>。</li>
<li>B 类地址的广播地址的示例：176.10.255.255（decimal 255 &#x3D; binary 11111111）</li>
</ul>
</li>
</ol>
<ul>
<li>类别示例</li>
</ul>
<ol>
<li>Class A<ul>
<li>99.0.0.0： a reserved network number</li>
<li>99.255.255.255： a broadcast number</li>
</ul>
</li>
<li>Class B<ul>
<li>156.1.0.0： a reserved network number</li>
<li>156.1.255.255： a broadcast number</li>
</ul>
</li>
<li>Class C<ul>
<li>203.1.17.0： a reserved network number</li>
<li>203.1.17.255：a broadcast number</li>
</ul>
</li>
</ol>
<h4 id="私有地址空间-Private-Address-Space"><a href="#私有地址空间-Private-Address-Space" class="headerlink" title="私有地址空间 Private Address Space"></a>私有地址空间 Private Address Space</h4><ul>
<li>私有IP地址是指在<strong>内部网络中使用的IP地址</strong>，这些地址在互联网中是不可路由的。</li>
<li>私有IP地址用于<strong>局域网（LAN）中的设备之间的通信</strong>，<strong>避免了公共IP地址的浪费</strong>。</li>
<li>私有IP地址与公网IP地址的区别：<ul>
<li>公网IP地址是<strong>唯一的、全球可访问</strong>的IP地址，用于设备之间的互联互通。</li>
<li>私有IP地址是<strong>保留给内网使用的</strong>，不会在互联网中传递，因此它们在全球范围内<strong>不唯一</strong>。多个不同的私有网络可以使用相同的私有IP地址范围。</li>
</ul>
</li>
<li>私有IP地址范围由IANA（互联网号码分配机构）定义，常见的私有IP地址范围包括：</li>
</ul>
<ol>
<li><strong>10.0.0.0 - 10.255.255.255</strong></li>
<li><strong>172.16.0.0 - 172.31.255.255</strong></li>
<li><strong>192.168.0.0 - 192.168.255.255</strong></li>
</ol>
<ul>
<li>**IP地址耗尽（IP address depletion）**及其解决方案：<ul>
<li>NAT（网络地址转换）<ul>
<li>通过在路由器或防火墙上将私有网络的IP地址转换为公网IP地址，使得多个内网设备可以共享一个公网IP地址访问互联网。</li>
</ul>
</li>
<li>CIDR（无类别域间路由）<ul>
<li>一种更灵活的IP地址分配方法，它突破了传统的类A、类B、类C的限制，通过可变子网掩码（VLSM）来实现更精细的IP地址划分，从而提高IP地址的利用率，延缓了IPv4地址的枯竭。</li>
</ul>
</li>
<li>IPv6<ul>
<li>是IPv4的继任者，采用128位的地址格式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-Subnet-子网"><a href="#5-Subnet-子网" class="headerlink" title="5. Subnet(子网)"></a>5. Subnet(子网)</h2><ul>
<li>网络管理员有时需要<strong>将网络划分为较小的网络</strong>，称为<strong>子网 subnet</strong>，以提供额外的灵活性.</li>
<li>从主机字段借来的位被指定为<strong>子网字段（Subnet Fields）</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">借的是Host字段从左往右开始数的位数！！</span><br><span class="line">Netwoek|Subnet|Host</span><br></pre></td></tr></table></figure>
<p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-11.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="5-1-Basics-of-Subnetting"><a href="#5-1-Basics-of-Subnetting" class="headerlink" title="5.1.Basics of Subnetting"></a>5.1.Basics of Subnetting</h3><ul>
<li>子网是网络的更小划分，提供<strong>地址灵活性</strong>。</li>
<li>子网地址是<strong>本地分配</strong>的，通常由网络管理员分配。</li>
<li>子网<strong>减少了广播域</strong>。</li>
</ul>
<h3 id="5-2-How-many-bits-can-I-borrow-可以借多少位给子网"><a href="#5-2-How-many-bits-can-I-borrow-可以借多少位给子网" class="headerlink" title="5.2.How many bits can I borrow(可以借多少位给子网)"></a>5.2.How many bits can I borrow(可以借多少位给子网)</h3><ul>
<li>可以借用的<strong>最小位数</strong>是<strong>2</strong>。<ul>
<li>如果只借用 1 位以创建一个子网，那么将只有一个<strong>网络号</strong>&lt;.0 网络&gt;和<strong>广播号</strong>&lt;.1 网络&gt;，没有可以使用的专用网络。</li>
<li>两位的时候，01 和 10 给 Host，00 表示网络 ID，11 表示广播地址</li>
<li>全 0 可能导致误判</li>
</ul>
</li>
<li>最大位数:<strong>保留至少2位主机号</strong>的<strong>任何</strong>数字<ul>
<li>原因也同上<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-5.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
<h3 id="5-3-子网划分的副产品：地址浪费Waste-Addresses"><a href="#5-3-子网划分的副产品：地址浪费Waste-Addresses" class="headerlink" title="5.3.子网划分的副产品：地址浪费Waste Addresses"></a>5.3.子网划分的副产品：地址浪费Waste Addresses</h3><ul>
<li>我们必须在<strong>所需的子网数</strong>，<strong>每个子网可接受的主机</strong>以及<strong>地址的浪费</strong>之间取得平衡（strike a balance）。</li>
<li>hostID 里面的全 0 和全 1 不能使用</li>
<li>subnet 不可以使用全 0 和全 1</li>
<li>借用 4 位是最高效率的，提升了划分灵活性，影响了效率</li>
<li>C类例图<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-6.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<ol>
<li><strong>（C类）</strong> 借用n位，则有了<strong>2^n-2个子网</strong>，每个子网可以有<strong>2^(8-n)-2台主机</strong>(host)<ul>
<li><strong>主机总数量&#x3D;子网数×每个子网的主机数</strong></li>
<li><strong>使用率&#x3D;主机总数量&#x2F;255</strong></li>
</ul>
</li>
</ol>
<h3 id="5-4-Subnet-Mask子网掩码"><a href="#5-4-Subnet-Mask子网掩码" class="headerlink" title="5.4 Subnet Mask子网掩码"></a>5.4 Subnet Mask子网掩码</h3><ul>
<li>把<strong>网络位全赋值为 1</strong>，<strong>host 位全部赋值为 0</strong>，这样我们就明白哪些位上面是 net，哪些位上面是 host</li>
</ul>
<ol>
<li>别名：扩展网络前缀</li>
<li>定义我们用来<strong>构建网络</strong>的位数，以及<strong>描述主机地址</strong>的位数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- Class A 255.0.0.0</span><br><span class="line">- Class B 255.255.0.0</span><br><span class="line">- Class C 255.255.255.0</span><br></pre></td></tr></table></figure>
<h2 id="6-计算子网"><a href="#6-计算子网" class="headerlink" title="6. 计算子网"></a>6. 计算子网</h2><p>例子: </p>
<ul>
<li>我们将对IP地址进行子网划分：<ul>
<li>223.14.17.0</li>
</ul>
</li>
<li>需要：13个子网，每个子网10台主机</li>
</ul>
<h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><ol>
<li>确定默认的子网掩码<ul>
<li>C类：192~223，所以此IP地址在C类</li>
</ul>
</li>
<li>C 类网络的默认子网掩码是：255.255.255.0</li>
</ol>
<h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><ol>
<li>通过从主机 ID 借用位来计算子网和主机的实际数量<ul>
<li>13 subnets</li>
<li>10 hosts on each subnet</li>
</ul>
<ol>
<li>2^4-2&#x3D;14，由此：子网借4位</li>
<li>每个子网10个主机, 也是至少需要4位(2^4 - 2 &#x3D;14), 主机位数为4位</li>
</ol>
</li>
<li>我们对每一个子网需要<strong>借用 4 位</strong>来满足一个子网有 <strong>10 台可用的主机</strong>。</li>
</ol>
<h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h3><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-12.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>产生16个子网和每个子网16台主机<ul>
<li>对于借用的 4 位，每个位可以是 1 或 0，从而有 16 种可能的组合。</li>
<li>4 个剩余主机位也是如此。</li>
</ul>
</li>
<li>【重要】<strong>每个子网上只有14个可用子网和14台主机</strong><ol>
<li>因为不能使用<strong>第一个和最后一个子网</strong>。（即全 0 和全 1）</li>
<li>因为不能使用<strong>每个子网中的第一个和最后一个地址</strong>。</li>
</ol>
<ul>
<li>对于每个，一个是广播地址，一个是网络地址。</li>
</ul>
</li>
</ol>
<h3 id="Step-4"><a href="#Step-4" class="headerlink" title="Step 4"></a>Step 4</h3><ol>
<li>确定子网掩码。<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-13.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>其中<strong>X表示用于子网划分的借用位</strong>。</li>
</ol>
<ul>
<li>将<strong>X的位值相加</strong>，得到子网掩码的最后一个八位字节的十进制值：128 + 64 + 32 + 16 &#x3D; 240<ul>
<li>也等于255-15</li>
</ul>
</li>
<li>子网掩码是：<strong>255.255.255.240</strong></li>
<li>子网掩码用于<strong>显示IP地址中的子网和主机地址字段</strong></li>
</ul>
<h3 id="Step-5"><a href="#Step-5" class="headerlink" title="Step 5"></a>Step 5</h3><ol>
<li>确定主机地址的范围<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-14.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-15.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>16个子网，14个可用子网</li>
<li>每个子网16个主机，14个可用主机</li>
</ol>
<h2 id="7-计算子网网络地址"><a href="#7-计算子网网络地址" class="headerlink" title="7. 计算子网网络地址"></a>7. 计算子网网络地址</h2><ol>
<li>第一步：将 <strong>IP 主机地址</strong>转换为<strong>二进制</strong>。</li>
<li>第二步：将<strong>子网掩码</strong>转换为<strong>二进制</strong>。</li>
<li>第三步：使用<strong>布尔运算符 AND</strong> 将两者进行运算。</li>
<li>第四步：将网络二进制地址<strong>转换为点分十进制</strong>。<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-16.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<ul>
<li>这是<em>子网的<strong>网络地址</strong></em></li>
<li>它可以帮助确定路径（即<strong>发送到哪一个具体的子网（网段）</strong>）：用来确定是否是一个网段，是否可以通过网关进行转发</li>
</ul>
<h3 id="7-1-路由器与IP地址"><a href="#7-1-路由器与IP地址" class="headerlink" title="7.1 路由器与IP地址"></a>7.1 路由器与IP地址</h3><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-17.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>为了找到子网的网络 ID，路由器必须采用 <strong>IP 地址</strong>和<strong>子网掩码</strong>，并且在逻辑上将它们取<strong>与</strong></li>
<li>131开头，说明是B类</li>
<li>上图中的子网掩码 255.255.255.0 是 255.255.0.0 借用了 8 位产生的（而不要理解成为 C 类地址的子网掩码）</li>
</ul>
<h3 id="实践：IP寻址问题"><a href="#实践：IP寻址问题" class="headerlink" title="实践：IP寻址问题"></a>实践：IP寻址问题</h3><ul>
<li>给定195.137.92.0并且需要8个可用子网，请找到子网号，主机号范围和子网广播号。</li>
<li>借用2位会产生2个可用子网，借用3位会产生6个可用子网，因此我们<strong>借用4位</strong>才能获得14个可用子网，其中我们需要8个可用地址。</li>
<li>这将使子网掩码为255.255.255.240。 因此，网络号为195.137.92.NNNN HHHH，其中Ns代表网络扩展位(子网)，Hs代表主机号。</li>
<li>接下来，我们必须为子网编号。 4位二进制数有16种组合，但它们在最后一个八位位组中保留其位置值。</li>
<li>借用<strong>4-6位都可以</strong>，因为<strong>并没有规定子网中主机数量</strong>。<ul>
<li><strong>为什么是6位</strong>是因为<strong>一个子网中最少用2位给主机</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="三、第三层设备"><a href="#三、第三层设备" class="headerlink" title="三、第三层设备"></a>三、第三层设备</h1><ul>
<li><strong>路由器</strong></li>
<li>路由器2个功能：<ol>
<li><strong>路径选择</strong></li>
<li><strong>路径转发</strong></li>
</ol>
</li>
</ul>
<h2 id="1-路径选择-Path-determination"><a href="#1-路径选择-Path-determination" class="headerlink" title="1. 路径选择 Path determination"></a>1. 路径选择 Path determination</h2><ul>
<li>路由器根据链路带宽、跳数、延迟等因素，选择数据包到达目的地路径中的下一跳。<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-18.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="2-IP-地址"><a href="#2-IP-地址" class="headerlink" title="2. IP 地址"></a>2. IP 地址</h2><ul>
<li>IP地址在软件中实现，指的是<strong>设备所在的网络</strong>。<ul>
<li>IP地址是网络中每个设备的<em>唯一标识符</em>。每个设备（例如电脑、手机、服务器等）在连接到网络时都会被分配一个IP地址。</li>
<li>IP地址通过软件协议来进行分配、识别和管理，而非硬件本身决定的。</li>
</ul>
</li>
<li>路由器连接网络，每个网络必须<strong>有一个唯一的网络号</strong>，以确保路由成功。<ul>
<li>路由器根据<em>IP地址</em>和<em>子网掩码</em>来判断数据包应该发送到哪个网络。</li>
</ul>
</li>
<li><strong>唯一的网络号</strong>被包含在分配给<strong>连接到该网络的每个设备的IP地址</strong>中。<ul>
<li>假设一个设备的IP地址是 192.168.1.5，并且子网掩码是 &#x2F;24，这表示：<ul>
<li>网络号是 192.168.1.0</li>
<li>主机号是 5</li>
</ul>
</li>
<li><strong>所有属于同一网络的设备的IP地址都会共享相同的网络号</strong></li>
</ul>
</li>
</ul>
<h2 id="3-路由器端口-Router-Interface"><a href="#3-路由器端口-Router-Interface" class="headerlink" title="3. 路由器端口 Router Interface"></a>3. 路由器端口 Router Interface</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-19.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>路由器端口记录了<strong>网段的 IP 地址</strong>（和连接的地方是相同的）</li>
<li>在计算<strong>需要分配的端口总数</strong>时，注意<strong>路由器端口也需要被计算上</strong></li>
</ol>
<h2 id="4-路由器发送的过程-Router-function"><a href="#4-路由器发送的过程-Router-function" class="headerlink" title="4. 路由器发送的过程 Router function"></a>4. 路由器发送的过程 Router function</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-20.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>A5 主机发送报文给 B5 主机，这个报文的 IP 地址是 B5 所在的 IP 地址，形成帧，然后放上总线。</li>
</ol>
<ul>
<li>路由器剥离由帧携带的<strong>数据链路层头部</strong>。<ul>
<li>（数据链路层头部包含<strong>源和目的地的MAC地址</strong>。）<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-21.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
<ol start="2">
<li>路由器收到帧，然后进行理解，看到报文，知道目的地是B5(解封装)</li>
</ol>
<ul>
<li><strong>检查网络层地址以确定目的网络</strong>。<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-22.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<ol start="3">
<li>检查自己的<strong>路由表</strong>，找到目的地对应的<strong>端口</strong></li>
</ol>
<ul>
<li>查询其<strong>路由表</strong>以确定将使用哪个<strong>接口</strong>发送数据，以便到达目的网络。<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-23.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<ol start="4">
<li>在B1端口进行转发，形成新的帧</li>
</ol>
<ul>
<li>通过接口B1发送数据，路由器会<em>将数据封装在适当的数据链路层帧</em>中。<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-24.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<ol start="5">
<li>形成一个全新的帧，<strong>这个帧的MAC地址是B1的MAC的地址</strong>。</li>
</ol>
<h2 id="5-路由器端口示例"><a href="#5-路由器端口示例" class="headerlink" title="5. 路由器端口示例"></a>5. 路由器端口示例</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-25.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>接口是路由器连接到网络的方式，在IP路由中也可以称为<strong>端口</strong>。</li>
<li><strong>每个接口</strong>必须有一个<strong>单独的、唯一的网络地址</strong>。<ul>
<li>比如上图中 S1 和 S2 不能是相同的 IP 地址</li>
<li>路由器的连接的网段一定要是不同的</li>
</ul>
</li>
</ol>
<h2 id="6-IP地址分配-IP-address-assignment"><a href="#6-IP地址分配-IP-address-assignment" class="headerlink" title="6. IP地址分配 IP address assignment"></a>6. IP地址分配 IP address assignment</h2><ol>
<li><strong>静态地址分配（Static addressing）</strong></li>
</ol>
<ul>
<li>为每个设备配置一个IP地址。</li>
<li>你应该保持非常详细的记录，因为使用重复的IP地址可能会导致问题。</li>
</ul>
<ol start="2">
<li><strong>动态地址分配（Dynamic addressing）</strong></li>
</ol>
<ul>
<li>有几种不同的方法可以用来动态分配IP地址：<ul>
<li>RARP: 反向地址解析协议（Reverse Address Resolution Protocol）</li>
<li>BOOTP: 引导协议（BOOTstrap Protocol）</li>
<li>DHCP: 动态主机配置协议（Dynamic Host Configuration Protocol）</li>
</ul>
</li>
</ul>
<hr>
<h1 id="四、ARP-Protocol"><a href="#四、ARP-Protocol" class="headerlink" title="四、ARP Protocol"></a>四、ARP Protocol</h1><h2 id="1-Address-Resolution-Protocol（ARP）地址解析协议"><a href="#1-Address-Resolution-Protocol（ARP）地址解析协议" class="headerlink" title="1. Address Resolution Protocol（ARP）地址解析协议"></a>1. Address Resolution Protocol（ARP）地址解析协议</h2><ol>
<li>为了使设备能够通信，<strong>发送设备</strong>需要<strong>目标设备</strong>的<strong>IP地址和MAC地址</strong>。</li>
</ol>
<ul>
<li>ARP使计算机能够找到<strong>与IP地址关联的计算机的MAC地址</strong>。</li>
</ul>
<h2 id="2-ARP示例"><a href="#2-ARP示例" class="headerlink" title="2. ARP示例"></a>2. ARP示例</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-26.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>source主机访问destination</li>
<li>不知道目的主机在哪里</li>
</ol>
<h2 id="3-ARP表的缓存"><a href="#3-ARP表的缓存" class="headerlink" title="3. ARP表的缓存"></a>3. ARP表的缓存</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-27.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>可以通过lookup命令进行。</li>
<li>在RAM里面，如果ARP没有本条目的对应MAC地址。</li>
<li>MAC地址在ARP中是有时效性的。到时间不更新不激活就会删除</li>
</ol>
<h2 id="4-ARP-操作"><a href="#4-ARP-操作" class="headerlink" title="4. ARP 操作"></a>4. ARP 操作</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-28.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>使用ARP机制</li>
<li>上图中是一个示意图</li>
<li>此时ARP table中<strong>没有缓存</strong></li>
<li>图的一个问题:目的MAC地址应该在前面，源MAC地址在后面</li>
</ol>
<ul>
<li>步骤如下</li>
</ul>
<h3 id="4-1-ARP-request"><a href="#4-1-ARP-request" class="headerlink" title="4.1 ARP request"></a>4.1 ARP request</h3><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-29.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><strong>向目的方请求MAC地址</strong><br>2。 命令如图：<strong>广播询问</strong>找谁是这个主机，你的MAC地址是啥</li>
<li><strong>将MAC地址设置为全1，作为广播发送</strong></li>
</ol>
<h3 id="4-2-Checking"><a href="#4-2-Checking" class="headerlink" title="4.2 Checking"></a>4.2 Checking</h3><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-30.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>10.0.2.5发现不是自己的主机，那么解析到这里<strong>丢掉</strong>就行，同样会记录下来对应的发送方的MAC地址。(攻击原理)</li>
<li>10.0.2.9<strong>发现自己的MAC地址</strong>，然后形成<strong>ARP应答</strong></li>
<li>同时10.0.2.9会同时记录下A主机的MAC地址，更新到自己ARP地址中去(会记录对方的)</li>
</ol>
<h3 id="4-3-ARP-reply"><a href="#4-3-ARP-reply" class="headerlink" title="4.3 ARP reply"></a>4.3 ARP reply</h3><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-31.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>向A主机进行MAC地址应答</li>
</ol>
<h3 id="4-4-Caching"><a href="#4-4-Caching" class="headerlink" title="4.4 Caching"></a>4.4 Caching</h3><ol>
<li>A的主机将刚刚得到的目标主机的<strong>MAC地址和IP地址的映射关系</strong>存储到ARP Table中</li>
<li>然后再次形成一个数据帧发送出去即可。</li>
</ol>
<h3 id="总结-ARP协议工作原理"><a href="#总结-ARP协议工作原理" class="headerlink" title="总结 ARP协议工作原理:"></a>总结 ARP协议工作原理:</h3><ol>
<li>ARP请求:<ol>
<li>数据链路层中目标地址(MAC地址)未知, 网络层中目标地址(IP地址)已知, 广播询问IP地址为目标地址(IP地址)的主机</li>
<li>你的MAC地址是多少</li>
</ol>
</li>
<li>ARP检查<ol>
<li>目标主机发现, 这个IP地址就是自己</li>
</ol>
</li>
<li>ARP回复<ol>
<li>目标主机将自己的MAC地址回复给源主机</li>
</ol>
</li>
<li>ARP缓存<ol>
<li>将刚刚得到的目标主机的MAC地址和IP地址的映射关系存储到ARP表中</li>
</ol>
</li>
</ol>
<h2 id="5-ARP-Destination-local-目的地址为本地"><a href="#5-ARP-Destination-local-目的地址为本地" class="headerlink" title="5. ARP: Destination local 目的地址为本地"></a>5. ARP: Destination local 目的地址为本地</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-32.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>当目标设备在<strong>本地网络</strong>中时，ARP协议用于解析目标设备的MAC地址。</li>
<li><strong>发送设备</strong>会<strong>广播ARP请求</strong>，询问<em>目标IP地址</em> 对应的<em>MAC地址</em>。</li>
<li><strong>目标设备</strong>收到ARP请求后，会<strong>回复其MAC地址</strong>。</li>
<li>发送设备将目标设备的IP地址和MAC地址映射关系<strong>存储在ARP缓存</strong>中，以便后续通信使用。</li>
</ul>
<h2 id="6-ARP-Internetwork-Communication-网络交流"><a href="#6-ARP-Internetwork-Communication-网络交流" class="headerlink" title="6. ARP: Internetwork Communication 网络交流"></a>6. ARP: Internetwork Communication 网络交流</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-33.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>如何与<strong>不在同一物理网段上的设备</strong>通信？如下是两种解决方案。<ul>
<li>Default gateway <strong>默认网关</strong></li>
<li>Proxy ARP <strong>代理ARP</strong></li>
</ul>
</li>
</ol>
<h3 id="6-1-默认网关-Default-gateway"><a href="#6-1-默认网关-Default-gateway" class="headerlink" title="6.1 默认网关 Default gateway:"></a>6.1 默认网关 Default gateway:</h3><ul>
<li>为了使设备能够与<strong>另一个网络上</strong>的设备通信，必须为其提供一个<strong>默认网关</strong>。</li>
<li>默认网关是<strong>路由器上连接到源主机所在网络段</strong>的<strong>接口的IP地址</strong>。</li>
<li>为了使设备将数据发送到另一个网络段上的设备地址，<strong>源设备将数据发送到默认网关</strong>。</li>
</ul>
<h3 id="6-2-Proxy-ARP-代理ARP："><a href="#6-2-Proxy-ARP-代理ARP：" class="headerlink" title="6.2 Proxy ARP 代理ARP："></a>6.2 Proxy ARP 代理ARP：</h3><ul>
<li>代理ARP代理ARP是ARP的一种变体。</li>
<li>在源主机没有配置默认网关的情况下，代理ARP可以发挥作用。<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-34.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>发送ARP请求，然后路由器给你一个ARP的reply，告诉你MAC地址(一般为本端口的IP地址)</li>
</ul>
<ol>
<li><strong>源主机发送ARP请求</strong>：<ul>
<li>当源主机没有配置默认网关时，它会发送ARP请求，询问目标IP地址的MAC地址。</li>
</ul>
</li>
<li><strong>路由器响应ARP请求</strong>：<ul>
<li>路由器配置了代理ARP功能，会拦截并响应这个ARP请求。</li>
<li><strong>路由器会回复其自己的MAC地址</strong>，作为目标IP地址的MAC地址。</li>
</ul>
</li>
<li><strong>源主机发送数据</strong>：<ul>
<li>源主机接收到路由器的ARP回复后，会将数据发送到路由器的MAC地址。</li>
</ul>
</li>
<li><strong>路由器转发数据</strong>：<ul>
<li>路由器接收到数据后，会根据其路由表将数据<strong>转发</strong>到目标网络上的实际目标设备。</li>
</ul>
</li>
</ol>
<h2 id="7-ARP-Destination-not-local"><a href="#7-ARP-Destination-not-local" class="headerlink" title="7. ARP: Destination not local"></a>7. ARP: Destination not local</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-35.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>路由器会把<strong>Router MAC</strong>的地址给你(连接本网段的MAC地址)</li>
</ul>
<h2 id="8-ARP-Flowchart-ARP流程图"><a href="#8-ARP-Flowchart-ARP流程图" class="headerlink" title="8. ARP Flowchart ARP流程图"></a>8. ARP Flowchart ARP流程图</h2><h2 id><a href="#" class="headerlink" title></a><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-36.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></h2><h1 id="五、网络层服务"><a href="#五、网络层服务" class="headerlink" title="五、网络层服务"></a>五、网络层服务</h1><h2 id="1-面向连接的网络服务-Connection-oriented"><a href="#1-面向连接的网络服务-Connection-oriented" class="headerlink" title="1. 面向连接的网络服务 Connection-oriented"></a>1. 面向连接的网络服务 Connection-oriented</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-37.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>在数据传输之前先建立连接</li>
</ul>
<h2 id="1-1-电路交换-Circuit-switched"><a href="#1-1-电路交换-Circuit-switched" class="headerlink" title="1.1 电路交换 Circuit-switched"></a>1.1 电路交换 Circuit-switched</h2><ol>
<li>面向连接vs电路交换<ul>
<li>这两个术语并不相同</li>
</ul>
</li>
</ol>
<ul>
<li>面向连接：首先与接收方建立连接，然后开始数据传输。</li>
<li>电路交换：所有数据包依次通过相同的通道传输，或者更常见的是，通过<strong>相同的虚拟电路</strong>传输。</li>
</ul>
<h2 id="2-无连接的网络服务-Connectionless"><a href="#2-无连接的网络服务-Connectionless" class="headerlink" title="2. 无连接的网络服务 Connectionless"></a>2. 无连接的网络服务 Connectionless</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-38.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>他们<strong>分别separately</strong>对待每个数据包。</li>
<li><strong>IP 是无连接系统</strong>。 IP 就是提供无连接的网络服务</li>
</ol>
<ul>
<li>不要求发送方和接收方在发送前先建立一个连接(不打招呼)。</li>
</ul>
<h2 id="2-1-数据包交换-Packet-switched"><a href="#2-1-数据包交换-Packet-switched" class="headerlink" title="2.1 数据包交换 Packet switched"></a>2.1 数据包交换 Packet switched</h2><ol>
<li>无连接网络vs数据包交换<ul>
<li>这两个术语并不相同</li>
</ul>
</li>
<li>当数据包从源传输到目的地时，它们可以：<ul>
<li><strong>切换</strong>到不同的<strong>路径</strong>。</li>
<li>到达<strong>顺序可能不同</strong>。</li>
</ul>
</li>
<li>设备会<strong>根据多种标准</strong>为每个数据包<strong>确定传输路径</strong>。某些标准可能会因数据包而异。</li>
</ol>
<hr>
<h1 id="六、Routed-and-Routing-protocol-路由和路由协议"><a href="#六、Routed-and-Routing-protocol-路由和路由协议" class="headerlink" title="六、Routed and Routing protocol 路由和路由协议"></a>六、Routed and Routing protocol 路由和路由协议</h1><ul>
<li>网络协议操作<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-39.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="1-Routed-protocol-被动可路由协议"><a href="#1-Routed-protocol-被动可路由协议" class="headerlink" title="1. Routed protocol 被动可路由协议"></a>1. Routed protocol 被动可路由协议</h2><ol>
<li>为网络层提供支持的协议称为<strong>路由协议</strong>或<strong>可路由协议</strong>。</li>
<li>IP 是网络层协议，因此，它可以通过互联网进行路由。</li>
</ol>
<h2 id="2-Non-routable-protocol-不可路由协议"><a href="#2-Non-routable-protocol-不可路由协议" class="headerlink" title="2. Non-routable protocol 不可路由协议"></a>2. Non-routable protocol 不可路由协议</h2><ol>
<li>不支持第三层</li>
<li>这些不可路由协议中最常见的是 NetBEUI。</li>
<li>NetBEUI 是一种小型，快速且高效的协议，仅限于在一个网段上运行。</li>
</ol>
<h2 id="3-被动可路由协议的寻址-Addressing-of-a-routable-protocol"><a href="#3-被动可路由协议的寻址-Addressing-of-a-routable-protocol" class="headerlink" title="3. 被动可路由协议的寻址 Addressing of a routable protocol"></a>3. 被动可路由协议的寻址 Addressing of a routable protocol</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-40.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-41.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>路由器连接三个网段(列出来的是网络号)</li>
</ul>
<ol>
<li>目的主机131.108.2.2</li>
<li>将目的主机和掩码进行逻辑AND操作，得到对应的网段，为131.108.2.0</li>
<li>请求路由表可以发现，E2端口为目的网段</li>
<li>再次将报文封装，转发给对应的主机</li>
<li>路由表是存储在内存中的</li>
</ol>
<h2 id="4-路由协议分类1：Static-and-Dynamic-静态和动态"><a href="#4-路由协议分类1：Static-and-Dynamic-静态和动态" class="headerlink" title="4. 路由协议分类1：Static and Dynamic 静态和动态"></a>4. 路由协议分类1：Static and Dynamic 静态和动态</h2><ol>
<li>静态路由 Static routes：<ul>
<li><strong>网络管理员</strong>在路由器中<strong>手动输入</strong>路由信息。</li>
</ul>
</li>
<li>动态路由 Dynamic routes：<ul>
<li>路由器可以在运行过程中互相学习信息。</li>
<li>使用**路由协议 (routing protocol)**更新路由信息。</li>
<li>RIP, IGRP, EIGRP, OSPF …</li>
<li>人工维护的代价比较大</li>
</ul>
</li>
</ol>
<ul>
<li>区别：</li>
</ul>
<ol>
<li>静态路由<ul>
<li>用于隐藏部分网络。安全(不必进行路由表的交换)</li>
<li>测试网络中的特定链接。</li>
<li>用于在只有一条路径到目标网络时维护路由表。</li>
</ul>
</li>
<li>动态路由<ul>
<li>维护路由表。</li>
<li>以路由更新的形式及时分发信息。</li>
<li>依靠路由协议共享知识。</li>
<li>路由器可以调整以适应不断变化的网络状况。</li>
<li>打开后会启动进程，按照不同的协议，和网上的不同设备学习信息，然后根据算法生成路由表</li>
</ul>
</li>
</ol>
<h3 id="4-1-Routing-protocol-主动路由协议-Routing"><a href="#4-1-Routing-protocol-主动路由协议-Routing" class="headerlink" title="4.1 Routing protocol 主动路由协议(Routing)"></a>4.1 Routing protocol 主动路由协议(Routing)</h3><ol>
<li>Routing protocols <em>确定</em> routed protocols遵循的到达目的地的路径。</li>
<li>是用来<strong>构建路由表</strong>的，<strong>所以叫做routing</strong></li>
<li>公平、简单、适应变化等特点</li>
</ol>
<h3 id="4-2-Routed-vs-Routing-protocol"><a href="#4-2-Routed-vs-Routing-protocol" class="headerlink" title="4.2 Routed vs. Routing protocol"></a>4.2 Routed vs. Routing protocol</h3><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-42.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><strong>Routed Portocol</strong> 用于路由器之间，用来保证路由器之间连通（完成转发），保证路由器有效连通。<ul>
<li><ul>
<li><strong>功能</strong>：实际承载和传输数据。</li>
</ul>
</li>
<li>示例：IP、IPX等</li>
</ul>
</li>
<li><strong>Routing Protocol</strong> 用于做各自的<strong>路由表的生成</strong>：路由器彼此交换信息。<ul>
<li><ul>
<li><strong>功能</strong>：帮助路由器构建和维护路由表。</li>
</ul>
</li>
<li>示例：RIP、OSPF、EIGRP、BGP等。</li>
</ul>
</li>
</ol>
<ul>
<li>Routing Protocol 决定 Routed Protocals</li>
</ul>
<ol start="3">
<li>简单来说，路由协议(routing)用于<strong>帮助路由器决定数据包的最佳传输路径</strong>，而路由协议(routed)是<strong>实际用于传输数据</strong>的协议。</li>
</ol>
<h2 id="5-路由协议分类2（动态路由协议）：IGP-and-EGP"><a href="#5-路由协议分类2（动态路由协议）：IGP-and-EGP" class="headerlink" title="5. 路由协议分类2（动态路由协议）：IGP and EGP"></a>5. 路由协议分类2（动态路由协议）：IGP and EGP</h2><ul>
<li>皆为动态路由</li>
</ul>
<ol>
<li><strong>内部网关协议 IGP</strong>(Interior Gateway Protocols)</li>
</ol>
<ul>
<li>示例：RIP、IGRP、EIGRP、OSPF</li>
<li>用途：在<strong>一个自治系统内</strong>使用，例如公司网络、学校网络或政府机构网络。</li>
</ul>
<ol start="2">
<li><strong>外部网关协议 EGP</strong>(Exterior Gateway Protocols)</li>
</ol>
<ul>
<li>示例：EGP、BGP</li>
<li>用途：在<strong>不同自治系统之间路由数据包</strong>，例如跨组织或跨地区的互联网连接。</li>
</ul>
<h2 id="6-路由协议分类3（内部网关协议）：DVP-and-LSP"><a href="#6-路由协议分类3（内部网关协议）：DVP-and-LSP" class="headerlink" title="6. 路由协议分类3（内部网关协议）：DVP and LSP"></a>6. 路由协议分类3（内部网关协议）：DVP and LSP</h2><ol>
<li><strong>距离矢量协议 (Distance-Vector Protocols)：RIP, IGRP</strong></li>
</ol>
<ul>
<li>从<strong>邻居的角度</strong>查看网络拓扑。</li>
<li>添加从路由器到路由器的<strong>距离+矢量</strong>。<ul>
<li>距离 (Distance)：通常是路由器与目标网络之间的<strong>跳数</strong>（hop count）。每个跳数代表从一个路由器到另一个路由器的路径。</li>
<li>矢量 (Vector)：在距离矢量协议中，矢量通常指的是<em>从源路由器到目标路由器的下一跳信息</em>。每个路由器会保存一张路由表，记录到每个目标网络的最短跳数和下一跳路由器。</li>
</ul>
</li>
<li><strong>频繁、定期periodic更新</strong>。<ul>
<li>周期性地交换路由信息来计算最佳路径<ol>
<li>到达每个目标网络的跳数（距离）。</li>
<li>用于到达目标网络的下一跳路由器（方向）。</li>
</ol>
</li>
</ul>
</li>
<li>将<strong>路由表的副本</strong>传递给邻居路由器。</li>
</ul>
<ol start="2">
<li><strong>链路状态协议 (Link State Protocols)：OSPF</strong>*</li>
</ol>
<ul>
<li>每个路由器获取<strong>整个网络拓扑</strong>的共同视图。</li>
<li><strong>计算</strong>到其他路由器的<strong>最短路径</strong>。</li>
<li><strong>事件触发更新</strong>。</li>
<li>传递<strong>链路状态路由更新</strong>到其他路由器。</li>
</ul>
<h3 id="6-1-距离矢量协议DVP的示例"><a href="#6-1-距离矢量协议DVP的示例" class="headerlink" title="6.1 距离矢量协议DVP的示例"></a>6.1 距离矢量协议DVP的示例</h3><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-43.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>初始的时候，各自持有的是黑色的部分（直连的线路）</li>
<li>定时路由表会相互交换给邻居，下一时刻 C 学习到 B，B 学习到 AC，A 学习到 B，在下一刻进行再次的转发。</li>
<li>DVP 只知道<strong>到达一个网段的最少跳数hops</strong>（但是不知道最佳路径）。</li>
<li>可能导致问题：生成路由回路</li>
</ul>
<h4 id="6-1-1-RIP-Route-Information-Protocol-路由信息协议"><a href="#6-1-1-RIP-Route-Information-Protocol-路由信息协议" class="headerlink" title="6.1.1 RIP (Route Information Protocol)路由信息协议"></a>6.1.1 RIP (Route Information Protocol)路由信息协议</h4><ul>
<li>最流行的协议。</li>
<li><strong>内部网关协议TGP</strong>。</li>
<li><strong>距离矢量协议DVP</strong>。</li>
<li>唯一的度量是跳数hops。</li>
<li>最大跳数为15。</li>
<li>每30秒更新一次。</li>
<li>并不总是选择最快的路径。</li>
<li>生成大量网络流量。</li>
<li>RIP v2是RIP v1的改进版本。</li>
</ul>
<h4 id="6-1-2-IGRP-Interior-Gateway-Route-Protocol-and-EIGRP-Enhanced-IGRP"><a href="#6-1-2-IGRP-Interior-Gateway-Route-Protocol-and-EIGRP-Enhanced-IGRP" class="headerlink" title="6.1.2 IGRP (Interior Gateway Route Protocol) and EIGRP (Enhanced IGRP)"></a>6.1.2 IGRP (Interior Gateway Route Protocol) and EIGRP (Enhanced IGRP)</h4><ul>
<li>IGRP（内部网关路由协议）和EIGRP（增强型IGRP）</li>
<li>Cisco专有协议。</li>
<li><strong>内部网关协议IGP</strong>。</li>
<li><strong>距离矢量协议DVP</strong>。</li>
<li>度量由带宽、负载、延迟和可靠性组成。</li>
<li>最大跳数为255。</li>
<li>每90秒更新一次。</li>
<li>EIGRP是IGRP的高级版本，是一种混合路由协议。</li>
</ul>
<h3 id="6-2-链路状态协议LSP的示例"><a href="#6-2-链路状态协议LSP的示例" class="headerlink" title="6.2 链路状态协议LSP的示例"></a>6.2 链路状态协议LSP的示例</h3><ul>
<li>下图中的 Routing table 应该叫做初始时刻的 Routing Table（本图的问题）<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-44.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<ol>
<li>彼此交换连接情况，<strong>交换的是Link state</strong>而不是路由表，包含 link 的信息，以 NetID 作为主键（无相同网段），包含的是 link 上的路由器邻接关系、链路类型（4 种）、链路带宽，会指定谁连接了谁，这个条目就被称为 Database（表）。这样子就不仅仅知道链路，还知道更多的全局信息。</li>
<li>LSP 操作过程：<ul>
<li>相互交换彼此学到对应的 Tpological Database（是全局的信息）</li>
<li>之后使用 SPF 算法，以自己为根，通过最短路径优先算法，生成以自己为根的树</li>
<li>根据这一个树再生成路由表（了解全局的信息），逻辑是树的逻辑。</li>
</ul>
</li>
<li>LSP 不是进行定时进行交换的，而是<em>初始的时候进行交换</em>，稳定之后，根据<strong>事件触发</strong>的时候才会更新数据。<ul>
<li>更新后发送给所有的路由器，需要将 Database 发送给所有的路由器</li>
<li>收到的路由器的，根据 database 更新自己的树，然后再次生成路由表。</li>
</ul>
</li>
<li>LSP 是指从所有可达的道路上找到代价最小的路径。</li>
<li>全局可能会比较大，考虑负载进行处理</li>
<li>但是没有路由回路，单域内一般不超过 20 个路由器</li>
<li>路由表一般只保存一个最优的转发点的（负载均衡）</li>
</ol>
<h4 id="6-2-1-OSPF（Open-Shortest-Path-First）开放最短路径优先"><a href="#6-2-1-OSPF（Open-Shortest-Path-First）开放最短路径优先" class="headerlink" title="6.2.1 OSPF（Open Shortest Path First）开放最短路径优先"></a>6.2.1 OSPF（Open Shortest Path First）开放最短路径优先</h4><ul>
<li>开放最短路径优先。</li>
<li><strong>内部网关协议IGP</strong>。</li>
<li><strong>链路状态协议LSP</strong>。</li>
<li>度量由成本、速度、流量、可靠性和安全性组成。</li>
<li>事件触发更新。</li>
</ul>
<h1 id="七、VLSM-可变长度子网掩码"><a href="#七、VLSM-可变长度子网掩码" class="headerlink" title="七、VLSM 可变长度子网掩码"></a>七、VLSM 可变长度子网掩码</h1><ul>
<li>Variable Length Subnet Mask</li>
</ul>
<h2 id="1-Classful-Routing（类路由）"><a href="#1-Classful-Routing（类路由）" class="headerlink" title="1. Classful Routing（类路由）"></a>1. Classful Routing（类路由）</h2><ol>
<li>类路由协议要求<strong>一个网络</strong>使用<strong>相同的子网掩码</strong>。</li>
<li>例如：如果网络是 192.168.187.0，那么它必须使用一个单一的子网掩码，如 255.255.255.0。</li>
</ol>
<ul>
<li>也就是说，类路由协议不允许在同一个网络中存在多个子网掩码，<strong>所有子网都需要使用相同的掩码</strong>。</li>
<li>类路由的这种特性比较简单，但它不具备灵活性，无法根据需求进行更精细的子网划分。<ul>
<li>会造成一些浪费</li>
</ul>
</li>
</ul>
<h2 id="2-VLSM-—-Variable-Length-Subnet-Mask"><a href="#2-VLSM-—-Variable-Length-Subnet-Mask" class="headerlink" title="2. VLSM — Variable Length Subnet Mask"></a>2. VLSM — Variable Length Subnet Mask</h2><ol>
<li>VLSM是一种允许在<strong>同一个自治系统内使用不同子网掩码</strong>的特性。<ul>
<li>有效地解决浪费问题</li>
</ul>
</li>
<li>为什么要使用VLSM<ul>
<li>VLSM允许一个组织在同一个网络地址空间内使用多个子网掩码。</li>
<li>实施VLSM通常被称为“子网的子网”，可以用来最大化地址分配的效率。</li>
<li>VLSM是帮助弥合IPv4和IPv6之间差距的修改之一。</li>
</ul>
</li>
<li>优点<ul>
<li>高效使用IP地址 Efficient use of IP addresses</li>
<li>更好的路由聚合 Better route aggregation</li>
</ul>
</li>
<li>支持VLSM的 Routing Protocol：<ul>
<li>开放最短路径优先Open Shortest Path First (OSPF) </li>
<li>集成中间系统到中间系统 Integrated Intermediate System to Intermediate System (Integrated IS-IS) </li>
<li>增强型内部网关路由协议 Enhanced Interior Gateway Routing Protocol (EIGRP)</li>
<li>RIP v2 </li>
<li>静态路由 Static routing</li>
</ul>
</li>
<li>缺点：<ul>
<li>地址空间的浪费:广播地址和网络号都无法被使用。<ul>
<li>过去，建议不要使用第一个和最后一个子网。但从Cisco IOS 12.0版本开始，可以使用子网0。</li>
<li>从IOS 12.0版本开始，Cisco路由器默认使用子网0。</li>
</ul>
</li>
<li>如果想要禁止零子网，使用该指令:<code>router(config)#no ip subnet-zero()</code><br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-45.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ol>
<ul>
<li>上图解释了子网长度相同会造成怎样的浪费(在路由器所在的子网段我们只需要满足2个主机，也就是需要2位的主机号就可以完成操作)</li>
</ul>
<h2 id="3-如何使用VLSM"><a href="#3-如何使用VLSM" class="headerlink" title="3. 如何使用VLSM"></a>3. 如何使用VLSM</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-47.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li><strong>斜杠的含义</strong>是指<strong>前面多少位保留给网络位</strong></li>
<li><strong>此时也就是&#x2F;30 就可以满足路由器之间的网络连通所需（减少浪费），剩下的网络地址可以在以后网络进行扩展</strong><ul>
<li>这个例子中不使用 VLSM 还是可以进行解决的<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-48.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
<h3 id="3-0-划分背景"><a href="#3-0-划分背景" class="headerlink" title="3.0 划分背景"></a>3.0 划分背景</h3><ul>
<li>已分配 192.168.10.0&#x2F;24 的 C 类地址。<ul>
<li>珀斯、悉尼和新加坡有一个到吉隆坡（KL）的广域网连接。</li>
<li>珀斯需要60个主机。</li>
<li>吉隆坡需要28个主机。</li>
<li>悉尼和新加坡各需要12个主机。</li>
</ul>
</li>
</ul>
<ol>
<li>要计算 VLSM，子网和相应的主机首先从地址范围中分配<strong>最大的要求</strong>。需求级别应<strong>从大到小</strong>列出。</li>
</ol>
<h3 id="3-1-第一步：满足珀斯的主机需求（需求最大）"><a href="#3-1-第一步：满足珀斯的主机需求（需求最大）" class="headerlink" title="3.1 第一步：满足珀斯的主机需求（需求最大）"></a>3.1 第一步：满足珀斯的主机需求（需求最大）</h3><ol>
<li>珀斯需要60个主机。</li>
<li>2^6-2&#x3D;62个可用主机地址，所以使用6位<ul>
<li>将从第四个八位位组开始使用 2 位来表示&#x2F;26 的扩展网络前缀，其余 6 位将用于主机地址。</li>
</ul>
</li>
<li>在地址 192.168.10.0&#x2F;24 上应用 VLSM 可得到：<ul>
<li><strong>子网掩码：255.255.255.192</strong>（<strong>&#x2F;26</strong>）</li>
<li><strong>子网地址：192.168.10.0&#x2F;26</strong></li>
<li><strong>可用地址范围：192.168.10.1 - 192.168.10.62</strong></li>
<li><strong>广播地址: 192.168.10.63</strong><br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-49.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ol>
<ul>
<li>第一个给 Perth 使用，剩下的用作保留未使用的</li>
</ul>
<h3 id="3-2-第二步：为吉隆坡划分子网（需求第二）"><a href="#3-2-第二步：为吉隆坡划分子网（需求第二）" class="headerlink" title="3.2 第二步：为吉隆坡划分子网（需求第二）"></a>3.2 第二步：为吉隆坡划分子网（需求第二）</h3><ol>
<li>吉隆坡需要28个主机<ul>
<li>下一个可用地址是192.168.10.64&#x2F;26。</li>
<li><strong>01</strong>00 0000</li>
</ul>
</li>
<li>由于需要28个主机，<strong>5位</strong>将用于主机地址，2^5 - 2 &#x3D; 30个可用主机地址。</li>
<li>因此，<strong>5位用于表示主机</strong>，<strong>3位用于表示扩展网络前缀&#x2F;27</strong>。</li>
<li>在地址 192.168.10.64&#x2F;26 上应用VLSM可得到<ul>
<li>子网掩码：255.255.255.<strong>224（&#x2F;27）</strong><ul>
<li>1110 0000</li>
</ul>
</li>
<li><strong>子网地址：192.168.10.64&#x2F;27</strong><ul>
<li>192.168.10.<strong>010 hhhhh</strong> &#x2F;27</li>
</ul>
</li>
<li><strong>可用地址范围：192.168.10.65 - 192.168.10.94</strong></li>
<li><strong>广播地址：192.168.10.95</strong><br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-50.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ol>
<h3 id="3-3-第三步：为悉尼和新加坡进行分配地址（需求第三）"><a href="#3-3-第三步：为悉尼和新加坡进行分配地址（需求第三）" class="headerlink" title="3.3 第三步：为悉尼和新加坡进行分配地址（需求第三）"></a>3.3 第三步：为悉尼和新加坡进行分配地址（需求第三）</h3><ol>
<li>悉尼和新加坡各需要12个主机：<ul>
<li>下一个可用地址是192.168.10.96&#x2F;27。</li>
</ul>
</li>
<li>由于需要12个主机，<strong>4位</strong>将用于主机地址，2^4 &#x3D; 16，16 - 2 &#x3D; 14个可用主机地址。</li>
<li>因此，<strong>4位用于表示主机</strong>，4位用于表示扩展<strong>网络前缀&#x2F;28</strong>。</li>
<li>在地址 192.168.10.96&#x2F;27 上应用 VLSM 可得到：<ul>
<li>子网掩码：255.255.255.<strong>240（&#x2F;28）</strong><ul>
<li>1111 0000</li>
</ul>
</li>
<li><strong>子网地址：192.168.10.96&#x2F;28</strong><ul>
<li>192.168.10.<strong>0110 hhhh</strong>&#x2F;28</li>
</ul>
</li>
<li><strong>可用地址范围：192.168.10.97 - 192.168.10.110</strong></li>
<li><strong>广播地址：192.168.10.111</strong></li>
</ul>
</li>
</ol>
<ul>
<li>新加坡同理（12个主机）：<ul>
<li>下一个可用地址是192.168.10.112&#x2F;28</li>
<li>需要12个主机——4位表示主机，4位表示扩展网络前缀</li>
</ul>
</li>
</ul>
<ol start="5">
<li>在地址192.168.10.112&#x2F;28上应用VLSM得到：<ul>
<li>子网掩码：255.255.255.<strong>240（&#x2F;28）</strong><ul>
<li>1111 0000</li>
</ul>
</li>
<li>子网地址：192.168.10.112&#x2F;28<ul>
<li>192.168.10.<strong>0111</strong> hhhh&#x2F;28</li>
</ul>
</li>
<li>可用地址范围：192.168.10.113 - 192.168.10.126</li>
<li>广播地址：192.168.10.127<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-51.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ol>
<h3 id="3-4-第四步：为之间的路由地址进行划分"><a href="#3-4-第四步：为之间的路由地址进行划分" class="headerlink" title="3.4 第四步：为之间的路由地址进行划分"></a>3.4 第四步：为之间的路由地址进行划分</h3><ol>
<li>现在为 WAN 连接分配地址。请记住，<strong>每个 WAN 连接都需要两个 IP 地址</strong>。<ul>
<li>下一个可用的子网是 192.168.10.128&#x2F;28。</li>
</ul>
</li>
<li>由于每个 WAN 链路需要 2 个网络地址，因此主机地址需要 2 位，即 2^2 -2 &#x3D; 2 个可用地址。</li>
<li>因此，2位用于表示链接，6位用于表示扩展网络前缀&#x2F;30。</li>
<li>在 192.168.10.128&#x2F;28 上应用 VLSM 可得到：<ul>
<li>子网掩码：255.255.255.252（&#x2F;30）<ul>
<li>1111 1100</li>
</ul>
</li>
<li>子网地址：192.168.10.128&#x2F;30<ul>
<li>192.168.10.<strong>011000</strong> hh &#x2F;30</li>
</ul>
</li>
<li>可用地址范围：192.168.10.129 - 192.168.10.130</li>
<li>广播地址：192.168.10.131<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-52.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-53.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li><strong>下一个WAN链接</strong>：<ul>
<li>子网地址：192.168.10.132&#x2F;30</li>
<li>可用地址范围：192.168.10.133 - 192.168.10.134</li>
<li>广播地址：192.168.10.135</li>
</ul>
</li>
<li><strong>下一个WAN链接</strong>：<ul>
<li>子网地址：192.168.10.136&#x2F;30</li>
<li>可用地址范围：192.168.10.137 - 192.168.10.138</li>
<li>广播地址：192.168.10.139</li>
</ul>
</li>
</ol>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><strong>重要的是要记住，只有未使用的子网才能进一步子网划分。</strong></li>
<li>如果子网中的任何地址已被使用，则该子网不能进一步子网划分。</li>
<li>一般是从<strong>主机多到主机少</strong>（路由间网络）进行划分</li>
<li>最后<strong>不要忘了路由地址的划分</strong></li>
</ul>
<h2 id="4-Route-Aggregation-路由聚合"><a href="#4-Route-Aggregation-路由聚合" class="headerlink" title="4. Route Aggregation 路由聚合"></a>4. Route Aggregation 路由聚合</h2><ol>
<li>使用<strong>无类域间路由</strong>(<strong>CIDR</strong>，Classless InterDomain Routing)和<strong>VLSM</strong>不仅可以防止地址浪费，而且还可以促进路由聚合或汇总。</li>
<li>路由聚合（也称为路由汇总）是一种将<strong>多个连续的IP地址块</strong>合并为<strong>一个单一的路由条目</strong>的技术。<ul>
<li>通过路由聚合，可以减少路由表中的条目数量，从而简化路由器的处理和提高网络效率。</li>
</ul>
</li>
<li>优点：<ol>
<li>减少<strong>路由表</strong>条目的数量。</li>
<li>可用于<strong>隔离拓扑更改</strong><ul>
<li>当网络拓扑发生变化时，路由聚合可以帮助隔离这些变化，减少对整个网络的影响。</li>
</ul>
</li>
</ol>
</li>
<li>为了使路由聚合正常工作，需要以<strong>层次化</strong>的方式仔细分配地址，以确保<strong>汇总地址能够共享相同的高阶位</strong>（高位部分）。</li>
<li>VLSM可以通过基于地址的**高阶位（左边高位部分）**来实现路由的汇总和灵活性，即使网络地址不一定是连续的。</li>
</ol>
<ul>
<li>比如下图：3个&#x2F;24的子网合并成一个&#x2F;16的网络高速远端<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-54.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="4-0-例子"><a href="#4-0-例子" class="headerlink" title="4.0 例子"></a>4.0 例子</h3><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-55.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="4-1-如何进行路由聚合"><a href="#4-1-如何进行路由聚合" class="headerlink" title="4.1 如何进行路由聚合"></a>4.1 如何进行路由聚合</h3><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-56.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>将尽可能多的位进行聚集，将之后的不通过的位置，作为 Host 位，就得到了上图的结果</li>
</ul>
<hr>
<h1 id="八、ICMP-因特网控制报文协议"><a href="#八、ICMP-因特网控制报文协议" class="headerlink" title="八、ICMP 因特网控制报文协议"></a>八、ICMP 因特网控制报文协议</h1><ol>
<li>ICMP (<strong>Internet Control Message Protocol</strong>)：为了提高<br>IP 数据报交付成功的机会</li>
<li>ICMP 允许主机或路由器<strong>报告差错情况</strong>和提供有关异常情况<br>的报告</li>
<li>ICMP 只是IP 层的协议</li>
<li>ICMP 报文作为IP 层数据报的数据，加上数据报的首部，组成IP 数据报发送出去</li>
</ol>
<h2 id="1-ICMP-报文的格式"><a href="#1-ICMP-报文的格式" class="headerlink" title="1. ICMP 报文的格式"></a>1. ICMP 报文的格式</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-57.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>前4个字节和普通数据报的格式一样<ul>
<li>类型</li>
<li>代码</li>
<li>检验和</li>
</ul>
</li>
<li>后面都是要根据类型</li>
</ol>
<h2 id="2-两种ICMP报文"><a href="#2-两种ICMP报文" class="headerlink" title="2. 两种ICMP报文"></a>2. 两种ICMP报文</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-58.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>查询报文：一般这种情况不是很多</li>
<li>差错报告报文：一般这种类型会多一些</li>
</ol>
<h2 id="3-目的站不可到达"><a href="#3-目的站不可到达" class="headerlink" title="3. 目的站不可到达"></a>3. 目的站不可到达</h2><ul>
<li><p>网络不可到达（net unreachable）</p>
</li>
<li><p>主机不可到达（host unreachable）</p>
</li>
<li><p>协议不可到达（protocol unreachable）</p>
</li>
<li><p>端口不可到达（port unreachable）</p>
</li>
<li><p>源路由选择不能完成（source route failed）</p>
</li>
<li><p>目的网络不可知（unknown destination network）</p>
</li>
<li><p>目的主机不可知（unknown destination host）</p>
</li>
<li><p>注：不可知是完全不可以解析，不可达是可以解析但是不可以到达</p>
</li>
</ul>
<h2 id="4-ICMP-差错报告报文的数据字段的内容"><a href="#4-ICMP-差错报告报文的数据字段的内容" class="headerlink" title="4. ICMP 差错报告报文的数据字段的内容"></a>4. ICMP 差错报告报文的数据字段的内容</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-59.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>一般会把原始的 IP 数据报文的数据报首部 + 8 字节（数据的，可能会包含端口信息）作为 ICMP 的数据部分</li>
<li>ICMP 的前 8 个字节的是确定的（前 4 个字节是类型，校验位，后面四个字节是确定的）</li>
<li>然后添加一个首部作为 IP 数据报进行发送。</li>
</ol>
<h2 id="5-不应发生ICMP差错报告报文的几种情况"><a href="#5-不应发生ICMP差错报告报文的几种情况" class="headerlink" title="5. 不应发生ICMP差错报告报文的几种情况"></a>5. 不应发生ICMP差错报告报文的几种情况</h2><ol>
<li>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文</li>
<li>对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文</li>
<li>对具有多播地址的数据报都不发送 ICMP 差错报告报文</li>
<li>对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送 ICMP 差错报告报文</li>
</ol>
<h2 id="6-PING（Packet-InterNet-Groper）"><a href="#6-PING（Packet-InterNet-Groper）" class="headerlink" title="6. PING（Packet InterNet Groper）"></a>6. PING（Packet InterNet Groper）</h2><ul>
<li>PING 是用**ICMP的”Echo request”和”Echo reply”**消息来实现的</li>
<li>PING 用来<strong>测试两个主机之间的连通性</strong></li>
<li>PING 使用了ICMP 回送请求与回送回答报文</li>
<li>PING 是<strong>应用层直接使用网络层 ICMP 的例子</strong>，它没有通过运输层的TCP或UDP</li>
</ul>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
