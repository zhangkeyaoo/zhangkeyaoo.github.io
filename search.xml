<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1-十进制二进制浮点数转换</title>
    <url>/2025/02/20/1-%E5%8D%81%E8%BF%9B%E5%88%B6%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="一、十进制整数-二进制补码"><a href="#一、十进制整数-二进制补码" class="headerlink" title="一、十进制整数-&gt;二进制补码"></a>一、十进制整数-&gt;二进制补码</h2><h3 id="1-用2整除的方式（正数）"><a href="#1-用2整除的方式（正数）" class="headerlink" title="1. 用2整除的方式（正数）"></a>1. 用2整除的方式（正数）</h3><ol>
<li>用2整除十进制整数，得到一个<strong>商</strong>和<strong>余数</strong>；</li>
<li>再<strong>用2去除商</strong>，又会得到一个商和余</li>
<li>如此重复，直到<strong>商为小于1</strong>时为止，</li>
<li>然后把<strong>先得到余数</strong>作为二进制数的<strong>低位有效位</strong>，<strong>后得到的余数</strong>作为二进制数的<strong>高位有效位</strong>，以此排列起来。<br><img src="/2025/02/20/1-%E5%8D%81%E8%BF%9B%E5%88%B6%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BD%AC%E6%8D%A2/image.png" alt="alt"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<h3 id="2-负数转化为其补码——（其绝对值转化成二进制后）逐位取反-加一"><a href="#2-负数转化为其补码——（其绝对值转化成二进制后）逐位取反-加一" class="headerlink" title="2. 负数转化为其补码——（其绝对值转化成二进制后）逐位取反+加一"></a>2. 负数转化为其补码——（其绝对值转化成二进制后）逐位取反+加一</h3><ol>
<li>将负数的<strong>绝对值</strong>转换为二进制。</li>
<li>对二进制数进行<strong>逐位取反</strong>（0变1，1变0）。</li>
<li>对<strong>取反后的二进制数加1</strong>。</li>
</ol>
<h3 id="3-将字符数组转换为字符串"><a href="#3-将字符数组转换为字符串" class="headerlink" title="3. 将字符数组转换为字符串"></a>3. 将字符数组转换为字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">binary</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(binaryStr);</span><br></pre></td></tr></table></figure>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>将字符串转换为整数：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">numInt</span> <span class="operator">=</span> Integer.parseInt(numStr);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>初始化一个长度为32的字符数组</strong>，用于存储二进制表示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] binaryStr = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">32</span>];</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>设置符号位</li>
<li>处理正数：使用除2取余法。从数组的末尾开始填充二进制位。</li>
<li>处理负数：<ul>
<li>先将负数转换为其<strong>绝对值</strong>。</li>
<li>使用<strong>除2取余法</strong>，将绝对值转换为二进制表示。</li>
<li>对二进制表示<strong>逐位取反</strong>。</li>
<li>对<strong>取反后的二进制数加一</strong>。注意<code>ifplus</code></li>
</ul>
</li>
<li>将<strong>字符数组转换为字符串</strong>并返回</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">binary</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(binaryStr);</span><br></pre></td></tr></table></figure>
<h3 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">intToBinary</span><span class="params">(String numStr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> numInt=Integer.parseInt(numStr);<span class="comment">//转成int</span></span><br><span class="line">    <span class="type">char</span> []binaryStr = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">if</span>(numInt&gt;=<span class="number">0</span>)&#123;<span class="comment">//符号位</span></span><br><span class="line">        binaryStr[<span class="number">0</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        binaryStr[<span class="number">0</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (numInt&gt;=<span class="number">0</span>)&#123;<span class="comment">//正数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numInt%<span class="number">2</span>==<span class="number">1</span>)&#123;<span class="comment">//余数是1</span></span><br><span class="line">                binaryStr[<span class="number">32</span>-i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//余数是0</span></span><br><span class="line">                binaryStr[<span class="number">32</span>-i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            numInt=numInt/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;<span class="comment">//负数，等于其正数的二进制数，逐位取反，再加一</span></span><br><span class="line">        numInt = -numInt;<span class="comment">//转正</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numInt % <span class="number">2</span> == <span class="number">1</span>) &#123;<span class="comment">//余数是1</span></span><br><span class="line">                binaryStr[<span class="number">32</span> - i] = <span class="string">&#x27;0&#x27;</span>;<span class="comment">//取反</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//余数是0</span></span><br><span class="line">                binaryStr[<span class="number">32</span> - i] = <span class="string">&#x27;1&#x27;</span>;<span class="comment">//取反</span></span><br><span class="line">            &#125;</span><br><span class="line">            numInt = numInt / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加一</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ifplus</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binaryStr[i] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; ifplus) &#123;</span><br><span class="line">                    binaryStr[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    ifplus = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (binaryStr[i] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; ifplus) &#123;</span><br><span class="line">                    binaryStr[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">binary</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(binaryStr);</span><br><span class="line">  <span class="keyword">return</span> binary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、二进制补码-十进制整数"><a href="#二、二进制补码-十进制整数" class="headerlink" title="二、二进制补码-&gt;十进制整数"></a>二、二进制补码-&gt;十进制整数</h2><h3 id="错误方法-无法通过最大-最小值测试"><a href="#错误方法-无法通过最大-最小值测试" class="headerlink" title="错误方法-无法通过最大&#x2F;最小值测试"></a>错误方法-无法通过最大&#x2F;最小值测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">binaryToInt</span><span class="params">(String binStr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(binStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>)&#123;<span class="comment">//正数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> temp=Integer.parseInt(String.valueOf(binStr.charAt(i)));</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">32</span>-i;j++)&#123;</span><br><span class="line">                temp*=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           temp/=<span class="number">2</span>;</span><br><span class="line">            num+=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;<span class="comment">//负数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> temp=Integer.parseInt(String.valueOf(binStr.charAt(i)));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">32</span>-i;j++)&#123;</span><br><span class="line">                temp*=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp/=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>) &#123;</span><br><span class="line">                num += temp;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num-=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String numStr=String.valueOf(num);</span><br><span class="line">    <span class="keyword">return</span> numStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-逐位累加（！！从左边开始！！）"><a href="#1-逐位累加（！！从左边开始！！）" class="headerlink" title="1.逐位累加（！！从左边开始！！）"></a>1.逐位累加（！！从左边开始！！）</h3><ul>
<li>逐位累加实现二进制转十进制的过程就是将二进制字符串中的每一位数字（<strong>从左到右</strong>）根据其所在的位置转换为相应的十进制值，并累加到最终结果中。</li>
</ul>
<ol>
<li>从二进制字符串的<strong>左边</strong>开始，对每个字符进行处理。</li>
<li>对每个字符，计算其<strong>对应的二进制值(1&#x2F;0)</strong>，然后将其加到累积结果中。</li>
<li>在处理每个字符时，将<strong>当前的累积值乘以 2</strong>，并<strong>加上当前字符所表示的数字（0 或 1）</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num = num * <span class="number">2</span> + (binStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>这样，最终的结果就是二进制转换成的十进制数。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (binStr.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>) &#123; <span class="comment">// 正数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        num = num * <span class="number">2</span> + (binStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-char转int"><a href="#2-char转int" class="headerlink" title="2. char转int"></a>2. char转int</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num = num * <span class="number">2</span> + (binStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="3-处理负数"><a href="#3-处理负数" class="headerlink" title="3. 处理负数"></a>3. 处理负数</h3><ol>
<li><strong>逐位取反</strong>：将二进制字符串逐位取反。</li>
<li><strong>加一</strong>：对取反后的二进制数加一。</li>
<li>累加计算：从第0位到第31位，逐位计算二进制数对应的十进制值。</li>
<li>取反：将结果取负。</li>
</ol>
<ul>
<li>注意：<strong>二进制负数取反后加一</strong>等价于相当于<strong>二进制负数先减一，再取反</strong></li>
</ul>
<h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol>
<li>正数处理：<ul>
<li>从第0位到第31位，逐位计算二进制数对应的十进制值。</li>
<li>num*2+(dinStr.charAt(i)-‘0’);</li>
</ul>
</li>
<li>负数处理：<ul>
<li>取反：将二进制字符串逐位取反。</li>
<li>加一：对取反后的二进制数加一。</li>
<li>累加计算：从第0位到第31位，逐位计算二进制数对应的十进制值。</li>
<li>取反：将结果取负。</li>
</ul>
</li>
<li>返回结果：<ul>
<li>将计算得到的十进制整数转换为字符串并返回。</li>
</ul>
</li>
</ol>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">binaryToInt</span><span class="params">(String binStr)</span> &#123;</span><br><span class="line">       <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span>(binStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>)&#123;<span class="comment">//正数</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;<span class="comment">//从0或者1开始都行，没影响</span></span><br><span class="line">               num=num*<span class="number">2</span>+(binStr.charAt(i)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;<span class="comment">//负数</span></span><br><span class="line">          <span class="comment">//1. 取反</span></span><br><span class="line">           <span class="type">char</span>[]binstr=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">32</span>];</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">               <span class="keyword">if</span> (binStr.charAt(i)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                   binstr[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   binstr[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//2. 加一</span></span><br><span class="line">           <span class="type">boolean</span> is_plus=<span class="literal">true</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">               <span class="keyword">if</span>(binstr[i]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;is_plus)&#123;</span><br><span class="line">                   binstr[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                   is_plus=<span class="literal">false</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(binstr[i]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;is_plus)&#123;</span><br><span class="line">                   binstr[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//3. 累加计算</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;<span class="comment">//从0或者1开始都行，没影响</span></span><br><span class="line">               num=num*<span class="number">2</span>+(binstr[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//4. 取反</span></span><br><span class="line">           num=-num;</span><br><span class="line">       &#125;</span><br><span class="line">       String numStr=String.valueOf(num);</span><br><span class="line">       <span class="keyword">return</span> numStr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结：二进制补码和十进制整数相互转换："><a href="#总结：二进制补码和十进制整数相互转换：" class="headerlink" title="总结：二进制补码和十进制整数相互转换："></a>总结：二进制补码和十进制整数相互转换：</h2><ol>
<li>负数补码和对应正数补码转换<ul>
<li><strong>负数转补码</strong>：<ol>
<li>将负数的<strong>绝对值转换为二进制</strong>。</li>
<li>对二进制数<em><strong>逐位取反</strong></em>（0变1，1变0）。</li>
<li>对取反后的<strong>二进制数加1</strong>。</li>
</ol>
</li>
<li><strong>补码转负数</strong>：<ol>
<li>对<strong>补码逐位取反</strong>（0变1，1变0）。</li>
<li>对取反后的<strong>二进制数加1</strong>。</li>
<li>将结果int<strong>取负</strong>。</li>
</ol>
</li>
</ul>
</li>
<li>十进制整数转二进制补码：<ul>
<li>正数：<ol>
<li>使用<strong>除2取余法</strong>，从<strong>低位到高位依次填充</strong>二进制位。</li>
<li>符号位为0。</li>
</ol>
</li>
<li>负数：<ol>
<li>将负数的<strong>绝对值</strong>转换为二进制。</li>
<li>对二进制数逐位取反（0变1，1变0）。</li>
<li>对取反后的二进制数加1。</li>
<li>符号位为1。</li>
</ol>
</li>
</ul>
</li>
<li>二进制补码转十进制整数：<ul>
<li>正数：<ul>
<li>从<strong>第0位到第31位（从左开始！！）</strong>，<strong>逐位计算</strong>二进制数对应的十进制值。</li>
</ul>
</li>
<li>负数：<ol>
<li>对二进制数逐位取反（0变1，1变0）。</li>
<li>对取反后的二进制数加1。</li>
<li>从第0位到第31位，逐位计算二进制数对应的十进制值。</li>
<li>将结果取负。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="三、十进制整数的真值转化成NBCD"><a href="#三、十进制整数的真值转化成NBCD" class="headerlink" title="三、十进制整数的真值转化成NBCD"></a>三、十进制整数的真值转化成NBCD</h2><h3 id="1-NBCD"><a href="#1-NBCD" class="headerlink" title="1. NBCD"></a>1. NBCD</h3><ol>
<li>NBCD格式：<ol>
<li>符号位<ul>
<li><strong>正数：1100</strong></li>
<li><strong>负数：1101</strong></li>
</ul>
</li>
<li>每个十进制数字用4位二进制数表示。</li>
<li>确保NBCD表示一定是32位。<ul>
<li>在<strong>符号位和有效位之间</strong>填充<strong>0</strong>!</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="2-将单位十进制数字转化为4位二进制形式"><a href="#2-将单位十进制数字转化为4位二进制形式" class="headerlink" title="2.将单位十进制数字转化为4位二进制形式"></a>2.将单位十进制数字转化为4位二进制形式</h3><ul>
<li>除2取余法<ul>
<li><strong>先得到的余数</strong>作为<strong>低位有效位</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">CharTo4bit</span><span class="params">(Character character)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> character-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="type">char</span>[] stringOf4=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        stringOf4[i] = <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 初始化字符数组为&#x27;0&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//转换为二进制[除二取余法]</span></span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            stringOf4[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(stringOf4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-步骤"><a href="#3-步骤" class="headerlink" title="3. 步骤"></a>3. 步骤</h3><ol>
<li>将字符串转换为<strong>整数</strong>。</li>
<li>初始化一个 StringBuilder 用于构建NBCD字符串。</li>
<li>根据整数的符号设置<strong>符号位</strong>：<ul>
<li>正数：1100</li>
<li>负数：1101</li>
</ul>
</li>
<li>计算需要<strong>填充的零</strong>的数量，以确保NBCD表示是<strong>32位</strong>。</li>
<li>将<strong>每个十进制数字转换为4位二进制形式</strong>，并<strong>添加</strong>到 StringBuilder 中。</li>
<li>返回NBCD字符串。</li>
</ol>
<h3 id="4-【注意】语法"><a href="#4-【注意】语法" class="headerlink" title="4. 【注意】语法"></a>4. 【注意】语法</h3><ol>
<li>return <strong>new String(stringOf4)</strong>;<ul>
<li>适用于将<strong>字符数组char[]转换为字符串</strong>的场景</li>
</ul>
</li>
<li>return <strong>nbcdStr.toString()</strong>;<ul>
<li>适用于将<strong>StringBuilder对象转换为字符串</strong>的场景</li>
</ul>
</li>
</ol>
<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">decimalToNBCD</span><span class="params">(String decimalStr)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">nbcdStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(decimalStr);</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> decimalStr.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">zero_length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        zero_length=<span class="number">28</span>-<span class="number">4</span>*length;</span><br><span class="line">        nbcdStr.append(<span class="number">1100</span>);<span class="comment">//符号位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;zero_length;i++)&#123;<span class="comment">//填充零</span></span><br><span class="line">            nbcdStr.append(<span class="number">0000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            nbcdStr.append(CharTo4bit(decimalStr.charAt(i)));<span class="comment">//转换每个十进制数字,并添加到 StringBuilder 中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        zero_length=<span class="number">28</span>-<span class="number">4</span>*(length-<span class="number">1</span>);</span><br><span class="line">        nbcdStr.append(<span class="number">1101</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;zero_length;i++)&#123;</span><br><span class="line">            nbcdStr.append(<span class="number">0000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;<span class="comment">//把负号跳过</span></span><br><span class="line">            nbcdStr.append(CharTo4bit(decimalStr.charAt(i)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nbcdStr.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、-NBCD（符号位用4位表示）转化成十进制整数的真值"><a href="#四、-NBCD（符号位用4位表示）转化成十进制整数的真值" class="headerlink" title="四、 NBCD（符号位用4位表示）转化成十进制整数的真值"></a>四、 NBCD（符号位用4位表示）转化成十进制整数的真值</h2><h3 id="1-4位二进制-转-1位十进制：bit4ToChar"><a href="#1-4位二进制-转-1位十进制：bit4ToChar" class="headerlink" title="1. 4位二进制 转 1位十进制：bit4ToChar"></a>1. 4位二进制 转 1位十进制：bit4ToChar</h3><ul>
<li>从左到右，累加</li>
<li>num&#x3D;num*2+(<strong>bit4.charAt(i)-‘0’</strong>);</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">bit4ToChar</span><span class="params">(String bit4)</span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        num=num*<span class="number">2</span>+(bit4.charAt(i)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>初始化一个 StringBuilder 用于构建十进制字符串。</li>
<li>从第4位开始，<strong>每4位表示一个十进制数字</strong>，使用 <strong>bit4ToChar</strong> 方法将其转换为<strong>对应的十进制字符</strong>，并添加到 StringBuilder 中。</li>
<li><strong>去除前面多余的0</strong>（<strong>保留至少一位，以满足数为0</strong>）。</li>
<li>将 StringBuilder 转换为字符串，并解析为整数。</li>
<li>根据符号位确定结果<strong>是否为负数</strong>。</li>
<li>返回十进制字符串。</li>
</ol>
<h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">NBCDToDecimal</span><span class="params">(String NBCDStr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    StringBuilder num_sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();   <span class="comment">//初始化 StringBuilder</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>;i&lt;<span class="number">32</span>;i+=<span class="number">4</span>)&#123;       <span class="comment">//转换每个4位二进制数字</span></span><br><span class="line">        num_sb.append(bit4ToChar(NBCDStr.substring(i,i+<span class="number">4</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去除前面多余的0（留一位，以满足数为0）</span></span><br><span class="line">    <span class="type">int</span> length=num_sb.length();</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num_sb.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>&amp;&amp;length!=<span class="number">1</span>)&#123;       <span class="comment">//去除前面多余的0(留1位)</span></span><br><span class="line">        num_sb.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">        length=num_sb.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">demical</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(num_sb);</span><br><span class="line">    num=Integer.parseInt(demical);      <span class="comment">//解析为整数</span></span><br><span class="line">    <span class="keyword">if</span> (NBCDStr.substring(<span class="number">0</span>, <span class="number">4</span>).equals(<span class="string">&quot;1101&quot;</span>))&#123;    <span class="comment">//负数判断</span></span><br><span class="line">        num=-num;</span><br><span class="line">    &#125;</span><br><span class="line">    demical=String.valueOf(num);        <span class="comment">//转为字符串</span></span><br><span class="line">    <span class="keyword">return</span> demical;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将4位二进制字符串转换为对应的十进制字符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">bit4ToChar</span><span class="params">(String binStr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        num = num * <span class="number">2</span> + (binStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>) (num + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、将浮点数真值转化成32位单精度浮点数表示"><a href="#五、将浮点数真值转化成32位单精度浮点数表示" class="headerlink" title="五、将浮点数真值转化成32位单精度浮点数表示"></a>五、将浮点数真值转化成32位单精度浮点数表示</h2><h3 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h3><ul>
<li>如果<strong>8位指数位全为0</strong>, 就代表当前数是个<strong>非规格数</strong>. 或者说, 形如 * 00000000 *********************** 格式的数就是非规格数.<ul>
<li>用于表示0, 以及非常靠近0的数, 比如1E-38.</li>
<li><strong>非规格数的实际指数固定为-126</strong></li>
</ul>
</li>
<li>如果<strong>8位指数位全为1</strong>, 就代表当前数是个<strong>特殊数</strong>. 或者说, 形如 * 11111111 *********************** 格式的数就是特殊数.<ul>
<li><strong>无穷大</strong>和<strong>NaN</strong></li>
</ul>
</li>
</ul>
<h3 id="1-0"><a href="#1-0" class="headerlink" title="1. 0"></a>1. 0</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (num == <span class="number">0.0f</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;00000000000000000000000000000000&quot;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="2-NaN"><a href="#2-NaN" class="headerlink" title="2.NaN"></a>2.NaN</h3><ol>
<li>符号位：0或1</li>
<li>指数位：<strong>11111111</strong></li>
<li>尾数位：任意非零值（通常为<strong>10000000000000000000000</strong>）</li>
</ol>
<ul>
<li>一般表示用：<strong>0 11111111 10000000000000000000000</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Float.isNaN(num)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;01111111110000000000000000000000&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-无穷大"><a href="#3-无穷大" class="headerlink" title="3. 无穷大"></a>3. 无穷大</h3><ol>
<li>8位指数位全为1：<strong>11111111</strong></li>
<li>23位尾数位全为0：<strong>00000000000000000000000</strong></li>
</ol>
<ul>
<li>正无穷：01111111100000000000000000000000</li>
<li>负无穷：11111111100000000000000000000000</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (num == Float.POSITIVE_INFINITY)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;+Inf&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&lt;=Float.NEGATIVE_INFINITY)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;-Inf&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-非规格数"><a href="#4-非规格数" class="headerlink" title="4. 非规格数"></a>4. 非规格数</h3><h3 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h3><ol>
<li>特殊情况处理<ol>
<li>零</li>
<li>正负无穷：num &#x3D;&#x3D; <strong>Float.POSITIVE_INFINITY</strong></li>
<li>NaN: <strong>if (Float.isNaN(num))</strong></li>
</ol>
</li>
<li>正常情况处理<ol>
<li>正负</li>
<li>调整尾数到1.f~2.f范围：（指数初始为0）<ul>
<li>尾数偏大时，除以2，指数加1。<code>while (num &gt;= 2.0f)</code></li>
<li>尾数偏小时，乘以2，指数减1。<code>while (num &lt; 1.0f &amp;&amp; exponent &gt; -126)</code><ul>
<li>如果指数减小到了<code>-126</code>，则<strong>非规格化数</strong>！</li>
</ul>
</li>
</ul>
</li>
<li>规格化判断<ul>
<li>非规格化数：如果<strong>实际指数为-126，则指数部分全为0</strong>，<strong>尾数不变</strong>（已经小于1.0f了）。</li>
<li>规格化数：尾数<strong>减去1.0f</strong>，指数<strong>加偏移量127</strong>。</li>
</ul>
</li>
<li>构建IEEE 754二进制字符串：<ul>
<li>符号位：1位</li>
<li>指数位：8位——<strong>除二取余法</strong></li>
<li><strong>尾数位</strong>：23位——<strong>乘二减一法</strong>：<ul>
<li>如果乘二之后大于1.0f，则1；否则0。</li>
<li>先出现的在左！</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">floatToBinary</span><span class="params">(String floatStr)</span> &#123;</span><br><span class="line">       <span class="type">float</span> <span class="variable">num</span> <span class="operator">=</span> Float.parseFloat(floatStr);</span><br><span class="line">       <span class="comment">//1、0</span></span><br><span class="line">       <span class="keyword">if</span>(num==<span class="number">0</span>)&#123;</span><br><span class="line">           String zeroStr=<span class="string">&quot;00000000000000000000000000000000&quot;</span>;</span><br><span class="line">           <span class="keyword">return</span> zeroStr;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2.+Inf和-Inf（正负无穷）</span></span><br><span class="line">       <span class="keyword">if</span> (num == Float.POSITIVE_INFINITY)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;+Inf&quot;</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&lt;=Float.NEGATIVE_INFINITY)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;-Inf&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3.NaN</span></span><br><span class="line">       <span class="keyword">if</span>(Float.isNaN(num))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;01111111110000000000000000000000&quot;</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Float.isNaN(-num))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;11111111110000000000000000000000&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//4. 正常情况</span></span><br><span class="line">       <span class="comment">//4.1判断正负</span></span><br><span class="line">       <span class="type">boolean</span> is_neg=<span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">if</span>(num&lt;<span class="number">0</span>)&#123;</span><br><span class="line">           is_neg=<span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> exponent=<span class="number">0</span>;<span class="comment">//指数</span></span><br><span class="line">       <span class="comment">//尾数</span></span><br><span class="line">       <span class="type">int</span> offset=<span class="number">127</span>;;<span class="comment">//偏移量</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//4.2 调整尾数到1.f~2.f范围</span></span><br><span class="line">       <span class="keyword">if</span>(num&lt;<span class="number">0</span>)&#123;</span><br><span class="line">           num=-num;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (num&gt;=<span class="number">2.0f</span>)&#123;   <span class="comment">//尾数偏大</span></span><br><span class="line">           num/=<span class="number">2.0f</span>;</span><br><span class="line">           exponent++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (num&lt;<span class="number">1.0f</span>&amp;&amp;exponent&gt;-<span class="number">126</span>)&#123;    <span class="comment">//尾数偏小</span></span><br><span class="line">           num*=<span class="number">2.0f</span>;</span><br><span class="line">           exponent--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//4.3 规格化判断</span></span><br><span class="line">       <span class="keyword">if</span> (exponent &lt;=-<span class="number">126</span>) &#123;</span><br><span class="line">           exponent = <span class="number">0</span>; <span class="comment">// 非规格化数，指数部分全为0(实际指数固定为-126)</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           num -= <span class="number">1.0f</span>; <span class="comment">// 规格化数，尾数减去1</span></span><br><span class="line">           exponent += offset; <span class="comment">// 加偏移量</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//4.4 化为IEEE</span></span><br><span class="line">       StringBuilder binFloat=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">       <span class="comment">//符号位</span></span><br><span class="line">       <span class="keyword">if</span> (is_neg)&#123;</span><br><span class="line">           binFloat.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           binFloat.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//指数位</span></span><br><span class="line">       <span class="type">char</span>[] exp = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">8</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">7</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">           <span class="keyword">if</span>(exponent%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">               exp[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               exp[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           exponent/=<span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//尾数位</span></span><br><span class="line">       <span class="type">char</span>[]wei=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">23</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">23</span>;i++)&#123;</span><br><span class="line">           num*=<span class="number">2.0f</span>;</span><br><span class="line">           <span class="keyword">if</span>(num&gt;=<span class="number">1.0f</span>)&#123;</span><br><span class="line">               wei[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">               num-=<span class="number">1.0f</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               wei[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">expStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(exp);</span><br><span class="line">       String weiStr=<span class="keyword">new</span> <span class="title class_">String</span>(wei);</span><br><span class="line">       binFloat.append(expStr);</span><br><span class="line">       binFloat.append(weiStr);</span><br><span class="line">       <span class="keyword">return</span> binFloat.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、32位单精度浮点数表示转化成浮点数真值"><a href="#六、32位单精度浮点数表示转化成浮点数真值" class="headerlink" title="六、32位单精度浮点数表示转化成浮点数真值"></a>六、32位单精度浮点数表示转化成浮点数真值</h2><h3 id="1-特殊情况"><a href="#1-特殊情况" class="headerlink" title="1. 特殊情况"></a>1. 特殊情况</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 0</span></span><br><span class="line">        <span class="keyword">if</span>(binStr==<span class="string">&quot;00000000000000000000000000000000&quot;</span>)&#123;</span><br><span class="line">            <span class="type">Float</span> <span class="variable">zero</span> <span class="operator">=</span> <span class="number">0.0f</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(zero);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. NaN</span></span><br><span class="line">        <span class="keyword">if</span>(binStr==<span class="string">&quot;01111111110000000000000000000000&quot;</span>)&#123;</span><br><span class="line">           <span class="type">Float</span> <span class="variable">nan</span> <span class="operator">=</span> Float.NaN;</span><br><span class="line">           <span class="keyword">return</span> String.valueOf(nan);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 正负无穷</span></span><br><span class="line">        <span class="keyword">if</span>(binStr==<span class="string">&quot;01111111100000000000000000000000&quot;</span>)&#123;</span><br><span class="line">           Float pos_inf=Float.POSITIVE_INFINITY;</span><br><span class="line">           <span class="keyword">return</span> String.valueOf(pos_inf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(binStr==<span class="string">&quot;11111111100000000000000000000000&quot;</span>)&#123;</span><br><span class="line">            Float neg_inf=Float.NEGATIVE_INFINITY;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(neg_inf);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-正常情况（规格化数-非规格化数）"><a href="#2-正常情况（规格化数-非规格化数）" class="headerlink" title="2. 正常情况（规格化数+非规格化数）"></a>2. 正常情况（规格化数+非规格化数）</h3><ol>
<li>符号位</li>
<li>指数位<ul>
<li>提取指数位的8位二进制数，并转换为整数。</li>
<li>对于<strong>规格化数</strong>，<strong>减去偏移量127</strong>。</li>
<li>对于<strong>非规格化数（指数位等于0）</strong>，<strong>实际指数为-126</strong>。</li>
</ul>
</li>
<li>尾数位：<ul>
<li>提取尾数位的23位二进制数，并转换为浮点数。</li>
<li>对于规格化数，尾数部分隐含一个1。<strong>规格化数，加1.0f</strong></li>
</ul>
</li>
<li>计算浮点数值：<ul>
<li>根据指数调整尾数的值&#x2F;直接算（注意<strong>double和float的转换</strong>）<ul>
<li><em><em>float num&#x3D;weishu</em>(float)Math.pow(2,exponent);</em>*</li>
</ul>
</li>
<li>如果符号位为1，则结果为负数。</li>
</ul>
</li>
</ol>
<h3 id="完整代码-4"><a href="#完整代码-4" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">binaryToFloat</span><span class="params">(String binStr)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 0</span></span><br><span class="line">        <span class="keyword">if</span>(binStr==<span class="string">&quot;00000000000000000000000000000000&quot;</span>)&#123;</span><br><span class="line">            <span class="type">Float</span> <span class="variable">zero</span> <span class="operator">=</span> <span class="number">0.0f</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(zero);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. NaN</span></span><br><span class="line">        <span class="keyword">if</span>(binStr==<span class="string">&quot;01111111110000000000000000000000&quot;</span>)&#123;</span><br><span class="line">           <span class="type">Float</span> <span class="variable">nan</span> <span class="operator">=</span> Float.NaN;</span><br><span class="line">           <span class="keyword">return</span> String.valueOf(nan);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 正负无穷</span></span><br><span class="line">        <span class="keyword">if</span>(binStr==<span class="string">&quot;01111111100000000000000000000000&quot;</span>)&#123;</span><br><span class="line">           Float pos_inf=Float.POSITIVE_INFINITY;</span><br><span class="line">           <span class="keyword">return</span> String.valueOf(pos_inf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(binStr==<span class="string">&quot;11111111100000000000000000000000&quot;</span>)&#123;</span><br><span class="line">            Float neg_inf=Float.NEGATIVE_INFINITY;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(neg_inf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4. 正常情况</span></span><br><span class="line">        <span class="comment">//4.1 正负</span></span><br><span class="line">        <span class="type">boolean</span> is_neg=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(binStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            is_neg=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.2指数</span></span><br><span class="line">        <span class="type">int</span> exponent=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">            exponent=exponent*<span class="number">2</span>+(binStr.charAt(i+<span class="number">1</span>)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(exponent!=<span class="number">0</span>)&#123;</span><br><span class="line">            exponent-=<span class="number">127</span>;<span class="comment">//规格数</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            exponent=-<span class="number">126</span>;<span class="comment">//非规格数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.3 尾数</span></span><br><span class="line">        <span class="type">float</span> weishu=<span class="number">0.0f</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">Add</span> <span class="operator">=</span> <span class="number">0.5f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">9</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(binStr.charAt(i)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                weishu+=Add;</span><br><span class="line">            &#125;</span><br><span class="line">            Add/=<span class="number">2.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exponent!=-<span class="number">126</span>)&#123;<span class="comment">//规格化数，加1.0f</span></span><br><span class="line">            weishu+=<span class="number">1.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.计算</span></span><br><span class="line">        <span class="keyword">while</span> (exponent&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            weishu*=<span class="number">2.0f</span>;</span><br><span class="line">            exponent--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (exponent&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            weishu/=<span class="number">2.0f</span>;</span><br><span class="line">            exponent++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(is_neg)&#123;</span><br><span class="line">            weishu=-weishu;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//法2：直接算</span></span><br><span class="line"><span class="comment">//        float num=weishu*(float)Math.pow(2,exponent);</span></span><br><span class="line"><span class="comment">//        if (is_neg)&#123;</span></span><br><span class="line"><span class="comment">//            num=-num;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">return</span> String.valueOf(weishu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>2-补码加减乘除</title>
    <url>/2025/02/22/2.%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/</url>
    <content><![CDATA[<h2 id="一-计算两个32位二进制整数补码真值的和"><a href="#一-计算两个32位二进制整数补码真值的和" class="headerlink" title="一. 计算两个32位二进制整数补码真值的和"></a>一. 计算两个32位二进制整数补码真值的和</h2><h3 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1. 步骤"></a>1. 步骤</h3><ol>
<li>初始化：将 src 和 dest 转换为字符串形式，并初始化一个 StringBuilder 来存储结果。</li>
<li>逐位相加：从最低位（第31位）开始逐位相加，<strong>考虑进位情况</strong>。</li>
<li>处理进位：根据<strong>当前位的和以及是否有进位</strong>，决定<strong>当前位的结果和是否产生新的进位</strong>。</li>
<li><strong>结果反转</strong>：由于结果是从最低位开始添加的，<strong>最终需要反转字符串以得到正确的顺序</strong>。</li>
<li>返回结果：将结果转换为 DataType 并返回。<ul>
<li>DataType ans &#x3D; <strong>new DataType(ansStr)</strong>;</li>
</ul>
</li>
</ol>
<h3 id="2-【注意】结果反转"><a href="#2-【注意】结果反转" class="headerlink" title="2. 【注意】结果反转"></a>2. 【注意】结果反转</h3><ul>
<li><code>String ans = ansStr.reverse().toString();</code></li>
<li><strong>StringBulider</strong>才能用<code>.reverse()</code>; String不能用</li>
</ul>
<h3 id="3-完整代码"><a href="#3-完整代码" class="headerlink" title="3. 完整代码"></a>3. 完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">add</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">       String srcStr=src.toString();</span><br><span class="line">       String destStr=dest.toString();</span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">ansStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">destInt</span> <span class="operator">=</span> destStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           <span class="type">int</span> <span class="variable">srcInt</span> <span class="operator">=</span> srcStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           <span class="keyword">if</span> (!carry) &#123;<span class="comment">//无进位</span></span><br><span class="line">               <span class="keyword">if</span> (destInt + srcInt == <span class="number">2</span>) &#123;</span><br><span class="line">                   carry = <span class="literal">true</span>;</span><br><span class="line">                   ansStr.append(<span class="number">0</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span>(destInt+srcInt==<span class="number">1</span>)&#123;</span><br><span class="line">                   ansStr.append(<span class="number">1</span>);</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   ansStr.append(<span class="number">0</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;<span class="comment">//有进位</span></span><br><span class="line">               <span class="keyword">if</span> (destInt + srcInt == <span class="number">2</span>) &#123;</span><br><span class="line">                   ansStr.append(<span class="number">1</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span>(destInt+srcInt==<span class="number">1</span>)&#123;</span><br><span class="line">                   ansStr.append(<span class="number">0</span>);</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   ansStr.append(<span class="number">1</span>);</span><br><span class="line">                   carry=<span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">DataType</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(ansStr.reverse().toString());</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-更简单："><a href="#4-更简单：" class="headerlink" title="4. 更简单："></a>4. 更简单：</h3><ul>
<li>int sum &#x3D; num1 + num2 + carry;</li>
<li>result.append(sum % 2);</li>
<li>carry &#x3D; sum &#x2F; 2;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">add</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">srcStr</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">destStr</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> srcStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> destStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> num1 + num2 + carry;</span><br><span class="line">        result.append(sum % <span class="number">2</span>);</span><br><span class="line">        carry = sum / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(result.reverse().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、计算两个32位二进制整数补码真值的差"><a href="#二、计算两个32位二进制整数补码真值的差" class="headerlink" title="二、计算两个32位二进制整数补码真值的差"></a>二、计算两个32位二进制整数补码真值的差</h2><ul>
<li>dest表示被减数，src表示减数(即计算dest - src)</li>
</ul>
<h3 id="1-取反操作"><a href="#1-取反操作" class="headerlink" title="1. 取反操作"></a>1. 取反操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">negation</span><span class="params">(String beforeStr)</span>&#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">afterStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">//逐位取反</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (beforeStr.charAt(i)==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            afterStr.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            afterStr.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加1</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(carry)&#123;<span class="comment">//有进位</span></span><br><span class="line">            <span class="keyword">if</span>(afterStr.charAt(i)==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                afterStr.replace(i,i+<span class="number">1</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                carry=<span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                afterStr.replace(i,i+<span class="number">1</span>,<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> afterStr.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-完整代码"><a href="#2-完整代码" class="headerlink" title="2.完整代码"></a>2.完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">sub</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    String srcStr=src.toString();</span><br><span class="line">    srcStr=negation(srcStr);</span><br><span class="line">    src = <span class="keyword">new</span> <span class="title class_">DataType</span>(srcStr);</span><br><span class="line">    <span class="keyword">return</span> add(src,dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、两个二进制整数的乘积-布斯乘法，结果低位截取后32位"><a href="#三、两个二进制整数的乘积-布斯乘法，结果低位截取后32位" class="headerlink" title="三、两个二进制整数的乘积(布斯乘法，结果低位截取后32位)"></a>三、两个二进制整数的乘积(布斯乘法，结果低位截取后32位)</h2><h3 id="1-布斯乘法"><a href="#1-布斯乘法" class="headerlink" title="1.布斯乘法"></a>1.布斯乘法</h3><ol>
<li>正负数处理：<ul>
<li>检查 src 和 dest 是否为负数，如果是负数，则将其<strong>转换为正数</strong>。</li>
</ul>
</li>
<li>初始化：<ol>
<li>初始化 <strong>resultStr</strong> 为<strong>65位字符串</strong>，其中<strong>前32位为0，后32位为 dest，并在末尾添一个0</strong>。<ul>
<li><strong>32个0+dest+0</strong></li>
</ul>
</li>
</ol>
</li>
<li>迭代计算：<ul>
<li>对 resultStr 进行<strong>32次迭代</strong>；第一次是<strong>0-最低位</strong></li>
<li>每次根据 resultStr 的最低位和次低位的组合（<strong>最低位-次低位</strong>）决定是否进行加法或减法操作。<ul>
<li>如果组合为 <strong>01（1）</strong>，则将 <strong>resultStr的高32位 + src</strong>。</li>
<li>如果组合为 10（-1），则将<strong>resultStr的高32位 - src</strong>。</li>
<li>如果组合为 11或00（0），则不变。</li>
<li>进行<strong>算术右移操作（保留符号位）</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>重复：<ul>
<li>重复上述迭代步骤，直到处理完乘数的所有位。</li>
</ul>
</li>
<li>结果：<ul>
<li>截取 resultStr 的**低32位（33~64）**作为最终结果</li>
<li>如果原始 src 和 dest 中有一个是负数，则将结果取反。</li>
</ul>
</li>
</ol>
<h3 id="2-算术右移方法："><a href="#2-算术右移方法：" class="headerlink" title="2. 算术右移方法："></a>2. 算术右移方法：</h3><ol>
<li>符号位不变</li>
<li>原本的64位整体右移</li>
</ol>
<ul>
<li>相当于<strong>前面变成两个符号位，最后一位丢掉</strong></li>
</ul>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">mul</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    String srcStr=src.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">destStr</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="comment">//1.判断正负，如果负，则标记并转为正</span></span><br><span class="line">    <span class="type">boolean</span> srcNeg=<span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> destNeg=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(srcStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">        srcNeg=<span class="literal">true</span>;</span><br><span class="line">        srcStr=negation(srcStr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(destStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">        destNeg=<span class="literal">true</span>;</span><br><span class="line">        destStr=negation(destStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.初始化</span></span><br><span class="line">    StringBuilder resultStr=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;0&quot;</span>.repeat(<span class="number">32</span>)+destStr+<span class="string">&quot;0&quot;</span>);<span class="comment">//result，32个0+dest+0组成</span></span><br><span class="line">    <span class="comment">//3.计算</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">32</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        DataType src1=<span class="keyword">new</span> <span class="title class_">DataType</span>(srcStr);</span><br><span class="line">        DataType dest1=<span class="keyword">new</span> <span class="title class_">DataType</span>(resultStr.substring(<span class="number">0</span>,<span class="number">32</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">32</span>)&#123;<span class="comment">//第1位（补充了一个0）</span></span><br><span class="line">            <span class="keyword">if</span>(destStr.charAt(<span class="number">31</span>)-<span class="string">&#x27;0&#x27;</span>==<span class="number">0</span>)&#123;<span class="comment">//0：右移</span></span><br><span class="line">                resultStr= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(rightshift(resultStr.toString()));<span class="comment">//右移</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//-1：减src，再右移</span></span><br><span class="line">                resultStr.replace(<span class="number">0</span>,<span class="number">32</span>,sub(src1,dest1).toString());</span><br><span class="line">                resultStr= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(rightshift(resultStr.toString()));<span class="comment">//右移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//其它位</span></span><br><span class="line">            <span class="keyword">if</span>(destStr.charAt(i)-destStr.charAt(i-<span class="number">1</span>)==<span class="number">0</span>)&#123;<span class="comment">//0：右移</span></span><br><span class="line">                resultStr= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(rightshift(resultStr.toString()));<span class="comment">//右移</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>  <span class="keyword">if</span>(destStr.charAt(i)-destStr.charAt(i-<span class="number">1</span>)==<span class="number">1</span>)&#123;<span class="comment">//1：加src，再右移</span></span><br><span class="line">                resultStr.replace(<span class="number">0</span>,<span class="number">32</span>,add(src1,dest1).toString());</span><br><span class="line">                resultStr= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(rightshift(resultStr.toString()));<span class="comment">//右移</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//-1：减src，再右移</span></span><br><span class="line">                resultStr.replace(<span class="number">0</span>,<span class="number">32</span>,sub(src1,dest1).toString());</span><br><span class="line">                resultStr= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(rightshift(resultStr.toString()));<span class="comment">//右移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.结果：截取低32位</span></span><br><span class="line">    String result=resultStr.substring(<span class="number">32</span>,<span class="number">64</span>);</span><br><span class="line">    <span class="comment">//正负调整</span></span><br><span class="line">    <span class="keyword">if</span>((srcNeg&amp;&amp;!destNeg)||(!srcNeg&amp;&amp;destNeg))&#123;</span><br><span class="line">        result =negation(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">rightshift</span><span class="params">(String beforeStr)</span>&#123;<span class="comment">//右移</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">afterStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    afterStr.append(beforeStr.charAt(<span class="number">0</span>));<span class="comment">//保留符号位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">64</span>;i++)&#123;</span><br><span class="line">        afterStr.append(beforeStr.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> afterStr.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、两个二进制整数的除法"><a href="#四、两个二进制整数的除法" class="headerlink" title="四、两个二进制整数的除法"></a>四、两个二进制整数的除法</h2><ul>
<li><strong>恢复余数除法</strong>和<strong>不恢复余数除法</strong>均可</li>
<li>dest ÷ src</li>
<li>将32位余数正确储存在余数寄存器remainderReg中</li>
<li>除数为0，且被除数不为0时要求能够正确抛出ArithmeticException<strong>异常</strong>。</li>
</ul>
<h3 id="1-恢复余数除法"><a href="#1-恢复余数除法" class="headerlink" title="1. 恢复余数除法"></a>1. 恢复余数除法</h3><ol start="0">
<li>（此代码中）正负调整(【Datatype】src和【String】srcStr都要)</li>
<li>初始化：<ul>
<li>被除数（Dividend）和除数（Divisor）分别存储在寄存器中。</li>
<li><strong>余数</strong>寄存器（Remainder）初始化为<strong>32位的0</strong>。</li>
<li><strong>商</strong>寄存器（Quotient）初始化为<strong>被除数</strong>。</li>
</ul>
</li>
<li>迭代：对<strong>被除数的每一位</strong>进行处理，从<strong>最高位到最低位</strong>。<ol>
<li>将<strong>余数左移一位</strong>，并将<strong>被除数的当前位移入余数的最低位</strong>。</li>
<li><strong>余数减去&#x2F;加上除数</strong>。<ul>
<li>如果余数<strong>与原本异号</strong>，则<strong>恢复余数（加回除数）</strong>，并将<strong>商的当前位设为0</strong>。</li>
<li>如果余数<strong>与原本同号</strong>，则将商的当前位<strong>设为1</strong>。</li>
</ul>
</li>
</ol>
</li>
<li>结果：<ul>
<li>（此代码中）调整<strong>余数和商的符号</strong></li>
<li>迭代完成后，商寄存器中存储的值即为商，余数寄存器中存储的值即为余数。</li>
</ul>
</li>
</ol>
<h3 id="2-不恢复余数除法"><a href="#2-不恢复余数除法" class="headerlink" title="2. 不恢复余数除法"></a>2. 不恢复余数除法</h3><ol>
<li>初始化：<ul>
<li>被除数（Dividend）和除数（Divisor）分别存储在寄存器中。</li>
<li>余数寄存器（Remainder）初始化为0。</li>
<li>商寄存器（Quotient）初始化为被除数。</li>
</ul>
</li>
<li>迭代： 对被除数的每一位进行处理，从最高位到最低位。<ol>
<li>将<strong>余数左移一位</strong>，并将<strong>被除数的当前位移入余数的最低位</strong>。</li>
<li>余数减去&#x2F;加上除数。<ul>
<li>如果余数<strong>与原本异号</strong>，则将商的当前位设为0，并在<strong>下一次迭代中将余数加回除数</strong>。</li>
<li>如果余数<strong>与原本同号</strong>，则将商的当前位设为1，并在<strong>下一次迭代中继续减去除数</strong>。</li>
</ul>
</li>
</ol>
</li>
<li>结果：<ul>
<li>根据被除数和除数的符号，调整商和余数的符号：<ul>
<li><strong>被除数和除数同号：余数+除数</strong>，商为正</li>
<li><strong>被除数和除数异号：余数-除数</strong>，商为负</li>
</ul>
</li>
<li>迭代完成后，商寄存器中存储的值即为商，余数寄存器中存储的值即为余数。</li>
</ul>
</li>
</ol>
<h3 id="3-调整余数和商的符号"><a href="#3-调整余数和商的符号" class="headerlink" title="3. 调整余数和商的符号"></a>3. 调整余数和商的符号</h3><ol>
<li><strong>余数和被除数同号</strong></li>
<li>其中<strong>一方为负，则商取负</strong></li>
</ol>
<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataType remainderReg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回两个二进制整数的除法结果</span></span><br><span class="line"><span class="comment"> * dest ÷ src</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src  32-bits</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest 32-bits</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 32-bits</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//用恢复余数除法</span></span><br><span class="line"><span class="keyword">public</span> DataType <span class="title function_">div</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">srcStr</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">destStr</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="comment">//0.判断除0情况</span></span><br><span class="line">    <span class="keyword">if</span>(srcStr.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;除0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 判断正负，如果是负就转正，并标记</span></span><br><span class="line">    <span class="type">boolean</span> srcNeg=<span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">destNeg</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(srcStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">        srcStr=negation(srcStr);</span><br><span class="line">        src=<span class="keyword">new</span> <span class="title class_">DataType</span>(srcStr);<span class="comment">//保证src也变号</span></span><br><span class="line">        srcNeg=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(destStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">        destStr=negation(destStr);</span><br><span class="line">        dest = <span class="keyword">new</span> <span class="title class_">DataType</span>(destStr);<span class="comment">//保证dest也变号</span></span><br><span class="line">        destNeg=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 初始化-商和余数寄存器</span></span><br><span class="line">    StringBuilder Shang=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(destStr);<span class="comment">//商，初始化为被除数</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">Yu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;0&quot;</span>.repeat(<span class="number">32</span>));<span class="comment">//余数，初始化为32个0</span></span><br><span class="line">    <span class="comment">//3. 计算</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//3.1左移</span></span><br><span class="line">        Yu=leftshift(Yu.toString());</span><br><span class="line">        Yu.append(Shang.charAt(<span class="number">0</span>));</span><br><span class="line">        Shang=leftshift(Shang.toString());</span><br><span class="line">        <span class="comment">//3.2 余数减去除数</span></span><br><span class="line">        String tmp=sub(src,<span class="keyword">new</span> <span class="title class_">DataType</span>(Yu.toString())).toString();</span><br><span class="line">        <span class="keyword">if</span>(tmp.charAt(<span class="number">0</span>)==<span class="string">&#x27;1&#x27;</span>)&#123;<span class="comment">//为负</span></span><br><span class="line">            Shang.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//非负</span></span><br><span class="line">            Yu=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(tmp);</span><br><span class="line">            Shang.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.结果</span></span><br><span class="line">    String YuStr= Yu.toString();</span><br><span class="line">    String ShangStr= Shang.toString();</span><br><span class="line">    <span class="comment">//被除数和余数同号</span></span><br><span class="line">    <span class="keyword">if</span>(!srcNeg&amp;&amp;destNeg)&#123;<span class="comment">//除数正，被除数负</span></span><br><span class="line">        YuStr=negation(YuStr);</span><br><span class="line">        ShangStr=negation(ShangStr);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (srcNeg&amp;&amp;!destNeg) &#123;<span class="comment">//除数负，被除数正</span></span><br><span class="line">        ShangStr=negation(YuStr);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(srcNeg&amp;&amp;destNeg)&#123;<span class="comment">//都是负</span></span><br><span class="line">        YuStr=negation(YuStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remainderReg=<span class="keyword">new</span> <span class="title class_">DataType</span>(YuStr);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(ShangStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左移</span></span><br><span class="line"><span class="keyword">public</span> StringBuilder <span class="title function_">leftshift</span><span class="params">(String beforeStr)</span>&#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">afterStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">32</span>;i++)&#123;<span class="comment">//跳过第一位</span></span><br><span class="line">        afterStr.append(beforeStr.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> afterStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>三、OSI第二层：数据链路层</title>
    <url>/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<h1 id="Layer2-Data-Link-Layer"><a href="#Layer2-Data-Link-Layer" class="headerlink" title="Layer2:Data Link Layer"></a>Layer2:Data Link Layer</h1><ul>
<li>Overview</li>
<li>Ethernet and CSMA&#x2F;CD<ul>
<li>LLC and MAC Sub-layers</li>
<li>Media Access Control in MAC Sub-layer</li>
</ul>
</li>
<li>Wireless LAN and CSMA&#x2F;CA</li>
<li>Layer 2 Devices</li>
</ul>
<h1 id="一、数据链路层-Overview"><a href="#一、数据链路层-Overview" class="headerlink" title="一、数据链路层 Overview"></a>一、数据链路层 Overview</h1><ul>
<li>数据链路层使用的信道：<ul>
<li>点对点信道：一对一</li>
<li>广播信道：一对多</li>
</ul>
</li>
<li>本章研究：局域网的数据链路层的技术标准</li>
<li>主要是以太网的介质和无线网的介质两大类。<br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="1-物理层和数据链路层的区别"><a href="#1-物理层和数据链路层的区别" class="headerlink" title="1. 物理层和数据链路层的区别"></a>1. 物理层和数据链路层的区别</h2><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-8.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>第一层<ul>
<li>无法与上层通信    </li>
<li>无法确定哪台主机将会传输或接受二进制数据    </li>
<li>无法命名或标识主机    </li>
<li>仅仅能描述比特流</li>
</ul>
</li>
<li>第二层<ul>
<li>通过LLC与上层通信</li>
<li>通过MAC确定</li>
<li>通过寻址或命名过程来实现</li>
<li>通过帧来组织&#x2F;分组比特</li>
</ul>
</li>
</ul>
<h2 id="2-数据链路层-Data-Link-Layer"><a href="#2-数据链路层-Data-Link-Layer" class="headerlink" title="2. 数据链路层 Data Link Layer"></a>2. 数据链路层 Data Link Layer</h2><ol>
<li>问题：如何在不稳定(instable)的链路上正确传输数据？</li>
<li>数据链路层提供<ul>
<li>网络介质访问:</li>
<li>跨媒体物理传输(transmission)</li>
</ul>
</li>
<li>第二层协议明确了<ul>
<li>在链路上<strong>交换的数据格式</strong></li>
<li>链路上的<strong>两个节点的行为</strong></li>
</ul>
</li>
<li>在数据链路层，<em>过程就是协议</em>。</li>
<li>在两端<strong>校验</strong>，帧是否正确，如果正确则交付第三层，否则进行相应的处理</li>
</ol>
<h2 id="3-局域网和数据链路"><a href="#3-局域网和数据链路" class="headerlink" title="3. 局域网和数据链路"></a>3. 局域网和数据链路</h2><ol>
<li>主要工作<ul>
<li><strong>错误识别(notification)</strong></li>
<li><strong>网络拓扑(Network topology)</strong></li>
<li><strong>流控制(Flow control)</strong></li>
</ul>
</li>
<li>第一层和第二层的不同:<ul>
<li>第一层不可以<strong>访问更高层</strong>(upper-level layers)，而第二层是通过<strong>逻辑链路LLC</strong>(Logical Link Control)访问更高层</li>
<li>第1层<strong>无法决定哪个主机</strong>将发送(transmit)或接收(receive)来自组的二进制数据；第2层使用<strong>媒体访问控制MAC</strong>（Media Access Control）做到这一点，共用总线链路</li>
<li>第1层无法命名或识别计算机；<strong>第2层使用寻址(或命名)过程</strong>，以太网场景下</li>
<li>第1层只能描述比特流；第2层使用**成帧（framing）**对比特进行组织或分组。</li>
</ul>
</li>
</ol>
<h2 id="4-第二层提供的服务"><a href="#4-第二层提供的服务" class="headerlink" title="4. 第二层提供的服务"></a>4. 第二层提供的服务</h2><ol>
<li>提供给<strong>网络层</strong>的三层服务<ol>
<li>(最弱，最不靠谱的)<strong>没有确认(acknowledgement)的无连接(Connectionless)服务</strong><ul>
<li>发送取出就行，不用等收到确认</li>
<li><strong>可靠(Reliable)的链接</strong>(上层以确保数据正确性)</li>
<li><strong>实时</strong>任务，比较高效</li>
<li>适用于大多数<strong>局域网</strong></li>
</ul>
</li>
<li><strong>带有确认的无连接服务</strong>：<ul>
<li><strong>不可靠</strong>的链接，例如<strong>无线网络</strong>：需要保证一定的通信质量(比如无线网络的传输)，同时会损失一定的性能。</li>
</ul>
</li>
<li><strong>带有确认的连接服务</strong><ul>
<li>比如蓝牙:需要先确定绑定关系才能进行通信</li>
<li>手机和手机之间的蓝牙连接需要确定一些信息</li>
</ul>
</li>
</ol>
</li>
<li>三种服务的连接的不同和区别:<ul>
<li><strong>无线连接</strong>有<strong>确认</strong>的过程，<strong>有线连接没有</strong></li>
<li><strong>网线连接</strong>:我们通信的对象是<strong>路由器</strong>，由路由器进行转发</li>
<li>PPPoP是<strong>路由器和远端</strong>的服务器的连接</li>
<li>有线无线都接给路由器，都需要连接，但是无线网相对有线网需要确认(包确认)</li>
</ul>
</li>
</ol>
<h2 id="5-常见的局域网的介质访问控制-Media-Access-Control-in-common-LANs"><a href="#5-常见的局域网的介质访问控制-Media-Access-Control-in-common-LANs" class="headerlink" title="5. 常见的局域网的介质访问控制(Media Access Control in common LANs)"></a>5. 常见的局域网的介质访问控制(Media Access Control in common LANs)</h2><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-9.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>以太网(Ethernet):<ul>
<li>逻辑：<strong>总线拓扑</strong>(信息流在线性总线上)</li>
<li>物理：星形或扩展星形(连线为星形)</li>
</ul>
</li>
<li>令牌环(Token Ring):<ul>
<li>逻辑：<strong>环拓扑</strong>(信息流在一个环中)</li>
<li>物理：星形拓扑(以星形连接)</li>
<li>使用令牌传递机制来控制网络访问</li>
</ul>
</li>
<li>光纤分布式数据接口(FDDI, Fiber Distributed Data Interface):<ul>
<li>逻辑：<strong>环拓扑</strong>(信息流在一个环中)</li>
<li>物理：双环拓扑(作为双环连接)</li>
<li>光纤作为传输介质，曾经很常用，后来被以太网有线接入逐渐替代</li>
</ul>
</li>
</ol>
<h2 id="6-介质访问控制方法-Access-Methods-for-Media-Access-Control"><a href="#6-介质访问控制方法-Access-Methods-for-Media-Access-Control" class="headerlink" title="6. 介质访问控制方法 Access Methods for Media-Access Control"></a>6. 介质访问控制方法 Access Methods for Media-Access Control</h2><ol>
<li><strong>确定性轮流 Deterministic</strong> —— taking turns<ul>
<li>Token Ring 和 FDDI(Fiber Distributed Data Interface)</li>
</ul>
</li>
<li><strong>争用式 Non-deterministic (probabilistic)</strong> —— 先到先得 first come, first sesrved<ul>
<li>Ethernet&#x2F;802.3</li>
</ul>
</li>
</ol>
<h3 id="6-1-确定性轮流-Deterministic-MAC-Protocols"><a href="#6-1-确定性轮流-Deterministic-MAC-Protocols" class="headerlink" title="6.1 确定性轮流 Deterministic MAC Protocols"></a>6.1 确定性轮流 Deterministic MAC Protocols</h3><ol>
<li>一个特殊的<strong>数据令牌token在环中循环(circulates)</strong>。</li>
<li>当主机host收到令牌时，它可以传输数据而不是令牌。这称为“<strong>夺取(seizing)令牌</strong>”。</li>
<li>当<strong>传输的帧回到发送者</strong>时，站点会<strong>传输一个新的令牌</strong>；<ul>
<li>帧会从环中移除或剥离。(stripped)。</li>
</ul>
</li>
</ol>
<h3 id="6-2-非确定性MAC协议-Non-Deterministic-MAC-Protocols"><a href="#6-2-非确定性MAC协议-Non-Deterministic-MAC-Protocols" class="headerlink" title="6.2 非确定性MAC协议 Non-Deterministic MAC Protocols"></a>6.2 非确定性MAC协议 Non-Deterministic MAC Protocols</h3><ul>
<li>【重要！】此MAC协议称为<strong>载波监听多路访问&#x2F;碰撞检测(CSMA&#x2F;CD)</strong>，即<strong>带冲突检测的载波侦听多路访问</strong><ul>
<li>Carrier Sense Multiple Access with Collision Detection</li>
</ul>
</li>
<li>为了使用这种共享介质(shared-medium)技术，以太网允许网络设备为传输权进行仲裁(arbitrate)。</li>
</ul>
<h2 id="7-局域网数据传输-Transmitison-方式-三种"><a href="#7-局域网数据传输-Transmitison-方式-三种" class="headerlink" title="7. 局域网数据传输(Transmitison)方式: 三种"></a>7. 局域网数据传输(Transmitison)方式: 三种</h2><ol>
<li><strong>单播(unicast)</strong><ul>
<li>将<strong>单个数据包</strong>从<strong>源</strong>发送到<strong>网络上的单个目标</strong></li>
</ul>
</li>
<li><strong>多播(multicast)</strong><ul>
<li>由发送到网络上特定节点子集的单个数据包组成，这些节点都有同样的进程进行响应</li>
<li>发送<strong>单个数据包</strong>到<strong>网络上的特定子集节点</strong>。</li>
</ul>
</li>
<li><strong>广播(broadcast)</strong><ul>
<li>由单个数据包组成，该数据包传输到网络上的所有节点。(广播的目的地址是0x11111111)</li>
<li>发送<strong>单个数据包</strong>到<strong>网络上的所有节点</strong></li>
</ul>
</li>
</ol>
<hr>
<h1 id="二、-以太网-和-带冲突检测的载波侦听多路访问-Ethernet-and-CSMA-CD"><a href="#二、-以太网-和-带冲突检测的载波侦听多路访问-Ethernet-and-CSMA-CD" class="headerlink" title="二、 以太网 和 带冲突检测的载波侦听多路访问 Ethernet and CSMA&#x2F;CD"></a>二、 以太网 和 带冲突检测的载波侦听多路访问 Ethernet and CSMA&#x2F;CD</h1><h2 id="（一）逻辑链路和介质访问控制子层-LLC-and-MAC-Sub-layers"><a href="#（一）逻辑链路和介质访问控制子层-LLC-and-MAC-Sub-layers" class="headerlink" title="（一）逻辑链路和介质访问控制子层 LLC and MAC Sub-layers"></a>（一）逻辑链路和介质访问控制子层 LLC and MAC Sub-layers</h2><ul>
<li>(Logical Link Control)(Media Access Control)</li>
</ul>
<ol>
<li>无缘电缆的方式传播电波:以太网</li>
<li>帧传播速度提高了</li>
<li>帧的标准没有改变</li>
</ol>
<h3 id="1-局域网标准"><a href="#1-局域网标准" class="headerlink" title="1. 局域网标准"></a>1. 局域网标准</h3><ul>
<li>定义<strong>物理媒体</strong>（如双绞线、光纤）和用于将设备连接到媒体的<strong>连接器</strong></li>
<li>定义<strong>设备在数据链路层的通信方式</strong></li>
<li>数据链路层定义了如何<strong>在物理介质上传输数据</strong>。</li>
<li>数据链路层还定义了<strong>如何封装(encapsulate)特定协议的流量(traffic)</strong>，以使去往不同上层协议的流量在到达堆栈时可以使用相同的通道进行传输。<br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-10.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>IEEE 802.2 对应 LLC，以太网则覆盖物理层和链路层</li>
</ul>
<ol>
<li><strong>IEEE 将数据链路层分为两部分</strong>：<ul>
<li><strong>媒体访问控制（MAC）</strong>（转换为媒体）</li>
<li><strong>逻辑链路控制（LLC）</strong>（过渡到网络层）</li>
</ul>
</li>
<li>乍一看，IEEE 标准似乎以两种方式违反了 OSI 模型。<ol>
<li><strong>定义了自己的层（LLC）</strong>：<ul>
<li>IEEE标准定义了逻辑链路控制（LLC）层，包括其接口等，这似乎与OSI模型的层次结构不一致。</li>
</ul>
</li>
<li><strong>MAC层标准跨越了第2层和第1层的接口</strong>：<ul>
<li>IEEE 802.3（以太网）和802.5（令牌环）标准似乎跨越了数据链路层（第2层）和物理层（第1层）的接口。</li>
</ul>
</li>
</ol>
</li>
<li>但是，802.3 和 802.5 定义了用于构建特定技术的命名，框架和媒体访问控制规则，都规范了对应的方案，不同方案不同解决标准</li>
</ol>
<h3 id="2-MAC-LLC"><a href="#2-MAC-LLC" class="headerlink" title="2. MAC &amp; LLC"></a>2. MAC &amp; LLC</h3><ul>
<li>MAC子层负责数据链路层的 <strong>物理传输</strong> 和 <strong>访问控制</strong>，其主要作用是确保数据能够有效地从源设备传送到目标设备。</li>
</ul>
<ol>
<li>MAC子层(802.3)<ul>
<li>定义如何在<strong>物理线路</strong>上<strong>传输帧(frames)</strong></li>
<li>处理<strong>物理寻址</strong><ul>
<li>在MAC子层中，设备是通过 MAC地址 来唯一标识的，MAC地址是硬件设备的唯一标识符，每个网络接口控制器（NIC）都有一个固定的MAC地址。当数据帧从一个设备发送到另一个设备时，MAC子层根据目标设备的MAC地址进行物理寻址。</li>
</ul>
</li>
<li><strong>定义网络拓扑</strong></li>
<li><strong>定义线路规则(discipline)</strong></li>
</ul>
</li>
</ol>
<ul>
<li>LLC子层则位于MAC子层之上，主要负责对数据的逻辑控制与协议管理</li>
</ul>
<ol start="2">
<li>LLC 子层(802.2)<ul>
<li><strong>为不同的上层协议提供逻辑上的标识</strong>，然后将其<strong>封装encapsulates</strong>，兼容不同介质的访问<ul>
<li>LLC会在数据帧中添加适当的标识符，使得上层协议能够知道数据的类型。</li>
</ul>
</li>
<li>使用SAP（Service Access Point）标识符用于标识数据包的接收方。<ul>
<li>它帮助MAC层识别数据包的目的地协议，指示它应该交给哪个上层协议进行处理。</li>
</ul>
</li>
<li>LLC帧的类型取决于上层协议期望的标识符，对于上层服务进行支持</li>
<li>LLC已经比较规范了，后来有的厂商已经放弃继续做</li>
</ul>
</li>
</ol>
<h2 id="（一-1）Media-Access-Control-Sublayer-介质访问控制子层"><a href="#（一-1）Media-Access-Control-Sublayer-介质访问控制子层" class="headerlink" title="（一.1）Media Access Control Sublayer 介质访问控制子层"></a>（一.1）Media Access Control Sublayer 介质访问控制子层</h2><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-1.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>以字节为单位进行<strong>帧结构描述</strong><ul>
<li>确保数据能够正确封装和解封装。</li>
</ul>
</li>
<li>有802.3的规范和以太网的规范</li>
<li>MAC 介质访问控制子层的帧结构<ul>
<li>控制多个设备如何共享同一物理介质，避免冲突和碰撞。</li>
</ul>
</li>
<li>物理地址寻址：<ul>
<li>使用MAC地址（物理地址）来唯一标识网络设备，确保数据帧能够正确传输到目标设备。</li>
</ul>
</li>
</ul>
<h3 id="1-前导码Preamble（8字节）"><a href="#1-前导码Preamble（8字节）" class="headerlink" title="1. 前导码Preamble（8字节）"></a>1. 前导码Preamble（8字节）</h3><ol>
<li>格式：从1和0的交替(alternating)模式开始，称为前同步码(preamble)。<ul>
<li><strong>告诉接收方，要来数据了</strong>，因为不是预约发数据的模式，这个码就是为了保证对方有相应准备时间，</li>
<li><strong>前面7个字节是0x10101010</strong>，用于进行<strong>时钟同步</strong></li>
<li>Start Frame Delimiter (SFD)（前导码）：<strong>最后一个字节是0x10101011</strong>，表示帧的开始，并且为接收方提供时钟同步的最后信号。</li>
</ul>
</li>
<li>作用：<ul>
<li>使用曼彻斯特编码的方案，无传输的时候是0电平的</li>
<li>前同步码告诉接收站一帧即将到来。</li>
</ul>
</li>
</ol>
<h3 id="2-目标和源物理地址字段-Dest-add-和-Source-add-（6字节-6字节）"><a href="#2-目标和源物理地址字段-Dest-add-和-Source-add-（6字节-6字节）" class="headerlink" title="2. 目标和源物理地址字段 Dest.add. 和 Source add.（6字节+6字节）"></a>2. 目标和源物理地址字段 Dest.add. 和 Source add.（6字节+6字节）</h3><ol>
<li>目的地址：单播地址，组播地址或广播地址。<ul>
<li>用于标识<strong>接收数据的设备的MAC地址</strong></li>
</ul>
</li>
<li>源地址：始终是<strong>单播地址</strong>。<ul>
<li>用于标识<strong>发送数据的设备的MAC地址</strong>。</li>
</ul>
</li>
</ol>
<ul>
<li>MAC地址：<strong>6个字节目的地址(Dest.add) 6个字节源地址(Source.add.)</strong>，和第三层第四层报文有差别</li>
<li><strong>先看目的地址</strong>的好处:交换机等看到目的地址就可以进行判断，<code>提高效率</code></li>
</ul>
<h3 id="3-长度字段Length（2字节）"><a href="#3-长度字段Length（2字节）" class="headerlink" title="3. 长度字段Length（2字节）"></a>3. 长度字段Length（2字节）</h3><ul>
<li>长度字段指示<strong>在该字段之后</strong>且<strong>在帧检查序列字段(FCS)之前</strong>的<strong>数据字节数</strong>。</li>
<li>确保接收方知道<strong>数据字段的长度</strong>，从而能够正确地解析和处理数据。</li>
</ul>
<h3 id="4-数据字段Data（字节长度可变）"><a href="#4-数据字段Data（字节长度可变）" class="headerlink" title="4. 数据字段Data（字节长度可变）"></a>4. 数据字段Data（字节长度可变）</h3><ul>
<li>数据字段<strong>包含要发送的信息</strong>。</li>
<li>若数据小于46字节，必须通过 填充 零来满足最小长度要求，确保帧的大小达到64字节。</li>
<li>以太网帧头部的前8个字节（如MAC地址、类型字段等）不算作数据字段内容。</li>
<li>发送多个64字节大小的帧可以确保链路带宽的有效利用，尤其在100M带宽的链路上，发送这些帧需要512微秒，占据了完整的传输带宽。</li>
</ul>
<h3 id="5-FCS字段（4个字节）"><a href="#5-FCS字段（4个字节）" class="headerlink" title="5. FCS字段（4个字节）"></a>5. FCS字段（4个字节）</h3><ul>
<li><strong>FCS（Frame Check Sequence，帧检验序列）</strong></li>
<li>FCS字段(四个字节)包含一个<strong>循环冗余校验值(CRC，cyclic redundancy check)</strong><ul>
<li>用于检测<strong>数据帧在传输过程中是否发生了错误</strong></li>
</ul>
<ol>
<li>发送设备生成CRC。</li>
<li>接收设备重新计算CRC，以检查在传输过程中帧是否发生了损坏。</li>
</ol>
</li>
</ul>
<h2 id="（一-2）LLC-逻辑链路控制子层"><a href="#（一-2）LLC-逻辑链路控制子层" class="headerlink" title="（一.2）LLC 逻辑链路控制子层"></a>（一.2）LLC 逻辑链路控制子层</h2><ul>
<li><strong>通信管理</strong>：逻辑链路控制（LLC）子层<strong>管理设备之间在单一链路上的通信</strong>。</li>
<li><strong>支持连接和无连接服务</strong>：<ul>
<li>无连接服务：类似于不需要建立正式连接的通信方式（例如UDP协议）。数据直接被发送，没有需要额外的握手或确认过程。</li>
<li>面向连接的服务：类似于需要事先建立连接的通信方式（例如TCP协议）。在数据传输前，设备需要进行连接建立、数据确认等操作。</li>
</ul>
</li>
<li>LLC子层允许数据链路层的一部分独立于现有技术进行工作。<ul>
<li>单个LLC子层可以与不同的MAC子层兼容。</li>
</ul>
</li>
<li>LLC子层的位置：位于MAC之上<ul>
<li>MAC层与物理层交互, LLC层与网络层交互</li>
</ul>
</li>
</ul>
<h3 id="1-LLC子层：封装"><a href="#1-LLC子层：封装" class="headerlink" title="1. LLC子层：封装"></a>1. LLC子层：封装</h3><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-11.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>LLC接收网络协议数据（数据包，packet），并添加更多的控制信息，帮助将数据包传递到目的地。</li>
<li>它在每端添加了IEEE 802.2标准中的两个地址组件，以标识上层协议：<ul>
<li>目标服务接入点（DSAP）</li>
<li>源服务接入点（SSAP）</li>
</ul>
</li>
<li>然后，这些重新封装的数据会传递给MAC子层，进行进一步的数据封装。</li>
</ol>
<h2 id="（二）-MAC子层上的介质访问控制-Media-Access-Control-in-MAC-Sub-layer"><a href="#（二）-MAC子层上的介质访问控制-Media-Access-Control-in-MAC-Sub-layer" class="headerlink" title="（二） MAC子层上的介质访问控制 Media Access Control in MAC Sub-layer"></a>（二） MAC子层上的介质访问控制 Media Access Control in MAC Sub-layer</h2><h3 id="1-十六进制数-Hexadecimal-作为MAC地址"><a href="#1-十六进制数-Hexadecimal-作为MAC地址" class="headerlink" title="1. 十六进制数(Hexadecimal)作为MAC地址"></a>1. 十六进制数(Hexadecimal)作为MAC地址</h3><ul>
<li>MAC地址<ul>
<li>MAC地址为48位</li>
<li>始终表示为<strong>12个十六进制数字</strong>。</li>
<li>分隔符：MAC地址的各个字节之间通常用冒号（:）或连字符（-）分隔。</li>
</ul>
</li>
<li>MAC地址的组成部分<ol>
<li><strong>组织唯一标识符（OUI）</strong>：<ul>
<li>前6个十六进制数字（从左到右），由IEEE管理，用于标识<strong>制造商</strong>或<strong>供应商</strong>，这部分被称为组织唯一标识符（OUI）。</li>
<li>例如：<code>00:1A:2B</code>。</li>
</ul>
</li>
<li><strong>接口序列号</strong>：<ul>
<li>剩下的6个十六进制数字组成了接口序列号，由具体的供应商管理，用于唯一标识设备。</li>
<li>例如：<code>3C:4D:5E</code>。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-12.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="2-以太网802-3广播"><a href="#2-以太网802-3广播" class="headerlink" title="2. 以太网802.3广播"></a>2. 以太网802.3广播</h3><ul>
<li>以太网802.3广播是指在以太网网络中，将数据帧发送给网络中的所有设备。</li>
</ul>
<ol>
<li>广播Broadcast<ul>
<li>目标MAC：48位全1(<code>FFFF.FFFF.FFFF</code>)<ul>
<li>保证<strong>所有设备</strong>都能收到这个地址</li>
<li>会导致非目的主机进行地址解析</li>
</ul>
</li>
</ul>
</li>
<li>广播会<em>不必要地打断</em> 电台(stations)，从而<strong>严重影响电台的性能</strong></li>
<li>因此，<strong>仅在以下情况下才使用</strong>广播：<ul>
<li><strong>目的地的MAC地址未知</strong></li>
<li><strong>T目的地是所有主机</strong></li>
</ul>
</li>
<li>非必要情况下我们不希望有很多广播，有可能会导致广播风暴</li>
</ol>
<h3 id="3-帧结构-Framing"><a href="#3-帧结构-Framing" class="headerlink" title="3. 帧结构 Framing"></a>3. 帧结构 Framing</h3><ul>
<li>帧结构是 数据链路层（Layer 2） 的<strong>封装</strong>过程。</li>
<li>一帧A frame是数据链路层<strong>协议数据单元（PDU）</strong>。</li>
<li>一帧由多个部分（字段）组成，每个字段由字节构成。<ul>
<li>帧开始字段（frame start field）</li>
<li>地址字段（address field）</li>
<li>长度&#x2F;类型&#x2F;控制字段（length&#x2F;type&#x2F;control field）</li>
<li>数据字段（data field）</li>
<li>帧检验序列字段（frame check sequence field）</li>
<li>帧停止字段（frame stop field）<br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-13.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
<h3 id="4-以太网的MAC机制-CSMA-CD"><a href="#4-以太网的MAC机制-CSMA-CD" class="headerlink" title="4. 以太网的MAC机制 CSMA&#x2F;CD"></a>4. 以太网的MAC机制 CSMA&#x2F;CD</h3><ol>
<li>历史（略）</li>
<li>CSMA&#x2F;CD（载波侦听多路访问&#x2F;碰撞检测）<ul>
<li>使用CSMA机制来判断主机是否应该发送数据。</li>
<li>在传输过程中，同时监听信道。<ul>
<li>当检测到碰撞时，广播干扰信号jam signal。</li>
<li>回退算法，确定发生碰撞的站点何时可以重新发送数据。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="5-以太网操作"><a href="#5-以太网操作" class="headerlink" title="5. 以太网操作"></a>5. 以太网操作</h3><ol>
<li>以太网是<strong>广播网络</strong>，也就是说，<strong>每个站都可以看到所有帧</strong>，而不管它们是否是目的地</li>
<li>通过 <strong>MAC 地址</strong>判断站点是否为<strong>目的地</strong></li>
<li>目标站在 OSI 层上发送数据。其他节点<strong>丢弃</strong>（discard）帧<br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-14.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<ul>
<li>上图中1是总线拓扑，1发送的数据帧会传达给所有在这个总线上的设备，非目的主机检查目的地址和本机MAC地址不同，则会将该帧丢弃。</li>
</ul>
<h3 id="6-广播操作步骤"><a href="#6-广播操作步骤" class="headerlink" title="6. 广播操作步骤"></a>6. 广播操作步骤</h3><ol>
<li>听然后传送</li>
<li>广播 jam 信号</li>
<li>发生碰撞(Collision)</li>
<li>设备退回(back off)适当的时间，然后重新传输(retransmit)发生冲突的设备<ul>
<li>根据特定的回退算法<br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-15.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ol>
<h3 id="7-以太网的-CSMA-CD"><a href="#7-以太网的-CSMA-CD" class="headerlink" title="7. 以太网的 CSMA&#x2F;CD"></a>7. 以太网的 CSMA&#x2F;CD</h3><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-16.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>首先host设备要发送数据</li>
<li>开始侦听链路是非忙，如果忙，则过一阵来再看看</li>
<li>如果不忙，则开始准备发送<ul>
<li>如果有冲突，则到 9，表示有冲突发送，广播一个 jam signal，把自己尝试的次数 + 1（重发有一定限度）</li>
<li>尝试次数过多（11），会像上层协议传输网络不可用（12）</li>
<li>尝试次数还可，则到 13 计算一个回退时间，来再次尝试，回退时间单位，会保证 A 和 D 的时间差能保证第一个人已经用完电路来避免冲突。</li>
</ul>
</li>
<li>如果没有错误，则一直传输到结束为止</li>
</ol>
<hr>
<h1 id="三、无线局域网Wireless-LAN和CSMA-CA"><a href="#三、无线局域网Wireless-LAN和CSMA-CA" class="headerlink" title="三、无线局域网Wireless LAN和CSMA&#x2F;CA"></a>三、无线局域网Wireless LAN和CSMA&#x2F;CA</h1><h2 id="（一）无线（Wireless）局域网"><a href="#（一）无线（Wireless）局域网" class="headerlink" title="（一）无线（Wireless）局域网"></a>（一）无线（Wireless）局域网</h2><h3 id="1-无线局域网"><a href="#1-无线局域网" class="headerlink" title="1. 无线局域网"></a>1. 无线局域网</h3><ul>
<li>基于单元的通信</li>
<li>电台发送的信号只能被附近的电台接收</li>
<li>短距离传输</li>
</ul>
<h3 id="2-无线局域网标准"><a href="#2-无线局域网标准" class="headerlink" title="2. 无线局域网标准"></a>2. 无线局域网标准</h3><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-17.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Wireless LAN Standard<ul>
<li>IEEE 802.11<ul>
<li>一种关键技术：直接序列扩频（DSSS）</li>
<li>DSSS适用于在1到2 Mbps范围内运行的无线设备。</li>
<li>DSSS可以在高达11 Mbps的速率下运行，但在超过2 Mbps时将不被视为合规。</li>
<li>也称为Wi-Fi™。</li>
</ul>
</li>
<li>IEEE 802.11b<ul>
<li>提高了传输能力，达到11 Mbps。</li>
<li>所有802.11b系统向后兼容，支持802.11的1 Mbps和2 Mbps数据速率，仅适用于DSSS。</li>
<li>通过使用不同于802.11的编码技术实现更高的数据吞吐率。</li>
<li>在2.4 GHz频段内运行。</li>
</ul>
</li>
<li>IEEE 802.11a<ul>
<li>覆盖在5 GHz传输频段内运行的无线局域网设备。</li>
<li>使用5 GHz频段。</li>
<li>802.11a能够提供54 Mbps的数据吞吐量，并且通过称为“速率倍增”的专有技术实现了108 Mbps。</li>
<li>实际上，更标准的速率为20-26 Mbps</li>
</ul>
</li>
<li>IEEE 802.11g<ul>
<li>提供与802.11a相同的吞吐量（54 Mbps），但向后兼容802.11b。</li>
<li>使用正交频分复用（OFDM）技术。</li>
</ul>
</li>
<li>IEEE 802.11n<ul>
<li>下一代无线局域网（WLAN）。</li>
<li>提供比802.11g双倍的带宽，即108 Mbps，理论上可达500-600 Mbps。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-Wireless-LAN-Topology-拓扑"><a href="#3-Wireless-LAN-Topology-拓扑" class="headerlink" title="3. Wireless LAN Topology 拓扑"></a>3. Wireless LAN Topology 拓扑</h3><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-18.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><strong>基础设施模式（Infrastructure Mode）</strong></li>
</ol>
<ul>
<li><strong>定义</strong>：设备通过无线接入点（AP）连接到网络。</li>
<li><strong>特点</strong>：<ul>
<li>中心化管理：所有通信都通过AP进行。</li>
<li>更适合大规模网络：支持更多设备和更广的覆盖范围。</li>
<li>提供更高的安全性和管理功能。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>自组织模式（Ad-hoc Mode）</strong></li>
</ol>
<ul>
<li><strong>定义</strong>：设备直接相互连接，不需要AP。</li>
<li><strong>特点</strong>：<ul>
<li>点对点通信：设备之间直接通信。</li>
<li>适合小规模网络：适用于临时或小范围的网络。</li>
<li>部署简单：无需额外的网络设备。</li>
</ul>
</li>
</ul>
<h3 id="4-访问过程（Accessing-Procedure）"><a href="#4-访问过程（Accessing-Procedure）" class="headerlink" title="4. 访问过程（Accessing Procedure）"></a>4. 访问过程（Accessing Procedure）</h3><ul>
<li>在 WLAN 中激活客户端时，它将开始“侦听”与之“关联”的兼容设备</li>
<li>这被称为“<strong>扫描</strong>”<ul>
<li><strong>主动扫描</strong></li>
<li><strong>被动扫描</strong></li>
</ul>
</li>
</ul>
<h4 id="4-1-主动扫描-Active-scanning"><a href="#4-1-主动扫描-Active-scanning" class="headerlink" title="4.1. 主动扫描 Active scanning"></a>4.1. 主动扫描 Active scanning</h4><ul>
<li>导致从寻求加入网络的无线节点发送探测（probe）请求。</li>
<li>探测请求将包含它希望加入的网络的服务集标识符（SSID）</li>
<li>当找到具有相同 SSID 的**接入点（AP）**时，该 AP 将发出探测响应</li>
<li>完成认证和关联步骤。</li>
</ul>
<h4 id="4-2-被动扫描-Passive-scanning"><a href="#4-2-被动扫描-Passive-scanning" class="headerlink" title="4.2. 被动扫描 Passive scanning"></a>4.2. 被动扫描 Passive scanning</h4><ol>
<li>客户端监听接入点（AP）广播的信标帧。这些帧由AP（基础设施模式）或对等节点（自组织模式）发送。</li>
<li>当节点接收到包含要尝试加入的网络的 SSID 的信标时，将尝试加入该网络。</li>
<li>被动扫描是一个连续的过程，节点可能会随着信号强度的变化与AP关联或取消关联。</li>
</ol>
<h3 id="5-无线局域网的帧结构"><a href="#5-无线局域网的帧结构" class="headerlink" title="5. 无线局域网的帧结构"></a>5. 无线局域网的帧结构</h3><ul>
<li>WLAN不使用标准的802.3帧。</li>
<li>有三种类型的帧：<ul>
<li><strong>控制帧（Control Frames）</strong></li>
<li><strong>管理帧（Management Frames）</strong></li>
<li><strong>数据帧（Data Frames，只有数据帧类似于802.3帧）</strong></li>
</ul>
</li>
<li>无线数据帧和802.3帧的有效载荷为1500字节。<ul>
<li>然而，以太网帧不得超过1518字节，而无线帧可以大到2346字节。</li>
<li>通常无线局域网帧的大小将限制在1518字节，因为它最常连接到有线以太网网络。</li>
</ul>
</li>
</ul>
<h4 id="5-1-数据帧结构-802-11-无线网"><a href="#5-1-数据帧结构-802-11-无线网" class="headerlink" title="5.1. 数据帧结构(802.11 无线网)"></a>5.1. 数据帧结构(802.11 无线网)</h4><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-2.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><strong>帧控制</strong><ul>
<li>帧控制信息包含 16 bit（2字节）</li>
<li>去往AP和来自AP是我们需要重点确认</li>
<li>WEP规格，Wired Equivalent Privacy(有线等效保密)</li>
<li>持续期:参数，很重要，CSMA&#x2F;CA需要，这个信息</li>
<li>有时间窗口，如果超时没收到信号，则进行重传</li>
</ul>
</li>
<li><strong>数据帧的的地址分类</strong><ol>
<li>ad hoc(无线网地址)用地址4</li>
<li>有基础设施(<code>AP</code>)用的是地址1、2、3</li>
</ol>
</li>
<li><strong>数据帧中的地址详解</strong><br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-19.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<h2 id="（二）CSMA-CA"><a href="#（二）CSMA-CA" class="headerlink" title="（二）CSMA&#x2F;CA"></a>（二）CSMA&#x2F;CA</h2><h3 id="1-为什么我们在WLAN需要CSMA-CA？"><a href="#1-为什么我们在WLAN需要CSMA-CA？" class="headerlink" title="1. 为什么我们在WLAN需要CSMA&#x2F;CA？"></a>1. 为什么我们在WLAN需要CSMA&#x2F;CA？</h3><ul>
<li>CSMA&#x2F;CA（载波侦听多路访问&#x2F;碰撞避免）是无线网络中解决碰撞问题的一种机制。</li>
<li>与有线以太网（Ethernet）中的 CSMA&#x2F;CD 不同，无线网络中的 CSMA&#x2F;CD 机制不起作用，原因在于无线信号的传播特性。</li>
</ul>
<ol>
<li>碰撞(Collisions)可能发生在WLAN中，但是站点只能知道附近的传输，因此CSMA&#x2F;CD不是一个好的选择。<ol>
<li><strong>隐藏站问题</strong>（Hidden Station Problem）:当A将数据传输到B时，C无法检测到A和B之间的传输，因此C可能会决定将数据传输到B并导致B发生碰撞。</li>
<li><strong>暴露站问题</strong>（Exposed Station Problem）:当B将数据传输到A时，C可以检测到传输，因此C不会将数据传输到D。但这是一个错误。(<strong>听到不应该听到的信号</strong>)<br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
</li>
</ol>
<h3 id="2-多路复用机制-Multiple-Accessing-Mechanism"><a href="#2-多路复用机制-Multiple-Accessing-Mechanism" class="headerlink" title="2. 多路复用机制 Multiple Accessing Mechanism"></a>2. 多路复用机制 Multiple Accessing Mechanism</h3><ol>
<li>在Ethernet中：<ul>
<li><strong>信号传输</strong>：在以太网中，信号会被传输到网络中的<strong>所有站点</strong>。</li>
<li><strong>碰撞检测</strong>：<strong>发送站点检测</strong>碰撞的发生。</li>
<li><strong>共享信道</strong>：在同一时间，<strong>只能有一个有效的帧</strong>（数据包）在信道上传输。</li>
</ul>
</li>
<li>WLAN (无线局域网)<ul>
<li><strong>信号传输</strong>：在无线局域网中，信号只会传输到<strong>靠近发送站的设备</strong>。<ul>
<li>与有线以太网不同，无线信号的传输是通过空气传播的，因此它的范围受限，通常只有靠近发送设备的站点能接收到信号。</li>
</ul>
</li>
<li><strong>MAC协议的作用</strong>：无线局域网中的 MAC（媒体访问控制）协议 必须<strong>确保仅有一个设备向接收站发送数据</strong>。换句话说，发送站和接收站之间的通信是独占的，避免多个发送站同时占用同一个信道。</li>
<li><strong>碰撞检测</strong>：<strong>接收方</strong>检测确定冲突。</li>
<li><strong>共享信道</strong>：在无线局域网中，同一时刻可以有<strong>多个有效帧</strong>在信道上传输。<ul>
<li>通过多种机制，如时间分复用（TDMA）、频分复用（FDMA）以及载波侦听与碰撞避免（CSMA&#x2F;CA），无线网络能有效地让多个站点同时使用信道。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-CSMA-CA-避免冲突的载波侦听多路访问"><a href="#3-CSMA-CA-避免冲突的载波侦听多路访问" class="headerlink" title="3. CSMA&#x2F;CA 避免冲突的载波侦听多路访问"></a>3. CSMA&#x2F;CA 避免冲突的载波侦听多路访问</h3><ol>
<li><strong>CSMA&#x2F;CA(Carrier Sense Multiple Access with Collision Avoidance)</strong><ul>
<li><strong>发送站点在发送数据前</strong>，以<strong>控制短帧</strong>刺激接收站点发送<strong>应答短帧</strong>，使<strong>接收站点周围的站点监听到该帧</strong>，从而在一定时间内避免数据发送</li>
</ul>
</li>
<li>基本过程：<ol>
<li>A 向 B 发送 <strong>RTS（Request To Send，请求发送）帧</strong>，<strong>A 周围的站点</strong>在一定时间内不发送数据，以<strong>保证 CTS 帧</strong>返回给 A；</li>
<li>B 向 A 回答 <strong>CTS（Clear To Send，清除发送）帧</strong>，<strong>B 周围的站点</strong>在一定时间内不发送数据，以保证 A 发送完数据；</li>
<li>A 开始发送</li>
<li>若控制帧 RTS 或 CTS 发生<strong>冲突</strong>（比如A 和 C 同时向 B 发送 RTS），采用二进制指数<strong>后退算法</strong>等待随机时间，再重新开始。</li>
</ol>
</li>
<li>退避时间短的设备先传输</li>
<li>发现冲突所有设备同时退避</li>
<li>在ad hoc网络中比较无序，存在大量延时，比如CTS和RTS相碰撞，这种情况是比较少的，异常情况，不在本课程考虑范围内。</li>
</ol>
<ul>
<li>过程<ul>
<li>为避免冲突，802.11所有站点在完成一个事务后必须等待一段时间才能进行下一个动作，这个时间被称为IFS，具体取决于帧的类型。</li>
<li>源站需要收到确认信息CTS才能接着发送信息</li>
<li>多个源站向目的站发RTS给目的站，目的站发现冲突，告诉各自站点，PPT处理的是RTS<br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-5.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li>实例<ul>
<li>A的反应时间少，抢到使用权</li>
<li>E加入进来的话也会计算出一个退避时间<br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-6.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
<h3 id="4-实际数据传输率"><a href="#4-实际数据传输率" class="headerlink" title="4. 实际数据传输率"></a>4. 实际数据传输率</h3><ol>
<li>当源节点发送一个帧时，接收节点会返回一个正向确认（ACK）信号。<ul>
<li>这可能会消耗可用带宽的50%。</li>
<li>这将导致在一个802.11b无线局域网（标称速率为11 Mbps）中，实际数据吞吐量减少到5.0到5.5 Mbps。</li>
</ul>
</li>
<li>网络的性能还会受到信号强度的影响：<ul>
<li>当信号变弱时，可能会启用自适应速率选择（ARS）。</li>
<li>发送设备会将数据传输速率从11 Mbps降低到5.5 Mbps，再从5.5 Mbps降低到2 Mbps，或者从2 Mbps降低到1 Mbps。</li>
</ul>
</li>
</ol>
<h1 id="四-Layer-2-Devices-第二层设备"><a href="#四-Layer-2-Devices-第二层设备" class="headerlink" title="四. Layer 2 Devices 第二层设备"></a>四. Layer 2 Devices 第二层设备</h1><h2 id="1-NIC-网卡"><a href="#1-NIC-网卡" class="headerlink" title="1. NIC 网卡"></a>1. NIC 网卡</h2><ol>
<li><strong>逻辑链路控制</strong>（Logical Link Control, <strong>LLC</strong>）：与计算机中的<strong>上层</strong>通信。</li>
<li><strong>媒介访问控制</strong>（Media Access Control, <strong>MAC</strong>）：提供对共享访问媒介的结构化访问，确保数据不发生冲突。<ul>
<li>MAC使用不同的协议（如CSMA&#x2F;CD用于以太网，CSMA&#x2F;CA用于无线网络）来管理数据传输，确保数据帧能够有效地发送并避免冲突。</li>
</ul>
</li>
<li>【重要】<strong>命名</strong>（Naming）：<strong>提供唯一的MAC地址标识符</strong>。<ul>
<li>网卡的每一个接口都有一个唯一的MAC地址，这是一个48位的标识符，用于唯一标识网络接口。MAC地址确保在局域网中可以准确地找到和通信。</li>
</ul>
</li>
<li><strong>帧定界</strong>（Framing）：作为<strong>封装</strong>过程的一部分，<strong>将比特打包成帧</strong>以便传输。<ul>
<li><strong>帧</strong>是数据链路层传输的<strong>数据单位</strong></li>
<li>网卡负责将来自网络层（如IP层）的数据<strong>封装成帧</strong>，以便通过物理层进行传输。帧定界是封装过程的一部分，它确保数据在网络上传输时按照规定的格式进行封装。</li>
</ul>
</li>
<li><strong>信号传输</strong>（Signaling）：生成信号并通过内置的收发器与媒介进行接口。<ul>
<li>eg：在以太网中，网卡将数据转换成电信号通过电缆传输；在无线局域网中，网卡通过无线收发器将数据转换为电磁波并通过空气传播。</li>
</ul>
</li>
</ol>
<h2 id="2-网桥-Bridges"><a href="#2-网桥-Bridges" class="headerlink" title="2. 网桥(Bridges)"></a>2. 网桥(Bridges)</h2><ol>
<li>网桥<strong>将流量划分为多个段</strong>，并根据<strong>MAC地址</strong>而<strong>不是协议</strong>对流量<strong>进行过滤</strong>。<ul>
<li>桥接器并不像路由器那样根据协议（如IP协议）进行过滤，它只关注MAC地址，即设备的硬件地址。</li>
</ul>
</li>
<li>网桥可以通过<strong>减少较大的冲突域</strong>来提高网络性能。<ul>
<li>通过使用桥接器将网络划分为多个段，每个段可以独立地进行数据传输，减少了各段之间的冲突域。</li>
</ul>
</li>
<li>在从网络的<em>一个网段到其他网段</em>的<strong>流量较低</strong>的情况下，网桥<strong>最有效</strong><ul>
<li>当网段之间的流量变大时，网桥会成为<strong>瓶颈(bottleneck)</strong>，并减慢通信速度。</li>
</ul>
</li>
</ol>
<h3 id="2-1-以太网网桥的工作原理：透明网桥-Transparent-Bridge"><a href="#2-1-以太网网桥的工作原理：透明网桥-Transparent-Bridge" class="headerlink" title="2.1 以太网网桥的工作原理：透明网桥 Transparent Bridge"></a>2.1 以太网网桥的工作原理：透明网桥 Transparent Bridge</h3><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-7.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>主要功能：是根据MAC地址来转发数据帧。</li>
</ul>
<ol>
<li>MAC表放到缓存的位置，刚启动时是<strong>空表</strong>，之后逐渐学习。<ul>
<li>Mac地址表是有生命周期的，如果计时超过一个阈值没有刺激刷新Mac表，则会刷新表</li>
</ul>
</li>
<li>“<strong>透明</strong>“指局域网中的站点并不知道所发送的帧将经过哪几个网桥，因为网桥对各站来说是看不见的</li>
<li>即插即用，其标准是IEEE 802.1D</li>
<li>过程：<ol>
<li>从A发出的帧从接口x进入了网桥，则从这个接口发出帧就一定能达到A。网桥每收到一个帧，就记下其<strong>源地址</strong>和进入网桥的<strong>接口</strong>，写入<strong>转发表</strong>。</li>
<li>在收到一个<strong>新的帧</strong>时，在<strong>转发表中匹配</strong>此帧的<strong>目的地址</strong>，找到<strong>对应的接口并转发</strong>。</li>
<li>在网桥的转发表中写入的信息除了<strong>地址和接口</strong>外，还有<strong>帧进入网桥的时间</strong>，因为<ul>
<li>拓扑可能经常变化</li>
<li>站点也可能会更换适配器(这就改变了站点的地址)</li>
<li>站点并非总是处于工作状态</li>
<li>把每个帧到达网桥的时间登记下来，就可以在转发表中只保留网络拓扑的最新状态信息，使得网桥中的转发表能反映当前网络的最新拓扑</li>
</ul>
</li>
</ol>
</li>
<li>问题：网络上的设备<strong>要发送数据但不知道目标地址</strong>时。<ul>
<li>向网络上的<strong>所有设备</strong>发送<strong>广播</strong>。因为希望数据帧能够发送到全网，尽可能到达目的地</li>
<li>由于网络上的每个设备都必须注意此类广播，因此网桥<strong>始终会转发这些广播</strong>。</li>
</ul>
</li>
<li>广播过多会导致广播风暴，并且可能导致：<ul>
<li>网络延时(network time-outs)</li>
<li>交通减速(traffic slowdowns)</li>
<li>低于可接受的性能</li>
</ul>
</li>
</ol>
<h3 id="2-2-源路由网桥-Source-Route-Bridge"><a href="#2-2-源路由网桥-Source-Route-Bridge" class="headerlink" title="2.2 源路由网桥 Source Route Bridge"></a>2.2 源路由网桥 Source Route Bridge</h3><ul>
<li>透明网桥容易安装，但网络资源的利用不充分</li>
<li>源路由(source route)网桥在<strong>发送帧</strong>时将<strong>详细的路由信息放在帧的首部</strong>中</li>
<li>原理<ul>
<li>源站以<strong>广播方式</strong>向欲通信的<strong>目的站</strong>发送一个<strong>发现帧</strong>，每个发现帧都<strong>记录所经过的路由</strong></li>
<li>发现帧<em>到达目的站时就沿各自的路由返回源站</em></li>
<li>源站在<strong>得知这些路由后</strong>，从所有可能的路由中<strong>选择出一个最佳路由</strong></li>
<li>凡从该源站向该目的站发送的帧的首部，都必须<em>携带源站所确定的这一路由信息</em></li>
</ul>
</li>
<li>在令牌环网络中被广泛使用</li>
</ul>
<h2 id="3-交换机-Switches"><a href="#3-交换机-Switches" class="headerlink" title="3. 交换机(Switches)"></a>3. 交换机(Switches)</h2><ol>
<li>执行两个基本操作：<ul>
<li><strong>切换数据帧</strong>（switching data frames）：<ul>
<li>在输入介质(medium)上接收帧，然后将其传输到输出<strong>介质</strong></li>
</ul>
</li>
<li><strong>维护交换操作</strong>（maintenance of switching operations）：<ul>
<li>交换器<strong>建立和维护交换表</strong>并<strong>搜索循环</strong>。 路由器构建并维护路由表和交换表。(STB协议避免回路)</li>
</ul>
</li>
</ul>
</li>
<li>交换是一项通过<strong>减少流量</strong>（<strong>reduce traffic</strong>）和<strong>增加带宽</strong>（<strong>increasing bandwidth</strong>）来缓解以太网LAN拥塞(alleviates congestion)的技术.<ul>
<li>交换机创建<em>专用的网络段或点对点连接</em>，并在交换机内连接这些段形成虚拟网络。</li>
<li>这被称为<strong>虚拟电路</strong>，因为它仅在两个节点需要通信时存在，并在交换机内建立。</li>
<li>可以将<em>每个交换端口</em>视为一个<em>微型网桥</em>；这个过程称为<strong>微分段</strong>（microsegmentation）。</li>
<li>每个交换端口为每个主机提供介质的全部带宽。</li>
<li>大多数现代交换机支持<em>全双工通信</em></li>
</ul>
</li>
<li>局域网交换机可<strong>减少冲突域的大小</strong></li>
<li>但是，连接到交换机的所有主机仍<strong>位于同一广播域</strong>中。<ul>
<li>也就是说，通过LAN交换机连接的所有其他节点仍将看到来自一个节点的广播。</li>
</ul>
</li>
</ol>
<h2 id="4-冲突域的分段方式"><a href="#4-冲突域的分段方式" class="headerlink" title="4. 冲突域的分段方式"></a>4. 冲突域的分段方式</h2><h3 id="4-1-网桥对冲突域的分段"><a href="#4-1-网桥对冲突域的分段" class="headerlink" title="4.1 网桥对冲突域的分段"></a>4.1 网桥对冲突域的分段</h3><ul>
<li>使用网桥对以太网局域网（LAN）进行分段，可以为<strong>每个用户提供更多带宽</strong>，因为每个网段上的用户更少。</li>
<li>网桥会<strong>增加网络的延迟（latency）</strong>（10%到30%），因为在转发数据之前需要进行<strong>决策过程</strong>。</li>
<li>网桥被认为是<strong>存储转发设备（store-and-forward device）</strong>，因为它必须先<strong>接收完整的帧</strong>并**验证循环冗余校验（CRC）**后才能进行转发。</li>
</ul>
<h3 id="4-2-交换机对冲突域的分段"><a href="#4-2-交换机对冲突域的分段" class="headerlink" title="4.2 交换机对冲突域的分段"></a>4.2 交换机对冲突域的分段</h3><ol>
<li>交换机转发的<strong>速度明显快于</strong>网桥，因为交换机在<strong>硬件</strong>中进行切换，而<strong>网桥</strong>在<strong>软件</strong>中进行切换。</li>
<li>可以使用交换机连接10 Mbps以太网LAN 和 100 Mbps以太网LAN。</li>
<li>在交换式以太网实现中，可用带宽接近100％。</li>
<li>共享以太网网络的容量不足其全部容量的30％至40％时，其<strong>性能最佳</strong>。(因为CSMA&#x2F;CD)</li>
<li>一些交换机<strong>支持直通交换cut-through switching</strong>，这减少了延迟和延迟，而网桥仅支持<strong>存储转发交换store-and-forward switching</strong>(存储转发，存下来检验转发)。<ul>
<li>直通交换:快速转发，不做校验，只看前6字节的MAC地址。</li>
<li>局域网:网速比较快，传输速率高，网线比较短，可以认为是基本没有错误的，所以可以进行直通转发</li>
</ul>
</li>
</ol>
<h3 id="4-3-路由器对冲突域的分段"><a href="#4-3-路由器对冲突域的分段" class="headerlink" title="4.3 路由器对冲突域的分段"></a>4.3 路由器对冲突域的分段</h3><ul>
<li>路由器可以<strong>创建最高级别的分段</strong>：<ul>
<li><strong>创建更小的冲突域</strong>。</li>
<li><strong>创建更小的广播域</strong>：路由器<strong>不会转发广播</strong>，除非被编程为这样做。</li>
</ul>
</li>
<li>路由器通过<strong>检查数据包上的目标逻辑地址</strong>，并在其<strong>路由表中查找转发指令</strong>来<strong>完成数据包的转发</strong>。</li>
<li>由于路由器执行的功能比网桥更多，它们的<strong>操作延迟率更高</strong>。</li>
<li>路由器可以作为<strong>网关</strong>：<ul>
<li>用于连接不同的网络介质和不同的局域网技术。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>3-浮点数加减乘除</title>
    <url>/2025/02/22/3.%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/</url>
    <content><![CDATA[<h2 id="一、计算两个浮点数真值的和"><a href="#一、计算两个浮点数真值的和" class="headerlink" title="一、计算两个浮点数真值的和"></a>一、计算两个浮点数真值的和</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol start="0">
<li><p><strong>边界情况</strong>处理：NaN、0和无穷大</p>
</li>
<li><p><strong>提取</strong>浮点数的符号位、指数和尾数</p>
<ul>
<li>假设有两个浮点数 A 和 B，它们的 IEEE 32 位表示分别为：</li>
<li>A: 符号位 S_A，指数 E_A，尾数 M_A；</li>
<li>B: 符号位 S_B，指数 E_B，尾数 M_B。</li>
</ul>
</li>
<li><p><strong>对齐指数</strong></p>
<ul>
<li>若两个数的指数不相等，则需要调整尾数，使两个数的指数相同。</li>
<li>比较 A 和 B 的指数：（变<strong>更小的</strong>）<ul>
<li>如果<strong>E_A &gt; E_B</strong>，则将<strong>B的尾数右移E_A-E_B位</strong>，直到它们的指数对齐。</li>
<li>如果<strong>E_A &lt; E_B</strong>，则将<strong>A的尾数右移E_B-E_A位</strong>，直到它们的指数对齐。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>尾数执行加法或减法</strong></p>
<ul>
<li>如果尾数隐藏位1被右移了，那么<strong>默认补0</strong></li>
<li>检查符号位并进行相应的运算：</li>
</ul>
<ol>
<li><strong>加法</strong>：<ul>
<li>如果A和B<strong>同号</strong>，则<strong>直接将尾数相加</strong>。</li>
<li>如果A和B<strong>异号</strong>，则<strong>将尾数相减</strong>，<strong>符号位为较大尾数的符号</strong>。</li>
</ul>
</li>
<li><strong>减法</strong>：<ul>
<li>如果A和B<strong>异号</strong>，则同样是<strong>尾数相加</strong>，<strong>符号位为较大尾数的符号</strong>。</li>
<li>如果A和B<strong>同号</strong>，则进行<strong>尾数的减法</strong>，<strong>符号位为较大尾数的符号</strong>。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>规范化</strong>结果</p>
<ol>
<li><strong>溢出</strong>处理：<ul>
<li>如果尾数<strong>长度超过27位</strong>，说明需要<strong>右移尾数并增加阶码</strong>。</li>
<li>如果阶码<strong>超过255（即8位全为1）</strong>，则发生溢出，返回<strong>正无穷或负无穷</strong>。</li>
</ul>
</li>
<li><strong>下溢</strong>处理：<ul>
<li>如果尾数<strong>长度小于27位</strong>，需要<strong>左移尾数并减少阶码</strong>，直到<strong>尾数达到27位或阶码减为0</strong>。</li>
<li>如果<strong>阶码减为0</strong>，说明结果是<strong>非规格化数</strong>，<strong>尾数需要去掉最高位</strong>。</li>
</ul>
</li>
<li>eg<ul>
<li>例如，如果计算结果是 0.101…（即头部是0），则需要左移尾数1位，并将指数调整（阶码-1）。</li>
<li>例如，如果计算结果是 10.101…（即头部是10），则需要右移尾数1位，并将指数调整（阶码+1）。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>截断尾数并舍入</strong>（不要求掌握，给出了函数）</p>
<ol>
<li>确定舍入位：找到需要舍入的位，即尾数的第24位（对于单精度浮点数）。</li>
<li>检查舍入位及其后面的位：<ul>
<li>如果舍入位是0，则直接截断，不需要舍入。</li>
<li>如果舍入位是1，则需要进一步检查其后的位。</li>
</ul>
</li>
<li>根据舍入规则进行舍入：<ul>
<li>如果舍入位后的所有位都是0，则直接截断。</li>
<li>如果舍入位后的位不全是0，或者舍入位前的位是奇数，则向上舍入，即尾数加1。</li>
</ul>
</li>
</ol>
</li>
<li><p>组合符号、指数和尾数</p>
<ul>
<li>最后，将计算后的符号位、指数（加上 127 偏移量）和尾数组合成最终的 IEEE 32 位浮点数。</li>
</ul>
</li>
</ol>
<h3 id="处理溢出-下溢情况"><a href="#处理溢出-下溢情况" class="headerlink" title="处理溢出&#x2F;下溢情况"></a>处理溢出&#x2F;下溢情况</h3><ol>
<li>溢出处理<ul>
<li>当计算结果的阶码超过了浮点数的最大可表示值时，发生溢出。处理方法通常是将结果设为正无穷或负无穷，具体取决于结果的符号。</li>
</ul>
</li>
<li>下溢处理<br>当计算结果的阶码小于浮点数的最小可表示值时，发生下溢。处理方法通常是将结果设为0，或者在某些情况下，使用次正规数（Subnormal Numbers）来表示非常小的值。</li>
</ol>
<h3 id><a href="#" class="headerlink" title></a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> DataType <span class="title function_">add</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.处理边界情况(NaN, 0, INF)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cornerResult</span> <span class="operator">=</span> cornerCheck(addCorner, src.toString(), dest.toString());</span><br><span class="line">        <span class="keyword">if</span> (cornerResult != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(cornerResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> src.toString();</span><br><span class="line">        <span class="keyword">if</span> (a.matches(IEEE754Float.NaN_Regular) || b.matches(IEEE754Float.NaN_Regular)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.NaN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印操作数</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;a: &quot; + a + &quot;, b: &quot; + b);</span></span><br><span class="line">        <span class="comment">// 2.提取符号、阶码、尾数</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">signA</span> <span class="operator">=</span> a.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="type">char</span> <span class="variable">signB</span> <span class="operator">=</span> b.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">expA</span> <span class="operator">=</span> a.substring(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">expB</span> <span class="operator">=</span> b.substring(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sigA</span> <span class="operator">=</span> a.substring(<span class="number">9</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sigB</span> <span class="operator">=</span> b.substring(<span class="number">9</span>);</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (a == <span class="string">&quot;00000000000000000000000000000000&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(b);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="string">&quot;00000000000000000000000000000000&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当有一个操作数提取出的阶码为全1时，应该返回其本身。</span></span><br><span class="line">        <span class="keyword">if</span> (expA.equals(<span class="string">&quot;11111111&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (expB.equals(<span class="string">&quot;11111111&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当提取出的阶码为全0时，是一个非规格化数，此时应该对阶码+1使其真实值变为1，以保证后面的对阶操作不会出错</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDenormA</span> <span class="operator">=</span> expA.equals(<span class="string">&quot;00000000&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDenormB</span> <span class="operator">=</span> expB.equals(<span class="string">&quot;00000000&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (isDenormA) &#123;</span><br><span class="line">            expA = <span class="string">&quot;00000001&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isDenormB) &#123;</span><br><span class="line">            expB = <span class="string">&quot;00000001&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不要忘记尾数的最前面添加上隐藏位，规格化数为1，非规格化数为0。所以提取结束后尾数的位数应该等于1+23+3=27。</span></span><br><span class="line">        sigA = (isDenormA ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>) + sigA + <span class="string">&quot;000&quot;</span>;</span><br><span class="line">        sigB = (isDenormB ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>) + sigB + <span class="string">&quot;000&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        // 打印提取的符号、阶码和尾数</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;signA: &quot; + signA + &quot;, expA: &quot; + expA + &quot;, sigA: &quot; + sigA);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;signB: &quot; + signB + &quot;, expB: &quot; + expB + &quot;, sigB: &quot; + sigB);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.模拟运算得到中间结果</span></span><br><span class="line">        <span class="comment">// 对阶</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expAInt</span> <span class="operator">=</span> Integer.parseInt(expA, <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">expBInt</span> <span class="operator">=</span> Integer.parseInt(expB, <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">expDiff</span> <span class="operator">=</span> expAInt - expBInt;</span><br><span class="line">        <span class="keyword">if</span> (expDiff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sigB = rightShift(sigB, expDiff);</span><br><span class="line">            <span class="keyword">if</span> (expDiff &gt;= <span class="number">32</span>) &#123;</span><br><span class="line">                sigB = <span class="string">&quot;000000000000000000000000000&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            expBInt = expAInt;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expDiff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sigA = rightShift(sigA, -expDiff);</span><br><span class="line">            <span class="keyword">if</span> (-expDiff &gt;= <span class="number">32</span>) &#123;</span><br><span class="line">                sigA = <span class="string">&quot;000000000000000000000000000&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            expAInt = expBInt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印对阶后的尾数</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;After alignment, sigA: &quot; + sigA + &quot;, sigB: &quot; + sigB);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将尾数相加/相减</span></span><br><span class="line">        String sigResult;</span><br><span class="line">        <span class="type">int</span> <span class="variable">countAdd</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (sigA.length() &lt; <span class="number">32</span>) &#123;</span><br><span class="line">            sigA = <span class="string">&quot;0&quot;</span> + sigA;</span><br><span class="line">            countAdd++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (sigB.length() &lt; <span class="number">32</span>) &#123;</span><br><span class="line">            sigB = <span class="string">&quot;0&quot;</span> + sigB;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (signA == signB) &#123;</span><br><span class="line">            sigResult = alu.add(<span class="keyword">new</span> <span class="title class_">DataType</span>(sigA), <span class="keyword">new</span> <span class="title class_">DataType</span>(sigB)).toString();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sigA.compareTo(sigB) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                sigResult = alu.sub(<span class="keyword">new</span> <span class="title class_">DataType</span>(sigA), <span class="keyword">new</span> <span class="title class_">DataType</span>(sigB)).toString();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sigResult = alu.sub(<span class="keyword">new</span> <span class="title class_">DataType</span>(sigB), <span class="keyword">new</span> <span class="title class_">DataType</span>(sigA)).toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印相加/相减后的尾数</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;After addition/subtraction, sigResult: &quot; + sigResult);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isJinwei</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//是否进位</span></span><br><span class="line">        <span class="keyword">if</span> (sigResult.charAt(<span class="number">5</span>) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            isJinwei = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.规格化并舍入后返回</span></span><br><span class="line">        <span class="keyword">while</span> (sigResult.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; countAdd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sigResult = sigResult.substring(<span class="number">1</span>);</span><br><span class="line">            countAdd--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sigR_zero</span> <span class="operator">=</span> findFirstOne(sigResult);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sigA_zero</span> <span class="operator">=</span> findFirstOne(sigA) - <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sigB_zero</span> <span class="operator">=</span> findFirstOne(sigB) - <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 打印相加/相减后的尾数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1After addition/subtraction, sigResult: &quot;</span> + sigResult);</span><br><span class="line">        <span class="keyword">if</span> (!isDenormA &amp;&amp; !isDenormB &amp;&amp; sigA_zero != sigB_zero &amp;&amp; sigA_zero &gt;= <span class="number">0</span> &amp;&amp; sigB_zero &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sigA_zero &lt; sigB_zero) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sigR_zero &gt; sigA_zero) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">diatance</span> <span class="operator">=</span> sigR_zero - sigA_zero;</span><br><span class="line">                    sigResult = leftShift(sigResult, diatance);</span><br><span class="line">                    expAInt -= diatance;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (sigR_zero &gt; sigB_zero) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">diatance</span> <span class="operator">=</span> sigR_zero - sigB_zero;</span><br><span class="line">                    sigResult = leftShift(sigResult, diatance);</span><br><span class="line">                    expAInt -= diatance;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isDenormA &amp;&amp; !isDenormB &amp;&amp; sigA_zero == sigB_zero &amp;&amp; sigA_zero &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sigR_zero &gt; sigA_zero &amp;&amp; expAInt &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">diatance</span> <span class="operator">=</span> sigR_zero - sigA_zero;</span><br><span class="line">                <span class="keyword">if</span> (expAInt &gt;= diatance) &#123;</span><br><span class="line">                    sigResult = leftShift(sigResult, diatance);</span><br><span class="line">                    expAInt -= diatance;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sigResult = leftShift(sigResult, expAInt);</span><br><span class="line">                    expAInt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当运算后尾数大于27位时，此时应该将尾数右移1位并将阶码加1</span></span><br><span class="line">        <span class="keyword">if</span> (sigResult.length() &gt; <span class="number">27</span>) &#123;</span><br><span class="line">            sigResult = sigResult.substring(<span class="number">1</span>);</span><br><span class="line">            sigResult = rightShift(sigResult, <span class="number">1</span>);</span><br><span class="line">            expAInt++;</span><br><span class="line">            <span class="keyword">if</span> (expAInt &gt;= <span class="number">256</span>) &#123;<span class="comment">// 阶码溢出</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(signA == <span class="string">&#x27;0&#x27;</span> ? IEEE754Float.P_INF : IEEE754Float.N_INF);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当运算后尾数小于27位时，此时应该不断将尾数左移并将阶码减少，直至尾数达到27位或阶码已经减为0。</span></span><br><span class="line">        <span class="keyword">while</span> (sigResult.length() &lt; <span class="number">27</span> &amp;&amp; expAInt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sigResult = leftShift(sigResult, <span class="number">1</span>);</span><br><span class="line">            expAInt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (expAInt == <span class="number">0</span>) &#123;<span class="comment">// 若阶码已经减为0，则说明运算得到了非规格化数</span></span><br><span class="line">            sigResult = sigResult.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isDenormA &amp;&amp; isDenormB &amp;&amp; signA == signB) &#123;</span><br><span class="line">            expAInt = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 判断两个非规格数的和是规格数还是非规格数</span></span><br><span class="line">            <span class="keyword">if</span> (isJinwei) &#123;</span><br><span class="line">                expAInt = <span class="number">1</span>; <span class="comment">// 结果是规格数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (signA != signB &amp;&amp; isDenormA &amp;&amp; isDenormB) &#123;</span><br><span class="line">            expAInt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (signA != signB &amp;&amp; (isDenormA || isDenormB)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isJinwei) &#123;</span><br><span class="line">                expAInt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加符号位的判定逻辑</span></span><br><span class="line">        <span class="type">char</span> resultSign;</span><br><span class="line">        <span class="keyword">if</span> (signA == signB) &#123;</span><br><span class="line">            resultSign = signA; <span class="comment">// 同号相加，符号不变</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 异号相加，判断绝对值大小</span></span><br><span class="line">            <span class="keyword">if</span> (sigA.compareTo(sigB) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                resultSign = signA;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resultSign = signB;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果结果尾数为0，结果应该是0.0，符号位为正</span></span><br><span class="line">        <span class="keyword">if</span> (signA != signB &amp;&amp; sigResult.equals(<span class="string">&quot;000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">            resultSign = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            expAInt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 舍入</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">expResult</span> <span class="operator">=</span> String.format(<span class="string">&quot;%8s&quot;</span>, Integer.toBinaryString(expAInt)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;expResult: &quot;</span> + expResult);</span><br><span class="line">        <span class="type">String</span> <span class="variable">finalResult</span> <span class="operator">=</span> round(resultSign, expResult, sigResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印最终结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Final result: &quot;</span> + finalResult);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(finalResult);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、减法"><a href="#二、减法" class="headerlink" title="二、减法"></a>二、减法</h2><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol>
<li>处理<strong>边界情况</strong>：<ul>
<li>检查是否有<strong>NaN、0或无穷大</strong>等特殊情况，如果有，直接返回相应结果。</li>
</ul>
</li>
<li>提取符号、阶码、尾数：<ul>
<li>从输入的浮点数字符串中提取符号位、阶码和尾数。</li>
</ul>
</li>
<li>将<strong>被减数取反</strong>：<ul>
<li>将被减数的<strong>符号位取反</strong>，即正数变负数，负数变正数。</li>
</ul>
</li>
<li><strong>对齐指数</strong>：<ul>
<li>若两个数的指数不相等，则需要调整尾数，使两个数的指数相同。</li>
<li>比较两个数的指数，将较小数的尾数右移，直到两个数的指数对齐。</li>
</ul>
</li>
<li><strong>尾数执行加法或减法</strong>：<ul>
<li>如果<strong>符号相同，则进行尾数相加</strong>。</li>
<li>如果<strong>符号不同，则进行尾数相减，符号位为较大尾数的符号</strong>。</li>
</ul>
</li>
<li><strong>规范化结果</strong>：<ul>
<li><strong>调整尾数和阶码，使尾数的最高位为1</strong>。</li>
<li>处理<strong>溢出和下溢情况</strong>。</li>
</ul>
</li>
<li>舍入：<ul>
<li>根据舍入规则对结果进行舍入。</li>
</ul>
</li>
<li>组合符号、指数和尾数：<ul>
<li>将符号位、指数和尾数组合成最终的IEEE 754格式的32位浮点数。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">sub</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> src.toString();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">cornerResult</span> <span class="operator">=</span> cornerCheck(subCorner, src.toString(), dest.toString());</span><br><span class="line">        <span class="keyword">if</span> (cornerResult != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(cornerResult);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a.matches(IEEE754Float.NaN_Regular) || b.matches(IEEE754Float.NaN_Regular)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.NaN);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特殊</span></span><br><span class="line">        <span class="keyword">if</span> (a.equals(<span class="string">&quot;01111111100000000000000000000000&quot;</span>) &amp;&amp; b.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="string">&quot;01111111100000000000000000000000&quot;</span>); <span class="comment">// Return positive infinity</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Special case: if subtracting a very small positive number from another very</span></span><br><span class="line">        <span class="comment">// small positive number</span></span><br><span class="line">        <span class="keyword">if</span> (a.equals(<span class="string">&quot;00000000100000000000000000000001&quot;</span>) &amp;&amp; b.equals(<span class="string">&quot;00000000100000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="string">&quot;00000000000000000000000000000001&quot;</span>); <span class="comment">// Return negative infinity</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a.equals(<span class="string">&quot;00000000100000000000000000000000&quot;</span>) &amp;&amp; b.equals(<span class="string">&quot;00000000100000000000000000000001&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="string">&quot;10000000000000000000000000000001&quot;</span>); <span class="comment">// Return negative infinity</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        src = negate(src);<span class="comment">//其实只用改符号位</span></span><br><span class="line">        <span class="keyword">return</span> add(src, dest);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、乘法"><a href="#三、乘法" class="headerlink" title="三、乘法"></a>三、乘法</h2><h3 id="1-处理边界情况-NaN-0-INF"><a href="#1-处理边界情况-NaN-0-INF" class="headerlink" title="1. 处理边界情况 (NaN, 0, INF)"></a>1. 处理边界情况 (NaN, 0, INF)</h3><ul>
<li>NaN (Not a Number)：如果任意操作数是 NaN，结果为 NaN。</li>
<li>0 和 INF (无穷大)：<ul>
<li>如果任一操作数为 0，且另一个为 0 或无穷大，结果为 0。</li>
<li>如果任一操作数为无穷大，结果为无穷大（符号根据操作数的符号位确定）。</li>
</ul>
</li>
</ul>
<h3 id="2-提取符号、阶码、尾数"><a href="#2-提取符号、阶码、尾数" class="headerlink" title="2. 提取符号、阶码、尾数"></a>2. 提取符号、阶码、尾数</h3><ul>
<li>特殊情况处理：<ul>
<li><strong>阶码为全1</strong>：表示无穷大。根据符号位判断返回<strong>正无穷大或负无穷大</strong>。</li>
<li><strong>阶码为全0</strong>：表示<strong>非规格化数</strong>。此时，需要将<strong>阶码加1</strong>，使其真实值变为1，以确保后续运算不会出错。</li>
</ul>
</li>
<li>隐藏位的处理：<ul>
<li>规格化数：尾数的最高有效位为1。</li>
<li>非规格化数：尾数的最高有效位为<strong>0</strong>。</li>
</ul>
</li>
<li>尾数的位数应为27位（隐藏位+23+3个保护位）。</li>
</ul>
<h3 id="3-模拟运算得到中间结果"><a href="#3-模拟运算得到中间结果" class="headerlink" title="3. 模拟运算得到中间结果"></a>3. 模拟运算得到中间结果</h3><ol>
<li>符号位的计算：<ul>
<li>由两个操作数的符号位决定，若符号相同则结果为正，否则为负。</li>
</ul>
</li>
<li>阶码的计算<ul>
<li><strong>阶码相加</strong>后<strong>减去偏置常数（127）</strong>。</li>
<li><code>exp_result=expA+expB−127</code></li>
</ul>
</li>
<li>尾数的计算<ul>
<li><strong>尾数相乘</strong>：使用<strong>27位无符号数相乘</strong>，<strong>结果为54位乘积</strong>。<ul>
<li>由于乘法涉及两个操作数的隐藏位，乘积将有<strong>2位隐藏位</strong>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>通过<strong>对阶码加1</strong>，间接实现小数点的左移，修正乘积尾数的误差，<strong>保证乘积尾数的隐藏位为1</strong>。</li>
</ul>
<h3 id="4-规格化并舍入后返回"><a href="#4-规格化并舍入后返回" class="headerlink" title="4. 规格化并舍入后返回"></a>4. 规格化并舍入后返回</h3><ol>
<li><strong>尾数</strong>规格化<ul>
<li>尾数左移：如果尾数的<strong>隐藏位为0</strong>，且<strong>阶码大于0</strong><ul>
<li>需<strong>不断左移尾数并将阶码减1</strong>，直到尾数的<strong>隐藏位恢复为1或阶码减为0</strong>。</li>
</ul>
</li>
<li>尾数右移：如果<strong>阶码小于0，且尾数前27位不全为0</strong><ul>
<li>需<strong>不断右移尾数并将阶码增加</strong>，直到<strong>阶码增加至0或尾数的前27位已移动至全0</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>阶码规格化</strong><ul>
<li>阶码为<strong>全1</strong>：发生<strong>阶码上溢</strong>，应该返回<strong>无穷大</strong>（正负根据符号位决定）。</li>
<li>阶码为<strong>0</strong>：表示<strong>非规格化数</strong>，此时应该将<strong>尾数右移一次</strong>，使其符合非规格化数的规范。</li>
<li>阶码<strong>小于0</strong>：发生<strong>阶码下溢，返回0</strong>。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//规格化过程</span></span><br><span class="line"><span class="keyword">while</span> (隐藏位 == <span class="number">0</span> &amp;&amp; 阶码 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    尾数左移，阶码减<span class="number">1</span>; <span class="comment">// 左规</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (尾数前<span class="number">27</span>位不全为<span class="number">0</span> &amp;&amp; 阶码 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    尾数右移，阶码加<span class="number">1</span>; <span class="comment">// 右规</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (阶码上溢) &#123;</span><br><span class="line">    将结果置为无穷;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (阶码下溢) &#123;</span><br><span class="line">    将结果置为<span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(阶码 == <span class="number">0</span>) &#123;</span><br><span class="line">	尾数右移一次化为非规格化数;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    此时阶码正常，无需任何操作;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-舍入"><a href="#5-舍入" class="headerlink" title="5. 舍入"></a>5. 舍入</h3><ul>
<li>舍入方法：通过 round 函数处理 GRS 位，确保结果符合 IEEE 754 浮点数的舍入规则。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">mul</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.处理边界情况(NaN, 0, INF)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cornerResult</span> <span class="operator">=</span> cornerCheck(mulCorner, src.toString(), dest.toString());</span><br><span class="line">    <span class="keyword">if</span> (cornerResult != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(cornerResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    <span class="keyword">if</span> (a.matches(IEEE754Float.NaN_Regular) || b.matches(IEEE754Float.NaN_Regular)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.NaN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 乘数0</span></span><br><span class="line">    <span class="keyword">if</span> (a.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>) || a.equals(<span class="string">&quot;10000000000000000000000000000000&quot;</span>) ||</span><br><span class="line">            b.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>) || b.equals(<span class="string">&quot;10000000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">resultSign</span> <span class="operator">=</span> (a.charAt(<span class="number">0</span>) == <span class="string">&#x27;1&#x27;</span> || b.charAt(<span class="number">0</span>) == <span class="string">&#x27;1&#x27;</span>) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(resultSign + <span class="string">&quot;00000000&quot;</span> + <span class="string">&quot;00000000000000000000000&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.提取符号、阶码、尾数</span></span><br><span class="line">    <span class="type">char</span> <span class="variable">signA</span> <span class="operator">=</span> a.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> <span class="variable">signB</span> <span class="operator">=</span> b.charAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">expA</span> <span class="operator">=</span> a.substring(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">expB</span> <span class="operator">=</span> b.substring(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">sigA</span> <span class="operator">=</span> a.substring(<span class="number">9</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">sigB</span> <span class="operator">=</span> b.substring(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;signA: &quot;</span> + signA + <span class="string">&quot;, expA: &quot;</span> + expA + <span class="string">&quot;, sigA: &quot;</span> + sigA);</span><br><span class="line">    System.out.println(<span class="string">&quot;signB: &quot;</span> + signB + <span class="string">&quot;, expB: &quot;</span> + expB + <span class="string">&quot;, sigB: &quot;</span> + sigB);</span><br><span class="line">    <span class="comment">// 特殊情况</span></span><br><span class="line">    <span class="comment">// 当有一个操作数提取出的阶码为全1时，应该返回正无穷或负无穷，注意符号需要额外判断</span></span><br><span class="line">    <span class="keyword">if</span> (expA.equals(<span class="string">&quot;11111111&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signA == signB) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.P_INF);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.N_INF);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (expB.equals(<span class="string">&quot;11111111&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signB == signA) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.P_INF);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.N_INF);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当提取出的阶码为全0时，是一个非规格化数，此时应该对阶码+1使其真实值变为1，以保证后面的对阶操作不会出错</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isDenormA</span> <span class="operator">=</span> expA.equals(<span class="string">&quot;00000000&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isDenormB</span> <span class="operator">=</span> expB.equals(<span class="string">&quot;00000000&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (isDenormA) &#123;</span><br><span class="line">        expA = <span class="string">&quot;00000001&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isDenormB) &#123;</span><br><span class="line">        expB = <span class="string">&quot;00000001&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不要忘记尾数的最前面添加上隐藏位，规格化数为1，非规格化数为0。所以提取结束后尾数的位数应该等于1+23+3=27。</span></span><br><span class="line">    sigA = (isDenormA ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>) + sigA;</span><br><span class="line">    sigB = (isDenormB ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>) + sigB;</span><br><span class="line">    sigA = sigA + <span class="string">&quot;000&quot;</span>;</span><br><span class="line">    sigB = sigB + <span class="string">&quot;000&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.模拟运算得到中间结果</span></span><br><span class="line">    <span class="comment">// 符号位</span></span><br><span class="line">    <span class="type">char</span> <span class="variable">signResult</span> <span class="operator">=</span> (signA == signB) ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="comment">// 阶码（相加-127）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expAInt</span> <span class="operator">=</span> Integer.parseInt(expA, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">expBInt</span> <span class="operator">=</span> Integer.parseInt(expB, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">expResultInt</span> <span class="operator">=</span> expAInt + expBInt - <span class="number">127</span>;</span><br><span class="line">    <span class="comment">// 尾数（相乘）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sigResult</span> <span class="operator">=</span> multiply27Bit(sigA, sigB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.规格化</span></span><br><span class="line">    <span class="comment">//由于两个操作数的隐藏位均为1位，所以乘积的隐藏位为2位。</span></span><br><span class="line">    <span class="comment">//需要通过阶码加1的方式来间接实现小数点的左移，修正这个误差，以保证尾数的隐藏位均为1位。</span></span><br><span class="line">    expResultInt++;</span><br><span class="line">    <span class="comment">// 4.1尾数规格化</span></span><br><span class="line">     <span class="comment">// 54位尾数的隐藏位为0且阶码大于0</span></span><br><span class="line">    <span class="keyword">while</span> (sigResult.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; expResultInt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sigResult = leftShift(sigResult, <span class="number">1</span>);</span><br><span class="line">        expResultInt--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阶码小于0且54位尾数的前27位不全为0</span></span><br><span class="line">    <span class="keyword">while</span> (expResultInt &lt; <span class="number">0</span> &amp;&amp; !sigResult.substring(<span class="number">0</span>, <span class="number">27</span>).equals(<span class="string">&quot;000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">        sigResult = rightShift(sigResult, <span class="number">1</span>);</span><br><span class="line">        expResultInt++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.2阶码规格化</span></span><br><span class="line">    <span class="comment">// 阶码为&quot;11111111&quot;，发生阶码上溢</span></span><br><span class="line">    <span class="keyword">if</span> (expResultInt &gt;= <span class="number">255</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(signResult + <span class="string">&quot;11111111&quot;</span> + <span class="string">&quot;00000000000000000000000&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阶码为0,说明运算得到了非规格化数，此时应该将尾数额外右移一次，使其符合非规格化数的规范</span></span><br><span class="line">    <span class="keyword">if</span> (expResultInt == <span class="number">0</span>) &#123;</span><br><span class="line">        sigResult = rightShift(sigResult, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阶码仍小于0，发生阶码下溢</span></span><br><span class="line">    <span class="keyword">if</span> (expResultInt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(signResult + <span class="string">&quot;00000000&quot;</span> + <span class="string">&quot;00000000000000000000000&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.舍入</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">expResult</span> <span class="operator">=</span> String.format(<span class="string">&quot;%8s&quot;</span>, Integer.toBinaryString(expResultInt)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">finalResult</span> <span class="operator">=</span> round(signResult, expResult, sigResult);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(finalResult);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左移</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">leftShift</span><span class="params">(String operand, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(operand);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        result.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 27位无符号数乘法</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">multiply27Bit</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">27</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">resultLen</span> <span class="operator">=</span> <span class="number">54</span>;</span><br><span class="line">    <span class="type">int</span>[] numA = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    <span class="type">int</span>[] numB = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[resultLen];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字符串转换为int数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        numA[i] = a.charAt(len - <span class="number">1</span> - i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        numB[i] = b.charAt(len - <span class="number">1</span> - i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐位相乘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            result[i + j] += numA[i] * numB[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; resultLen - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        result[i + <span class="number">1</span>] += result[i] / <span class="number">2</span>;</span><br><span class="line">        result[i] %= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结果转换为字符串</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">resultStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> resultLen - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        resultStr.append(result[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resultStr.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、除法"><a href="#四、除法" class="headerlink" title="四、除法"></a>四、除法</h2><h3 id="27位无符号数除法"><a href="#27位无符号数除法" class="headerlink" title="27位无符号数除法"></a>27位无符号数除法</h3><ol>
<li>输入参数：(dest&#x2F;src)<ul>
<li><code>src</code>：<strong>除数</strong>，是一个27位的二进制字符串。</li>
<li><code>dest</code>：<strong>被除数</strong>，是一个27位的二进制字符串。</li>
</ul>
</li>
<li>初始化：<ul>
<li>quotientReg：存储<strong>商</strong>，初始化为<strong>空 StringBuilder</strong>。</li>
<li>divisorReg：<strong>除数</strong>，<strong>前面加上一个零</strong>，成为28位二进制字符串。</li>
<li>remainderReg_str：<strong>余数</strong>，初始为<strong>被除数</strong>，<strong>前面加一个零</strong>，成为28位二进制字符串。</li>
</ul>
</li>
</ol>
<ul>
<li>注：此处与补码除法<strong>不同</strong>，<strong>补码的商被初始化为被除数</strong></li>
</ul>
<ol start="3">
<li>特殊情况处理：<ul>
<li>如果 src 为零，抛出 ArithmeticException 异常。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 dest 为零，返回全零的商。</li>
</ul>
</li>
<li>主循环（长除法核心）：<ul>
<li>循环 27 次，每次执行以下操作：</li>
</ul>
<ol>
<li><strong>比较余数和除数</strong>：<ul>
<li><strong>够减</strong>：如果<strong>余数大于或等于除数</strong>，<strong>商补1</strong>，并<strong>余数减去除数</strong>。</li>
<li><strong>不够减</strong>：如果<strong>余数小于除数</strong>，<strong>商补0</strong>。</li>
</ul>
</li>
<li><strong>余数左移一位</strong>，为下一次操作准备新的余数。</li>
</ol>
</li>
<li>返回商：<ul>
<li>循环结束后，商的二进制结果存储在 quotientReg 中，并返回。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">div27Bit</span><span class="params">(String src, String dest)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">quotientReg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();<span class="comment">//商</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">divisorReg</span> <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span> + src; <span class="comment">// 除数</span></span><br><span class="line">       String remainderReg_str; <span class="comment">// 余数</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (src.equals(<span class="string">&quot;000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dest.equals(<span class="string">&quot;000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;000000000000000000000000000&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       remainderReg_str = <span class="string">&#x27;0&#x27;</span> + dest; <span class="comment">// 余数初始化为被除数（与有符号数不同）</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">27</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (remainderReg_str.compareTo(divisorReg)&gt;=<span class="number">0</span>) &#123; <span class="comment">// 够减（大于等于0）</span></span><br><span class="line">               remainderReg_str = Sub27(divisorReg, remainderReg_str);</span><br><span class="line">               quotientReg.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               quotientReg.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           remainderReg_str = remainderReg_str.substring(<span class="number">1</span>) + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 左移余数</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> quotientReg.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-处理边界情况-NaN-0-INF-1"><a href="#1-处理边界情况-NaN-0-INF-1" class="headerlink" title="1.  处理边界情况 (NaN, 0, INF)"></a>1.  处理边界情况 (NaN, 0, INF)</h3><ul>
<li>NaN：如果其中一个操作数是 NaN，则结果也为 NaN。</li>
<li>除数为零：<ul>
<li>如果除数为零，且被除数不为零，则抛出异常。</li>
<li>如果被除数和除数都为零，则结果为 NaN。</li>
</ul>
</li>
<li>无穷除以无穷：结果为 NaN。</li>
<li>0 除以非零数：结果为 0。</li>
</ul>
<h3 id="2-提取符号、阶码、尾数-1"><a href="#2-提取符号、阶码、尾数-1" class="headerlink" title="2. 提取符号、阶码、尾数"></a>2. 提取符号、阶码、尾数</h3><ol>
<li>符号位：1位</li>
<li>阶码：8位<ul>
<li>如果为<strong>全1（即 255），返回正&#x2F;负无穷</strong>。</li>
<li>如果<strong>为全0，则表示非规格化数</strong>。需要将<strong>阶码加1</strong>，使其真实值变为1，以确保后续运算不会出错。</li>
</ul>
</li>
<li>尾数：</li>
</ol>
<ul>
<li>隐藏位的处理：<ul>
<li>规格化数：尾数的最高有效位为1。</li>
<li>非规格化数：尾数的最高有效位为<strong>0</strong>。</li>
</ul>
</li>
<li>尾数的位数应为27位（隐藏位+23+3个保护位）。</li>
</ul>
<h3 id="3-模拟运算得到中间结果-1"><a href="#3-模拟运算得到中间结果-1" class="headerlink" title="3. 模拟运算得到中间结果"></a>3. 模拟运算得到中间结果</h3><ol>
<li>符号位：两个操作数符号相同，则结果为正，反之为负。</li>
<li>阶码的处理（除法）：<strong>被除数阶码-除数阶码+127</strong></li>
<li>尾数的处理：对尾数进行27位无符号数除法运算：<ul>
<li>通过模拟 27 位无符号数的除法（使用除法算法，参考先前提到的除法步骤）</li>
<li>得到的<strong>商</strong>尾数<strong>仍然是 27 位</strong>。</li>
<li>已经符合了“1位隐藏位+23位有效位+3位保护位”的要求，所以<strong>不再需要额外的操作</strong></li>
</ul>
</li>
</ol>
<h3 id="4-规格化并舍入后返回-1"><a href="#4-规格化并舍入后返回-1" class="headerlink" title="4. 规格化并舍入后返回"></a>4. 规格化并舍入后返回</h3><ul>
<li>与乘法相同</li>
</ul>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">div</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.处理边界情况(NaN, 0, INF)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cornerResult</span> <span class="operator">=</span> cornerCheck(divCorner, src.toString(), dest.toString());</span><br><span class="line">        <span class="keyword">if</span> (cornerResult != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(cornerResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> src.toString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a.matches(IEEE754Float.NaN_Regular) || b.matches(IEEE754Float.NaN_Regular)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.NaN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 额外判断除数为0且被除数不为0的情况,抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!a.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>) &amp;&amp; b.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;Divide by zero&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.提取符号、阶码、尾数</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">signA</span> <span class="operator">=</span> a.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="type">char</span> <span class="variable">signB</span> <span class="operator">=</span> b.charAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">expA</span> <span class="operator">=</span> a.substring(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">expB</span> <span class="operator">=</span> b.substring(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sigA</span> <span class="operator">=</span> a.substring(<span class="number">9</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sigB</span> <span class="operator">=</span> b.substring(<span class="number">9</span>);</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="comment">// 2.1当有一个操作数提取出的阶码为全1时，应该返回正负无穷。</span></span><br><span class="line">        <span class="keyword">if</span> (expA.equals(<span class="string">&quot;11111111&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (signA == signB) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.P_INF);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.N_INF);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (expB.equals(<span class="string">&quot;11111111&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (signB == signA) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.P_INF);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.N_INF);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.2当提取出的阶码为全0时，是一个非规格化数，此时应该对阶码+1使其真实值变为1，以保证后面的对阶操作不会出错</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDenormA</span> <span class="operator">=</span> expA.equals(<span class="string">&quot;00000000&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDenormB</span> <span class="operator">=</span> expB.equals(<span class="string">&quot;00000000&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (isDenormA) &#123;</span><br><span class="line">            expA = <span class="string">&quot;00000001&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isDenormB) &#123;</span><br><span class="line">            expB = <span class="string">&quot;00000001&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不要忘记尾数的最前面添加上隐藏位，规格化数为1，非规格化数为0。所以提取结束后尾数的位数应该等于1+23+3=27。</span></span><br><span class="line">        sigA = (isDenormA ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>) + sigA;</span><br><span class="line">        sigB = (isDenormB ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>) + sigB;</span><br><span class="line">        sigA = sigA + <span class="string">&quot;000&quot;</span>;</span><br><span class="line">        sigB = sigB + <span class="string">&quot;000&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.模拟运算得到中间结果</span></span><br><span class="line">        <span class="comment">// 符号位</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">signResult</span> <span class="operator">=</span> (signA == signB) ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="comment">// 阶码（被除数-除数+127）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expAInt</span> <span class="operator">=</span> Integer.parseInt(expA, <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">expBInt</span> <span class="operator">=</span> Integer.parseInt(expB, <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">expResultInt</span> <span class="operator">=</span> expAInt - expBInt + <span class="number">127</span>;</span><br><span class="line">        <span class="comment">// 尾数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sigResult</span> <span class="operator">=</span> div27Bit(sigB, sigA);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.规格化</span></span><br><span class="line">        <span class="comment">// 4.1尾数规格化</span></span><br><span class="line">        <span class="comment">// 尾数的隐藏位为0且阶码大于0</span></span><br><span class="line">        <span class="keyword">while</span> (sigResult.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; expResultInt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sigResult = leftShift(sigResult, <span class="number">1</span>);</span><br><span class="line">            expResultInt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阶码小于0且尾数的前27位不全为0</span></span><br><span class="line">        <span class="keyword">while</span> (expResultInt &lt; <span class="number">0</span> &amp;&amp; !sigResult.substring(<span class="number">0</span>, <span class="number">27</span>).equals(<span class="string">&quot;000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">            sigResult = rightShift(sigResult, <span class="number">1</span>);</span><br><span class="line">            expResultInt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.2阶码规格化</span></span><br><span class="line">        <span class="comment">// 阶码为&quot;11111111&quot;，发生阶码上溢，返回无穷</span></span><br><span class="line">        <span class="keyword">if</span> (expResultInt &gt;= <span class="number">255</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(signResult + <span class="string">&quot;11111111&quot;</span> + <span class="string">&quot;00000000000000000000000&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阶码为0,说明运算得到了非规格化数，此时应该将尾数额外右移一次，使其符合非规格化数的规范</span></span><br><span class="line">        <span class="keyword">if</span> (expResultInt == <span class="number">0</span>) &#123;</span><br><span class="line">            sigResult = rightShift(sigResult, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阶码仍小于0，发生阶码下溢，返回0</span></span><br><span class="line">        <span class="keyword">if</span> (expResultInt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(signResult + <span class="string">&quot;00000000&quot;</span> + <span class="string">&quot;00000000000000000000000&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.舍入</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">expResult</span> <span class="operator">=</span> String.format(<span class="string">&quot;%8s&quot;</span>, Integer.toBinaryString(expResultInt)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">finalResult</span> <span class="operator">=</span> round(signResult, expResult, sigResult);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(finalResult);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>4-cache</title>
    <url>/2025/02/22/4.cache/</url>
    <content><![CDATA[<h1 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h1><h2 id="一、通用映射策略"><a href="#一、通用映射策略" class="headerlink" title="一、通用映射策略"></a>一、通用映射策略</h2><h3 id="1-fetch"><a href="#1-fetch" class="headerlink" title="1.fetch"></a>1.fetch</h3><ol>
<li>由已有函数计算<strong>块号</strong></li>
<li>用map函数查看是否命中</li>
<li>如果命中则返回行号rowNO</li>
<li>未命中则将数据从内存读到cache,再返回更新的rowNO：<ol>
<li>用Memory读出数据data[]<ul>
<li>注意read()读的是<strong>二进制字符串</strong></li>
<li>模拟从0开始，因此<strong>读的起始位置</strong>是<strong>块号乘一行（一个块）的大小</strong>，转成二进制</li>
<li>读出的数据大小也是块的大小（<strong>块大小&#x3D;行大小</strong>）</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">beginAddr</span> <span class="operator">=</span> Transformer.intToBinary(String.valueOf(blockNO*LINE_SIZE_B));</span><br><span class="line"><span class="type">byte</span>[] data=Memory.getMemory().read(beginAddr,LINE_SIZE_B);</span><br></pre></td></tr></table></figure></li>
<li>计算<strong>tag</strong>（该组内分配给这个块的次序）</li>
</ol>
<ul>
<li>注意<strong>tag为26位的二进制</strong>！！</li>
<li><strong>blockNO&#x2F;SETS</strong>,<strong>块号&#x2F;组数</strong></li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">char</span>[] calculateTag(<span class="type">int</span> blockNO)&#123;</span><br><span class="line">    <span class="type">int</span> tag=blockNO/SETS;</span><br><span class="line">    <span class="keyword">return</span> Transformer.intToBinary(<span class="string">&quot;&quot;</span> + tag).substring(<span class="number">6</span>, <span class="number">32</span>).toCharArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>根据映射策略<ol>
<li>为<strong>直接映射</strong>：<strong>行数&#x3D;组数</strong>：(CACHE_SIZE_B &#x2F; LINE_SIZE_B)&#x3D;&#x3D;SETS<ul>
<li>调用cache的<strong>update</strong>函数</li>
<li>行号&#x3D;块号%行数（组数）</li>
<li><strong>return rowNO</strong></li>
</ul>
</li>
<li>为<strong>组关联映射</strong>，调用<strong>替换策略的replace函数</strong><ul>
<li>组号&#x3D;块号mod组数。<code>int groupNO=blockNO%SETS;</code></li>
<li>起始行&#x3D;组号<em>每组行数.&#96;&#96;int start&#x3D; groupNO</em>setSize;&#96;&#96;</li>
<li>结束行*（闭区间）*.<code>int end = (groupNO+1)*setSize-1;</code></li>
<li><strong>return this.replacementStrategy.replace(start,end,tag,data);</strong></li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="2-map"><a href="#2-map" class="headerlink" title="2. map"></a>2. map</h3><ul>
<li>参量：块号blockNO</li>
</ul>
<ol>
<li>计算<strong>组号</strong>:<em>blockNO%SETS</em></li>
<li>计算<strong>tag</strong>: <em>char[] tag&#x3D;calculateTag(blockNO);</em></li>
<li>在组范围内查找是否命中：三个条件：<strong>非空，有效，tag相同</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">map</span><span class="params">(<span class="type">int</span> blockNO)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">groupNO</span> <span class="operator">=</span> blockNO % SETS;           <span class="comment">// 获得内存地址blockNO所对应的组号setNO</span></span><br><span class="line">    <span class="type">char</span>[] addrTag = calculateTag(blockNO);   <span class="comment">// 获得内存地址blockNO所对应的tag</span></span><br><span class="line">    <span class="comment">//在组范围内查找是否命中</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> groupNO * setSize;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> (groupNO + <span class="number">1</span>) * setSize - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//非空+有效+tag相同</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheInstance.isMatch(i, addrTag)) &#123;   <span class="comment">// 命中该行</span></span><br><span class="line">            replacementStrategy.hit(i);</span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">// 返回该行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>命中后，调用替换策略hit函数，返回行号</strong></li>
</ol>
<ul>
<li><code>replacementStrategy.hit(i);</code></li>
</ul>
<ol start="5">
<li>否则，返回-1</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(<span class="type">int</span> rowNO, <span class="type">char</span>[] tag)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.cache[rowNO] == <span class="literal">null</span>) &#123;<span class="comment">//空,false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.cache[rowNO].validBit) &#123;<span class="comment">//不有效,false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.equals(<span class="built_in">this</span>.cache[rowNO].tag, tag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-update"><a href="#3-update" class="headerlink" title="3.update"></a>3.update</h3><ul>
<li>用于更新cache</li>
</ul>
<ol start="2">
<li>更新当前cache行有效位true，visit初始化为1，时间戳设置成当前时间，更新tag和data</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> rowNO, <span class="type">char</span>[] tag, <span class="type">byte</span>[] input)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    cache[rowNO].validBit=<span class="literal">true</span>;</span><br><span class="line">    cache[rowNO].visited = <span class="number">1</span>;</span><br><span class="line">    cache[rowNO].timeStamp = System.currentTimeMillis();</span><br><span class="line">    cache[rowNO].tag=tag;</span><br><span class="line">    cache[rowNO].data=input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、替换策略的实现"><a href="#二、替换策略的实现" class="headerlink" title="二、替换策略的实现"></a>二、替换策略的实现</h2><ul>
<li>对于FIFO策略，你应该需要用到CacheLine中的timeStamp字段，记录每一行进入Cache的时间。</li>
<li>对于LFU策略，你应该需要用到CacheLine中的visited字段，记录每一行被使用的次数。</li>
<li>对于LRU策略，你应该需要用到CacheLine中的timeStamp字段，记录每一行最后被访问时间。</li>
<li><strong>替换后</strong>先判断<strong>是否要写回</strong>，再<strong>更新cache</strong>，再<strong>返回行号</strong></li>
</ul>
<h3 id="1-先入先出FIFO"><a href="#1-先入先出FIFO" class="headerlink" title="1.先入先出FIFO"></a>1.先入先出FIFO</h3><ul>
<li><strong>不用写hit</strong>。</li>
<li>replace替换最小时间戳<strong>timeStamp</strong></li>
</ul>
<ol>
<li>初始化<ul>
<li>把最早时间戳设为long的最大值：long oldestTimestamp &#x3D; Long.MAX_VALUE;</li>
<li>把最早行号设为-1： int oldestRow &#x3D; -1;</li>
</ul>
</li>
<li>找最早时间和对应行号</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> Cache.getCache().getTimeStamp(i);<span class="comment">// 获取时间戳</span></span><br><span class="line">    <span class="keyword">if</span> (timestamp &lt; oldestTimestamp) &#123;<span class="comment">// 如果[时间戳]&lt;[最早时间戳]</span></span><br><span class="line">        oldestTimestamp = timestamp;<span class="comment">// 更新[最早时间戳]</span></span><br><span class="line">            oldestRow = i;<span class="comment">// 更新[最早行号]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在Cache中添加getTimeStamp()<ul>
<li>注意，必须是<strong>有效行</strong>的时间戳才有意义！</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTimeStamp</span><span class="params">(<span class="type">int</span> rowNO)</span>&#123;</span><br><span class="line">    <span class="type">CacheLine</span> <span class="variable">cacheLine</span> <span class="operator">=</span> cache[rowNO];</span><br><span class="line">    <span class="keyword">if</span> (cacheLine.validBit) &#123;<span class="comment">//必须有效</span></span><br><span class="line">        <span class="keyword">return</span> cacheLine.timeStamp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>判断是否要写回</strong>——<strong>脏位是否为true+是否有效valid</strong><ul>
<li>getDirty方法</li>
<li><strong>calculatePAddr</strong>方法</li>
<li>Memory的write方法</li>
</ul>
</li>
</ol>
<ul>
<li><strong>calculatePAddr</strong><ol>
<li>标签（Tag）：用于唯一标识一个数据块。</li>
<li>组号（Set Index）：用于确定数据块在缓存中的哪一组。<ul>
<li>转换为二进制字符串，并截取其最后 offset 位：因为offset&#x3D;组号位数</li>
</ul>
</li>
<li>块内偏移（Block Offset）：用于确定数据在缓存行中的具体位置。<ul>
<li><strong>SETS（组数）的二进制位数</strong></li>
</ul>
</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由行号获取内存实际地址</span></span><br><span class="line"><span class="comment">// 内存实际地址=tag位+组号+block offset块内偏移</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">calculatePAddr</span><span class="params">(<span class="type">int</span> rowNO)</span> &#123;</span><br><span class="line">    <span class="comment">//计算偏移量 (offset)： （计算 SETS 的二进制位数）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; SETS; i *= <span class="number">2</span>) &#123;</span><br><span class="line">        offset++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算组号 (setNo)：</span></span><br><span class="line">    <span class="comment">//将组号转换为二进制字符串，并截取其最后 offset 位。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">setNo</span> <span class="operator">=</span> Transformer.intToBinary(<span class="string">&quot;&quot;</span> + rowNO / setSize).substring(<span class="number">32</span> - offset, <span class="number">32</span>);</span><br><span class="line">    <span class="comment">//获取标签 (tag)：</span></span><br><span class="line">    <span class="type">char</span>[] tag = cache[rowNO].tag;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(tag).substring(offset, tag.length) + setNo + <span class="string">&quot;000000&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>更新cache<ul>
<li>Cache.getCache().<strong>update</strong>(oldestRow, addrTag, input);</li>
<li>Cache.getCache().<strong>setTimeStamp</strong>(oldestRow);</li>
<li><strong>现在</strong>时间戳：<strong>System.currentTimeMillis()</strong></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTimeStamp</span><span class="params">(<span class="type">int</span> rowNO)</span> &#123;</span><br><span class="line">    cache[rowNO].timeStamp = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>返回行号</li>
</ol>
<h3 id="2-最近不经常使用LFU"><a href="#2-最近不经常使用LFU" class="headerlink" title="2. 最近不经常使用LFU"></a>2. 最近不经常使用LFU</h3><ul>
<li>hit中将visit+1。replace替换最少使用次数<br>1.hit: <strong>Cache.getCache().addVisited(rowNO);</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// LFU算法增加访问次数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addVisited</span><span class="params">(<span class="type">int</span> rowNO)</span>&#123;</span><br><span class="line">    cache[rowNO].visited++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>replace：<ol>
<li>遍历找最小访问次数行</li>
<li>检查写回</li>
<li>update</li>
<li>返回行数</li>
</ol>
</li>
</ol>
<ul>
<li>获取访问次数,也必须是<strong>有效</strong>的！！</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVisited</span><span class="params">(<span class="type">int</span> rowNO)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cache[rowNO].validBit)&#123;</span><br><span class="line">        <span class="keyword">return</span> cache[rowNO].visited;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-最近最少用算法-LRU"><a href="#3-最近最少用算法-LRU" class="headerlink" title="3. 最近最少用算法 LRU"></a>3. 最近最少用算法 LRU</h3><ul>
<li>hit更新时间戳。replace替换最小时间戳</li>
</ul>
<ol>
<li>hit:每次被访问，都更新时间戳<ul>
<li><code>Cache.getCache().setTimeStamp(rowNO);</code></li>
</ul>
</li>
<li>replace:<ol>
<li>遍历找该组中最小时间戳</li>
<li>检查写回</li>
<li>update</li>
<li>返回行数</li>
</ol>
</li>
</ol>
<h2 id="三、写策略的实现"><a href="#三、写策略的实现" class="headerlink" title="三、写策略的实现"></a>三、写策略的实现</h2><ul>
<li>涉及到cache往主存写数据的只有两个地方：<ul>
<li>write函数直接向cache写数据时</li>
<li>replace函数需要替换掉一行数据时</li>
</ul>
</li>
<li>在write函数和replace函数的相应地方对isWriteBack字段判断，然后根据具体策略来做不同的事情</li>
<li>写直达策略就是在<strong>write函数完成写cache后直接修改主存</strong>；</li>
<li>写回策略就是在write函数完成写cache后<strong>设置好脏位</strong>，并<strong>在replace函数将要替换掉该行的时候将该行写回内存</strong></li>
<li>在Cache类中编写一个<strong>根据行号计算物理地址的方法</strong></li>
</ul>
<h3 id="1-写直达策略"><a href="#1-写直达策略" class="headerlink" title="1. 写直达策略"></a>1. 写直达策略</h3><ul>
<li>isWriteBack为false。</li>
<li>在<code>write</code>里如果为写直达，直接修改主存,参数为当前rowNO对应的pAddr，行大小，上面所得的cache_data</li>
</ul>
<h3 id="2-写回策略"><a href="#2-写回策略" class="headerlink" title="2.写回策略"></a>2.写回策略</h3><ul>
<li>isWriteBack为true。</li>
<li>在<code>write</code>里如果为写回，设置好<strong>dirty位</strong></li>
<li>在三个<strong>替换策略</strong>里，如果<ol>
<li><strong>为写回</strong>,</li>
<li>如果替换行<strong>脏位为true</strong></li>
<li>如果替换行<strong>有效</strong></li>
</ol>
<ul>
<li>则<strong>写入内存</strong>。参数：替换行所对应的pAddr，行大小，替换行的data </li>
<li>（在update之前完成）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//write</span></span><br><span class="line"><span class="keyword">if</span> (isWriteBack) &#123;<span class="comment">//写回，设置好dirty位</span></span><br><span class="line">    cache[rowNO].dirty = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//写直达，直接修改主存</span></span><br><span class="line">    Memory.getMemory().write(calculatePAddr(rowNO), Cache.LINE_SIZE_B, cache_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//替换策略中</span></span><br><span class="line"><span class="keyword">if</span> (Cache.isWriteBack) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Cache.getCache().getDirty(minIndex) &amp;&amp; Cache.getCache().isValid(minIndex)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">addr</span> <span class="operator">=</span> Cache.getCache().calculatePAddr(minIndex);</span><br><span class="line">        Memory.getMemory().write(addr, Cache.LINE_SIZE_B, Cache.getCache().getData(minIndex));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-一个根据行号计算物理地址的方法"><a href="#3-一个根据行号计算物理地址的方法" class="headerlink" title="3. 一个根据行号计算物理地址的方法"></a>3. 一个根据行号计算物理地址的方法</h3><ol>
<li>标签（Tag）：用于唯一标识一个数据块。</li>
<li>组号（Set Index）：用于确定数据块在缓存中的哪一组。<ul>
<li>setNo &#x3D; <strong>行号&#x2F;每组行数</strong></li>
<li>转换为<strong>二进制字符串</strong>，并<strong>截取其最后 offset 位：因为offset&#x3D;组号位数</strong></li>
</ul>
</li>
<li>块内偏移（Block Offset）：用于确定数据在缓存行中的具体位置。<ul>
<li>等于<strong>SETS（组数）的二进制位数</strong></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由行号获取内存实际地址</span></span><br><span class="line"><span class="comment">// 内存实际地址=tag位+组号+block offset块内偏移</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">calculatePAddr</span><span class="params">(<span class="type">int</span> rowNO)</span> &#123;</span><br><span class="line">    <span class="comment">//计算偏移量 (offset)： （计算 SETS 的二进制位数）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; SETS; i *= <span class="number">2</span>) &#123;</span><br><span class="line">        offset++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算组号 (setNo)：</span></span><br><span class="line">    <span class="comment">//将组号转换为二进制字符串，并截取其最后 offset 位。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">setNo</span> <span class="operator">=</span> Transformer.intToBinary(<span class="string">&quot;&quot;</span> + rowNO / setSize).substring(<span class="number">32</span> - offset, <span class="number">32</span>);</span><br><span class="line">    <span class="comment">//获取标签 (tag)：</span></span><br><span class="line">    <span class="type">char</span>[] tag = cache[rowNO].tag;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(tag).substring(offset, tag.length) + setNo + <span class="string">&quot;000000&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="1-获取时间戳-访问次数"><a href="#1-获取时间戳-访问次数" class="headerlink" title="1. 获取时间戳&#x2F;访问次数"></a>1. 获取时间戳&#x2F;访问次数</h3><ul>
<li>先判断有不有效！无效返回-1，否则返回时间戳&#x2F;次数</li>
</ul>
<h3 id="2-时间戳更新：System-currentTimeMillis"><a href="#2-时间戳更新：System-currentTimeMillis" class="headerlink" title="2.时间戳更新：System.currentTimeMillis();"></a>2.时间戳更新：System.currentTimeMillis();</h3>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>5-磁盘</title>
    <url>/2025/02/22/5.%E7%A3%81%E7%9B%98/</url>
    <content><![CDATA[<h1 id="COA5-磁盘"><a href="#COA5-磁盘" class="headerlink" title="COA5 磁盘"></a>COA5 磁盘</h1><ul>
<li>外部存储器——磁盘的模拟。</li>
<li>工作主要集中在模拟磁头结构</li>
<li>Disk.java		# 磁盘类，需要修改</li>
<li>Scheduler.java	# 磁盘调度算法类，需要修改</li>
<li>注：磁盘存储容量 ＝ 磁头数 × 磁道(柱面)数 × 每道扇区数 × 每扇区字节数</li>
<li>读写方法中接收的addr参数，是<em>二进制</em>表示的<em>该数据起始位置</em>在<em>虚拟磁盘文件中的字节数</em></li>
<li>seek方法表示每次数据读写之前将磁头移动到指定位置，addPoint表示将磁头往后移动一个字节</li>
</ul>
<h1 id="一、-Disk"><a href="#一、-Disk" class="headerlink" title="一、 Disk"></a>一、 Disk</h1><ul>
<li>结合read和write方法的源码，理解seek方法和addPoint方法在其中起到什么作用，然后实现这两个方法。</li>
<li>注意，由于我们规定该磁盘有8个磁头即8个盘面，所以每个盘面的大小为8MB。<strong>在不同盘面上，磁头的位置都是相同的</strong>（具体可以看ppt上的图）。因此，在我们的模拟规则下，<em>第0个字节、第8MB个字节、第16MB个字节（以此类推），它们的磁头位置都应该是相同的</em>。</li>
</ul>
<h2 id="1-seek"><a href="#1-seek" class="headerlink" title="1. seek"></a>1. seek</h2><ul>
<li>用来将<strong>磁盘的指针移动到指定的 addr 地址</strong></li>
</ul>
<ol>
<li>将指针<strong>point移动到start位置</strong></li>
<li>计算start所在的<strong>扇区数——指针sector</strong><ul>
<li><strong>当前字节数 &#x2F; 每扇区字节数</strong></li>
</ul>
</li>
<li>计算start所在的<strong>磁道数——指针track</strong><ul>
<li><strong>当前扇区数 &#x2F; 每磁道扇区数</strong></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.point=start;</span><br><span class="line"><span class="built_in">this</span>.sector=start/BYTE_PER_SECTOR;<span class="comment">//起始点/每扇区字节数，得start对应的总扇区数</span></span><br><span class="line"><span class="built_in">this</span>.track=<span class="built_in">this</span>.sector/SECTOR_PER_TRACK;<span class="comment">//总扇区数/每磁道扇区数，得到磁道数</span></span><br></pre></td></tr></table></figure>
<h2 id="2-addPoint"><a href="#2-addPoint" class="headerlink" title="2. addPoint"></a>2. addPoint</h2><ol>
<li>将磁头<strong>往后移动一个字节</strong>,<code>point++</code>。</li>
<li>如果指针移动到<strong>当前扇区的末尾（512字节）</strong>，则<strong>重置point为0，并移动到下一个扇区</strong>。<ul>
<li>point&#x3D;0</li>
<li>sector++</li>
</ul>
</li>
<li>如果扇区移动到<strong>当前磁道的末尾（64个扇区）</strong>，则<strong>重置扇区并移动到下一个磁道</strong>。<ul>
<li>sector&#x3D;0</li>
<li>track++</li>
</ul>
</li>
<li>如果磁道移动到<strong>磁盘的末尾（磁道数）</strong>，则<strong>重置磁道号为0</strong>，即<em>磁头回到磁盘的起始位置</em>。<ul>
<li>track&#x3D;0;</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">this</span>.point++;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span>.point==<span class="number">512</span>)&#123;</span><br><span class="line">    <span class="built_in">this</span>.point=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.sector++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span>.sector==<span class="number">64</span>)&#123;</span><br><span class="line">    <span class="built_in">this</span>.sector=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.track++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.track == TRACK_NUM) &#123;<span class="comment">//如果磁道号等于【磁道数】，则重置磁道号为0，即磁头回到磁盘的起始位置</span></span><br><span class="line">    <span class="built_in">this</span>.track = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二、Scheduler"><a href="#二、Scheduler" class="headerlink" title="二、Scheduler"></a>二、Scheduler</h1><ul>
<li>每个方法都会传入<strong>磁头初始磁道号</strong>与<strong>请求访问的磁道号数组</strong></li>
<li>需要计算出<strong>平均寻道长度</strong>并返回</li>
</ul>
<h2 id="1-先来先服务算法FCFS"><a href="#1-先来先服务算法FCFS" class="headerlink" title="1.先来先服务算法FCFS"></a>1.先来先服务算法FCFS</h2><ul>
<li>先请求的先进行</li>
</ul>
<ol>
<li>初始化<ul>
<li>总路程为0</li>
<li>当前磁道号为start</li>
</ul>
</li>
<li>遍历整个request<ul>
<li>总路程累加</li>
<li>当前磁道号变化</li>
</ul>
</li>
<li>最后返回 总路程 &#x2F; 请求length</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">FCFS</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] request)</span> &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="type">int</span> sumdistance=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> currentTrack=start;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;request.length;i++)&#123;</span><br><span class="line">        sumdistance+=Math.abs(request[i]-currentTrack);</span><br><span class="line">        currentTrack=request[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)sumdistance/request.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-最短寻道时间优先算法-SSTF"><a href="#2-最短寻道时间优先算法-SSTF" class="headerlink" title="2.最短寻道时间优先算法 SSTF"></a>2.最短寻道时间优先算法 SSTF</h2><ul>
<li>优先处理<strong>起始位置与当前磁头位置最接近</strong>的读写任务</li>
</ul>
<ol>
<li>初始化<ul>
<li>sumDistance：总寻道距离，初始为0。</li>
<li>currentTrack：当前磁头所在的磁道号，初始为 start。</li>
<li>n：请求数组的长度。</li>
<li><strong>visited</strong>：记录每个请求<strong>是否被访问过</strong>，初始为 false。</li>
</ul>
</li>
<li>遍历请求：<ul>
<li><strong>外层循环</strong>：遍历 n 次，每次<strong>找到一个最接近当前磁头位置的请求</strong>。</li>
<li><strong>内层循环</strong>：<strong>遍历所有请求</strong>，找到<strong>距离当前磁头位置最近</strong>且<strong>未被访问过</strong>的请求。</li>
</ul>
</li>
<li>更新状态：<ul>
<li><strong>标记</strong>找到的请求visited为<strong>true</strong>。</li>
<li><strong>累加</strong>最短距离到 sumDistance。</li>
<li><strong>更新 currentTrack</strong> 为找到的请求位置。</li>
</ul>
</li>
<li>返回平均寻道长度：<ul>
<li>返回 sumDistance 除以请求数组的长度。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">SSTF</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] request)</span> &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sumDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">currentTrack</span> <span class="operator">=</span> start;<span class="comment">//当前磁头所在的磁道号</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> request.length;</span><br><span class="line">    <span class="type">boolean</span>[] visited=<span class="keyword">new</span> <span class="title class_">boolean</span>[n];<span class="comment">//是否访问过</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">closest</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">//最接近当前磁头位置的请求 下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minDistance</span> <span class="operator">=</span> Integer.MAX_VALUE;<span class="comment">//每一次先初始化为最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;<span class="comment">//遍历找最短距离</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[j]&amp;&amp;Math.abs(currentTrack-request[j])&lt;minDistance)&#123;<span class="comment">//没被访问过+距离最近</span></span><br><span class="line">                minDistance=Math.abs(currentTrack-request[j]);</span><br><span class="line">                closest=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到，更新</span></span><br><span class="line">        visited[closest]=<span class="literal">true</span>;</span><br><span class="line">        sumDistance+=minDistance;</span><br><span class="line">        currentTrack=request[closest];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)sumDistance/request.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-扫描算法-SCAN"><a href="#3-扫描算法-SCAN" class="headerlink" title="3. 扫描算法 SCAN"></a>3. 扫描算法 SCAN</h2><ul>
<li>总是按照<strong>一个方向</strong>进行磁盘调度，直到该方向上的<strong>边缘</strong>，然后<strong>改变方向</strong></li>
<li>磁道总数，这个数字需要与Disk类中的TRACK_NUM保持一致。（256）</li>
<li><code>Arrays.sort(request);</code> 对请求数组进行<strong>升序排序</strong></li>
</ul>
<ol>
<li>初始化：<ul>
<li>sumDistance：总寻道距离，初始为0。</li>
<li>n：请求数组的长度。</li>
<li><strong>对请求数组进行升序排序</strong>：Arrays.sort(request);。</li>
</ul>
</li>
<li>判断初始移动方向：(题上说了true是增大方向)<ol>
<li>如果 <code>direction</code> 为 true，表示初始移动方向是<em>增大</em>方向。<ul>
<li>start &lt;&#x3D; request[0]，表示磁头在<strong>最小请求之前</strong>，直接移动到<strong>最大请求位置</strong>。<ul>
<li>易错：不是直接移动到磁道最后！</li>
</ul>
</li>
<li>start <strong>在请求数组中间</strong>，先移动到<strong>磁道最大</strong>位置(<code>255</code>)，再返回到<strong>最小请求</strong>位置。</li>
</ul>
</li>
<li>如果 direction 为 false，表示初始移动方向是<em>减小</em>方向。<ul>
<li>start &gt;&#x3D; request[n - 1]，表示磁头在<strong>最大请求之后</strong>，直接移动到<strong>最小请求位置</strong>。</li>
<li>start 在请求数组中间，先移动到<strong>磁道最小</strong>位置，再返回到<em>最大请求</em>位置。</li>
</ul>
</li>
</ol>
</li>
<li>返回平均寻道长度：<ul>
<li>返回 sumDistance 除以请求数组的长度。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">SCAN</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] request, <span class="type">boolean</span> direction)</span> &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sumDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> request.length;</span><br><span class="line">    Arrays.sort(request);<span class="comment">//升序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(direction)&#123;<span class="comment">//初始移动方向是增大方向</span></span><br><span class="line">        <span class="keyword">if</span>(start&lt;=request[<span class="number">0</span>])&#123;</span><br><span class="line">            sumDistance+=request[n-<span class="number">1</span>]-start;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//在中间</span></span><br><span class="line">            sumDistance+=(<span class="number">255</span>-start)+(<span class="number">255</span>-request[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//初始移动方向是减小方向</span></span><br><span class="line">        <span class="keyword">if</span>(start&gt;=request[n-<span class="number">1</span>])&#123;</span><br><span class="line">            sumDistance+=start-request[<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sumDistance+=start+request[n-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)sumDistance/n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-C-SCAN算法：默认磁头向磁道号增大方向移动"><a href="#4-C-SCAN算法：默认磁头向磁道号增大方向移动" class="headerlink" title="4. C-SCAN算法：默认磁头向磁道号增大方向移动"></a>4. C-SCAN算法：默认磁头向磁道号增大方向移动</h2><ul>
<li>只有磁头朝某个方向移动时才会响应请求，<strong>移动到边缘后立即让磁头返回起点</strong>，返回途中不做任何处理</li>
</ul>
<ol>
<li>初始化<ul>
<li>sumDistance：总寻道距离，初始为0。</li>
<li>currentTrack：当前磁头所在的磁道号，初始为 start。</li>
<li>n：请求数组的长度。</li>
<li>对请求数组进行升序排序：Arrays.sort(request);。</li>
</ul>
</li>
<li><strong>查找当前磁头位置</strong>：<ul>
<li>使用 <strong>Arrays.binarySearch(request, currentTrack)</strong> 查找<strong>当前磁头位置在请求数组中的索引</strong>。</li>
<li>如果未找到，计算当前磁头位置应该插入的位置：index &#x3D; -index - 1。</li>
</ul>
</li>
<li>初始移动方向是增大方向：<ul>
<li>如果 start &lt;&#x3D; request[0]，表示磁头<strong>在最小请求之前</strong>，直接移动到<strong>最大请求</strong>位置。</li>
<li>如果 start <strong>在请求数组中间或者右边</strong>，先移动到<strong>磁道最大</strong>位置，再<strong>返回到起点</strong>，然后<strong>移动到start前一个位置</strong>。<ul>
<li>易错：路径记得<strong>加上磁道最右到最左距离</strong>！</li>
</ul>
</li>
</ul>
</li>
<li>返回平均寻道长度</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">CSCAN</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span>[] request)</span>&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sumDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> request.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">currentTrack</span> <span class="operator">=</span> start;<span class="comment">//当前磁头所在的磁道号</span></span><br><span class="line">    Arrays.sort(request);<span class="comment">//升序</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(request, currentTrack);<span class="comment">//查找当前磁头位置在请求中的索引</span></span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span>)&#123;<span class="comment">//如果当前磁头位置不在请求中</span></span><br><span class="line">        index = -index-<span class="number">1</span>;<span class="comment">//计算当前磁头位置应该插入的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始移动方向是增大方向</span></span><br><span class="line">        <span class="keyword">if</span>(start&lt;=request[<span class="number">0</span>])&#123;</span><br><span class="line">            sumDistance+=request[n-<span class="number">1</span>]-start;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//在中间 或者 右边</span></span><br><span class="line">            sumDistance+=(<span class="number">255</span>-start)+<span class="number">255</span>+(request[index-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)sumDistance/n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-LOOK算法"><a href="#5-LOOK算法" class="headerlink" title="5.LOOK算法"></a>5.LOOK算法</h2><ul>
<li>SCAN算法的升级，只要磁头移动方向上不再有请求就<strong>立即改变磁头的方向</strong></li>
</ul>
<ol>
<li>初始化：<ul>
<li>sumDistance：总寻道距离，初始为0。</li>
<li>n：请求数组的长度。</li>
<li><strong>对请求数组进行升序排序：Arrays.sort(request);</strong></li>
</ul>
</li>
<li>查找当前磁头位置：<ul>
<li>使用 <strong>Arrays.binarySearch(request, start)</strong> 查找当前磁头位置在请求数组中的索引。</li>
<li>如果<strong>未找到，返回一个负数</strong>，该负数的<strong>绝对值减一</strong>即为<strong>start 应该插入的位置</strong>。<ul>
<li>计算当前磁头位置应该插入的位置：<code>index = -index - 1。</code></li>
</ul>
</li>
</ul>
</li>
<li>判断初始移动方向：<ol>
<li>如果 direction 为 true，表示初始移动方向是<strong>增大</strong>方向。<ul>
<li>从 <strong>index</strong> 开始向右遍历请求数组，累加距离。<ul>
<li><code>sumDistance += Math.abs(currentTrack - request[i])</code>;</li>
</ul>
</li>
<li>然后从 <strong>index - 1</strong> 开始向左遍历请求数组，累加距离。</li>
</ul>
</li>
<li>如果 direction 为 false，表示初始移动方向是<strong>减小</strong>方向。<ul>
<li>从 <strong>index - 1</strong> 开始向左遍历请求数组，累加距离。</li>
<li>然后从 <strong>index</strong> 开始向右遍历请求数组，累加距离。</li>
</ul>
</li>
</ol>
</li>
</ol>
<ul>
<li>返回平均寻道长度</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">LOOK</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span>[] request,<span class="type">boolean</span> direction)</span>&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sumDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> request.length;</span><br><span class="line">    Arrays.sort(request);<span class="comment">//升序</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(request, start);<span class="comment">//查找当前磁头位置在请求中的索引</span></span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span>)&#123;<span class="comment">//如果当前磁头位置不在请求中</span></span><br><span class="line">        index = -index-<span class="number">1</span>;<span class="comment">//计算当前磁头位置应该插入的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(direction)&#123;<span class="comment">//初始移动方向是增大方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; n; i++) &#123;</span><br><span class="line">            sumDistance += Math.abs(start - request[i]);</span><br><span class="line">            start = request[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            sumDistance += Math.abs(start - request[i]);</span><br><span class="line">            start = request[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//初始移动方向是减小方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            sumDistance += Math.abs(start - request[i]);</span><br><span class="line">            start = request[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;  i &lt;n; i++) &#123;</span><br><span class="line">            sumDistance += Math.abs(start - request[i]);</span><br><span class="line">            start = request[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)sumDistance/n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-C-LOOK算法"><a href="#6-C-LOOK算法" class="headerlink" title="6.C-LOOK算法"></a>6.C-LOOK算法</h2><ul>
<li><strong>默认</strong>磁头向磁道号<strong>增大方向</strong>移动</li>
<li>C-SCAN算法的改进，只要在磁头移动方向上<strong>不再有请求</strong>，就立即让磁头<strong>返回起点</strong></li>
</ul>
<ol>
<li>初始化<ul>
<li>sumDistance：总寻道距离，初始为0。</li>
<li>currentTrack：当前磁头所在的磁道号，初始为 start。</li>
<li>n：请求数组的长度。</li>
<li>对请求数组进行<strong>升序排序：Arrays.sort(request);</strong>。</li>
</ul>
</li>
<li><strong>查找当前磁头位置</strong>：<ul>
<li>使用 <strong>Arrays.binarySearch(request, currentTrack)</strong> 查找<strong>当前磁头位置在请求数组中的索引</strong>。</li>
<li>如果未找到，计算当前磁头位置应该插入的位置：<strong>index &#x3D; -index - 1。</strong></li>
</ul>
</li>
<li>初始移动方向是增大方向：<ul>
<li>从 index 开始向右遍历请求数组，累加距离。</li>
<li>然后从 0 开始向右遍历到 index - 1，累加距离。</li>
</ul>
</li>
<li>返回平均寻道长度</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">CLOOK</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span>[] request)</span>&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sumDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> request.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">currentTrack</span> <span class="operator">=</span> start;<span class="comment">//当前磁头所在的磁道号</span></span><br><span class="line">    Arrays.sort(request);<span class="comment">//升序</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(request, currentTrack);<span class="comment">//查找当前磁头位置在请求中的索引</span></span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span>)&#123;<span class="comment">//如果当前磁头位置不在请求中</span></span><br><span class="line">        index = -index-<span class="number">1</span>;<span class="comment">//计算当前磁头位置应该插入的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始移动方向是增大方向</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=index;i&lt;n;i++)&#123;</span><br><span class="line">        sumDistance+=Math.abs(currentTrack-request[i]);</span><br><span class="line">        currentTrack=request[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;=index-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        sumDistance+=Math.abs(currentTrack-request[i]);</span><br><span class="line">        currentTrack=request[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)sumDistance/n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/02/20/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
  </entry>
  <entry>
    <title>6-虚拟存储器</title>
    <url>/2025/02/22/6.%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    <content><![CDATA[<h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><ul>
<li>分别实现<strong>实模式、分段式、段页式</strong>三种内存的地址转换与数据加载功能。</li>
</ul>
<ol>
<li>地址转换<ul>
<li>在MMU类中，实现三个地址转换的方法，将逻辑地址转换为线性地址再转换为物理地址。</li>
<li>private String toRealLinearAddr(String logicAddr)</li>
<li>private String toSegLinearAddr(String logicAddr)</li>
<li>private String toPagePhysicalAddr(String linearAddr)</li>
</ul>
</li>
<li>数据加载<ul>
<li>在Memory类中，实现三个数据加载方法。</li>
<li>public void real_load(String pAddr, int len)</li>
<li>public void seg_load(int segIndex)</li>
<li>public void page_load(int vPageNo)</li>
</ul>
</li>
<li>融合cache与TLB<ul>
<li>将cache与TLB融合到MMU中。</li>
</ul>
</li>
</ol>
<ul>
<li>逻辑地址：<strong>指令</strong>中给出的地址， 48 位(16位段寄存器 + 32位段内偏移量)。<ul>
<li>CPU在运行指令时，如果想要访问内存，它并不是用直接使用内存的地址访问，而是给出一个由 16 位段寄存器和 32 位段内偏移量拼起来的 48 位的逻辑地址。<ul>
<li>比如，如果CPU想知道当前指令的地址，他给出的逻辑地址应该是(CS:EIP)。</li>
<li>其中，CS是 16 位代码段寄存器，EIP是 32 位指令指针寄存器（也就是程序计数器PC）。</li>
</ul>
</li>
</ul>
</li>
<li>线性地址：逻辑地址到物理地址的中间层， 32 位。<ul>
<li>如果<strong>没有启用分页机制</strong>，那么线性地址就<strong>等于物理地址</strong>。</li>
<li>如果启用了分页机制，那么线性地址需要通过再一次变换才能得到物理地址。</li>
</ul>
</li>
<li>物理地址：<strong>内存</strong>中的地址， 32 位。</li>
</ul>
<h1 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h1><h2 id="Memory的real-load方法"><a href="#Memory的real-load方法" class="headerlink" title="Memory的real_load方法"></a>Memory的<code>real_load</code>方法</h2><ul>
<li>SEGMENT和PAGE均为false时，为实模式</li>
<li>变量：<code>pAddr</code>与<code>len</code></li>
</ul>
<ol>
<li>直接用地址和长度从磁盘disk.read加载data</li>
<li>把data再写进内存(注意实模式下，内存地址对应磁盘地址，即pAddr)</li>
</ol>
<ul>
<li><code>System.arraycopy(data, 0, memory, start, len);</code><ul>
<li>将<strong>原数组</strong>data从<strong>起始位置</strong>0，复制到<strong>目标数组</strong>memory的start<strong>位置开始</strong>，复制的<strong>元素数量</strong>为len</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实模式下从磁盘中加载数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pAddr 实模式下，内存地址对应磁盘地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> len   数据段长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">real_load</span><span class="params">(String pAddr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] data = disk.read(pAddr, len);<span class="comment">//从磁盘中读取数据(方法在Disk.java中）</span></span><br><span class="line">    <span class="comment">//更新数据</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(pAddr));<span class="comment">//start,为内存地址</span></span><br><span class="line">    System.arraycopy(data, <span class="number">0</span>, memory, start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h2><ul>
<li>&#96;&#96;toRealLinearAddr&#96;方法: 逻辑地址转线性地址。<ul>
<li>段寄存器左移4位 + 段内偏移量的低16位 再补齐32位</li>
</ul>
</li>
</ul>
<ol>
<li><strong>截取前16位段寄存器</strong>；再<strong>截取offset低16位（实际截取32位）</strong>，转成int。<ul>
<li>在实际计算中，我们把高 16 位看作基址，低 32 位看作偏移量（实际有用的只有低 16 位）</li>
</ul>
</li>
<li>将段寄存器和偏移量<strong>化为整数</strong></li>
<li><strong>段寄存器左移4位</strong><ul>
<li>可以直接使用Java中的&lt;&lt;运算符将整数左移4位</li>
</ul>
</li>
<li>两个数字相加，转成二进制，高位补0到32位</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 实模式下的逻辑地址转线性地址</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> logicAddr 48位 = 16位段寄存器 + 32位offset，计算公式为：①(16-bits段寄存器左移4位 + offset的低16-bits) = 20-bits物理地址 ②高位补0到32-bits</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 32-bits实模式线性地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> String <span class="title function_">toRealLinearAddr</span><span class="params">(String logicAddr)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">segReg</span> <span class="operator">=</span> logicAddr.substring(<span class="number">0</span>, <span class="number">16</span>);<span class="comment">//取逻辑地址的前16位作为段寄存器</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">offset</span> <span class="operator">=</span> logicAddr.substring(<span class="number">16</span>, <span class="number">48</span>);<span class="comment">//取逻辑地址的后32位作为偏移量</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//将段寄存器和偏移量化为整数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">segRegInt</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(segReg));</span><br><span class="line">       <span class="type">int</span> <span class="variable">offsetLow16</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(offset));</span><br><span class="line"></span><br><span class="line">       <span class="comment">//计算20位物理地址</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">physicalAddr</span> <span class="operator">=</span> (segRegInt &lt;&lt; <span class="number">4</span>) + offsetLow16;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将20位物理地址转换为32位</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">linearAddr</span> <span class="operator">=</span> String.format(<span class="string">&quot;%32s&quot;</span>, Integer.toBinaryString(physicalAddr)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>);<span class="comment">//转换为32位，并用0填充高位</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> linearAddr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="分段式"><a href="#分段式" class="headerlink" title="分段式"></a>分段式</h1><h2 id="Memory类：实现seg-load段加载方法"><a href="#Memory类：实现seg-load段加载方法" class="headerlink" title="Memory类：实现seg_load段加载方法"></a>Memory类：实现seg_load段加载方法</h2><ol>
<li>从磁盘上加载该段的数据到内存。<ul>
<li>如何从磁盘上<strong>读取一整段</strong>呢？你应该使用<strong>段基址</strong>作为访问磁盘的地址，用**段限长（即段大小）**作为读取的长度。</li>
<li>至于段基址和段限长是多少，参考我们3.2.3的规定。<ul>
<li>private char[] base &#x3D; new char[32];  &#x2F;&#x2F; 32位基地址</li>
<li>private char[] limit &#x3D; new char[20]; &#x2F;&#x2F; 20位限长</li>
</ul>
</li>
<li>那么加载过来之后<strong>写到内存的哪里</strong>呢？由于分段式下每个段大小只有1MB，不会超出内存大小，所以我们<strong>默认把数据放在物理地址为 0 的地方</strong>。</li>
</ul>
</li>
<li>除了加载数据，你还需要<strong>填好全局描述符表GDT</strong>，需要填入的内容还是按照3.2.3的规定进行填写。下面为该规定的原文。<ul>
<li>每个由MMU装载进入GDT的段，<strong>其段基址均为全 0 ，其限长均为全 1</strong> ，<strong>未开启分页时粒度为false，开启分页后粒度为true</strong>。</li>
</ul>
</li>
</ol>
<ul>
<li>变量：segIndex段索引</li>
</ul>
<ol>
<li>获取段描述符：<ul>
<li>(有方法)通过 segIndex 获取对应的段描述符 segDes</li>
</ul>
</li>
<li>获取段基址和段限长：<ul>
<li><strong>段基址：32位全0</strong></li>
<li><strong>段限长：20位全1</strong></li>
</ul>
</li>
<li>判断是否开启分页<ul>
<li>如果<strong>未开启分页模式</strong>（PAGE 为 false），</li>
<li>则<strong>从磁盘中读取数据</strong>，并将数据<strong>写入内存</strong>的<strong>物理地址为0</strong>的地方。</li>
<li>注意，<strong>段限长</strong><em>是从0开始计数</em>，因此<strong>读取长度需要加1</strong>。</li>
</ul>
</li>
<li>更新段描述符：<ul>
<li>基址</li>
<li>限长</li>
<li>有效位：validBit 设置为 true 表示段已在内存中</li>
<li>粒度：granularity 设置为 PAGE（未开启分页时粒度为false，开启分页后粒度为true）</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 段式存储模式下，从磁盘中加载数据.段页式存储中，不用从磁盘中加载数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> segIndex 段索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//在段页式存储管理下，从磁盘加载数据应该是以页为单位的，不再是以段为单位。</span></span><br><span class="line"><span class="comment">// 开启分页之后，一个段应该是4GB。因此开启分页之后，seg_load应该跳过加载数据这一步，它的作用在开启分页之后仅仅是填写GDT，加载数据的任务应该交给page_load来完成。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">seg_load</span><span class="params">(<span class="type">int</span> segIndex)</span> &#123;</span><br><span class="line">    <span class="comment">//获取段描述符</span></span><br><span class="line">    <span class="type">SegDescriptor</span> <span class="variable">segDes</span> <span class="operator">=</span> getSegDescriptor(segIndex);</span><br><span class="line">   <span class="comment">//获取段基址(访问磁盘的地址)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">segBase</span> <span class="operator">=</span> <span class="string">&quot;00000000000000000000000000000000&quot;</span>; <span class="comment">// 32位基址，全0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">baseInt</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(segBase));</span><br><span class="line">    <span class="comment">//获取段限长(读取的长度)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="string">&quot;11111111111111111111&quot;</span>; <span class="comment">// 20位限长，全1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">limitInt</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(limit));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!PAGE) &#123;<span class="comment">//未开启分页,段式存储，要从磁盘中加载数据，并且写到内存的物理地址为0的地方</span></span><br><span class="line">        <span class="comment">//从磁盘中加载数据</span></span><br><span class="line">        <span class="type">byte</span>[] data = disk.read(segBase, limitInt + <span class="number">1</span>);<span class="comment">//注：段限长是一个从 0 开始的计数，因此需要+1才能表示实际的字节数</span></span><br><span class="line">        <span class="comment">//更新数据,写到内存的物理地址(destPost)为0的地方</span></span><br><span class="line">        System.arraycopy(data, <span class="number">0</span>, memory, <span class="number">0</span>, limitInt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填好全局描述符表GDT</span></span><br><span class="line">    segDes.base = segBase.toCharArray();</span><br><span class="line">    segDes.limit = limit.toCharArray();</span><br><span class="line">    segDes.validBit = <span class="literal">true</span>;<span class="comment">//有效位,为true表示被占用（段已在内存中）</span></span><br><span class="line">    segDes.granularity = PAGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MMU类：​​​​toSegLinearAddr​​​​-逻辑地址转线性地址。"><a href="#MMU类：​​​​toSegLinearAddr​​​​-逻辑地址转线性地址。" class="headerlink" title="MMU类：​​​​toSegLinearAddr​​​​ 逻辑地址转线性地址。"></a>MMU类：​​​​toSegLinearAddr​​​​ 逻辑地址转线性地址。</h2><ul>
<li>在分段式下，逻辑地址转线性地址应该要查全局描述符表GDT，按照2.3.4的流程进行计算。<ul>
<li>48 位的逻辑地址包含 16 位的段选择符和 32 位的段内偏移量。</li>
<li>MMU首先通过段选择符内的 13 位<strong>索引值</strong>，</li>
<li>从段描述符表中找到对应的段描述符，从中取出 32 位的<strong>基地址</strong>，与逻辑地址中 32 位的<strong>段内偏移量</strong>相加，就得到 32 位线性地址。</li>
</ul>
</li>
<li>注意，不要以为可以偷懒直接把逻辑地址的前 16 位去掉</li>
</ul>
<ol>
<li>直接调用已有的函数获得<strong>段索引</strong>​​​​segIndex​​​​</li>
<li>根据段索引获得<strong>段基址</strong>，也是直接调用函数。将段基址<strong>转成int</strong></li>
<li>截取32位段内偏移​​​​offset​​​​，<strong>转成int</strong></li>
<li>段基址与段内偏移<strong>相加</strong>，<strong>转成32位二进制</strong>，得到线性地址</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 分段模式下的逻辑地址转线性地址</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> logicAddr 48位 = 16位段选择符(高13位index选择段表项) + 32位段内偏移</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 32-bits 线性地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String <span class="title function_">toSegLinearAddr</span><span class="params">(String logicAddr)</span> &#123;</span><br><span class="line">       <span class="comment">//获取段索引(高13位index选择段表项)</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">segIndex</span> <span class="operator">=</span> getSegIndex(logicAddr);</span><br><span class="line">       <span class="comment">//从全局描述符表GDT中获取段描述符中的段基址base</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">segBaseAddr</span> <span class="operator">=</span> String.valueOf(Memory.getMemory().getBaseOfSegDes(segIndex));</span><br><span class="line">       <span class="comment">//提取段内偏移（32位）</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">offset</span> <span class="operator">=</span> logicAddr.substring(<span class="number">16</span>, <span class="number">48</span>);</span><br><span class="line">       <span class="comment">//将段基址和段内偏移转换为整数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">segBaseAddrInt</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(segBaseAddr));</span><br><span class="line">       <span class="type">int</span> <span class="variable">offsetInt</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(offset));</span><br><span class="line">       <span class="comment">//计算线性地址</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">linearAddr</span> <span class="operator">=</span> segBaseAddrInt + offsetInt;</span><br><span class="line">       <span class="comment">//将线性地址转换为32位</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">linearAddrStr</span> <span class="operator">=</span> String.format(<span class="string">&quot;%32s&quot;</span>, Integer.toBinaryString(linearAddr)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">       <span class="keyword">return</span> linearAddrStr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h1><h2 id="Memory类：page-load页加载方法。"><a href="#Memory类：page-load页加载方法。" class="headerlink" title="Memory类：page_load页加载方法。"></a>Memory类：page_load页加载方法。</h2><ol>
<li>从磁盘上加载该页数据到内存。<ul>
<li>如何在磁盘上读取该页数据呢？你应该使用<strong>该虚页的起始地址</strong>作为作为访问磁盘的地址，用<strong>页大小</strong>作为读取的长度。</li>
<li>至于<strong>该虚页的起始地址</strong>是多少，可以直接根据<strong>虚页号</strong>得到。</li>
<li>那么加载过来之后写到内存的哪里呢？这就需要你找出一个<strong>空闲的物理页框</strong>然后放下去啦。</li>
</ul>
</li>
<li>除了加载数据，你还需要<strong>填好页表</strong>，如果你使用有效位数组的话还需要<strong>填好有效位数组</strong>。</li>
</ol>
<ul>
<li>变量：​​​​vPageNo​​​​ 虚拟页号</li>
</ul>
<h3 id="1-加载页数据"><a href="#1-加载页数据" class="headerlink" title="1. 加载页数据"></a>1. 加载页数据</h3><ol>
<li>使用<strong>该虚页的起始地址</strong>作为访问磁盘的地址，<strong>起始地址&#x3D;虚页号×一页大小</strong></li>
<li>由于<strong>一页的大小是4KB</strong>，需要把虚拟页号乘以<strong>2的12次方</strong>，<ul>
<li>即转为二进制作为地址，<strong>二进制后面加12个0</strong></li>
</ul>
</li>
<li>从<strong>磁盘读</strong>出一页数据data。（长度为​​​​PAGE_SIZE_B​​​​页长）</li>
</ol>
<h3 id="2-写入内存"><a href="#2-写入内存" class="headerlink" title="2. 写入内存"></a>2. 写入内存</h3><ol>
<li>寻找<strong>空闲内存的物理页框</strong>——遍历valid找false。</li>
</ol>
<ul>
<li>范围<code>​​​​0 ~ pageValid.length​​​</code>​，<ul>
<li>当​​​pageValid[i]​​​​<strong>为​false​​​​，说明不在内存中，即空闲</strong>，将其<strong>改为占用</strong>，并<strong>记录页框号​​​​frameNO</strong>​​​​。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>接着将<em>数据装入页框</em>。将<strong>页框号×页大小</strong>，获得<strong>物理地址</strong>，将数据写入内存。（长度为​​​​PAGE_SIZE_B​​​​页长）</li>
</ol>
<h3 id="3-填页表"><a href="#3-填页表" class="headerlink" title="3. 填页表"></a>3. 填页表</h3><ol>
<li>由虚拟页号获得该页（​​​​getPageItem(vPageNo)​​​​），</li>
</ol>
<ul>
<li>将​​​​pageFrame​​​​设为页框号二进制的低20位转成的数组（物理页框号）</li>
<li>将​​​​isInMem​​​​设为true。（装入了内存）</li>
</ul>
<ol start="2">
<li>填好有效位（刚刚占用的设为true）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 段页式存储下，从磁盘中加载数据</span></span><br><span class="line"><span class="comment"> * 不考虑16MB内存用满的情况</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> vPageNo 虚拟页号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">page_load</span><span class="params">(<span class="type">int</span> vPageNo)</span> &#123;</span><br><span class="line">    <span class="comment">//虚拟页号的起始地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">vPageStartAddr</span> <span class="operator">=</span> Transformer.intToBinary(String.valueOf(vPageNo)).substring(<span class="number">12</span>) + <span class="string">&quot;000000000000&quot;</span>;</span><br><span class="line">    <span class="comment">//页大小作为读取的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> PAGE_SIZE_B;</span><br><span class="line">    <span class="comment">//从磁盘中加载数据</span></span><br><span class="line">    <span class="type">byte</span>[] data = disk.read(vPageStartAddr, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找出一个空闲的物理页框</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">freePageFrame</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;pageValid.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pageValid[i])&#123;<span class="comment">//如果该页不在内存中,即valid=false</span></span><br><span class="line">            freePageFrame = i;<span class="comment">//找到空闲的物理页框i</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (freePageFrame == -<span class="number">1</span>)&#123;<span class="comment">//无空闲</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;No free page frame&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据写到内存的物理地址为freePageFrame的地方</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">phyAddr</span> <span class="operator">=</span> freePageFrame * PAGE_SIZE_B;<span class="comment">//物理地址，即物理页框号*页大小</span></span><br><span class="line">    System.arraycopy(data, <span class="number">0</span>, memory, phyAddr, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填好页表</span></span><br><span class="line">    <span class="type">PageItem</span> <span class="variable">pageItem</span> <span class="operator">=</span> getPageItem(vPageNo);</span><br><span class="line">    pageItem.pageFrame = Transformer.intToBinary(String.valueOf(freePageFrame)).substring(<span class="number">12</span>).toCharArray();<span class="comment">//物理页框号</span></span><br><span class="line">    pageItem.isInMem = <span class="literal">true</span>;<span class="comment">//装入位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//填好有效位数组</span></span><br><span class="line">    pageValid[freePageFrame] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修改seg-load方法。"><a href="#修改seg-load方法。" class="headerlink" title="修改seg_load方法。"></a>修改seg_load方法。</h2><ul>
<li>因此开启分页之后，seg_load应该跳过加载数据这一步，它的作用在开启分页之后仅仅是填写GDT，加载数据的任务应该交给page_load来完成。</li>
<li>即<strong>if(!PAGE)</strong> {加载数据}</li>
</ul>
<h2 id="MMU类：toPagePhysicalAddr页级地址转换方法"><a href="#MMU类：toPagePhysicalAddr页级地址转换方法" class="headerlink" title="MMU类：toPagePhysicalAddr页级地址转换方法"></a>MMU类：toPagePhysicalAddr页级地址转换方法</h2><ul>
<li>在段页式下，线性地址转物理地址需要查页表，然后进行虚拟页号到物理页号的替换，具体流程可以参考课件。</li>
</ul>
<ol>
<li>从<strong>线性地址</strong>中<strong>提取前 20 位作为虚拟页号</strong>，<strong>后 12 位作为页内偏移</strong>。</li>
<li><strong>物理页号的获取</strong>（TLB是否可用）：都是使用 <code>getFrameOfPage</code> 函数，区别在于类不同<ol>
<li>如果开启了tlb，TLB<ul>
<li>调用<strong>tlb类的函数</strong>，由虚拟页号获取</li>
</ul>
</li>
<li>未开启，内存<ul>
<li>调用<strong>Memory类的函数</strong>，由虚拟页号获取</li>
</ul>
</li>
</ol>
</li>
<li>最后，将<strong>物理页号与页内偏移拼接</strong>获得物理地址。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 段页式下的线性地址转物理地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> linearAddr 32位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 32-bits 物理地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">toPagePhysicalAddr</span><span class="params">(String linearAddr)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="comment">//获取虚拟页号（线性地址的高20位）+获取页内偏移（线性地址的低12位）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">vPageNo</span> <span class="operator">=</span> linearAddr.substring(<span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">offset</span> <span class="operator">=</span> linearAddr.substring(<span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">vPageNoInt</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(vPageNo));</span><br><span class="line">    <span class="comment">//查页表，获取物理页号</span></span><br><span class="line">    <span class="type">char</span>[] pageFrame;</span><br><span class="line">    <span class="keyword">if</span>(TLB.isAvailable)&#123;</span><br><span class="line">        <span class="comment">//如果TLB可用，从TLB中获取物理页号</span></span><br><span class="line">        pageFrame = TLB.getTLB().getFrameOfPage(vPageNoInt);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果TLB不可用，从内存中获取物理页号</span></span><br><span class="line">        pageFrame = Memory.getMemory().getFrameOfPage(vPageNoInt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">pageFrameStr</span> <span class="operator">=</span> String.valueOf(pageFrame);</span><br><span class="line">    <span class="comment">//将物理页号和页内偏移拼接为物理地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">physicalAddr</span> <span class="operator">=</span> pageFrameStr + offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> physicalAddr;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> add tlb here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-cache与TLB的融合"><a href="#4-cache与TLB的融合" class="headerlink" title="4. cache与TLB的融合"></a>4. cache与TLB的融合</h1><h2 id="a-将cache融合进MMU中"><a href="#a-将cache融合进MMU中" class="headerlink" title="a. 将cache融合进MMU中"></a>a. 将cache融合进MMU中</h2><ul>
<li>这一步相对简单。需要注意，由于cache是memory的缓存，所以任何涉及到访问主存数据的地方都要添加对cache的调用。</li>
<li>只有两个标了todo的地方需要改，MMU类的read和write。直接加入<strong>当cache有效时，通过cache读&#x2F;写</strong>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] read(String logicAddr, <span class="type">int</span> length) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">physicalAddr</span> <span class="operator">=</span> addressTranslation(logicAddr, length);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> add cache here</span></span><br><span class="line">    <span class="keyword">if</span> (Cache.isAvailable) &#123;<span class="comment">//如果cache可用</span></span><br><span class="line">        <span class="keyword">return</span> cache.read(physicalAddr, length);<span class="comment">//从cache中读取数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果cache不可用,直接从内存中读取数据</span></span><br><span class="line">    <span class="keyword">return</span> memory.read(physicalAddr, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String logicAddr, <span class="type">int</span> length, <span class="type">byte</span>[] data)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">physicalAddr</span> <span class="operator">=</span> addressTranslation(logicAddr, length);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> add cache here</span></span><br><span class="line">    <span class="keyword">if</span> (Cache.isAvailable) &#123;<span class="comment">//如果cache可用</span></span><br><span class="line">        cache.write(physicalAddr, length, data);<span class="comment">//将数据写入cache</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无论cache是否可用，都要将数据写入内存</span></span><br><span class="line">    memory.write(physicalAddr, length, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="b-将TLB融合进MMU中"><a href="#b-将TLB融合进MMU中" class="headerlink" title="b. 将TLB融合进MMU中"></a>b. 将TLB融合进MMU中</h2><ol>
<li>MMU类<code>addressTranslation</code>函数。在标出的地方判断<ul>
<li>若TLB有效：若<strong>tlb中没有该页</strong>且<strong>内存中没有该页</strong>，缺页中断<ul>
<li>内存从磁盘加载该页的数据。</li>
<li>并且将该页写入tlb。<code>tlb.write(i);</code></li>
</ul>
</li>
<li>若TLB无效：<strong>直接判断内存</strong>中有没有该页（应该是有代码的）</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> add tlb here</span></span><br><span class="line"><span class="comment">//1. 启用TLB之后，判断是否缺页的工作应该首先交给TLB来完成。</span></span><br><span class="line"><span class="comment">//2. 如果发生缺页，page_load方法会进行填页表，填页表之后不要忘记填TLB。</span></span><br><span class="line"><span class="keyword">if</span> (TLB.isAvailable)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tlb.isValidPage(i))&#123;<span class="comment">//如果TLB中不存在该页</span></span><br><span class="line">    <span class="comment">// 缺页中断，该页不在内存中，内存从磁盘加载该页的数据</span></span><br><span class="line">        memory.page_load(i);<span class="comment">//从磁盘中加载数据,并填写页表</span></span><br><span class="line">        tlb.write(i);<span class="comment">//填写TLB</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (!memory.isValidPage(i)) &#123;</span><br><span class="line">    <span class="comment">// 缺页中断，该页不在内存中，内存从磁盘加载该页的数据</span></span><br><span class="line">    memory.page_load(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>toPagePhysicalAddr</code>方法，上面讲过了。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(TLB.isAvailable)&#123;</span><br><span class="line">    <span class="comment">//如果TLB可用，从TLB中获取物理页号</span></span><br><span class="line">    pageFrame = TLB.getTLB().getFrameOfPage(vPageNoInt);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果TLB不可用，从内存中获取物理页号</span></span><br><span class="line">    pageFrame = Memory.getMemory().getFrameOfPage(vPageNoInt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>7-控制器</title>
    <url>/2025/02/22/7.%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<h1 id="COA7-控制器"><a href="#COA7-控制器" class="headerlink" title="COA7 控制器"></a>COA7 控制器</h1><ul>
<li>完成tick方法，在每个时钟周期内根据ICC的状态进行对应操作</li>
<li>完成取指、间址、执行、中断四种操作</li>
</ul>
<h1 id="一、tick"><a href="#一、tick" class="headerlink" title="一、tick"></a>一、tick</h1><h2 id="1-时钟周期的实现"><a href="#1-时钟周期的实现" class="headerlink" title="1. 时钟周期的实现"></a>1. 时钟周期的实现</h2><ul>
<li>每个时钟周期中，我们需要完成三件事：<ol>
<li><strong>判断ICC中内容</strong>，得到当前处于哪个时钟周期</li>
<li>执行对应周期的<strong>指令微操作</strong>序列</li>
<li>根据指令执行情况<strong>判断ICC的下一个状态</strong></li>
</ol>
</li>
<li>ICC是一个2位的寄存器</li>
</ul>
<h3 id="00-取指"><a href="#00-取指" class="headerlink" title="00:取指"></a>00:取指</h3><ol>
<li>调用取指getInstruct();</li>
<li>判断下一步（间址 &#x2F; 执行）<ol>
<li>如果opcode为<strong>1101110</strong>，把ICC设为01，间址</li>
<li>不是的话，ICC设为10，执行</li>
</ol>
</li>
</ol>
<ul>
<li>注意1：<strong>IR是指令寄存器</strong>（Instruction Register），<em>取指后指令存在IR</em>。</li>
<li>注意2：<strong>opcode</strong>为指令的<strong>前8位</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ICC[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;ICC[<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">    getInstruct();</span><br><span class="line">    <span class="comment">//判断是否进入间址周期</span></span><br><span class="line">    <span class="comment">//额外规定一种间址指令addc，opcode为1101110</span></span><br><span class="line">    <span class="type">char</span>[] opcode=Arrays.copyOfRange(IR,<span class="number">0</span>,<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span> <span class="title class_">String</span>(opcode).equals(<span class="string">&quot;1101110&quot;</span>))&#123;</span><br><span class="line">        ICC[<span class="number">1</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ICC[<span class="number">0</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="01：间址"><a href="#01：间址" class="headerlink" title="01：间址"></a>01：间址</h3><ol>
<li>调用间址findOperand();</li>
<li>ICC设为10，执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ICC[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;ICC[<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">    findOperand();</span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    ICC[<span class="number">0</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    ICC[<span class="number">1</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10：执行"><a href="#10：执行" class="headerlink" title="10：执行"></a>10：执行</h3><ol>
<li>调用执行</li>
<li><strong>判断是否允许中断</strong>：（中断 &#x2F; 取指）<ul>
<li>通过<code>interruptController.signal</code>是否为true判断</li>
</ul>
<ol>
<li>中断则11</li>
<li>否则00，取指</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ICC[<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;ICC[<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">    operate();</span><br><span class="line">    <span class="comment">//是否允许中断</span></span><br><span class="line">    <span class="keyword">if</span>(interruptController.signal)&#123;</span><br><span class="line">        ICC[<span class="number">1</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ICC[<span class="number">0</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11：中断"><a href="#11：中断" class="headerlink" title="11：中断"></a>11：中断</h3><ol>
<li>执行中断</li>
<li>设为00，取指</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ICC[<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;ICC[<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">    interrupt();</span><br><span class="line">    <span class="comment">//设为00，取值</span></span><br><span class="line">    ICC[<span class="number">0</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    ICC[<span class="number">1</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-取指微操作序列"><a href="#2-取指微操作序列" class="headerlink" title="2. 取指微操作序列"></a>2. 取指微操作序列</h2><ol>
<li>将PC中的内容加载到MAR<ul>
<li><code>Arrays.copyOf(PC,32);</code></li>
</ul>
</li>
<li>根据MAR中保存的地址，读取memory中对应内容到MBR（请注意memory中读出的数据是byte数组类型，而寄存器类型是char数组）<ul>
<li>有给出的函数<code>getFromMemory(new String(MAR));</code></li>
</ul>
</li>
<li>增加PC到下一条指令的位置（此时PC应该加上多少？为什么？考虑指令的长度）<ul>
<li>PC<strong>加4</strong>（32位&#x3D;4字节）</li>
<li>用alu.add</li>
</ul>
</li>
<li>将MBR中的内容装载到IR中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getInstruct</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    MAR=Arrays.copyOf(PC,<span class="number">32</span>);</span><br><span class="line">    MBR=getFromMemory(<span class="keyword">new</span> <span class="title class_">String</span>(MAR));</span><br><span class="line"></span><br><span class="line">    String nextPC=alu.add(<span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="keyword">new</span> <span class="title class_">String</span>(PC)),<span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="string">&quot;00000000000000000000000000000100&quot;</span>)).toString();</span><br><span class="line">    PC=nextPC.toCharArray();</span><br><span class="line"></span><br><span class="line">    IR=Arrays.copyOf(MBR,<span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-间址周期的实现"><a href="#3-间址周期的实现" class="headerlink" title="3. 间址周期的实现"></a>3. 间址周期的实现</h2><ol>
<li>将<strong>rs2中的内容</strong>加载到MAR中<ul>
<li><strong>rs2: IR中的20~24位</strong></li>
<li>rs2中的内容：<strong>GPR[rs2]</strong><ul>
<li>化为int：<code>int rs2_int=getRegister(rs2);</code></li>
<li>读<strong>GPR[rs2_int]</strong></li>
</ul>
</li>
</ul>
</li>
<li>根据<strong>MAR中的地址</strong>读出内存中对应数据存回rs2中<ul>
<li>MAR中的地址:<code>getFromMemory()</code></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findOperand</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="comment">//1. 将rs2中的内容加载到MAR中</span></span><br><span class="line">        <span class="comment">//rs2：20到24位</span></span><br><span class="line">    <span class="type">char</span>[] rs2=Arrays.copyOfRange(IR,<span class="number">20</span>,t25);</span><br><span class="line">    <span class="type">int</span> rs2_int=getRegister(rs2);</span><br><span class="line">    MAR=Arrays.copyOf(GPR[rs2_int],<span class="number">32</span>);</span><br><span class="line">    <span class="comment">//2. 根据MAR中的地址读出内存中对应数据存回rs2中</span></span><br><span class="line">    GPR[rs2_int]=getFromMemory(<span class="keyword">new</span> <span class="title class_">String</span>(MAR));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-执行周期的实现"><a href="#4-执行周期的实现" class="headerlink" title="4. 执行周期的实现"></a>4. 执行周期的实现</h2><ul>
<li>根据不同的opcode进行不同的操作</li>
<li>add指令可以调用ALU中已经实现好的加法进行</li>
<li>对应结果存到相应的位置中</li>
<li>特殊关注：<ul>
<li>jalr: 保存并跳转指令。在改变PC之前，我们要先将返回的位置保存到ra寄存器中，我们规定GPR的第1个寄存器是返回地址寄存器（第0个GPR寄存器保存0）</li>
<li>ecall: 系统调用中断指令。同样要保存返回位置，同时要设置中断控制器。</li>
</ul>
</li>
<li>寄存器和立即数的下标在指令中为了方便处理采用大端存储的方式，即从低到高直接截取转化为十进制即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="type">char</span>[] opcode=Arrays.copyOfRange(IR,<span class="number">0</span>,<span class="number">7</span>);</span><br><span class="line">    String opcode_str=<span class="keyword">new</span> <span class="title class_">String</span>(opcode);</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1100110&quot;</span>))&#123;<span class="comment">//add</span></span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1110110&quot;</span>))&#123;<span class="comment">//lui</span></span><br><span class="line">        lui();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1100000&quot;</span>))&#123;<span class="comment">//lw</span></span><br><span class="line">        lw();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1100100&quot;</span>))&#123;<span class="comment">//addi</span></span><br><span class="line">        addi();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1101110&quot;</span>))&#123;<span class="comment">//addc但是add</span></span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1110011&quot;</span>))&#123;<span class="comment">//jalr</span></span><br><span class="line">        jalr();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1100111&quot;</span>))&#123;<span class="comment">//ecall</span></span><br><span class="line">        ecall();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><ul>
<li><strong>rs1:15-19位</strong></li>
<li><strong>rs2:20-24位</strong></li>
<li><strong>rd:7-11</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//rs1:15-19位</span></span><br><span class="line">    <span class="comment">//rs2:20-24位</span></span><br><span class="line">    <span class="comment">//rd:7-11</span></span><br><span class="line">    <span class="type">char</span>[] rs1=Arrays.copyOfRange(IR,<span class="number">15</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="type">char</span>[] rs2=Arrays.copyOfRange(IR,<span class="number">20</span>,<span class="number">25</span>);</span><br><span class="line">    <span class="type">char</span>[] rd =Arrays.copyOfRange(IR,<span class="number">7</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rs1_num=getRegister(rs1);</span><br><span class="line">    <span class="type">int</span> rs2_num=getRegister(rs2);</span><br><span class="line">    <span class="type">int</span> rd_num=getRegister(rd);</span><br><span class="line"></span><br><span class="line">    GPR[rd_num]=alu.add(<span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="keyword">new</span> <span class="title class_">String</span>(GPR[rs1_num])),<span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="keyword">new</span> <span class="title class_">String</span>(GPR[rs2_num]))).toString().toCharArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lui：将12-31位的20位立即数加载到目标寄存器的高20位，低12位全0"><a href="#lui：将12-31位的20位立即数加载到目标寄存器的高20位，低12位全0" class="headerlink" title="lui：将12-31位的20位立即数加载到目标寄存器的高20位，低12位全0"></a>lui：将12-31位的20位立即数加载到目标寄存器的高20位，低12位全0</h3><ul>
<li>将一个 <strong>20 位的立即数</strong>加载到<strong>寄存器的高 20 位</strong>，而<strong>低 12 位则被置为 0</strong></li>
<li><strong>rd:7-11位</strong></li>
<li><strong>imm：12-31位</strong></li>
<li><strong>int IMM&#x3D;Integer.valueOf(String.valueOf(imm_num),2)&lt;&lt;12</strong>;<ul>
<li><code>String.valueOf(imm_num)</code>：将 imm_num 转换为字符串。</li>
<li><code>Integer.valueOf(String.valueOf(imm_num), 2)</code>：将上一步得到的字符串<strong>作为二进制数解析</strong>，并转换为一个<strong>整数</strong>。这里的 <strong>2 表示二进制</strong>。</li>
<li><code>&lt;&lt; 12</code>：将解析得到的整数<strong>左移 12 位</strong>。左移 12 位相当于将该整数乘以 2 的 12 次方（4096），这<strong>会将原来的低 12 位置为 0，并将高 20 位保留</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lui</span><span class="params">()</span>&#123;<span class="comment">//将一个 20 位的立即数加载到寄存器的高 20 位，而低 12 位则被置为 0</span></span><br><span class="line">    <span class="comment">//rd:7-11</span></span><br><span class="line">    <span class="comment">//imm:12-31</span></span><br><span class="line">    <span class="type">char</span>[] rd=Arrays.copyOfRange(IR,<span class="number">7</span>,<span class="number">12</span>);</span><br><span class="line">    <span class="type">char</span>[] imm=Arrays.copyOfRange(IR,<span class="number">12</span>,<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rd_num=getRegister(rd);</span><br><span class="line">    <span class="type">int</span> imm_num=getRegister(imm);</span><br><span class="line">    <span class="type">int</span> IMM=Integer.valueOf(String.valueOf(imm_num),<span class="number">2</span>)&lt;&lt;<span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    GPR[rd_num]=Transformer.intToBinary(String.valueOf(IMM)).toCharArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lw：基址寄存器内的值-偏移量得到新地址，将新地址内的值存到目标寄存器中"><a href="#lw：基址寄存器内的值-偏移量得到新地址，将新地址内的值存到目标寄存器中" class="headerlink" title="lw：基址寄存器内的值+偏移量得到新地址，将新地址内的值存到目标寄存器中"></a>lw：基址寄存器内的值+偏移量得到新地址，将新地址内的值存到目标寄存器中</h3><ol>
<li>提取指令字段<ul>
<li>基址寄存器rs1：15-19位</li>
<li>立即数（偏移量）imm：20-31位</li>
<li>目标寄存器rd：7-11位</li>
</ul>
</li>
<li>获取寄存器编号：getRegister()</li>
<li>计算<strong>新内存地址</strong>offset<ul>
<li>将 imm 转换为二进制整数 IMM。（变string，再string变二进制int）</li>
<li>将基址寄存器 GPR[rs1_num] 的值转换为二进制整数 RS1。</li>
<li>计算内存地址 offset，即 IMM 加上 RS1。</li>
</ul>
</li>
<li>从内存中读取数据<ul>
<li>使用 <code>Transformer.intToBinary</code> 方法将 offset 转换为二进制字符串。</li>
<li>调用 <code>getFromMemory</code> 方法从内存中读取数据，并将其存储到目标寄存器 GPR[rd_num] 中。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lw</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//rs1:15-19位</span></span><br><span class="line">    <span class="comment">//imm：20-31位</span></span><br><span class="line">    <span class="comment">//rd:7-11位</span></span><br><span class="line">    <span class="type">char</span>[] rs1=Arrays.copyOfRange(IR,<span class="number">15</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="type">char</span>[] imm=Arrays.copyOfRange(IR,<span class="number">20</span>,<span class="number">32</span>);</span><br><span class="line">    <span class="type">char</span>[] rd =Arrays.copyOfRange(IR,<span class="number">7</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rs1_num=getRegister(rs1);</span><br><span class="line">    <span class="type">int</span> rd_num=getRegister(rd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> IMM=Integer.valueOf(String.valueOf(imm),<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> RS1=Integer.valueOf(String.valueOf(GPR[rs1_num]),<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> offset=IMM+RS1;</span><br><span class="line"></span><br><span class="line">    GPR[rd_num]=getFromMemory(Transformer.intToBinary(String.valueOf(offset)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="addi-源寄存器内的值-偏移量，存入目标寄存器"><a href="#addi-源寄存器内的值-偏移量，存入目标寄存器" class="headerlink" title="addi 源寄存器内的值+偏移量，存入目标寄存器"></a>addi 源寄存器内的值+偏移量，存入目标寄存器</h3><ol>
<li>提取指令字段<ul>
<li>源寄存器rs1：15-19位</li>
<li>立即数（偏移量）imm：20-31位</li>
<li>目标寄存器rd：7-11位</li>
</ul>
</li>
<li>获取寄存器编号：getRegister()</li>
<li>计算<em>立即数</em>和<em>源寄存器内数据</em>的值，转换为<strong>二进制整数</strong></li>
<li>计算结果：立即数+源寄存器内数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addi</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//rs1:15-19位</span></span><br><span class="line">    <span class="comment">//imm：20-31位</span></span><br><span class="line">    <span class="comment">//rd:7-11位</span></span><br><span class="line">    <span class="type">char</span>[] rs1=Arrays.copyOfRange(IR,<span class="number">15</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="type">char</span>[] imm=Arrays.copyOfRange(IR,<span class="number">20</span>,<span class="number">32</span>);</span><br><span class="line">    <span class="type">char</span>[] rd =Arrays.copyOfRange(IR,<span class="number">7</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rs1_num=getRegister(rs1);</span><br><span class="line">    <span class="type">int</span> rd_num=getRegister(rd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> IMM=Integer.valueOf(String.valueOf(imm),<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> RS1=Integer.valueOf(String.valueOf(GPR[rs1_num]),<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=IMM+RS1;</span><br><span class="line"></span><br><span class="line">    GPR[rd_num]=Transformer.intToBinary(String.valueOf(res)).toCharArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="addc：直接add（间址）"><a href="#addc：直接add（间址）" class="headerlink" title="addc：直接add（间址）"></a>addc：直接add（间址）</h3><h3 id="jalr：保存当前程序计数器（PC）的值到返回地址寄存器（ra），然后跳转到新的地址"><a href="#jalr：保存当前程序计数器（PC）的值到返回地址寄存器（ra），然后跳转到新的地址" class="headerlink" title="jalr：保存当前程序计数器（PC）的值到返回地址寄存器（ra），然后跳转到新的地址"></a>jalr：保存当前程序计数器（PC）的值到返回地址寄存器（ra），然后跳转到新的地址</h3><ul>
<li>在<strong>改变PC之前</strong>，我们要先<strong>将返回的位置保存到ra寄存器</strong>中，我们<strong>规定GPR的第1个寄存器是返回地址寄存器</strong>（第0个GPR寄存器保存0）</li>
</ul>
<ol>
<li>提取指令字段<ul>
<li>基质寄存器rs1：15-19位</li>
<li>立即数（偏移量）imm：20-31位</li>
<li>返回地址寄存器ra：7-11位a</li>
</ul>
</li>
<li>获取寄存器编号</li>
<li>计算立即数IMM和基址寄存器内数RS1的值(化为二进制整数)</li>
<li>计算<strong>新地址</strong>，即 <strong>IMM 加上 RS1</strong></li>
<li><strong>保存当前 PC 到ra，并跳转到新地址</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jalr</span><span class="params">()</span>&#123;<span class="comment">//保存并跳转指令</span></span><br><span class="line">    <span class="comment">//rs1:15-19位</span></span><br><span class="line">    <span class="comment">//imm：20-31位</span></span><br><span class="line">    <span class="comment">//ra:7-11位</span></span><br><span class="line">    <span class="type">char</span>[] rs1=Arrays.copyOfRange(IR,<span class="number">15</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="type">char</span>[] imm=Arrays.copyOfRange(IR,<span class="number">20</span>,<span class="number">32</span>);</span><br><span class="line">    <span class="type">char</span>[] ra =Arrays.copyOfRange(IR,<span class="number">7</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rs1_num=getRegister(rs1);</span><br><span class="line">    <span class="type">int</span> ra_num=getRegister(ra);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> IMM=Integer.valueOf(String.valueOf(imm),<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> RS1=Integer.valueOf(String.valueOf(GPR[rs1_num]),<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> newAddr=IMM+RS1;</span><br><span class="line"></span><br><span class="line">    GPR[ra_num]=Arrays.copyOf(PC,<span class="number">32</span>);</span><br><span class="line">    PC=Transformer.intToBinary(String.valueOf(newAddr)).toCharArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ecall：系统调用中断指令。保存当前程序计数器（PC）的值，并设置中断控制器。"><a href="#ecall：系统调用中断指令。保存当前程序计数器（PC）的值，并设置中断控制器。" class="headerlink" title="ecall：系统调用中断指令。保存当前程序计数器（PC）的值，并设置中断控制器。"></a>ecall：系统调用中断指令。保存当前程序计数器（PC）的值，并设置中断控制器。</h3><ul>
<li>规定GPR的第1个寄存器是返回地址寄存器</li>
</ul>
<ol>
<li>PC保存到GPR[1]中</li>
<li>中断信号设置为true</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ecall</span><span class="params">()</span>&#123;<span class="comment">//系统调用中断指令。同样要保存返回位置，同时要设置中断控制器。</span></span><br><span class="line">    interruptController.signal=<span class="literal">true</span>;</span><br><span class="line">    GPR[<span class="number">1</span>]=Arrays.copyOf(PC,<span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-中断"><a href="#5-中断" class="headerlink" title="5. 中断"></a>5. 中断</h2><ul>
<li>使用ecall指令来模拟中断操作。在中断发生时，系统要保存程序的返回位置（是多少？），以便完成中断处理程序后返回原有程序。</li>
</ul>
<ol>
<li>此处我们使用<strong>handleInterrupt</strong>来模拟中断程序的实现。</li>
<li>执行完中断操作后，将<strong>允许中断位改为false</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    interruptController.handleInterrupt();</span><br><span class="line">    interruptController.signal=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>一、计算机网络及其参考模型</title>
    <url>/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="互联网计算"><a href="#互联网计算" class="headerlink" title="互联网计算"></a>互联网计算</h1><h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p> 10% 大作业 + 40% 上机 + 50% 期末</p>
<h2 id="课程资料"><a href="#课程资料" class="headerlink" title="课程资料"></a>课程资料</h2><p>219.219.113.233<br>用户:net<br>密码:net</p>
<h1 id="一、计算机网络概述"><a href="#一、计算机网络概述" class="headerlink" title="一、计算机网络概述"></a>一、计算机网络概述</h1><h3 id="1-What-is-a-network"><a href="#1-What-is-a-network" class="headerlink" title="1. What is a network?"></a>1. What is a network?</h3><ul>
<li>物体,事物,设备,人的连接</li>
<li><strong>LAN</strong>(Local Area Networks) 局域网</li>
<li><strong>WAN</strong>(Wide Area Networks) 广域网</li>
</ul>
<h2 id="2-数据网络分类：LAN-WAN"><a href="#2-数据网络分类：LAN-WAN" class="headerlink" title="2. 数据网络分类：LAN&#x2F;WAN"></a>2. 数据网络分类：LAN&#x2F;WAN</h2><ol>
<li>LANs 局域网 广播方式通信<ol>
<li>Operate locally</li>
<li>Multi-user access 连接可以被共享</li>
<li>High speeds expected 最高达到800G (距离短)</li>
<li>Error rate is easily controlled 因为范围小好判断出错</li>
</ol>
</li>
<li>WANs 广域网<ul>
<li>先于 LAN 网络产生</li>
</ul>
<ol>
<li>Operate over larger areas 现在主要使用光纤</li>
<li>Access over serial links, optical links, etc. <strong>点对点的连接</strong></li>
<li>Traditionally, have <strong>lower</strong> speeds</li>
<li>Error rate can <strong>not</strong> be easily controlled</li>
</ol>
</li>
<li>网络抽象模型<ul>
<li>node：节点</li>
<li>link：链路</li>
</ul>
</li>
</ol>
<h3 id="2-1-局域网和广域网差别"><a href="#2-1-局域网和广域网差别" class="headerlink" title="2.1 局域网和广域网差别"></a>2.1 局域网和广域网差别</h3><ol>
<li>局域网<ul>
<li>作用<strong>范围比较窄</strong></li>
<li>多用户<strong>同时复用链路介质</strong></li>
<li>网络<strong>性能比较高</strong>（一般是一个公司来管理处理，可以达到 GPS 甚至是 10GPS）</li>
<li><strong>出错率</strong>相对比较容易控制（<strong>低</strong>）</li>
</ul>
</li>
<li>广域网<ul>
<li>在比较<strong>大的地理范围</strong>上进行连接</li>
<li>要么<strong>串行连接（serial links）</strong>，要么<strong>光链路连接（optical links）</strong></li>
<li>传统上，<strong>传输速率比较低</strong>，因为一般是多公司管理，标准和介质等都不同</li>
<li><strong>出错率</strong>相对比较<strong>高</strong></li>
</ul>
</li>
</ol>
<h3 id="2-2-LAN-Devices-局域网设备"><a href="#2-2-LAN-Devices-局域网设备" class="headerlink" title="2.2 LAN Devices 局域网设备"></a>2.2 LAN Devices 局域网设备</h3><ol>
<li>Hub 集线器：工作在第一层<ul>
<li>多端口中继器（Reapter），连接 PC</li>
<li>重复信号</li>
</ul>
</li>
<li>Bridge 网桥：工作在第二层<ul>
<li>将局域网分段</li>
<li>进行 MAC 地址的计算</li>
</ul>
</li>
<li>Switch 交换机，多端口网桥：工作在第二层<ul>
<li>多端口网桥</li>
<li>全带宽（满带宽）</li>
<li>大规模集成电路实现：相对于网桥的优点</li>
</ul>
</li>
<li>Router 路由器 ：工作在第三层<ul>
<li>路径选择</li>
<li>分组交换<br><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-1.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ol>
<h3 id="2-3-WAN-Devices-广域网设备"><a href="#2-3-WAN-Devices-广域网设备" class="headerlink" title="2.3 WAN Devices 广域网设备"></a>2.3 WAN Devices 广域网设备</h3><ol>
<li>Router 路由器<ul>
<li>路径选择</li>
<li>分组交换</li>
</ul>
</li>
<li>Modem: 调制解调器</li>
<li>CSU&#x2F;DSU: 通道服务单元&#x2F;数据服务单元</li>
<li>TA&#x2F;NT1: 终端适配器&#x2F;网络终端1</li>
</ol>
<ul>
<li>234都是将<em>模拟信号转换为数字信号</em>, 还可以进行<em>远程局域网连接</em></li>
</ul>
<h3 id="2-4-LAN-Services-and-WAN-Services"><a href="#2-4-LAN-Services-and-WAN-Services" class="headerlink" title="2.4 LAN Services and WAN Services"></a>2.4 LAN Services and WAN Services</h3><ol>
<li>LAN Service: <strong>Ethernet</strong> (以太网) 最流行的局域网服务</li>
<li>WAN Service: 有很多,不是本节课重点</li>
</ol>
<h2 id="3-Internet-互联网"><a href="#3-Internet-互联网" class="headerlink" title="3. Internet 互联网"></a>3. Internet 互联网</h2><ol>
<li>简介</li>
</ol>
<ul>
<li>互联网, 全球性的计算机网络系统, 将世界各地的局域网（LAN）,广域网（WAN）和其他类型的网络连接在一起</li>
<li>全球最大的开放性广域网</li>
<li>TCP&#x2F;IP 作为参考标准</li>
<li>从 ARPNET 发展出来</li>
</ul>
<h3 id="3-1-Internet-with-Multi-layer-ISP-structure（多层-ISP-结构的-Internet"><a href="#3-1-Internet-with-Multi-layer-ISP-structure（多层-ISP-结构的-Internet" class="headerlink" title="3.1 Internet with Multi-layer ISP structure（多层 ISP 结构的 Internet"></a>3.1 Internet with Multi-layer ISP structure（多层 ISP 结构的 Internet</h3><ol>
<li><strong>Internet Service Providers（ISP）：互联网服务提供商</strong><ul>
<li>user——ISP——Internet</li>
</ul>
</li>
<li>具有多层 ISP 结构的 Internet<ul>
<li>主机A → 本地 ISP → 第二层 ISP → NAP → 第一层 ISP → NAP → 第二层 ISP → 本地 ISP → 主机B<br><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-2.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ol>
<ul>
<li><strong>第一层 ISP 是核心层</strong>，主要负责<strong>远距离连通。</strong></li>
<li>这种多层 ISP 结构可以将大量的流量本地化</li>
<li>NAP（Network Access Point）：第一二层之间的接入点，也可以是 google（大公司）直接和第一层 ISP 进行链接</li>
<li>ICP（Internet Content Provider）：互联网内容提供商，不提供接入服务</li>
<li>在低层次的 ISP 可以解决的问题就不进入上一层进行解决，将大量的流量分流。</li>
</ul>
<h1 id="二、计算机网络基本概念"><a href="#二、计算机网络基本概念" class="headerlink" title="二、计算机网络基本概念"></a>二、计算机网络基本概念</h1><h2 id="1-Data数据"><a href="#1-Data数据" class="headerlink" title="1. Data数据"></a>1. Data数据</h2><ul>
<li>Data is sent in bits, 1s and 0s.<ul>
<li><strong>数据按位（1 和 0）为单位发送</strong></li>
</ul>
</li>
<li>Data is not the information itself.<ul>
<li><strong>数据不是信息本身</strong>，不同方式解析数据会是不同信息<ul>
<li>数据都是 0-1 序列，需要按照一定编码格式翻译转码才成为信息</li>
</ul>
</li>
</ul>
</li>
<li>Data is an encoded form of information which is a series of electrical impulses&#x2F;optical signals into which information is transmitted for sending.<ul>
<li><strong>数据是信息的一种编码形式</strong>，它是一系列电脉冲&#x2F;光信号，信息被传输到其中进行发送</li>
</ul>
</li>
</ul>
<h3 id="1-1-Data-Packets数据包"><a href="#1-1-Data-Packets数据包" class="headerlink" title="1.1 Data Packets数据包"></a>1.1 Data Packets数据包</h3><ol>
<li>为了传输，计算机数据通常被分解成<strong>小的、易于传输的单元</strong><ul>
<li>使用 OSI 模型</li>
<li>这些单元可以称为：包packets、帧frames、段segments</li>
<li>具体取决于OSI模型的不同层次<ul>
<li>网络层称为 packets 报文，数据链路层称为 frames 帧，数据段层称为 segments 段</li>
</ul>
</li>
</ul>
</li>
<li>why data packets? 为什么使用数据包？<ul>
<li>Computers can take turns sending packets<ul>
<li><strong>计算机可以轮流发送数据包</strong>，分时段处理不同报文，使得<em>多进程</em>处理事务。</li>
</ul>
</li>
<li>If packet is lost, only small amount of data must be retransmitted重新传输.<ul>
<li>如果数据包<strong>丢失，则只需重新传输少量数据</strong></li>
</ul>
</li>
<li>Data can take different paths.<ul>
<li>数据可以采用<strong>不同的路径</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="1-2-Protocol协议"><a href="#1-2-Protocol协议" class="headerlink" title="1.2 Protocol协议"></a>1.2 Protocol协议</h3><ol>
<li>It is possible for different types of computer systems to communicate<ul>
<li><strong>不同类型的计算机系统可</strong>以进行<strong>通信</strong></li>
</ul>
</li>
<li>All devices must speak the same “language” or use the same <strong>protocol</strong> (use same set of rules).<ul>
<li>所有设备必须使用<strong>相同的“语言”或使用相同的协议</strong>（使用同一套规则）。</li>
</ul>
</li>
</ol>
<h3 id="1-3-Source-and-Destination源地址和目标地址"><a href="#1-3-Source-and-Destination源地址和目标地址" class="headerlink" title="1.3 Source and Destination源地址和目标地址"></a>1.3 Source and Destination源地址和目标地址</h3><ul>
<li><strong>源地址</strong> Source address specifies the identity of the computer sending the packet.<ul>
<li><strong>发送数据包</strong>的计算机的身份</li>
</ul>
</li>
<li><strong>目标地址</strong> Destination address specifies the identity of the computer designated to receive the packet.<ul>
<li><strong>接收数据包</strong>的计算机的身份</li>
</ul>
</li>
</ul>
<h3 id="1-4-传输介质-Media-Types"><a href="#1-4-传输介质-Media-Types" class="headerlink" title="1.4 传输介质 Media Types"></a>1.4 传输介质 Media Types</h3><ol>
<li>Media—material through which data packets travel<ul>
<li>介质是数据包传输所通过的介质。</li>
</ul>
</li>
<li><strong>带宽 Bandwidth</strong>：<ul>
<li>is the measure of how much information can flow from one place to another in a given amount of time.带宽是指在单位时间内可以传输的最大数据量</li>
<li>Measured in: bits&#x2F;second (bps)通常以比特每秒（bps）为单位。<ul>
<li>单位：bps，计算时注意要<strong>将字转换为位</strong></li>
</ul>
</li>
<li>作用: 带宽决定了网络的最大传输能力。带宽越高，网络能够传输的数据量就越大。</li>
<li>类比: 可以将带宽类比为高速公路的车道数，车道越多，能够同时通过的车辆就越多。</li>
</ul>
</li>
<li>通量 Throughput：<ul>
<li>Actual measured bandwidth at a specific time <em>单位时间</em>内<strong>实际</strong>传输的数据量，也以*比特每秒（bps）*为单位。</li>
<li><strong>Throughput &lt;&#x3D; Bandwidth</strong></li>
<li>作用: 通量反映了网络的实际性能，通常会受到网络拥塞、延迟、丢包等因素的影响。</li>
<li>类比: 通量可以类比为高速公路上实际通过的车辆数，即使高速公路有很多车道，但如果有交通堵塞，实际通过的车辆数也会减少。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="三、OSI-参考模型"><a href="#三、OSI-参考模型" class="headerlink" title="三、OSI 参考模型"></a>三、OSI 参考模型</h1><h2 id="1-OSI-Open-System-Interconnection-Model开放系统互连参考模型"><a href="#1-OSI-Open-System-Interconnection-Model开放系统互连参考模型" class="headerlink" title="1. OSI (Open System Interconnection) Model开放系统互连参考模型"></a>1. OSI (Open System Interconnection) Model开放系统互连参考模型</h2><ul>
<li>由国际标准化组织 （ISO） 提议 </li>
<li>是一个<strong>分层的网络架构模型</strong>，用于<em>标准化网络通信的功能</em></li>
<li>帮助网络构建者实现<strong>可以通信和协同工作</strong>的网络模型 </li>
<li>描述<em>信息或数据</em>如何<em>通过网络</em>从一台计算机<em>移动到另一台计算机</em> </li>
<li><strong>分层通信</strong>过程：每一层执行一项特定任务</li>
</ul>
<h2 id="2-The-OSI-Reference-Model层次模型"><a href="#2-The-OSI-Reference-Model层次模型" class="headerlink" title="2. The OSI Reference Model层次模型"></a>2. The OSI Reference Model层次模型</h2><p>+——————-+<br>|   应用层 (Layer 7)<br>|   Application<br>+——————-+<br>|   表示层 (Layer 6)<br>|   Presentation<br>+——————-+<br>|   会话层 (Layer 5)<br>|   Session<br>+——————-+<br>|   传输层 (Layer 4)<br>|   Transport<br>+——————-+<br>|   网络层 (Layer 3)<br>|   Network<br>+——————-+<br>|   数据链路层 (Layer 2)<br>|   Data Link<br>+——————-+<br>|   物理层 (Layer 1)<br>|   Physical<br>+——————-+</p>
<h2 id="3-OSI模型的七层结构"><a href="#3-OSI模型的七层结构" class="headerlink" title="3. OSI模型的七层结构"></a>3. OSI模型的七层结构</h2><ul>
<li><ol>
<li><strong>物理层</strong> (Physical Layer)</li>
</ol>
<ul>
<li>Keywords: <strong>Signal and Media 信号和介质</strong></li>
<li>Binary transmission 二进制传输</li>
<li>功能: 负责传输原始的比特流。</li>
</ul>
</li>
<li><ol start="2">
<li><strong>数据链路层</strong> (Data Link Layer)</li>
</ol>
<ul>
<li>Keywords: <strong>frame, media access control 帧和介质访问控制</strong></li>
<li>Access to media 介质访问</li>
<li>功能: 负责节点之间的可靠传输。负责帧的创建、传输和错误检测。</li>
</ul>
</li>
<li><ol start="3">
<li><strong>网络层</strong> (Network Layer)</li>
</ol>
<ul>
<li>Keywords: <strong>Path selection路径选择, Routing路由, Addressing寻址</strong></li>
<li>Addresses and best path <strong>路径选择，最优路径</strong></li>
<li>功能: 在进行路由的两个终端系统之间提供连接和路径选择</li>
</ul>
</li>
<li><ol start="4">
<li><strong>传输层</strong> (Transport Layer)</li>
</ol>
<ul>
<li>Keywords: <strong>Reliability可靠性, Flow control流量控制, Error correction纠错</strong></li>
<li>End-to-end connections 终端到终端通信</li>
<li>功能: 负责终端节点之间的可靠网络通信，负责数据传输的流量控制，并为虚拟电路的建立、维护和终止、传输故障检测和恢复提供机制</li>
</ul>
</li>
<li><ol start="5">
<li><strong>会话层</strong> (Session Layer)</li>
</ol>
<ul>
<li>Keywords: <strong>Dialog and Conversations 对话和交流</strong></li>
<li>Inter-host connection 进程之间通信如何用户交流</li>
<li>功能: 管理和控制（建立、维护和终止）应用程序之间的会话；manages data exchange between presentation layer entities管理表示层实体之间的数据交换。</li>
</ul>
</li>
<li><ol start="6">
<li><strong>表示层</strong> (Presentation Layer)</li>
</ol>
<ul>
<li>Keywords:<strong>Common Format 标准</strong></li>
<li>Data presentation and encryption 展示</li>
<li>功能: 负责数据的格式化、加密和解密，确保数据的语法和语义正确。</li>
</ul>
</li>
<li><ol start="7">
<li><strong>应用层</strong> (Application Layer)</li>
</ol>
<ul>
<li>Keyword: <strong>Browser 浏览</strong></li>
<li>User interface 给用户展示交互接口</li>
<li>功能: 提供网络服务和应用程序接口，直接为用户和应用程序提供服务。</li>
</ul>
</li>
</ul>
<h2 id="4-分组"><a href="#4-分组" class="headerlink" title="4. 分组"></a>4. 分组</h2><ul>
<li>（1）application layers<strong>应用层</strong><ul>
<li>Application应用</li>
<li>Presentation展示</li>
<li>Session会话</li>
<li>deal with the user interface, data formatting, and the application access<ul>
<li>处理了用户接口，数据格式和应用权限</li>
</ul>
</li>
</ul>
</li>
<li>（2）data flow layers<strong>数据流层</strong><ul>
<li>Transport传输<br> Network网络<br> Data Link数据链路<br> Physical物理</li>
<li>control the physical delivery of messages over the network.<ul>
<li>控制着通过网络传输的数据信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-Data-Encapsulation数据封装"><a href="#5-Data-Encapsulation数据封装" class="headerlink" title="5. Data Encapsulation数据封装"></a>5. Data Encapsulation数据封装</h2><ul>
<li><p>定义：<br>数据封装是指在网络通信中，数据在传输过程中<code>通过各层协议逐层添加协议头（header）和协议尾（trailer）</code>的过程。每一层协议都在数据包的<code>前面或后面添加特定的信息</code>，以便在接收端能够正确地解析和处理数据。</p>
</li>
<li><p>基本步骤：</p>
<ol start="7">
<li>应用层（Application Layer）：<br> 数据生成并准备传输。</li>
<li>表示层（Presentation Layer）：<br> 数据格式化和加密。</li>
<li>会话层（Session Layer）：<br> 管理会话和数据交换。</li>
<li>传输层（Transport Layer）：<br> 添加<strong>传输层头部</strong>（如TCP&#x2F;UDP头），用于数据分段和重组。</li>
<li>网络层（Network Layer）：<br> 添加网<strong>络层头部</strong>（如IP头），用于路由和寻址。</li>
<li>数据链路层（Data Link Layer）：<br> 添加<strong>数据链路层头部和尾部</strong>（如MAC地址和帧<em>校验</em>序列），用于帧的传输和错误检测。</li>
<li>物理层（Physical Layer）：<br> 将数据转换为电信号或光信号，通过物理介质传输。</li>
</ol>
</li>
<li><p>数据封装过程</p>
<ul>
<li>5-&gt;4：添加首部 H5，应用程序数据作为数据部分</li>
<li>4-&gt;3：添加首部 H4，第五层的作为数据部分</li>
<li>3-&gt;2：添加首部 H3，第四层的作为数据部分</li>
<li>2-&gt;1：添加首部 H2 和尾部 T2（校验位），第三层的作为数据部分</li>
<li>1：转成比特流进行发送</li>
</ul>
</li>
<li><p>在接收端，数据封装的过程将逆向进行，即逐层剥离协议头和协议尾，直到还原出原始数据。</p>
</li>
</ul>
<h2 id="6-Peer-to-Peer-Communications-点对点通信"><a href="#6-Peer-to-Peer-Communications-点对点通信" class="headerlink" title="6. Peer-to-Peer Communications 点对点通信"></a>6. Peer-to-Peer Communications 点对点通信</h2><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/peertopeer%20communications.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h1 id="四、TCP-IP-Model"><a href="#四、TCP-IP-Model" class="headerlink" title="四、TCP&#x2F;IP Model"></a>四、TCP&#x2F;IP Model</h1><h2 id="1-组成"><a href="#1-组成" class="headerlink" title="1. 组成"></a>1. 组成</h2><ul>
<li>含有<strong>四层</strong><ul>
<li>应用层Application</li>
<li>传输层Transport</li>
<li>网络层Internet</li>
<li>网络访问层Network Access</li>
</ul>
</li>
</ul>
<h2 id="2-功能"><a href="#2-功能" class="headerlink" title="2.功能"></a>2.功能</h2><ul>
<li>（1）<strong>Application Layer 应用层</strong><ul>
<li>处理高级协议、表示、编码和会话控制问题<ul>
<li>包含[OSI]中上三层（应用层、表示层、会话层）的全部功能</li>
</ul>
</li>
<li>Handles <strong>high-level protocols</strong>, issues of <strong>representation, encoding, and session control</strong></li>
<li>TCP&#x2F;IP将所有与应用程序相关的问题合并到一个层中，并确保这些数据被正确打包到下一层。</li>
</ul>
</li>
<li>（2）<strong>Transport Layer 传输层</strong><ul>
<li>处理服务质量问题，如可靠性、流量控制和错误校正 <ul>
<li>对应[OSI]中第4层：传输层</li>
</ul>
</li>
<li>Deals with the quality-of-service issues of <strong>reliability, flow control, and error correction</strong>.</li>
</ul>
</li>
<li>（3）<strong>Internet Layer 网络层</strong><ul>
<li>最优路径的选择（报文从一方发送给另一方，报文传输经过<em>路由器</em>进行路径选择）<ul>
<li>对应[OSI]中第3层：网络层</li>
</ul>
</li>
<li><strong>Best path determination and packet switching</strong></li>
</ul>
</li>
<li>（4）<strong>Network Access 网络接入层</strong><ul>
<li>也称为<strong>host-to-network layer 主机到网络层</strong>。 <ul>
<li>包含[OSI]中下两层：物理层和数据链路层</li>
</ul>
</li>
<li>它关注 IP 分组实际建立物理链路，然后建立另一个物理链路所需的所有问题。</li>
<li>它包括 LAN 和 WAN 技术的细节，以及 OSI 物理和数据链路层中的所有细节。</li>
</ul>
</li>
</ul>
<h2 id="3-名词解释——常见的TCP-IP协议"><a href="#3-名词解释——常见的TCP-IP协议" class="headerlink" title="3.名词解释——常见的TCP&#x2F;IP协议"></a>3.名词解释——常见的TCP&#x2F;IP协议</h2><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-3.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>FTP <ul>
<li>File Transfer Protocol 文件传输协议</li>
</ul>
</li>
<li>HTTP <ul>
<li>Hypertext Transfer Protocol 超文本传输协议</li>
<li>主要用于浏览器</li>
</ul>
</li>
<li>SMTP <ul>
<li>Simple Mail Transfer protocol 简单邮件传输协议</li>
</ul>
</li>
<li>DNS <ul>
<li>Domain Name System 域名解析系统</li>
<li>将域名解析成IP地址</li>
</ul>
</li>
<li>TFTP <ul>
<li>Trivial File Transfer Protocol 简单文件传输协议</li>
<li>基于UDP，在局域网发送较小文件</li>
</ul>
</li>
</ul>
<h2 id="4-TCP-IP-和-OSI-的相似点"><a href="#4-TCP-IP-和-OSI-的相似点" class="headerlink" title="4. TCP&#x2F;IP 和 OSI 的相似点"></a>4. TCP&#x2F;IP 和 OSI 的相似点</h2><ul>
<li>both have layers, networking professionals need to know both<ul>
<li>层次</li>
</ul>
</li>
<li>both have application layers, though they include very different services <ul>
<li>应用层（虽然服务不同）</li>
</ul>
</li>
<li>both have comparable transport and network layers <ul>
<li>相同的传输层和网络层</li>
</ul>
</li>
<li>packet-switched (not circuit-switched) technology is assumed <ul>
<li>假设采用<strong>分组交换（非电路交换）技术</strong></li>
</ul>
</li>
<li>OSI 是<strong>基于报文交换</strong>来进行实现的，TCP&#x2F;IP 也是基于报文交换来完成实现的。</li>
</ul>
<h2 id="5-TCP-IP-和-OSI-的不同点"><a href="#5-TCP-IP-和-OSI-的不同点" class="headerlink" title="5.TCP&#x2F;IP 和 OSI 的不同点"></a>5.TCP&#x2F;IP 和 OSI 的不同点</h2><ol>
<li>TCP&#x2F;IP 看起来更简单，因为它有更少的层</li>
<li><strong>TCP&#x2F;IP 协议是因特网发展的标准，因此 TCP&#x2F;IP 模型正是因为它的协议才获得了可信性</strong>。</li>
<li>通常网络不是建立在 OSI 协议之上的，即使 OSI 模型被用作指南。</li>
<li><strong>TCP&#x2F;IP 标准是大家都在使用的标准（实施标准）</strong>，5 层和 7 层都只是讲课使用的</li>
<li>本课程我们一般使用<strong>5 层</strong>来进行分割讲解。<br><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-4.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<hr>
<h1 id="五-Network-Topology-网络拓扑"><a href="#五-Network-Topology-网络拓扑" class="headerlink" title="五.Network Topology 网络拓扑"></a>五.Network Topology 网络拓扑</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><ul>
<li>网络拓扑是指<strong>网络中各个节点</strong>（如计算机、路由器、交换机等）之间的<strong>物理或逻辑连接方式</strong>。不同的网络拓扑结构有不同的特点和适用场景。</li>
</ul>
<h2 id="2-常见的网络拓扑结构包括："><a href="#2-常见的网络拓扑结构包括：" class="headerlink" title="2.常见的网络拓扑结构包括："></a>2.常见的网络拓扑结构包括：</h2><ul>
<li>物理拓扑：导线（介质）的实际布局<ul>
<li>总线、星形、环形、扩展星形、分层（树形）、渔网型（mesh）</li>
<li>如何把节点具体连接起来<br><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-5.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li>逻辑拓扑：定义主机如何访问媒体<ul>
<li>令牌传递，使用 token 来获取通信的权利</li>
<li>主要涉及到管理介质如何被访问</li>
</ul>
</li>
<li>逻辑拓扑：主要是指如何在逻辑上如何控制网络</li>
</ul>
<h3 id="1-总线拓扑（Bus-Topology）"><a href="#1-总线拓扑（Bus-Topology）" class="headerlink" title="1. 总线拓扑（Bus Topology）"></a>1. 总线拓扑（Bus Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-6.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Physical Perspective：<ul>
<li><strong>所有节点通过一条主干电缆连接</strong>。</li>
<li>数据在主干电缆上传输，所有节点都能接收到数据。</li>
<li>优点：<ul>
<li>所有主机都可以直接通信。</li>
</ul>
</li>
<li>缺点：<ul>
<li>主干电缆故障会导致整个网络瘫痪，断开主机之间的连接。</li>
</ul>
</li>
</ul>
</li>
<li>Logical Perspective：<ul>
<li>Every networking device to see all signals from all other devices</li>
<li><strong>每个网络设备都可以看到来自所有其他设备的所有信号</strong>，实际上是广播式传播</li>
<li>优点：比较简单，所有的设备都可以监听到总线的信号。</li>
<li>缺点：<ul>
<li>信号冲突，需要进行复杂的介质访问权限控制来保证通信正常</li>
<li>如果<strong>一处断开，则全部无法</strong>进行网络传输</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-环形拓扑（Ring-Topology）"><a href="#2-环形拓扑（Ring-Topology）" class="headerlink" title="2. 环形拓扑（Ring Topology）"></a>2. 环形拓扑（Ring Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-7.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Physical Perspective：<ul>
<li><strong>所有的设备直接首尾相连，组成一个菊花链（daisy-chain）</strong></li>
<li>数据沿着环路单向或双向传输。</li>
<li>优点：<ul>
<li>数据传输延迟较小。</li>
<li>适用于负载均衡。</li>
</ul>
</li>
<li>缺点：<ul>
<li><strong>任意一个节点或连接故障都会影响整个网络</strong>。</li>
<li>故障定位和修复较为复杂。</li>
</ul>
</li>
</ul>
</li>
<li>Logical Perspective<ul>
<li>为了使信息流动，每个站点必须将信息传递给其相邻的站点。</li>
<li>我们需要对于链路进行访问控制，防止很多设备同时使用环，我们使用 token 来进行控制访问权力</li>
</ul>
</li>
</ul>
<h3 id="3-双环拓扑（Dual-Ring-Topology）"><a href="#3-双环拓扑（Dual-Ring-Topology）" class="headerlink" title="3. 双环拓扑（Dual Ring Topology）"></a>3. 双环拓扑（Dual Ring Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-8.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Physical Perspective<ul>
<li>每个节点通过两条环形链路连接到相邻节点，形成<code>两个</code>独立的环。</li>
<li>双环拓扑是指一个节点有两个点，同时只能一个环在传输信息，两个环的传输时的方向是不能确定的。</li>
</ul>
</li>
<li>Logical Perspective<ul>
<li>双环拓扑就像两个独立的环，<strong>同一时间只有一个环被应用</strong>。</li>
<li>有 token 令牌才有发送权力发送信息（使用总线）</li>
</ul>
</li>
<li>优点:<ul>
<li>提供可靠性和灵活性</li>
<li>容错性：一个环出现故障时，数据可以通过另一个环继续传输，确保网络的可靠性。</li>
</ul>
</li>
<li>Eg.优先使用外环，如果外环出现物理错误，则切换到内环上使用，并且对外环进行物理修复。</li>
</ul>
<h3 id="4-星型拓扑（Star-Topology）"><a href="#4-星型拓扑（Star-Topology）" class="headerlink" title="4. 星型拓扑（Star Topology）"></a>4. 星型拓扑（Star Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-9.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Physical Perspective：<ul>
<li>星型拓扑结构有一个<strong>中心节点</strong>，所有的链路都从它辐射（radiating）出去。</li>
</ul>
</li>
<li>Logical Perspective<ul>
<li><strong>所有信息的流动将通过一个设备</strong>。</li>
</ul>
</li>
<li>优点：<ul>
<li>它允许所有其他节点相互通信，方便。出于安全或限制访问的原因，它也可能是可取的</li>
</ul>
</li>
<li>缺点：<ul>
<li><strong>中央节点故障会导致整个网络瘫痪</strong>。</li>
<li>根据使用的网络设备类型，冲突可能是一个问题，中心点会有很大的负担，并且容易造成通信阻塞</li>
</ul>
</li>
</ul>
<h3 id="5-树形拓扑（Tree-Topology）"><a href="#5-树形拓扑（Tree-Topology）" class="headerlink" title="5. 树形拓扑（Tree Topology）"></a>5. 树形拓扑（Tree Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-10.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>树拓扑使用一个主干节点（Trunk Node），从该节点分支到其他节点。</li>
<li>物理观点：主干是一条有几层分支的电线。</li>
<li>逻辑观点：信息流是层次性的。</li>
<li>在根一级数据节点可以对数据进行汇总和统计</li>
</ul>
<h3 id="6-渔网状拓扑（Mesh-Topology）"><a href="#6-渔网状拓扑（Mesh-Topology）" class="headerlink" title="6. 渔网状拓扑（Mesh Topology）"></a>6. 渔网状拓扑（Mesh Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-11.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Physical Perspective：</li>
<li><strong>每个节点</strong>与网络中的<strong>其他节点直接相连</strong>。<ul>
<li>优点：<ul>
<li>高度冗余，任意节点或连接故障不会影响网络整体。</li>
<li>高可靠性和稳定性。 the maximum connectivity and reliability.</li>
</ul>
</li>
<li>缺点：<ul>
<li>结构复杂，成本高。</li>
<li>需要大量的电缆和端口。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-蜂窝拓扑（Cellular-Topology）"><a href="#7-蜂窝拓扑（Cellular-Topology）" class="headerlink" title="7. 蜂窝拓扑（Cellular Topology）"></a>7. 蜂窝拓扑（Cellular Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-12.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>物理视角（Physical Perspective）<ul>
<li>蜂窝拓扑结构是用于<strong>无线技术</strong>的拓扑结构</li>
<li>有时接收节点移动（如<em>手机</em>），有时发送节点移动（如<em>卫星</em>）</li>
</ul>
</li>
<li>逻辑视角（Logical Perspective）<ul>
<li>节点之间直接通信（尽管有时非常困难），或者只与相邻的单元通信，这是<strong>非常低效</strong>的。</li>
<li>每一个节点都是无线的连通方式：远节点需要进行转发。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="六-Network-Devices-网络设备"><a href="#六-Network-Devices-网络设备" class="headerlink" title="六.Network Devices 网络设备"></a>六.Network Devices 网络设备</h1><h2 id="1-LAN-Devices-in-a-Topology"><a href="#1-LAN-Devices-in-a-Topology" class="headerlink" title="1.LAN Devices in a Topology"></a>1.LAN Devices in a Topology</h2><ul>
<li>主机<strong>Hosts</strong> （网络终端设备）：<ul>
<li><strong>直接连接到网段的设备</strong></li>
<li>打印机、计算机、服务器、传真机、复印机</li>
</ul>
</li>
<li>Hosts（网络中间设备）<ul>
<li><strong>主机不属于任何层</strong>，但 OSI 模型的功能在主机内部的软件中执行</li>
</ul>
</li>
</ul>
<h2 id="2-NIC-网络接口卡-–-Layer-2（Data-Link数据链路层）"><a href="#2-NIC-网络接口卡-–-Layer-2（Data-Link数据链路层）" class="headerlink" title="2.NIC 网络接口卡 – Layer 2（Data Link数据链路层）"></a>2.NIC 网络接口卡 – Layer 2（Data Link数据链路层）</h2><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-13.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>NIC，第二层，网卡（Network Interface Controller），<strong>网络终端设备</strong></li>
<li>携带称为 MAC 地址的唯一代码，固定地址，在芯片上</li>
<li>用于控制网络上主机的数据通信</li>
<li>将计算机产生的并行信号转换成串行格式通过网络发送</li>
<li>用于转换信号以及发送和接收比特的收发器</li>
<li>提供主机对媒体的访问权限</li>
<li>为什么是第二层的设备：<ul>
<li>可以识别帧</li>
<li>帮助主机接入网络</li>
</ul>
</li>
<li>计算机母线：并行通信；网卡总线：串行通信<ul>
<li>所以网卡需要完成两者之间的交换。</li>
</ul>
</li>
<li>也是可以完成第一层的工作的</li>
</ul>
<h2 id="3-Media介质-–-Layer-1"><a href="#3-Media介质-–-Layer-1" class="headerlink" title="3.Media介质 – Layer 1"></a>3.Media介质 – Layer 1</h2><ul>
<li>网络中间设备，第一层</li>
</ul>
<ol>
<li><strong>以位为单位携带信息流</strong></li>
<li>信号从一个网络设备传送到另一个网络设备的方式</li>
<li>0-1 信号变为电信号或者无线电波光信号等。</li>
</ol>
<h2 id="4-Repeaters中继器-Layer-1（物理层）"><a href="#4-Repeaters中继器-Layer-1（物理层）" class="headerlink" title="4.Repeaters中继器 - Layer 1（物理层）"></a>4.Repeaters中继器 - Layer 1（物理层）</h2><ul>
<li>网络中间设备</li>
<li>主要功能：<ul>
<li><strong>延长网络长度</strong>：<ul>
<li>用于延长网络的物理长度，实现传输超出一段介质传输的介质</li>
</ul>
</li>
<li>清理、放大和重发信号：<ul>
<li>清理、放大和重发由于长电缆传输而减弱的信号。</li>
</ul>
</li>
<li>信号再生和重定时：<ul>
<li>在<em>比特级别</em>重新生成（放大）和重定时网络信号（<strong>数字信号</strong>），以允许它们在媒体上传播更长的距离</li>
</ul>
</li>
<li>不进行过滤：<ul>
<li>中继器不对数据包进行任何过滤或处理，只是简单地转发信号。</li>
</ul>
</li>
</ul>
</li>
<li>这些功能确保了信号在长距离传输中的完整性和可靠性。</li>
</ul>
<h2 id="5-Hubs（集线器）-–-Layer-1"><a href="#5-Hubs（集线器）-–-Layer-1" class="headerlink" title="5.Hubs（集线器） – Layer 1"></a>5.Hubs（集线器） – Layer 1</h2><ul>
<li>网络中间设备</li>
<li>信号再生和重定时：用于重新生成和重定时网络信号，连接多个端口，可以比中继器做更多的事情</li>
<li>传播信号propagate signals<ul>
<li><code>不能过滤流量</code>cannot filter traffic</li>
<li><code>不能确定最佳路径</code>cannot determine the best path</li>
<li>网络中心节点used as network concentration points</li>
<li>有时称为多端口中继器sometimes called multiport repeaters</li>
</ul>
</li>
<li>逻辑拓扑：<strong>总线方式连接</strong>，一个端口入，所有端口出</li>
<li>不允许总线上同时有两路信号进行传输</li>
<li>冲突域：可能出现冲突的区域，但是集线器不进行这些控制，而是由交换机或者路由器来完成控制，不能降低冲突概率</li>
<li>而放大器方法的是模拟信号。</li>
</ul>
<h3 id="Repeaters-Hubs-Difference中继器和集线器的不同"><a href="#Repeaters-Hubs-Difference中继器和集线器的不同" class="headerlink" title="Repeaters&#x2F;Hubs - Difference中继器和集线器的不同"></a>Repeaters&#x2F;Hubs - Difference中继器和集线器的不同</h3><ul>
<li>中继器通常只有两个端口，而集线器通常有4个到20个或更多端口。</li>
<li>中继器在<strong>一个端口接收</strong>信号，并在<strong>另一个端口重复</strong>信号，而集线器在<strong>一个端口接收</strong>信号并在<strong>所有其他端口传输</strong>信号。</li>
<li>集线器最常见于以太网10Base-T或100Base-T网络中。</li>
<li>都是转发，<strong>都不做过滤功能</strong></li>
<li>两个设备之间最多有 4 个集线器和网桥</li>
</ul>
<h2 id="6-Bridges（网桥）-–-Layer-2（数据链路层）"><a href="#6-Bridges（网桥）-–-Layer-2（数据链路层）" class="headerlink" title="6.Bridges（网桥） – Layer 2（数据链路层）"></a>6.Bridges（网桥） – Layer 2（数据链路层）</h2><ul>
<li>网络中间设备</li>
</ul>
<ol>
<li>目的是在 LAN 上过滤流量，以保持本地流量，但允许连接到 LAN 的其他部分以定向到那里的流量</li>
<li>跟踪网桥两侧的 MAC 地址，并根据此 MAC 地址列表进行决策<ul>
<li>目的地址如果在同一端，就不进行转发（不必进行转发，MAC Table）</li>
<li>而在不同侧（不同的 segments）就进行尽量向外转发</li>
</ul>
</li>
<li>比集线器更智能</li>
<li>收集并在段之间传递数据包</li>
<li>创建冲突域<ul>
<li>通过网桥划分冲突域</li>
<li>每个冲突域中都有一定的主机</li>
<li>第一层以上的设备才能划分冲突域</li>
</ul>
</li>
<li>维护地址表</li>
</ol>
<ul>
<li>这些功能使得网桥在局域网中能够有效地管理和优化流量，提高网络的整体性能和效率。</li>
</ul>
<h2 id="7-Switches（交换机）-–-Layer-2"><a href="#7-Switches（交换机）-–-Layer-2" class="headerlink" title="7.Switches（交换机） – Layer 2"></a>7.Switches（交换机） – Layer 2</h2><ul>
<li>网络中间设备</li>
<li>集中连接 used to concentrate connectivity</li>
<li>结合集线器的连接性和网桥的流量调节 combine the connectivity of a hub with the traffic regulation of a bridge</li>
<li>switch frames from incoming ports to outgoing ports providing each port with full bandwidth 根据MAC地址表将帧从输入端口切换到相应的输出端口，为每个端口提供全带宽。</li>
<li>provide separate data paths 为每个连接的设备提供独立的数据路径，避免冲突，提高网络性能。</li>
</ul>
<h2 id="8-Routers路由器-–-Layer-3"><a href="#8-Routers路由器-–-Layer-3" class="headerlink" title="8.Routers路由器 – Layer 3"></a>8.Routers路由器 – Layer 3</h2><ul>
<li>网络中间设备</li>
<li>在大型网络中调节流量。</li>
<li>基于网络地址（如IP地址）做出转发决策。<ul>
<li>主要是进行网段的划分，根据网络地址（包含在 IP 地址中）进行转化</li>
</ul>
</li>
<li>检查数据包的第三层数据，选择最佳路径，并通过适当的输出端口转发数据包。</li>
<li><code>主要目的</code>：<ul>
<li>用于<strong>路径选择</strong>和<strong>将数据包切换到最佳路由</strong>。</li>
</ul>
</li>
</ul>
<h2 id="9-Evolution-of-Networking-Devices-and-the-OSI-Layers"><a href="#9-Evolution-of-Networking-Devices-and-the-OSI-Layers" class="headerlink" title="9.Evolution of Networking Devices and the OSI Layers"></a>9.Evolution of Networking Devices and the OSI Layers</h2><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>网络设备的工作层次和主机情况<ul>
<li>物理层：<strong>介质、中继器、集线器</strong></li>
<li>数据链路层：<strong>网桥、交换机、电路交换设备</strong></li>
<li>网络层：<strong>路由器</strong></li>
</ul>
</li>
</ol>
<ul>
<li>高层设备可以识别低层设备的信号，但是低层设备不能识别高层次的数据逻辑</li>
<li>Host 下层通过网卡进行实现，上层通过网络操作系统、应用实现</li>
</ul>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>七、路由和路由器</title>
    <url>/2025/02/24/%E4%B8%83.%E8%B7%AF%E7%94%B1%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="07-Routing-and-Routers"><a href="#07-Routing-and-Routers" class="headerlink" title="07. Routing and Routers"></a>07. Routing and Routers</h1><ul>
<li>Router Basics</li>
<li>Router Startup procedure</li>
<li>Routing</li>
<li>Router configuration</li>
</ul>
<h1 id="一、Router-Basics-路由器基础"><a href="#一、Router-Basics-路由器基础" class="headerlink" title="一、Router Basics 路由器基础"></a>一、Router Basics 路由器基础</h1><h2 id="1-内部组成"><a href="#1-内部组成" class="headerlink" title="1. 内部组成"></a>1. 内部组成</h2><p><img src="/2025/02/24/%E4%B8%83.%E8%B7%AF%E7%94%B1%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8/image.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><strong>RAM</strong> 随机存取存储器<ul>
<li>用于<strong>临时</strong>存储路由器<strong>配置文件</strong></li>
<li><strong>断电或重启</strong>时RAM内容会<strong>丢失</strong></li>
<li>存储内容包括：<ul>
<li><strong>路由表</strong></li>
<li>ARP缓存</li>
<li>快速交换缓存</li>
<li>数据包缓冲</li>
<li>数据包保持队列</li>
</ul>
</li>
</ul>
</li>
<li><strong>NVRAM</strong> 非易失性随机存取存储器<ul>
<li><strong>非易失性 Non-volatile</strong> 随机存取存储器</li>
<li>存储备份&#x2F;启动配置文件</li>
<li>路由器断电或重启时内容<strong>不会丢失</strong></li>
</ul>
</li>
<li><strong>Flash</strong><ul>
<li><strong>EEPROM</strong>（电子可擦除可编程只读存储器）<ul>
<li>Electronically Erasable Programmable Read-Only Memory</li>
</ul>
</li>
<li>存储Cisco IOS（互联网操作系统）</li>
<li>允许在不更换Flash芯片的情况下更新软件</li>
<li>可以存储多个版本的IOS</li>
<li>断电时内容<strong>不会丢失</strong></li>
</ul>
</li>
<li><strong>ROM</strong> 只读存储器 Read-Only Memory<ul>
<li>包含<strong>上电自检POST</strong>（Power On Self Test）</li>
<li><strong>启动程序</strong>（加载Cisco IOS）</li>
<li>操作系统软件</li>
<li>备份的精简版IOS</li>
<li>升级需要安装新的芯片组</li>
</ul>
</li>
<li><strong>Interface</strong> 接口<ul>
<li>网络连接，通过这些接口连接数据包进入和退出路由器</li>
<li>附加在主板上或作为独立模块</li>
</ul>
</li>
</ol>
<hr>
<h1 id="Router-Startup-Procedure-路由器启动步骤"><a href="#Router-Startup-Procedure-路由器启动步骤" class="headerlink" title="Router Startup Procedure 路由器启动步骤"></a>Router Startup Procedure 路由器启动步骤</h1><h2 id="1-系统启动过程-System-Startup-Procedure"><a href="#1-系统启动过程-System-Startup-Procedure" class="headerlink" title="1. 系统启动过程: System Startup Procedure"></a>1. 系统启动过程: System Startup Procedure</h2><ol>
<li><strong>执行上电自检（POST）</strong>：<ul>
<li>在自检过程中，路由器从<strong>ROM</strong>中执行诊断，检查所有硬件模块。</li>
</ul>
</li>
<li><strong>验证基本操作</strong>：<ul>
<li>验证CPU、内存和网络接口端口的基本操作。</li>
</ul>
</li>
<li><strong>软件初始化</strong>：<ul>
<li>初始化操作系统和其他软件组件。</li>
</ul>
</li>
</ol>
<h2 id="2-软件启动过程"><a href="#2-软件启动过程" class="headerlink" title="2. 软件启动过程:"></a>2. 软件启动过程:</h2><ol>
<li><strong>步骤1</strong>：通用引导加载程序在ROM中执行，在CPU卡上运行。</li>
<li><strong>步骤2</strong>：操作系统（Cisco IOS）可以在多个位置找到。位置在配置寄存器的引导字段中指定。</li>
<li><strong>步骤3</strong>：加载操作系统映像。</li>
<li><strong>步骤4</strong>：将保存在NVRAM中的配置文件加载到主内存中，并逐行执行。</li>
<li><strong>步骤5</strong>：如果NVRAM中没有有效的配置文件，则执行一个问题驱动的初始配置例程，称为系统配置对话，也称为设置模式。</li>
</ol>
<h2 id="3-检验基本的路由配置"><a href="#3-检验基本的路由配置" class="headerlink" title="3. 检验基本的路由配置"></a>3. 检验基本的路由配置</h2><ul>
<li>使用show running-config 命令</li>
<li>存储路由器基本配置copy running-config<br> startup-config</li>
</ul>
<hr>
<h1 id="三、Routing-路由"><a href="#三、Routing-路由" class="headerlink" title="三、Routing 路由"></a>三、Routing 路由</h1><h2 id="1-使用网络寻址进行路由"><a href="#1-使用网络寻址进行路由" class="headerlink" title="1. 使用网络寻址进行路由"></a>1. 使用网络寻址进行路由</h2><p><img src="/2025/02/24/%E4%B8%83.%E8%B7%AF%E7%94%B1%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8/image-1.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>路由器通常通过两个基本功能将数据包从一个数据链路中继到另一个数据链路：<ol>
<li><strong>path determination 路径确定功能</strong>：决定数据包的最佳传输路径。</li>
<li><strong>switching 交换功能</strong>：将数据包从<em>输入接口</em>转发到适当的<em>输出接口</em>。</li>
</ol>
</li>
<li><strong>交换功能</strong>允许路由器<strong>在一个接口上接受数据包</strong>并<strong>通过第二个接口转发</strong>。</li>
<li><strong>路径确定功能</strong>使路由器能够<strong>选择最合适的接口</strong>来<strong>转发数据包</strong>。</li>
<li>路由器使用地址的<strong>网络部分</strong>进行<em>路径选择</em>，以将数据包传递到<em>下一个路由器</em></li>
<li>地址的<strong>节点部分</strong>由<em>直接连接到目标网络的路由器</em> 使用，以将数据包传递到<em>正确的主机</em>。</li>
</ol>
<h2 id="2-Static-and-Dynamic-Route-静态和动态路由"><a href="#2-Static-and-Dynamic-Route-静态和动态路由" class="headerlink" title="2. Static and Dynamic Route 静态和动态路由"></a>2. Static and Dynamic Route 静态和动态路由</h2><p><img src="/2025/02/24/%E4%B8%83.%E8%B7%AF%E7%94%B1%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8/image-2.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="2-1-静态路由例子"><a href="#2-1-静态路由例子" class="headerlink" title="2.1. 静态路由例子"></a>2.1. 静态路由例子</h3><ul>
<li><img src="/2025/02/24/%E4%B8%83.%E8%B7%AF%E7%94%B1%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8/image-3.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>尽管（whereas）动态路由倾向于显示（reveal）有关互联网络的所有已知信息，但是出于安全原因，您可能<em>希望隐藏互联网络的某些部分</em>。</li>
<li>当<em>只有一条路径可访问网络时</em>，到网络的静态路由就足够了。</li>
<li>这种分区称为<strong>Stub Network</strong></li>
</ul>
<h3 id="2-2-静态路由配置Configuration"><a href="#2-2-静态路由配置Configuration" class="headerlink" title="2.2. 静态路由配置Configuration"></a>2.2. 静态路由配置Configuration</h3><p><img src="/2025/02/24/%E4%B8%83.%E8%B7%AF%E7%94%B1%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8/image-4.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><code>ip route network [mask] &#123;address | interface&#125; [distance]</code></p>
<ul>
<li><strong>network</strong>：目标网络或子网</li>
<li><strong>mask</strong>：子网掩码</li>
<li><strong>address</strong>：下一跳路由器的IP地址</li>
<li><strong>interface</strong>：到达目标网络所使用的接口</li>
<li><strong>distance</strong>：管理距离 administrative distance</li>
</ul>
<h4 id="管理距离-Administrative-Distance"><a href="#管理距离-Administrative-Distance" class="headerlink" title="管理距离 Administrative Distance"></a>管理距离 Administrative Distance</h4><ul>
<li>管理距离是对路由信息源<strong>可信度</strong>的评级，以0到255的数值表示。</li>
<li><strong>数值越高，可信度越低</strong>。</li>
<li>因此，<strong>静态路由的管理距离通常较低（默认值为1）</strong></li>
</ul>
<h2 id="3-动态路由"><a href="#3-动态路由" class="headerlink" title="3. 动态路由"></a>3. 动态路由</h2><ul>
<li>动态路由协议也可以在网络中的不同路径之间重定向流量 redirect traffic（或负载共享loadshare）。</li>
</ul>
<ol>
<li>动态路由依赖于路由协议在路由器之间共享知识。</li>
<li>动态路由<em>取决于</em>两个基本路由器功能：<ul>
<li><strong>维护（maintance）路由表</strong></li>
<li><strong>向其他路由器分发（distribution）路由信息</strong></li>
</ul>
</li>
</ol>
<h2 id="4-收敛时间-Time-to-Convergence"><a href="#4-收敛时间-Time-to-Convergence" class="headerlink" title="4. 收敛时间 Time to Convergence"></a>4. 收敛时间 Time to Convergence</h2><ol>
<li>收敛时间：<ul>
<li>从刚启动到网络达到稳定的时间</li>
<li>从（网络拓扑）发生变化到再次稳定的时间</li>
</ul>
</li>
<li>收敛时间越短，路由协议越强，网络的稳定性和可靠性也越高，需要路由器的基本硬件支持。</li>
</ol>
<h2 id="5-动态路由协议分类"><a href="#5-动态路由协议分类" class="headerlink" title="5. 动态路由协议分类"></a>5. 动态路由协议分类</h2><ul>
<li>距离矢量（DV,Distance Vector）</li>
<li>链路状态（LS,Link State）</li>
<li>混合路由（HR,Hybird Routing）</li>
</ul>
<h3 id="5-1-距离矢量协议-Distance-Vector-Protocol"><a href="#5-1-距离矢量协议-Distance-Vector-Protocol" class="headerlink" title="5.1 距离矢量协议 Distance-Vector Protocol"></a>5.1 距离矢量协议 Distance-Vector Protocol</h3><ul>
<li>距离矢量算法<strong>不允许</strong>路由器知道互联网络的<strong>确切拓扑</strong>结构。</li>
<li>基于距离矢量的路由算法（也称为<strong>Bellman-Ford算法</strong>）通过路由器之间定期传递路由表的副本来工作。<ul>
<li>大家交换 Routing Table</li>
<li>只知道可达，但是不知道怎么可达（知道 where,但是不知道 how），不知道整个网路的具体拓扑</li>
</ul>
</li>
</ul>
<h4 id="DVP导致问题"><a href="#DVP导致问题" class="headerlink" title="DVP导致问题"></a>DVP导致问题</h4><ol>
<li>问题1：<strong>路由环路 Routing loops</strong>:<ul>
<li>路由环路是指数据包在网络中不断循环，无法到达目的地。距离矢量协议由于缺乏全局拓扑信息，容易导致路由环路。</li>
</ul>
</li>
<li>问题2：<strong>计数到无穷大 Couting to Infinity</strong>：<ul>
<li>当网络中某条路径失效时，路由器可能会不断增加到该路径的距离，直到达到预设的最大值（无穷大）。这会导致网络收敛时间变长，影响网络性能。</li>
<li>当路由器在计数到无穷大时，无效信息会导致路由环路的存在。</li>
</ul>
</li>
</ol>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li><strong>定义最大值（最大跳数）</strong>：<ul>
<li>通过定义一个最大跳数（例如15跳），限制路由器可以传播的最大距离。当达到这个最大值时，路由器将认为路径不可达，从而避免计数到无穷大的问题。</li>
</ul>
</li>
<li><strong>路由毒化 Route Poisoning</strong>：<ul>
<li>当路由器检测到某条路径<em>失效</em>时，将该路径的距离<em>设置为无穷大</em>，并立即<em>通知其他路由器</em>，从而加速收敛。</li>
</ul>
</li>
<li><strong>水平分割 Split Horizon</strong>：<ul>
<li>路由器从某个端口收到的报文信息，不能再从该端口发送回去，从而防止路由环路。</li>
</ul>
</li>
<li><strong>持久计时器 Hold-Down Timers</strong>：<ul>
<li>在路径失效后，路由器会等待一段时间再接受关于该路径的更新信息，从而避免无效信息的传播。</li>
</ul>
</li>
</ol>
<h4 id="防止发送路由更新"><a href="#防止发送路由更新" class="headerlink" title="防止发送路由更新"></a>防止发送路由更新</h4><ul>
<li>为了防止接口发送任何路由更新信息，可以使用以下命令：</li>
</ul>
<p><code>Router(config-router)# passive-interface f0/0</code></p>
<ul>
<li>仅当使用距离矢量路由协议时，它才有效，因为链路状态路由协议不会直接从其邻接方的路由表中获取拓扑信息</li>
</ul>
<h3 id="5-2-链路状态协议-LSP-Link-state-Protocol"><a href="#5-2-链路状态协议-LSP-Link-state-Protocol" class="headerlink" title="5.2 链路状态协议 LSP Link-state Protocol"></a>5.2 链路状态协议 LSP Link-state Protocol</h3><ul>
<li>基于链路状态的路由算法（也称为<strong>SPF（最短路径优先）算法</strong>）维护一个复杂的拓扑信息数据库。</li>
<li>链路状态路由使用：<ul>
<li><strong>链路状态公告（LSAs）</strong></li>
<li><strong>拓扑数据库</strong></li>
<li><strong>SPF算法和生成的SPF树</strong></li>
<li><strong>到每个网络的路径和端口的路由表</strong></li>
</ul>
</li>
<li>RFC 1583包含了OSPF链路状态概念和操作的描述。</li>
<li>工作原理<ol>
<li><strong>交换LSAs</strong>：<ul>
<li>路由器之间交换链路状态公告（LSAs）。每个路由器从直接连接的网络开始。</li>
</ul>
</li>
<li><strong>构建拓扑数据库</strong>：<ul>
<li>每个路由器与其他路由器并行构建一个包含所有LSAs的拓扑数据库。</li>
</ul>
</li>
<li><strong>SPF算法计算网络可达性</strong>：<ul>
<li>SPF算法计算网络的可达性。路由器将这个逻辑拓扑构建为一棵树，以自身为根，包含到每个网络的所有可能路径。然后按最短路径优先（SPF）对这些路径进行排序。</li>
</ul>
</li>
<li><strong>更新路由表</strong>：<ul>
<li>路由器在路由表中列出其最佳路径和到这些目标网络的端口。它还维护其他拓扑元素和状态细节的数据库。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="LSP关注点"><a href="#LSP关注点" class="headerlink" title="LSP关注点"></a>LSP关注点</h4><ol>
<li><strong>处理和内存需求</strong>：<ul>
<li>运行链路状态路由协议通常需要路由器使用<strong>更多</strong>的内存和进行更多的处理，相比于距离矢量路由协议。</li>
</ul>
</li>
<li><strong>带宽需求</strong>：<ul>
<li>在初始链路状态数据包泛洪期间，所有使用链路状态路由协议的路由器会向其他所有路由器发送LSA数据包。这一行为会泛洪整个互联网络，<strong>增加带宽需求</strong>，并暂时减少用于传输用户数据的带宽。</li>
</ul>
</li>
</ol>
<h4 id="问题-链路状态更新-Link-State-Updates"><a href="#问题-链路状态更新-Link-State-Updates" class="headerlink" title="问题: 链路状态更新 Link-State Updates"></a>问题: 链路状态更新 Link-State Updates</h4><ul>
<li>链路状态路由必须确保<em>所有路由器</em>都获取到<em>所有必要的LSA数据包</em>。</li>
<li>拥有不同LSA集合的路由器会基于不同的拓扑数据计算路由。</li>
</ul>
<h3 id="比较：链路状态LSP和距离矢量DVP"><a href="#比较：链路状态LSP和距离矢量DVP" class="headerlink" title="比较：链路状态LSP和距离矢量DVP"></a>比较：链路状态LSP和距离矢量DVP</h3><ol>
<li>DV：距离矢量<ul>
<li>视野窄，代价小</li>
<li>基于<strong>跳数</strong></li>
<li>定期交换路由表，收敛慢</li>
<li>交换<strong>路由表</strong></li>
</ul>
</li>
<li>LS：链路状态<ul>
<li>视野宽，有一定代价</li>
<li>基于<strong>带宽</strong></li>
<li>初期充分交换，收敛快</li>
<li>交换 <strong>Linked State 的数据库</strong></li>
</ul>
</li>
</ol>
<h3 id="5-3-混合协议-Hybrid-Protocols"><a href="#5-3-混合协议-Hybrid-Protocols" class="headerlink" title="5.3 混合协议 Hybrid Protocols"></a>5.3 混合协议 Hybrid Protocols</h3><ol>
<li>混合协议结合了距离矢量协议DVP和链路状态协议LSP的特性。</li>
</ol>
<ul>
<li><strong>示例</strong>：<ul>
<li><strong>OSI的IS-IS（Intermediate System-to-Intermediate System）</strong></li>
<li><strong>Cisco的EIGRP（Enhanced Interior Gateway Routing Protocol）</strong></li>
</ul>
</li>
</ul>
<hr>
<h1 id="四、Routing-Protocols-主动路由协议"><a href="#四、Routing-Protocols-主动路由协议" class="headerlink" title="四、Routing Protocols 主动路由协议"></a>四、Routing Protocols 主动路由协议</h1><ol>
<li>IP路由协议示例<ul>
<li><strong>RIP</strong>：距离矢量路由协议</li>
<li><strong>IGRP</strong>：Cisco的距离矢量路由协议</li>
<li><strong>OSPF</strong>：链路状态路由协议</li>
<li><strong>EIGRP</strong>：平衡混合路由协议<br><img src="/2025/02/24/%E4%B8%83.%E8%B7%AF%E7%94%B1%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8/image-5.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li>工作在第3层——网络层</li>
<li>路由协议的主要目标<ul>
<li><strong>最佳路径</strong>：Optimal<ul>
<li>选择最佳路径</li>
</ul>
</li>
<li><strong>效率</strong>：Efficiency<ul>
<li>最小化带宽和路由器处理资源的使用</li>
</ul>
</li>
<li><strong>快速收敛</strong>：Rapid Convergence<ul>
<li>收敛速度越快越好。有些协议比其他协议收敛得更快。</li>
</ul>
</li>
<li><strong>灵活性</strong>：Flexibility<ul>
<li>能够处理各种情况，如高使用率和路由失败</li>
</ul>
</li>
</ul>
</li>
<li>动态路由配置 Dynamic Routing Configuration</li>
</ol>
<p><code>router protocol [keyword]</code> 定义一个IP路由协议<br><code>network network-number</code> network-number：指定一个直接连接的网络</p>
<ul>
<li>例如<ol>
<li>启动RIP：<code>router protocol [RIP...]</code></li>
</ol>
</li>
</ul>
<ol start="5">
<li>定义<strong>默认路由</strong></li>
</ol>
<ul>
<li><strong>默认路由</strong>：保持路由表简短。</li>
<li>当路由表中不存在目标网络的条目时，数据包将被发送到默认网络。<ol>
<li>用动态路由协议定义默认路由</li>
</ol>
<p>  <code>ip default-network [network-number]</code><br>  2. 用静态路由定义默认路由<br>  <code> ip route 0.0.0.0 0.0.0.0 [next-hop-ip address| exit-interface]</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>九、局域网交换和VLAN</title>
    <url>/2025/02/24/%E4%B9%9D.%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%92%8CVLAN/</url>
    <content><![CDATA[<h1 id="09-LAN-Switching-and-VLAN"><a href="#09-LAN-Switching-and-VLAN" class="headerlink" title="09 LAN Switching and VLAN"></a>09 LAN Switching and VLAN</h1><h1 id="一、Switching"><a href="#一、Switching" class="headerlink" title="一、Switching"></a>一、Switching</h1><ol>
<li>对称交换(Symmetric Switching)</li>
</ol>
<ul>
<li><strong>对称交换</strong>：<ul>
<li>提供<strong>带宽相同的端口</strong>之间的交换连接（如10&#x2F;10 Mbps或100&#x2F;100 Mbps）。</li>
<li>当用户尝试访问其他段上的服务器时，可能会导致瓶颈。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>非对称交换(Asymmetric Switching)</li>
</ol>
<ul>
<li><strong>非对称交换</strong>：<ul>
<li>通过将服务器所在的段<strong>连接到更高带宽的端口</strong>（如100 Mbps），减少潜在瓶颈的可能性。</li>
<li>非对称交换需要在交换机中进行内存缓冲。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>内存缓冲</strong>：<ul>
<li>交换机中的内存区域，用于存储目的地和传输数据，直到可以通过正确的端口交换出去。</li>
</ul>
<ol>
<li>基于端口的内存缓冲<ul>
<li>数据包存储在每个端口的队列中。</li>
<li>由于目标端口繁忙，可能导致一个数据包延迟其他数据包的传输。</li>
</ul>
</li>
<li>共享内存缓冲<ul>
<li>所有端口共享的公共内存缓冲。</li>
<li>允许数据包在一个端口接收（RX）并在另一个端口发送（TX），而无需更改到不同的队列。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="4-交换方式"><a href="#4-交换方式" class="headerlink" title="4. 交换方式"></a>4. 交换方式</h2><h3 id="1-存储转发（Store-and-Forward）"><a href="#1-存储转发（Store-and-Forward）" class="headerlink" title="1. 存储转发（Store-and-Forward）"></a>1. 存储转发（Store-and-Forward）</h3><ul>
<li>网桥、路由器等通过软件的设备</li>
</ul>
<ol>
<li>交换机<strong>接收整个帧</strong>，最后将其计算为CRC，然后再将其发送到目的地</li>
<li>接收后，<em>校验</em>，正确再发送</li>
</ol>
<h3 id="2-直通交换（Cut-through）"><a href="#2-直通交换（Cut-through）" class="headerlink" title="2. 直通交换（Cut-through）"></a>2. 直通交换（Cut-through）</h3><ul>
<li>交换机会增加延迟，可以通过使用直通交换方法来<em>减少延迟</em>。<ul>
<li><strong>快速转发交换（Fast Forward Switching）</strong>：仅检查<strong>目标MAC地址</strong>，然后立即转发帧。</li>
</ul>
</li>
</ul>
<h3 id="3-无碎片转发（Segment-free-Switching）"><a href="#3-无碎片转发（Segment-free-Switching）" class="headerlink" title="3. 无碎片转发（Segment-free Switching）"></a>3. 无碎片转发（Segment-free Switching）</h3><ul>
<li>碎片释放（Fragment Free）：在转发帧之前读取前 64 个字节以减少错误：避免碰撞和帧碎片</li>
</ul>
<h1 id="二、The-Spanning-Tree-Protocol-STP-生成树协议"><a href="#二、The-Spanning-Tree-Protocol-STP-生成树协议" class="headerlink" title="二、The Spanning-Tree Protocol (STP)生成树协议"></a>二、The Spanning-Tree Protocol (STP)生成树协议</h1><p>ISDN中</p>
<ul>
<li><p><strong>ISDN BRI服务</strong>：</p>
<ul>
<li>提供两个B信道和一个D信道。</li>
<li>ISDN BRI提供总带宽为144kbps（2B+D&#x3D;144kbps）的线路，分为三个独立的信道。</li>
<li>BRI的B信道服务以64kbps的速度运行，用于传输用户数据和语音通信。</li>
<li>第三个信道，D信道，是一个16kbps的信令信道，用于传输指令，告诉电话网络如何处理每个B信道。</li>
</ul>
</li>
<li><p><strong>ISDN PRI服务</strong></p>
</li>
<li><p>提供23或30个B信道和一个D信道</p>
</li>
<li><p>带宽：</p>
<ul>
<li>B信道 B Channal  64kbps</li>
<li>D信道 D Channal  16kbps</li>
</ul>
</li>
<li><p>what is the bandwidth of <strong>an</strong> ISDN BRI-B Channel? </p>
<ul>
<li>64kbps</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>二、OSI第一层：物理层</title>
    <url>/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<h1 id="OSI第一层：物理层"><a href="#OSI第一层：物理层" class="headerlink" title="OSI第一层：物理层"></a>OSI第一层：物理层</h1><h1 id="一、网络连接类型"><a href="#一、网络连接类型" class="headerlink" title="一、网络连接类型"></a>一、网络连接类型</h1><p><img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image-4.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><strong>多路复用共享机制</strong></li>
</ol>
<ul>
<li><strong>多个主机可以访问同一介质</strong></li>
<li>它们都使用相同的传输介质—即使这个传输介质是<strong>非屏蔽双绞线（UTP）</strong>，它也包含四对线来传输数据。</li>
</ul>
<ol start="2">
<li><strong>点对点网络</strong></li>
</ol>
<ul>
<li><strong>一个设备通过链路连接到另一个设备</strong></li>
<li>最广泛地应用于拨号网络连接，也是你最熟悉的一种。使用电信号来完成传输。</li>
</ul>
<h1 id="二、LAN-Media局域网介质"><a href="#二、LAN-Media局域网介质" class="headerlink" title="二、LAN Media局域网介质"></a>二、LAN Media局域网介质</h1><p><img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image-5.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>功能是<strong>传输数据</strong></li>
<li>光信号、无线信号等传输过程称为<strong>编码</strong></li>
<li><strong>电缆类型</strong>包括<strong>STP(有屏蔽双绞线)、UTP(无屏蔽双绞线)、同轴电缆、光纤</strong></li>
<li>调节频率、电压、相位等方式来实现不同01编码</li>
</ol>
<h2 id="1-STP和ScTP-屏蔽双绞线-抗干扰能力强"><a href="#1-STP和ScTP-屏蔽双绞线-抗干扰能力强" class="headerlink" title="1. STP和ScTP: 屏蔽双绞线, 抗干扰能力强"></a>1. STP和ScTP: 屏蔽双绞线, 抗干扰能力强</h2><ul>
<li>STP:<code>Shielded Twisted Pair</code></li>
</ul>
<ol>
<li>4对线布线，结合了屏蔽和通过线缆扭绞实现的消除效应。</li>
<li>通常是一种150欧姆的电缆</li>
<li>能够减少串扰、EMI（电磁干扰）和RFI（射频干扰）</li>
<li>比UTP（非屏蔽双绞线）提供更好的<strong>对所有类型外部干扰的保护</strong>。</li>
</ol>
<ul>
<li>ScTP：<code>Screened Twisted Pair</code></li>
</ul>
<ol>
<li>包裹在金属箔屏蔽层或屏蔽网中</li>
<li>通常是100或120欧姆的电缆。</li>
<li>STP和ScTP都能防止外来的电磁波在数据线上产生噪声，并且还能最大限度地减少向外辐射的电磁波。</li>
</ol>
<ul>
<li>缺点: <ol>
<li>信号不被中继的情况下, 传输距离较近</li>
<li>绝缘大大增加了电缆的尺寸、重量和成本</li>
<li>屏蔽材料使端接更加困难，并且容易受到工艺不良的影响</li>
</ol>
</li>
</ul>
<h2 id="2-UTP-非屏蔽双绞线-Unshielded-Twisted-Pair"><a href="#2-UTP-非屏蔽双绞线-Unshielded-Twisted-Pair" class="headerlink" title="2. UTP (非屏蔽双绞线 Unshielded Twisted Pair)"></a>2. UTP (非屏蔽双绞线 Unshielded Twisted Pair)</h2><ul>
<li>由<strong>八根子线</strong>组成,<strong>两个线组合成一组</strong>，<strong>共四组</strong>，可以保证每一组电流抵消电磁波干扰（抗干扰能力有限）</li>
</ul>
<ol>
<li>仅（solely）依赖于消除效应，由双绞线对产生，以限制由 EMI 和 RFI 引起的信号退化</li>
<li>有四对铜线，阻抗（impedance）为 100 欧姆，频率低、接口小、布线更加方便</li>
<li>一般认为有效范围为 100m</li>
</ol>
<ul>
<li>优点<ul>
<li><em>易于安装且成本较低</em>，线薄接口小</li>
<li>每米成本低于任何其他类型的局域网布线</li>
<li>较小的外径不能像其他类型的电缆那样迅速地填满布线管道（duct）</li>
<li>使用 RJ 连接器安装，因此可以大大减少潜在的网络噪声源，并确保良好的可靠连接</li>
</ul>
</li>
<li>缺点：<ul>
<li>与其他类型的网络媒体相比，电缆更容易产生电噪声和干扰</li>
<li>双绞线的信号增强距离比同轴电缆（Coaxial）和光纤（Fiber-Optic）短</li>
</ul>
</li>
</ul>
<h2 id="3-同轴电缆-Coaxial-Cable"><a href="#3-同轴电缆-Coaxial-Cable" class="headerlink" title="3. 同轴电缆 Coaxial Cable"></a>3. 同轴电缆 Coaxial Cable</h2><ol>
<li><em>Thinnet&#x2F;thicknet</em></li>
<li>与双绞线twisted-pair相比，不使用中继器的网络运行时间更长</li>
<li>比光纤便宜但比双绞线贵</li>
</ol>
<h2 id="4-光纤-Fiber-Optic-Cable"><a href="#4-光纤-Fiber-Optic-Cable" class="headerlink" title="4. 光纤 Fiber Optic Cable"></a>4. 光纤 Fiber Optic Cable</h2><ol>
<li>传导调制（modulated）光传输</li>
<li>不易受到电磁干扰或射频干扰，并且能够比其他网络媒体更高的数据速率</li>
<li>电磁波（electromagnetic wave）通过光纤被引导</li>
<li>比较可靠，中间是二氧化硅（光导体），外面是塑料套，两个接口一个接收一个发送</li>
<li>成本比较高</li>
</ol>
<h3 id="模式1：单模光纤（Single-Mode-Fiber-SMF）"><a href="#模式1：单模光纤（Single-Mode-Fiber-SMF）" class="headerlink" title="模式1：单模光纤（Single-Mode Fiber, SMF）"></a>模式1：单模光纤（Single-Mode Fiber, SMF）</h3><ul>
<li>也称为轴向光纤axial：光沿着光纤的轴线传播。</li>
<li>比多模光纤更快：因为多模光纤中存在色散</li>
<li>通常用于<strong>广域网（WANs）</strong>：单模光纤常用于需要<strong>长距离、高速传输的广域网</strong>。</li>
<li>直径比多模光纤小：色散较少，因此信号传输更稳定。</li>
<li>使用激光二极管（ILD）最常见，但也使用发光二极管（LED）</li>
</ul>
<h3 id="模式2：多模光纤（Multi-Mode-Fiber-MMF）"><a href="#模式2：多模光纤（Multi-Mode-Fiber-MMF）" class="headerlink" title="模式2：多模光纤（Multi-Mode Fiber, MMF）"></a>模式2：多模光纤（Multi-Mode Fiber, MMF）</h3><ul>
<li>非轴向传播：光以不同角度进入玻璃管</li>
<li>直径比单模光纤大：多模光纤的直径比单模光纤大，通常用于<strong>局域网（LANs）</strong>。</li>
<li>更容易受到色散的影响</li>
</ul>
<h2 id="5-无线通信（Wireless-Communication）"><a href="#5-无线通信（Wireless-Communication）" class="headerlink" title="5. 无线通信（Wireless Communication）"></a>5. 无线通信（Wireless Communication）</h2><ul>
<li>区分不同电磁波的主要方法是通过它们的<strong>频率</strong>。（频率多路复用）</li>
<li>把信号编码成为电磁波的方式<ul>
<li>不同设备使用不同频段，可以互不干扰</li>
</ul>
</li>
</ul>
<h2 id="6-无线传输手段（Wireless-Transmission-Methods）"><a href="#6-无线传输手段（Wireless-Transmission-Methods）" class="headerlink" title="6. 无线传输手段（Wireless Transmission Methods）"></a>6. 无线传输手段（Wireless Transmission Methods）</h2><ol>
<li>激光：<ul>
<li>输出相干（coherent）电磁场：所有波的频率相同且相位对齐。</li>
</ul>
</li>
<li>红外线（Infrared）：激光通常使用红外线。<ul>
<li>通常是视距技术：激光通常需要视距传输，但可以通过反射或重定向来传输。</li>
<li>不能穿透不透明物体。</li>
</ul>
</li>
<li>无线电（Radio）：<ul>
<li>传输数据信号：无线电可以传输数据信号，并且这些信号可以穿透墙壁。</li>
<li>地面和卫星无线电技术：无线电技术包括地面无线电和卫星无线电两种。</li>
</ul>
</li>
</ol>
<h1 id="三、UTP-for-Ethernet-以太网中的非屏蔽双绞线"><a href="#三、UTP-for-Ethernet-以太网中的非屏蔽双绞线" class="headerlink" title="三、UTP for Ethernet 以太网中的非屏蔽双绞线"></a>三、UTP for Ethernet 以太网中的非屏蔽双绞线</h1><h2 id="1-非屏蔽双绞线的分类"><a href="#1-非屏蔽双绞线的分类" class="headerlink" title="1. 非屏蔽双绞线的分类"></a>1. 非屏蔽双绞线的分类</h2><ol>
<li>一类线：主要用于语音传输，不用于数据传输</li>
<li>二类线：传输频率1MHz，用于语音和最高4Mbps的数据传输，常见于令牌网</li>
<li><strong>三类线</strong>：EIA&#x2F;TIA568标准指定电缆，传输频率16MHz，用于语音传输及最高传输速率为10Mbps的数据传输，主要用于10BASE-T</li>
<li>四类线：传输频率为20MHz，用于语音传输和最高传输速率16Mbps的数据传输，主要用于令牌网和10BASE-T&#x2F;100BASE-T</li>
<li><strong>五类线</strong>：增加了绕线密度，外套高质量绝缘材料，用于语音和数据传输(主要为100&#x2F;1000BASE-T)，是最常用的以太网电缆</li>
<li><strong>超五类线</strong>：衰减小，串扰少，具有更高的衰减&#x2F;串扰比和信噪比、更小的时延误差，主要用于1000BASE-T</li>
<li><strong>六类线</strong>：传输频率为1MHz～250MHz，性能远高于超五类标准，适用于高于1Gbps的应用</li>
<li>七类线：带宽为600MHz，可能用于今后的10G比特以太网</li>
</ol>
<h2 id="2-Type-of-Cable-线的类型"><a href="#2-Type-of-Cable-线的类型" class="headerlink" title="2. Type of Cable 线的类型"></a>2. Type of Cable 线的类型</h2><ul>
<li><strong>直通线 Straight Cable</strong><ol>
<li><strong>用途</strong>：用于连接<strong>不同类型的设备</strong>，如计算机和交换机、计算机和路由器。</li>
<li>连接方式：直通电缆的两端使用<em>相同的线序标准</em>进行连接，常见的标准有T568A和T568B。</li>
</ol>
</li>
<li><strong>反转线 Rollover Cable</strong><ol>
<li><strong>用途</strong>：用于连接<strong>终端设备和控制台端口</strong>，通常用于配置路由器或交换机。</li>
<li><strong>连接方式</strong>：一端的线序完全反转，即1对8、2对7、3对6、4对5。</li>
</ol>
</li>
<li><strong>交叉线Crossover Cable</strong><ol>
<li><strong>用途</strong>：用于连接<strong>相同类型的设备</strong>，如计算机和计算机、交换机和交换机。</li>
<li><strong>连接方式</strong>：两端的线序<em>不同</em>，一端使用T568A标准，另一端使用T568B标准。</li>
</ol>
</li>
</ul>
<h1 id="四、Media-and-signal-Problems介质和信号问题"><a href="#四、Media-and-signal-Problems介质和信号问题" class="headerlink" title="四、Media and signal Problems介质和信号问题"></a>四、Media and signal Problems介质和信号问题</h1><h2 id="1-Collisions-and-Collision-Domains-碰撞和碰撞域"><a href="#1-Collisions-and-Collision-Domains-碰撞和碰撞域" class="headerlink" title="1. Collisions and Collision Domains 碰撞和碰撞域"></a>1. Collisions and Collision Domains 碰撞和碰撞域</h2><ol>
<li><strong>碰撞（Collisions）</strong><ul>
<li>在网络中，碰撞是指两个或多个设备<strong>同时尝试发送数据</strong>时，<strong>数据包在网络介质上相互干扰的现象</strong>。</li>
</ul>
</li>
<li><strong>碰撞域（Collision Domains）</strong><ul>
<li>碰撞域是指在网络中，数据包碰撞可能发生的范围或区域。在同一个碰撞域内，所有设备共享同一个通信介质，因此它们可能会发生碰撞。</li>
<li><strong>拓展碰撞域</strong>：添加<strong>中继器（repeaters）和集线器（hubs）</strong></li>
<li><strong>限制碰撞域</strong>：通过添加智能设备如<strong>网桥（bridges）、交换机（switches）和路由器（routers）</strong>，可以对网络进行<em>分段</em>。</li>
</ul>
</li>
</ol>
<ul>
<li>当网络中的延迟超过一定限制时，<em>晚碰撞</em>的数量会显著增加。</li>
<li>晚碰撞（<code>Late Collision</code>）：是指在帧的前64字节传输之后发生的碰撞。</li>
<li>消耗延迟（<code>Consumption Delay</code>）：这些晚碰撞帧会增加一种称为消耗延迟的延迟。<br>网络性能：</li>
<li>随着消耗延迟和延迟（Latency）的增加，网络性能会下降。</li>
</ul>
<h2 id="2-5-4-3-2-1规则"><a href="#2-5-4-3-2-1规则" class="headerlink" title="2. 5-4-3-2-1规则"></a>2. 5-4-3-2-1规则</h2><ul>
<li>5-4-3-2-1规则是以太网网络设计中的一个指导原则，用于确保网络性能和减少冲突。具体内容如下：</li>
</ul>
<ol>
<li><strong>5个网段</strong>：在一个以太网网络中，最多可以有5个网段。</li>
<li><strong>4个中继器&#x2F;集线器</strong>：在这5个网段之间，最多可以有4个repeaters或hubs。</li>
<li><strong>3个有源网段</strong>：在这5个网段中，最多可以有3个”mixing” sections（即连接了计算机或其他设备）。</li>
<li><strong>2个无源网段</strong>：其余的2个网段必须是link sections（即只用于信号传输，不连接任何设备）。</li>
<li><strong>1个冲突域</strong>：整个网络必须在一个冲突域内，确保所有设备都能检测到冲突。</li>
</ol>
<h1 id="五、-Basic-Knowledge-of-Data-Communication数据通信基本知识"><a href="#五、-Basic-Knowledge-of-Data-Communication数据通信基本知识" class="headerlink" title="五、 Basic Knowledge of Data Communication数据通信基本知识"></a>五、 Basic Knowledge of Data Communication数据通信基本知识</h1><h2 id="1-数据通信的理论基础"><a href="#1-数据通信的理论基础" class="headerlink" title="1. 数据通信的理论基础"></a>1. 数据通信的理论基础</h2><h3 id="1-1-基本术语"><a href="#1-1-基本术语" class="headerlink" title="1.1 基本术语"></a>1.1 基本术语</h3><ul>
<li>信号(signal)——数据的电气的或电磁的表现<ol>
<li>模拟的(analogous)——消息的参数的取值是连续的<ul>
<li>模拟信号是随时间变化而平稳变化的连续波形式</li>
</ul>
</li>
<li>数字的(digital)——消息的参数的取值是离散的<ul>
<li>数字信号是离散信号，可能包含有限的几个预定值</li>
</ul>
</li>
</ol>
</li>
<li>码元(code)——在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形</li>
</ul>
<h3 id="1-2-信号处理"><a href="#1-2-信号处理" class="headerlink" title="1.2 信号处理"></a>1.2 信号处理</h3><h3 id="1-3-波特率和比特率"><a href="#1-3-波特率和比特率" class="headerlink" title="1.3 波特率和比特率"></a>1.3 波特率和比特率</h3><ul>
<li>波特率（baud）和比特率（bit）<ul>
<li>波特率（调制速率）：信号每秒钟变化的次数</li>
<li>比特率：每秒钟传送的二进制位数</li>
</ul>
</li>
</ul>
<h2 id="2-数据通信技术"><a href="#2-数据通信技术" class="headerlink" title="2. 数据通信技术"></a>2. 数据通信技术</h2><h3 id="2-1-数据通信系统的模型"><a href="#2-1-数据通信系统的模型" class="headerlink" title="2.1 数据通信系统的模型"></a>2.1 数据通信系统的模型</h3><p><img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image-6.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="2-3-数字数据编码"><a href="#2-3-数字数据编码" class="headerlink" title="2.3 数字数据编码"></a>2.3 数字数据编码</h3><ul>
<li>将数字数据转换到模拟信号：调制</li>
<li>将数字数据转换到数字信号：线路编码, 线路编码是指将二进制数据转换为可以在物理通信链路上传播的形式，例如电线上的电脉冲、光纤上的光脉冲或太空中的电磁波</li>
</ul>
<h3 id="2-4-编码方式"><a href="#2-4-编码方式" class="headerlink" title="2.4 编码方式"></a>2.4 编码方式</h3><ul>
<li>可以分为三类</li>
</ul>
<ol>
<li>单极性编码<ul>
<li>用0电平表示”0”，正电平表示”1”</li>
</ul>
</li>
<li>极化编码<ol>
<li>不归零制码(NRZ: Non-Return to Zero)<ul>
<li>不归零电平编码：用负电平表示“0”，正电平表示“1”（或相反）</li>
<li>不归零反相编码：信号电平的一次翻转代表比特1，无电平变化代表0</li>
</ul>
</li>
<li>归零制码（RZ: Return to Zero）<ul>
<li>原理：用负电平表示“0”，正电平表示“1”（或相反），比特中位跳变到零电平，从而提供同步</li>
</ul>
</li>
<li></li>
</ol>
</li>
<li>双极性编码</li>
</ol>
<h3 id="2-5-数据通信技术：多路复用"><a href="#2-5-数据通信技术：多路复用" class="headerlink" title="2.5 数据通信技术：多路复用"></a>2.5 数据通信技术：多路复用</h3><ul>
<li>多路复用技术<ul>
<li>由于一条传输线路的能力远远超过传输一个用户信号所需的能力，为了提高线路利用率，经常让多个信号共用一条物理线路</li>
</ul>
</li>
</ul>
<h4 id="a-时分复用-TDM-（Time-Division-Multiplexing）"><a href="#a-时分复用-TDM-（Time-Division-Multiplexing）" class="headerlink" title="a. 时分复用 TDM （Time Division Multiplexing）"></a>a. 时分复用 TDM （Time Division Multiplexing）</h4><ul>
<li>时分复用是将时间划分为一段段等长的<strong>时分复用（TDM ）帧</strong>，每个时分复用的用户在每个TDM 帧中占用固定序号的时隙。</li>
<li>每一个用户所占用的时隙是周期性地出现</li>
<li>TDM 信号也称为<strong>等时(isochronous)信号</strong></li>
<li><strong>时分复用的所有用户在不同的时间占用同样的带宽资源</strong></li>
<li>可能会造成线路资源的浪费<br><img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image-7.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h4 id="b-频分复用-FDM（Frequency-Division-Multiplexing）"><a href="#b-频分复用-FDM（Frequency-Division-Multiplexing）" class="headerlink" title="b. 频分复用 FDM（Frequency Division Multiplexing）"></a>b. 频分复用 FDM（Frequency Division Multiplexing）</h4><ul>
<li>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带</li>
<li><strong>频分复用的所有用户在同样的时间占用不同的带宽资源</strong><br><img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image-1.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h4 id="c-波分复用-WDM-Wavelength-Division-Multiplexing"><a href="#c-波分复用-WDM-Wavelength-Division-Multiplexing" class="headerlink" title="c. 波分复用 WDM (Wavelength Division Multiplexing)"></a>c. 波分复用 WDM (Wavelength Division Multiplexing)</h4><ul>
<li>就是<strong>光的频分复用</strong><br><img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image-2.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image-3.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h4 id="d-码分复用-CDM-Code-Division-Multiplexing"><a href="#d-码分复用-CDM-Code-Division-Multiplexing" class="headerlink" title="d. 码分复用 CDM (Code Division Multiplexing)"></a>d. 码分复用 CDM (Code Division Multiplexing)</h4><ul>
<li>更常用的名词是<strong>码分多址 CDMA</strong> (Code Division<br>Multiple Access)</li>
<li>各用户使用经过特殊挑选的<strong>不同码型</strong>，因此<strong>各用户之间不会造成干扰</strong></li>
<li>有很强的<strong>抗干扰能力</strong>，其频谱类似于白噪声，不易被敌人发现</li>
</ul>
<h2 id="2-6-数据通信技术：通信方式"><a href="#2-6-数据通信技术：通信方式" class="headerlink" title="2.6 数据通信技术：通信方式"></a>2.6 数据通信技术：通信方式</h2><ul>
<li>分类：<ul>
<li>单工Simplex Transmission<ul>
<li>信号只能在一个方向传播</li>
</ul>
</li>
<li>半双工Half-Duplex Transmission<ul>
<li>可以双向传播，但不能同时</li>
</ul>
</li>
<li>全双工Full-Duplex Transmission<ul>
<li>可以双向同时传播</li>
</ul>
</li>
</ul>
</li>
<li>并行传输与串行传输<ul>
<li>并行传输：0、1组成的二进制数据。组成每组n比特的位组，同时发送这种位组（8根线一次发送01010101）</li>
<li>串行传输：每次传输1位比特（一根线8次发送01010101）<br>  <img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image-8.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>五、OSI第四层:运输层</title>
    <url>/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h1 id="第五章-第四层-运输层-Transport-Layer"><a href="#第五章-第四层-运输层-Transport-Layer" class="headerlink" title="第五章 第四层:运输层 Transport Layer"></a>第五章 第四层:运输层 Transport Layer</h1><ul>
<li>第四层运输层主要是实现了主机之间的通信。</li>
<li>数据通信是服务于主机上的进程(Session)</li>
</ul>
<ol>
<li>An overview of layer 4</li>
<li>TCP (Transmission Control Protocol)</li>
<li>UDP(User Datagram Protocol)</li>
<li>An application: NAT and PAT</li>
</ol>
<h1 id="一、第四层综述"><a href="#一、第四层综述" class="headerlink" title="一、第四层综述"></a>一、第四层综述</h1><h2 id="1、第4层执行多项功能："><a href="#1、第4层执行多项功能：" class="headerlink" title="1、第4层执行多项功能："></a>1、第4层执行多项功能：</h2><ol>
<li>对上层应用数据进行分段（segmenting upper-layer application data）</li>
<li>建立<strong>端到端</strong>(end to end)的运营</li>
<li>将段从一个端主机发送到另一个端主机<ul>
<li>(第三层和第二层不进行可靠性检验，第四层完成可靠性检验，接受方认为数据错误，在第四层进行要求重传)</li>
</ul>
</li>
<li><strong>流量控制</strong>和<strong>可靠性</strong><ul>
<li>可以比喻为<em>与外国人交谈</em>:通常，您会要求外国人<em>重复他&#x2F;她的话(可靠性)</em> 并<em>慢声说话(流量控制)</em></li>
<li>双方主机的网络的处理能力不同，缓存能力不同</li>
</ul>
</li>
</ol>
<h2 id="2-两个特别重要的第4层协议："><a href="#2-两个特别重要的第4层协议：" class="headerlink" title="2. 两个特别重要的第4层协议："></a>2. 两个特别重要的第4层协议：</h2><ol>
<li><strong>传输控制协议</strong>(<strong>TCP</strong>, Transmission Control Protocol)</li>
<li><strong>用户数据报协议</strong>(<strong>UDP</strong>, User Datagram Protocol)</li>
</ol>
<h2 id="3-Layer-4-The-Transport-Layer"><a href="#3-Layer-4-The-Transport-Layer" class="headerlink" title="3. Layer 4:  The Transport Layer"></a>3. Layer 4:  The Transport Layer</h2><ol>
<li>将传出消息划分为多个<strong>段</strong> + 在目标站重新<strong>组合</strong>消息</li>
<li><strong>传输控制协议（TCP）</strong>：<ul>
<li><strong>可靠</strong></li>
<li><strong>面向连接 Connection -oriented</strong></li>
<li>软件<strong>检查</strong>段</li>
<li><strong>重新发送</strong>任何丢失或出错的段</li>
<li>使用<strong>确认 acknowledgments</strong></li>
<li>提供<strong>流量控制</strong></li>
</ul>
</li>
<li><strong>用户数据报协议（UDP）</strong>：<ul>
<li>不可靠</li>
<li>无连接 connectionless</li>
<li>不提供段的软件检查</li>
<li>（直接丢弃错误的报文，而不进行其他操作）</li>
<li>不使用确认</li>
<li>不提供流量控制</li>
</ul>
</li>
</ol>
<h2 id="4-服务模型"><a href="#4-服务模型" class="headerlink" title="4. 服务模型"></a>4. 服务模型</h2><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-1.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>TCP和UDP都使用<strong>端口 port</strong>来跟踪(track)同时穿越网络的不同会话</li>
<li>应用软件开发人员同意使用在RFC1700中定义的知名端口号。</li>
<li>端口号低于255的端口保留用于TCP和UDP公共应用程序。<ul>
<li>端口号<strong>0-255是public</strong>的，<strong>不可以随意分给其他的进程</strong>，如果分发则不符合规范</li>
</ul>
</li>
</ol>
<h2 id="5-套接字-Socket-第四层的单位"><a href="#5-套接字-Socket-第四层的单位" class="headerlink" title="5. 套接字(Socket, 第四层的单位)"></a>5. 套接字(Socket, 第四层的单位)</h2><ul>
<li>套接字<strong>表示为（IP地址，端口）</strong>。</li>
<li>每个<strong>连接</strong>表示为（<strong>源套接字，目标套接字</strong>），这是一个<strong>点对点</strong>的<strong>全双工</strong>通道。</li>
<li>TCP不支持多播和广播。</li>
</ul>
<hr>
<h1 id="二、-TCP-Transmission-Control-Protocol"><a href="#二、-TCP-Transmission-Control-Protocol" class="headerlink" title="二、 TCP (Transmission Control Protocol)"></a>二、 TCP (Transmission Control Protocol)</h1><ul>
<li><strong>传输控制协议</strong></li>
</ul>
<h2 id="1-TCP-服务模型"><a href="#1-TCP-服务模型" class="headerlink" title="1. TCP 服务模型"></a>1. TCP 服务模型</h2><h3 id="1-1-TCP必须解决的问题"><a href="#1-1-TCP必须解决的问题" class="headerlink" title="1.1 TCP必须解决的问题"></a>1.1 TCP必须解决的问题</h3><ol>
<li><strong>可靠传输</strong> Reliable transfer</li>
<li><strong>流量传输</strong> Flow control<ul>
<li>滑动窗口 Sliding window</li>
<li>避免拥塞 congestion avoidance</li>
</ul>
</li>
<li><strong>连接控制</strong> Connection management<ul>
<li>建立连接:三次握手</li>
<li>断开连接:四次握手</li>
</ul>
</li>
</ol>
<h3 id="1-2-TCP数据段的格式"><a href="#1-2-TCP数据段的格式" class="headerlink" title="1.2 TCP数据段的格式"></a>1.2 TCP数据段的格式</h3><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h4 id="1-2-1-首部情况"><a href="#1-2-1-首部情况" class="headerlink" title="1.2.1. 首部情况"></a>1.2.1. 首部情况</h4><ul>
<li>一行共计4字节，段首在前，<strong>固定首部长度为20字节</strong>。</li>
</ul>
<h4 id="1-2-2-源端口和目的端口"><a href="#1-2-2-源端口和目的端口" class="headerlink" title="1.2.2. 源端口和目的端口"></a>1.2.2. 源端口和目的端口</h4><ul>
<li>源端口和目的端口字段:各占 <strong>2 字节</strong></li>
</ul>
<ol>
<li>端口是运输层与<strong>应用层</strong>的服务接口</li>
<li>运输层的复用和分用功能都要通过端口才能实现</li>
</ol>
<h4 id="1-2-3-序号"><a href="#1-2-3-序号" class="headerlink" title="1.2.3. 序号"></a>1.2.3. 序号</h4><ul>
<li>序号字段：占<strong>4 字节</strong></li>
</ul>
<ol>
<li>TCP 传送的数据流中的每一个字节都编上一个序号</li>
<li>序号字段的值指本报文段所发送的数据的第一个字节的序号</li>
</ol>
<h4 id="1-2-4-确认号"><a href="#1-2-4-确认号" class="headerlink" title="1.2.4. 确认号"></a>1.2.4. 确认号</h4><ul>
<li>确认号字段：占 <strong>4 字节</strong>，是<strong>期望</strong>收到对方的<strong>下一个报文段的数据的第一个字节的序号</strong></li>
</ul>
<ol>
<li>确认对方的数据号(发送同时对上一次传输进行确认)</li>
<li>体现出了全双工通信的优点，比如上回收到最后序号是700，那么确认号就是701</li>
</ol>
<h4 id="1-2-5-数据偏移"><a href="#1-2-5-数据偏移" class="headerlink" title="1.2.5. 数据偏移"></a>1.2.5. 数据偏移</h4><ul>
<li>数据偏移(即<em>首部长度</em>)：占 <strong>4 位</strong></li>
</ul>
<ol>
<li>指出 TCP 报文段的<strong>数据起始处距 TCP 报文段的起始处的长度</strong><ul>
<li>(Data部分从什么地方开始算)</li>
</ul>
</li>
<li>单位是 32 位字(以 4 字节为计算单位)</li>
<li>不满足的话<strong>使用填充位保证为4字节的整数倍</strong>(保证对齐问题)</li>
</ol>
<h4 id="1-2-6-保留"><a href="#1-2-6-保留" class="headerlink" title="1.2.6. 保留"></a>1.2.6. 保留</h4><ul>
<li>保留字段：占 <strong>6 位</strong>，保留为今后使用，<strong>目前置 0</strong><ul>
<li>也就是说截止到现在也没有使用这部分的字段。</li>
</ul>
</li>
</ul>
<p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-2.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h4 id="1-2-7-URG"><a href="#1-2-7-URG" class="headerlink" title="1.2.7. URG"></a>1.2.7. URG</h4><ul>
<li><strong>紧急 URG &#x3D; 1 时</strong>，表明紧急指针字段有效。</li>
</ul>
<ol>
<li>告诉系统此报文段中<strong>有紧急数据</strong>，应尽快传送(相当于<strong>高优先级</strong>的数据)</li>
</ol>
<h4 id="1-2-8-ACK"><a href="#1-2-8-ACK" class="headerlink" title="1.2.8. ACK"></a>1.2.8. ACK</h4><ul>
<li>ACK &#x3D; 1 时<strong>确认号字段</strong>有效;</li>
<li>ACK &#x3D; 0 时确认号字段无效</li>
</ul>
<h4 id="1-2-9-PSH-PuSH-推送"><a href="#1-2-9-PSH-PuSH-推送" class="headerlink" title="1.2.9. PSH(PuSH) 推送"></a>1.2.9. PSH(PuSH) 推送</h4><ol>
<li>接收 TCP 收到 <strong>PSH &#x3D; 1</strong> 的报文段，就<strong>尽快地交付接收应用进程</strong>，而<strong>不再等到整个缓存都填满了后再向上交付</strong><ul>
<li>此时<strong>将缓存所有部分都传输</strong>，而<em>并不是只将这个报文段的信息进行传输</em>。</li>
<li>TCP在正常条件下并不是立马传输的，首先要缓存满了才发送，其次还有就是要保证网络可信的时候才发送</li>
</ul>
</li>
</ol>
<h4 id="1-2-10-RST-复位"><a href="#1-2-10-RST-复位" class="headerlink" title="1.2.10. RST 复位"></a>1.2.10. RST 复位</h4><ol>
<li><strong>ReSeT &#x3D; 1时</strong>，表明TCP连接中出现<strong>严重差错</strong>(如由于主机崩溃或其他原因)，<strong>必须释放连接，然后再重新建立运输连接</strong></li>
</ol>
<h4 id="1-2-11-SYN"><a href="#1-2-11-SYN" class="headerlink" title="1.2.11. SYN"></a>1.2.11. SYN</h4><ol>
<li>同步 <strong>SYN &#x3D; 1</strong>:表示<strong>这是一个连接请求或连接接受报文</strong><ul>
<li>(初始的时候才出现)</li>
</ul>
</li>
</ol>
<h4 id="1-2-12-FIN-FINis-终止"><a href="#1-2-12-FIN-FINis-终止" class="headerlink" title="1.2.12. FIN(FINis) 终止"></a>1.2.12. FIN(FINis) 终止</h4><ul>
<li>用来<strong>释放一个连接</strong>。</li>
<li><strong>FIN &#x3D; 1</strong> 表明<strong>此报文段的发送端的数据已发送完毕</strong>，并<em>要求释放运输连接</em>。 <ul>
<li>(发送方没有传输数据了)</li>
</ul>
</li>
</ul>
<p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-3.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h4 id="1-2-13-窗口"><a href="#1-2-13-窗口" class="headerlink" title="1.2.13. 窗口"></a>1.2.13. 窗口</h4><ul>
<li>占 <strong>2 字节</strong>，用来让对方设置发送窗口的依据，单位为字节。<ul>
<li>表示<strong>可以进行传输的窗口大小</strong>是多少。</li>
</ul>
</li>
</ul>
<h4 id="1-2-14-检验和"><a href="#1-2-14-检验和" class="headerlink" title="1.2.14. 检验和"></a>1.2.14. 检验和</h4><ul>
<li>检验和:占<strong>2字节</strong>。检验和字段检验的范围包括<strong>首部</strong>和<strong>数据</strong>这两部分</li>
</ul>
<h4 id="1-2-15-紧急指针字段"><a href="#1-2-15-紧急指针字段" class="headerlink" title="1.2.15. 紧急指针字段"></a>1.2.15. 紧急指针字段</h4><ul>
<li>紧急指针字段:占<strong>16位</strong>，指出在本报文段中<strong>紧急数据共有多少个字节</strong>（紧急数据放在本报文段数据的<strong>最前面</strong>）</li>
</ul>
<h4 id="1-2-16-选项（长度可变）"><a href="#1-2-16-选项（长度可变）" class="headerlink" title="1.2.16. 选项（长度可变）"></a>1.2.16. 选项（长度可变）</h4><ol>
<li>TCP 最初只有一种选项，即最大报文段长度 MSS(Maximum Segment Size)</li>
<li>MSS 告诉对方缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节</li>
<li>数据字段加上 TCP 首部才等于整个的 TCP 报文段</li>
</ol>
<h4 id="1-2-17-填充字段"><a href="#1-2-17-填充字段" class="headerlink" title="1.2.17. 填充字段"></a>1.2.17. 填充字段</h4><ul>
<li>填充字段：这是为了<strong>使整个首部长度是 4 字节的整数倍</strong>。</li>
</ul>
<hr>
<h2 id="2-TCP协议"><a href="#2-TCP协议" class="headerlink" title="2. TCP协议"></a>2. TCP协议</h2><ol>
<li>主机使用**段（TPDU传输层PDU）**交换数据</li>
<li>每个段都有：<ul>
<li>一个<strong>20字节的首部</strong>（不包括可选部分）</li>
<li><strong>0 或更多数据字节</strong>（请求连接的时候）</li>
</ul>
</li>
<li>段的大小必须与 IP 数据包匹配，并且还必须满足底层的需求<ul>
<li>例如，以太网的 MTU（最大传输单位）为 1500 字节</li>
</ul>
</li>
<li><strong>每个字节 byte</strong> 都有一个 32 位的序号<strong>seq</strong></li>
</ol>
<h3 id="2-1-Reliable-Connection-可靠连接"><a href="#2-1-Reliable-Connection-可靠连接" class="headerlink" title="2.1 Reliable Connection 可靠连接"></a>2.1 Reliable Connection 可靠连接</h3><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-4.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>“红蓝两军问题”是一个经典的计算机网络中的死锁（Deadlock）问题，或者说是资源竞争的一个类比。通常是用于阐述一些竞争、阻塞和同步问题。</li>
</ul>
<hr>
<h2 id="3-TCP-Establish-Connection"><a href="#3-TCP-Establish-Connection" class="headerlink" title="3. TCP:Establish Connection"></a>3. TCP:Establish Connection</h2><h3 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h3><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-6.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li><strong>服务器Server</strong>：执行LISTEN和ACCEPT原语，被动监听。</li>
<li><strong>客户端Client</strong>：执行CONNECT原语，生成一个<strong>SYN&#x3D;1和ACK&#x3D;0</strong>的TCP段，表示连<strong>接请求</strong>。<ul>
<li>SYN&#x3D;1：连接请求</li>
<li>ACK&#x3D;0：确认号无效</li>
</ul>
</li>
</ul>
<h3 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h3><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-7.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li><strong>服务器</strong>：检查<strong>是否有服务进程在监听端口</strong></li>
</ul>
<ol>
<li>如果<strong>没有</strong>进程，回复一个<strong>RST&#x3D;1</strong>的TCP段<ul>
<li>差错，要重连</li>
</ul>
</li>
<li>如果<strong>有</strong>进程，决定拒绝或接受请求</li>
<li>如果接受连接请求，发送一个SYN&#x3D;1和ACK&#x3D;1的TCP段<ul>
<li>连接请求</li>
<li>确认号有效</li>
</ul>
</li>
</ol>
<h3 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h3><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-8.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><p><strong>客户端</strong>：发送一个<strong>SYN&#x3D;0和ACK&#x3D;1</strong>的TCP段，以<strong>确认连接</strong>。</p>
</li>
<li><p><strong>服务器</strong>：接收到确认后，通知上层应用程序连接已建立。<br><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-5.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</li>
<li><p>默认三次握手就认为可靠了，之后就进行数据传输</p>
</li>
<li><p>有时候我们会选择，第三次握手的时候同时携带数据。</p>
</li>
</ol>
<ul>
<li>TCP头部中的<strong>SEQ（序列号）字段</strong>：<ul>
<li>32位，用来标识当前数据段的序列号。每发送一个数据段时，序列号会<strong>根据数据段的大小递增</strong>。</li>
<li>通过与ACK（确认号）一起使用，确保了数据的可靠性和完整性。<ul>
<li>此ACK指的是32位的那个</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-10.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>seq和ack的关系：<ul>
<li>在三次握手（TCP连接建立过程）中，序列号用于确保双方都准备好建立连接。</li>
<li>在数据传输过程中，SEQ标识发送的数据包的顺序，而ACK确认已收到的数据。</li>
<li>例如，客户端发送的数据包的SEQ为1000，服务器确认收到后返回ACK为1001，表示它已经成功接收到序列号为1000的数据包。</li>
</ul>
</li>
</ul>
<h2 id="建立连接实例"><a href="#建立连接实例" class="headerlink" title="建立连接实例"></a>建立连接实例</h2><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-9.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>基本的三次握手用于连接同步Synchronization</li>
<li>注意，<strong>ACK不占用序列号空间</strong>（如果占用，我们将最终确认ACK的ACK！）</li>
</ul>
<hr>
<h2 id="4-数据传输——停止等待协议-Data-transfer——stop-and-wait-protocol"><a href="#4-数据传输——停止等待协议-Data-transfer——stop-and-wait-protocol" class="headerlink" title="4. 数据传输——停止等待协议 Data transfer——stop-and-wait protocol"></a>4. 数据传输——停止等待协议 Data transfer——stop-and-wait protocol</h2><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-11.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>发送段后，<strong>暂时保留备份 backup</strong><ul>
<li>在发送后没有收到确认的时候，要保存备份来重传</li>
<li>收到确认的时候，抛弃备份</li>
<li><strong>超时</strong>计时器：如果对方的应答超过一定时间后则<strong>直接进行重发</strong>（时间要比正常往返时间稍微长一点）</li>
</ul>
</li>
<li>每个<strong>segment和 ACK 必须具有 ID</strong></li>
<li>重新发送时间必须大于<strong>平均传输时间 * 2</strong></li>
<li>停止等待协议是一个简单的协议，但是效率很低</li>
</ol>
<h2 id="5-数据传输——丢失-延迟-Lost-ACK-and-Late-ACK"><a href="#5-数据传输——丢失-延迟-Lost-ACK-and-Late-ACK" class="headerlink" title="5. 数据传输——丢失&#x2F;延迟 Lost ACK and Late ACK"></a>5. 数据传输——丢失&#x2F;延迟 Lost ACK and Late ACK</h2><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-12.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>丢失ACK情况:</li>
</ol>
<ul>
<li><strong>发送方</strong>：<strong>重新发送一份</strong>M1数据段</li>
<li><strong>接收方</strong>：如果<strong>接收到重复</strong>的M1数据段，接收方将<strong>丢弃</strong>重复的数据段。<ul>
<li>将<strong>重新发送ACK</strong>，以确认已经接收到的M1数据段。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>ACK迟到情况:</li>
</ol>
<ul>
<li><strong>发送方</strong>：<strong>重新发送一份</strong>M1数据段</li>
<li><strong>接收方</strong>：如果<strong>接收到重复</strong>的M1数据段，接收方将<strong>丢弃</strong>重复的数据段。<ul>
<li>将<strong>重新发送ACK</strong>，以确认已经接收到的M1数据段。</li>
</ul>
</li>
<li>发送方收到迟到的ACK不做理会<ul>
<li>晚到的应答直接丢弃（不做处理）</li>
</ul>
</li>
</ul>
<h2 id="6-可靠通信——自动重传请求（ARQ）"><a href="#6-可靠通信——自动重传请求（ARQ）" class="headerlink" title="6. 可靠通信——自动重传请求（ARQ）"></a>6. 可靠通信——自动重传请求（ARQ）</h2><ul>
<li><strong>ARQ (Automatic Repeat reQuest)</strong></li>
<li>这意味着“重传请求”是<strong>自动发送</strong>的，接收方<strong>无需请求发送方重传出错的数据段</strong>。</li>
</ul>
<h3 id="6-1-连续-ARQ-协议"><a href="#6-1-连续-ARQ-协议" class="headerlink" title="6.1 连续 ARQ 协议"></a>6.1 连续 ARQ 协议</h3><ul>
<li>连续 ARQ 协议（<strong>Contiguous ARQ Protocol</strong>）<br><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-13.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>ARQ的工作原理</li>
</ul>
<ol>
<li><strong>发送方维持发送窗口</strong></li>
<li>收到<strong>一个确认</strong>后，发送窗口<strong>向前滑动</strong></li>
<li>只可发送发送窗口内的数据</li>
</ol>
<h3 id="6-2-具体实例"><a href="#6-2-具体实例" class="headerlink" title="6.2 具体实例"></a>6.2 具体实例</h3><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-14.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>发送端要发送 900 字节长的数据，划分为 9 个 100 字节长的报文段，而<strong>发送窗口确定为 500 字节</strong>。</li>
<li><strong>发送端只要收到了对方的确认，发送窗口就可前移</strong>。</li>
<li>发送 TCP 要维护一个指针。每发送一个报文段，指针就向前移动一个报文段的距离。<br><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-15.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>发送端已发送了 400 字节的数据，但只收到对前 200 字节数据的确认，同时窗口大小不变。</li>
<li>现在发送端还可发送 300 字节。</li>
<li>发送端收到了对方对前 400 字节数据的确认，但对方<strong>通知发送端必须把窗口减小到 400 字节</strong>。</li>
<li>现在发送端最多还可发送 400 字节的数据。<br><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-16.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>利用可变窗口大小进行流量控制，双方确定的窗口值是 400<br><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-17.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<ul>
<li><strong>WIN：窗口的大小</strong>：双方动态协商，收到确认调整窗口</li>
<li>ACK：是指可以继续发送的数据的位置。</li>
<li>为什么 201 在 401 后面发送？<strong>超时重传</strong>（<strong>要超过两倍的平均传输时间后才进行重传</strong>）</li>
</ul>
<hr>
<h2 id="7-TCP-Release-Connection-中断连接"><a href="#7-TCP-Release-Connection-中断连接" class="headerlink" title="7. TCP: Release Connection 中断连接"></a>7. TCP: Release Connection 中断连接</h2><h3 id="第一次握手：A发起断开连接请求"><a href="#第一次握手：A发起断开连接请求" class="headerlink" title="第一次握手：A发起断开连接请求"></a>第一次握手：A发起断开连接请求</h3><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-18.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li><strong>客户端</strong>：发送一个<strong>FIN&#x3D;1</strong>的TCP段，表示<strong>请求中断连接</strong>。</li>
<li>这表示发送方已经没有数据要发送了，但仍然可以接收数据</li>
</ul>
<h3 id="第二次握手：B-Ack-1-允许断开"><a href="#第二次握手：B-Ack-1-允许断开" class="headerlink" title="第二次握手：B:Ack &#x3D; 1:允许断开"></a>第二次握手：B:Ack &#x3D; 1:允许断开</h3><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-21.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li><strong>服务器</strong>：发送一个ACK&#x3D;1的TCP段，表示确认接收到中断连接请求.</li>
<li>此时，<em>接收方可能还有未发送完的数据</em>，因此<strong>连接仍然保持</strong>，只是<strong>不再发送新的数据</strong>，此时我们需要完成之前未处理完成的数据的处理。(这里只是说我已经收到了你请求停止传输的请求)</li>
</ul>
<h3 id="第三次握手：B-FIN-1-数据处理完成"><a href="#第三次握手：B-FIN-1-数据处理完成" class="headerlink" title="第三次握手：B:FIN &#x3D; 1:数据处理完成"></a>第三次握手：B:FIN &#x3D; 1:数据处理完成</h3><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-22.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li><strong>服务器</strong>: 发送一个FIN&#x3D;1的TCP段, 表示它也没有数据要发送了，准备中断连接</li>
</ul>
<h3 id="第四次握手：A：ACK-1，确认收到B的断开信息"><a href="#第四次握手：A：ACK-1，确认收到B的断开信息" class="headerlink" title="第四次握手：A：ACK&#x3D;1，确认收到B的断开信息"></a>第四次握手：A：ACK&#x3D;1，确认收到B的断开信息</h3><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-23.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li><strong>客户端</strong>: 发送一个ACK&#x3D;1的TCP段, 表示确认中断连接. 此时<strong>连接正式关闭</strong></li>
</ul>
<h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-24.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>在<strong>释放连接之前</strong>，<strong>客户端</strong>必须等待<strong>2倍的最大报文段生存时间（2MSL）</strong></li>
</ul>
<h2 id="7-为什么要等待2MSL"><a href="#7-为什么要等待2MSL" class="headerlink" title="7. 为什么要等待2MSL"></a>7. 为什么要等待2MSL</h2><ul>
<li>确保A发送的最后一个ACK能够到达B</li>
<li>防止任何无效的连接请求段出现<ul>
<li>等待2MSL后，我们可以确保连接上的所有段都已消失</li>
</ul>
</li>
</ul>
<hr>
<h2 id="9-TCP的计时器"><a href="#9-TCP的计时器" class="headerlink" title="9. TCP的计时器"></a>9. TCP的计时器</h2><ol>
<li>重传计时器</li>
<li>坚持计时器<ul>
<li><strong>作用</strong>：用于解决TCP连接中的“零窗口”问题。当接收方的接收窗口为零时，发送方会停止发送数据，并启动坚持计时器。坚持计时器到期后，发送方会发送一个小的探测报文段（窗口探测），询问接收方的窗口大小是否已经更新。</li>
<li><strong>目的</strong>：防止发送方和接收方在“零窗口”状态下进入死锁。</li>
</ul>
</li>
<li>保持计时器<ul>
<li><strong>作用</strong>：用于检测TCP连接是否仍然有效。当一段时间内没有数据传输时，保持计时器会启动，并定期发送探测报文段。如果在多次探测后没有收到对方的响应，连接将被认为已经失效。</li>
<li><strong>目的</strong>：确保连接的有效性，及时发现和关闭失效的连接，释放资源。</li>
</ul>
</li>
<li>时间等待计时器</li>
</ol>
<h2 id="10-TCP的有限状态机"><a href="#10-TCP的有限状态机" class="headerlink" title="10. TCP的有限状态机"></a>10. TCP的有限状态机</h2><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-25.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>粗线：正常的服务器端</li>
<li>虚线：正常客户端</li>
<li>细线：异常状态的问题</li>
</ul>
<hr>
<h1 id="三、UDP-User-Datagram-Protocol"><a href="#三、UDP-User-Datagram-Protocol" class="headerlink" title="三、UDP (User Datagram Protocol)"></a>三、UDP (User Datagram Protocol)</h1><ul>
<li><strong>用户数据报协议</strong></li>
</ul>
<h2 id="1-为什么需要UDP"><a href="#1-为什么需要UDP" class="headerlink" title="1. 为什么需要UDP"></a>1. 为什么需要UDP</h2><ul>
<li><strong>无需连接建立</strong>：不需要连接建立过程（比如TCP三次握手，这可能会增加<strong>延迟</strong>）。</li>
<li><strong>简单</strong>：发送方和接收方<strong>没有连接状态</strong>。</li>
<li><strong>小的段头部</strong>：段头部较小，只有<strong>8个字节</strong>。</li>
<li><strong>无拥塞控制</strong>：UDP可以根据需要快速发送数据。</li>
</ul>
<h2 id="2-介绍（特点与应用）"><a href="#2-介绍（特点与应用）" class="headerlink" title="2. 介绍（特点与应用）"></a>2. 介绍（特点与应用）</h2><ol>
<li>无连接 Connectionless：<ul>
<li><strong>无握手</strong>：UDP发送方sender和接收方receiver之间没有握手过程。</li>
<li><strong>独立处理</strong>：UDP中的每个数据报文（Datagram）是独立处理的</li>
</ul>
</li>
<li>常用于流媒体应用 streaming multimedia applications：<ul>
<li><strong>容错</strong>：对丢失容忍。loss tolerant</li>
<li><strong>速率敏感</strong>：对传输速率敏感，而UDP允许尽可能快。rate sensitive</li>
<li>流媒体应用eg：音频、视频</li>
</ul>
</li>
<li>UDP的应用：<ul>
<li><strong>RIP（路由信息协议）</strong>：定期发送路由信息。<ul>
<li>由于RIP的数据包较小且定期发送，使用UDP可以避免TCP的连接建立和关闭带来的延迟。</li>
</ul>
</li>
<li><strong>DNS（域名系统）</strong>：DNS查询通常使用UDP<ul>
<li>因为DNS查询通常是短小的请求和响应，且不需要建立连接，使用UDP可以避免TCP建立连接时的延迟。</li>
</ul>
</li>
<li><strong>SNMP（简单网络管理协议）</strong>：SNMP用于网络设备的监控和管理<ul>
<li>尤其是在拥塞的情况下，UDP能够比TCP提供更高的性能，因为TCP在拥塞情况下会出现重传和延迟。</li>
</ul>
</li>
<li><strong>其他协议</strong>：包括TFTP（简单文件传输协议）、DHCP（动态主机配置协议）等不需要建立可靠连接的协议。</li>
</ul>
</li>
<li>必要时在应用层添加可靠性<ul>
<li>由于UDP本身不提供可靠性，应用层可以根据需要自己实现数据的可靠性控制。</li>
</ul>
</li>
</ol>
<h2 id="3-UDP段格式"><a href="#3-UDP段格式" class="headerlink" title="3. UDP段格式"></a>3. UDP段格式</h2><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-26.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>UDP 的数据段很简单</li>
<li>UDP 只有 <strong>8 个字节的首部</strong>，所以 <strong>UDP 报文最少是 8 个字节</strong></li>
</ul>
<ol>
<li>源端口（Source Port）：16位，发送方的端口号。</li>
<li>目的端口（Destination Port）：16位，接收方的端口号。</li>
<li>长度（Length）：16位，UDP数据报的总长度（包括头部和数据部分）。</li>
<li>校验和（Checksum）：16位，UDP数据的校验和，用于检验数据在传输过程中是否出错。校验和覆盖数据部分，如果发生错误，接收方会丢弃数据报。</li>
</ol>
<ul>
<li><strong>校验</strong>也要对 data 一并校验，如果出现错误，直接丢弃。</li>
<li>数据：UDP 直接发送，UDP 不会再自己分片了；应用层根据需要决定如何将数据分割成适合传输的大小。</li>
</ul>
<h2 id="TCP和UDP对比"><a href="#TCP和UDP对比" class="headerlink" title="TCP和UDP对比"></a>TCP和UDP对比</h2><h2 id><a href="#" class="headerlink" title></a><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-27.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></h2><h1 id="四、An-application-NAT-and-PAT"><a href="#四、An-application-NAT-and-PAT" class="headerlink" title="四、An application: NAT and PAT"></a>四、An application: NAT and PAT</h1><h2 id="1-什么是NAT（Network-Address-Translation）"><a href="#1-什么是NAT（Network-Address-Translation）" class="headerlink" title="1. 什么是NAT（Network Address Translation）"></a>1. 什么是NAT（Network Address Translation）</h2><ol>
<li><strong>定义</strong>：NAT（<strong>网络地址转换</strong>）是将<strong>IP数据包头中</strong>的<strong>一个地址</strong>替换为<strong>另一个地址</strong>的过程。</li>
<li><strong>用途</strong>：NAT用于允许<strong>使用私有地址的主机</strong> <strong>访问互联网</strong>。</li>
<li><strong>解决IP地址耗尽的方案之一</strong>：<ul>
<li>节省注册（合法）地址</li>
<li>增加连接互联网的灵活性</li>
</ul>
</li>
<li><strong>相关标准</strong>：RFC 1631 - 网络地址转换器（NAT）</li>
</ol>
<h2 id="2-NAT-a-simple-concept"><a href="#2-NAT-a-simple-concept" class="headerlink" title="2. NAT a simple concept"></a>2. NAT a simple concept</h2><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-28.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="3-NAT-类型"><a href="#3-NAT-类型" class="headerlink" title="3. NAT 类型"></a>3. NAT 类型</h2><ol>
<li><strong>静态NAT</strong>：Static NAT<ul>
<li>固定映射：一个内部地址到一个注册地址。</li>
</ul>
</li>
<li><strong>动态NAT</strong>：Dynamic NAT<ul>
<li>映射是动态完成的，基于<strong>先到先得</strong>的原则。</li>
</ul>
</li>
<li><strong>PAT（端口地址转换&#x2F;重载）</strong>： PAT (Overload)<ul>
<li>使用端口地址转换允许<strong>多个内部用户共享一个“内部全局”地址</strong>。</li>
</ul>
</li>
</ol>
<h2 id="4-NAT中的地址类型"><a href="#4-NAT中的地址类型" class="headerlink" title="4. NAT中的地址类型"></a>4. NAT中的地址类型</h2><ol>
<li>Inside Local address 内部本地地址: <strong>内网IP地址</strong></li>
<li>Inside Global address 内部全局地址: <strong>注册IP地址</strong>, 对外部展示的内部地址</li>
<li>Outside Global address外部全局地址: 由<strong>主机所有者分配</strong>的IP地址, 通常是<strong>注册地址</strong>。<br><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-29.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<ul>
<li>内部主机发送报文给网关，网关根据 NAT Table 进行翻译，转换成内部全局地址，然后进行转发</li>
</ul>
<h2 id="5-Static-NAT-例子"><a href="#5-Static-NAT-例子" class="headerlink" title="5. Static NAT 例子"></a>5. Static NAT 例子</h2><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-30.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><strong>静态映射</strong>：静态NAT通过<strong>手动配置</strong>，将每个内部私有IP地址<strong>固定映射</strong>到一个公网IP地址。</li>
<li><strong>转换表</strong>：NAT设备维护一个<strong>静态转换表</strong>，记录内部私有IP地址和对应的公网IP地址之间的映射关系。</li>
<li><strong>地址转换</strong>：当内部主机发起连接请求时，NAT设备根据静态转换表，将内部私有IP地址替换为对应的公网IP地址。</li>
<li><strong>固定映射</strong>：映射关系是固定的，不会随时间变化，确保每个内部主机始终使用相同的公网IP地址进行通信。</li>
</ol>
<h2 id="6-Dynamic-NAT-例子"><a href="#6-Dynamic-NAT-例子" class="headerlink" title="6. Dynamic NAT 例子"></a>6. Dynamic NAT 例子</h2><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-31.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><strong>地址池</strong>：动态NAT使用一个公网IP地址池来动态映射内部私有IP地址。</li>
<li><strong>请求映射</strong>：当内部主机发起连接请求时，NAT设备从地址池中选择一个未使用的公网IP地址，并将其映射到内部私有IP地址。</li>
<li><strong>建立映射</strong>：NAT设备在内部私有IP地址和选定的公网IP地址之间建立临时映射。</li>
<li><strong>释放映射</strong>：当连接结束或超时时，NAT设备释放该映射，使公网IP地址返回地址池供其他内部主机使用。</li>
</ol>
<ul>
<li>先到先得</li>
</ul>
<h2 id="7-NAT-的优缺点"><a href="#7-NAT-的优缺点" class="headerlink" title="7. NAT 的优缺点"></a>7. NAT 的优缺点</h2><ol>
<li><strong>优点</strong>：<ul>
<li>由于<strong>并非每个内部主机同时需要外部访问</strong>，可以使用一个较小的公网IP地址池来服务相对较多的私有地址主机。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>一对一映射 one-to-one mapping</strong>。</li>
<li>例如，如果私有地址空间是&#x2F;8，但公网地址是&#x2F;24，则只有254个主机可以同时访问互联网。</li>
</ul>
</li>
</ol>
<h2 id="8-PAT-端口地址转换-Port-Address-Translation"><a href="#8-PAT-端口地址转换-Port-Address-Translation" class="headerlink" title="8. PAT 端口地址转换 Port Address Translation"></a>8. PAT 端口地址转换 Port Address Translation</h2><ul>
<li>一种特殊类型的动态NAT</li>
<li>将<strong>私有IP地址</strong>和<strong>公网IP地址</strong>映射到<strong>不同的端口号</strong>来实现<strong>多个私有IP地址共享一个公网IP地址</strong>。</li>
<li>每个私有IP地址的每个连接都通过<strong>不同的端口号</strong>进行区分。</li>
</ul>
<h2 id="9-PAT-工作原理"><a href="#9-PAT-工作原理" class="headerlink" title="9. PAT 工作原理"></a>9. PAT 工作原理</h2><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-32.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><strong>端口重载</strong>：PAT使用一个公网IP地址，并通过<strong>不同的端口号</strong>来区分内部主机的连接请求。</li>
<li><strong>端口映射</strong>：当内部主机发起连接请求时，NAT设备将内部私有IP地址和端口号映射到<strong>公网IP地址和唯一的端口号</strong>。</li>
<li><strong>建立映射</strong>：NAT设备在内部私有IP地址和端口号与公网IP地址和唯一端口号之间建立临时映射。</li>
<li><strong>转换表</strong>：NAT设备维护一个转换表，记录内部私有IP地址和端口号与公网IP地址和唯一端口号之间的映射关系。</li>
<li><strong>地址转换</strong>：当数据包通过NAT设备时，NAT设备根据转换表将内部私有IP地址和端口号替换为公网IP地址和唯一端口号，反之亦然。</li>
<li><strong>释放映射</strong>：当连接结束或超时时，NAT设备释放该映射，使端口号返回端口池供其他内部主机使用。</li>
</ol>
<h2 id="10-PAT-操作"><a href="#10-PAT-操作" class="headerlink" title="10. PAT 操作"></a>10. PAT 操作</h2><p><img src="/2025/02/24/%E4%BA%94%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82/image-33.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>八、RIP&amp;OSPF</title>
    <url>/2025/02/24/%E5%85%AB.RIP&amp;OSPF/</url>
    <content><![CDATA[<h1 id="08-Routing-Protocols：RIP-and-OSPF"><a href="#08-Routing-Protocols：RIP-and-OSPF" class="headerlink" title="08 Routing Protocols：RIP and OSPF"></a>08 Routing Protocols：RIP and OSPF</h1><ul>
<li>RIPv1&#x2F;RIPv2<ul>
<li>RIP History </li>
<li>Differences Between RIP v1 and RIP v2 </li>
<li>Configuration of RIP v2</li>
</ul>
</li>
<li>OSPF(single area)<ul>
<li>Link-state routing protocol</li>
<li>Single-area OSPF concepts</li>
<li>Single-area OSPF configuration</li>
</ul>
</li>
</ul>
<h1 id="一、RIPv1-RIPv2"><a href="#一、RIPv1-RIPv2" class="headerlink" title="一、RIPv1&#x2F;RIPv2"></a>一、RIPv1&#x2F;RIPv2</h1><h2 id="（一）RIP-History"><a href="#（一）RIP-History" class="headerlink" title="（一）RIP History"></a>（一）RIP History</h2><h2 id="1-RIP的历史"><a href="#1-RIP的历史" class="headerlink" title="1. RIP的历史"></a>1. RIP的历史</h2><ol>
<li><strong>RIP v1</strong>被认为是一种无类别的<strong>内部网关协议（IGP）</strong>。<ul>
<li><strong>距离矢量协议 DVP</strong>：RIP v1是一种距离矢量协议，它以预定的间隔向每个邻居路由器广播其整个路由表。默认间隔为<strong>30秒</strong>。</li>
<li><strong>跳数作为度量</strong>：RIP使用跳数作为度量，最大跳数为<strong>15</strong>。<ul>
<li>如果目的地的跳数超过15，则认为该目的地不可达。</li>
</ul>
</li>
</ul>
</li>
<li><strong>负载均衡 load balancing</strong>：RIP v1能够在多达<strong>6条</strong>等成本路径上进行负载均衡，默认情况下为<strong>4条</strong>路径。</li>
<li><strong>规范</strong>：RIP最初在RFC 1058中指定。</li>
</ol>
<ul>
<li>RIP v1的局限性<ul>
<li><strong>不发送子网掩码信息</strong>：RIP v1在更新中不发送子网掩码信息。<ul>
<li>意味着只能支持类网络，必须用同样的子网掩码</li>
</ul>
</li>
<li><strong>广播更新</strong>：RIP v1以广播形式发送更新，地址为255.255.255.255。<ul>
<li>只能发给邻居，不能通过路由器转发</li>
</ul>
</li>
<li><strong>不支持身份验证（authentication）</strong>：RIP v1不支持认证。<ul>
<li>安全隐患</li>
</ul>
</li>
<li><strong>不支持VLSM或CIDR</strong>：RIP v1无法支持可变长子网掩码（VLSM）或无类别域间路由（CIDR）。</li>
</ul>
</li>
</ul>
<h2 id="2-RIP的配置Configuration"><a href="#2-RIP的配置Configuration" class="headerlink" title="2. RIP的配置Configuration"></a>2. RIP的配置Configuration</h2><ul>
<li><code>router rip</code> 开始RIP路由过程(<strong>选择 RIP 作为路由协议</strong>)</li>
<li><code>network network-number</code> 分配基于 NIC（Network Interface Card）的网络地址，也就是说，路由器与哪些网络直接连接，就要配置对应的网络地址。</li>
<li>例子：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router rip</span><br><span class="line">network 1.0.0.0</span><br><span class="line">network 2.0.0.0</span><br><span class="line">//路由器是直接连接到 1.0.0.0 和 2.0.0.0 这两个网络的，且这两个网络会启用RIP协议</span><br></pre></td></tr></table></figure>

<ul>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="（二）Configuration-of-RIP-v2"><a href="#（二）Configuration-of-RIP-v2" class="headerlink" title="（二）Configuration of RIP v2"></a>（二）Configuration of RIP v2</h2><h2 id="1-RIP-v2"><a href="#1-RIP-v2" class="headerlink" title="1. RIP v2"></a>1. RIP v2</h2><ul>
<li>RIP v2是RIP v1的改进版本，具有以下特性：<ul>
<li><strong>距离矢量协议</strong>：使用<strong>跳数</strong>作为度量。</li>
<li><strong>保持定时器</strong>：使用holddown timers防止路由环路，默认时间为<strong>180秒</strong>。<ul>
<li>如果路由器在180s内没有接收到路由更新，它会认为路由不可用。</li>
</ul>
</li>
<li><strong>水平分割</strong>：使用split horizons防止路由环路。</li>
<li><strong>无限距离</strong>：使用<strong>16跳</strong>作为<strong>无限距离的度量</strong>。<ul>
<li>15 跳及以内可达；否则认为目标不可达</li>
</ul>
</li>
<li><strong>支持CIDR和VLSM</strong></li>
<li>支持<strong>认证</strong>（Authentication）</li>
<li>使用<strong>多播</strong>而不是广播, 地址<strong>224.0.0.9</strong></li>
<li>会发送<strong>子网掩码</strong>信息</li>
</ul>
</li>
</ul>
<h2 id="2-RIP-v2-的配置"><a href="#2-RIP-v2-的配置" class="headerlink" title="2. RIP v2 的配置"></a>2. RIP v2 的配置</h2><ol>
<li><code>router</code>命令启动路由过程。</li>
<li><code>version 2</code>：表示启动 RIPv2<ul>
<li>直接使用 router rip <strong>默认为 v1</strong>，一定要输入这个命令才能启动 RIPv2</li>
</ul>
</li>
<li><code>network</code>配置网络，命令实现以下三个功能：<ul>
<li><strong>路由更新</strong>通过该命令指定的<strong>网络接口</strong>进行<strong>多播</strong> multicast。<ul>
<li>并将路由更新通过该接口发送到多播地址（224.0.0.9），发送给同一网络上的其他 RIP 路由器。</li>
</ul>
</li>
<li>如果路由更新进入<strong>同一接口</strong>，则进行<strong>处理</strong>。<ul>
<li>同一接口（即该接口本身已配置为 RIP 网络接口）</li>
<li>路由器会处理该更新并更新自己的路由表</li>
</ul>
</li>
<li>广播直接连接到该接口的子网。<ul>
<li>路由器会在指定网络接口上广播或多播该接口直接连接的子网信息</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-1.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="3-验证与故障排除"><a href="#3-验证与故障排除" class="headerlink" title="3. 验证与故障排除"></a>3. 验证与故障排除</h2><ol>
<li>验证 RIPv2：</li>
</ol>
<ul>
<li>Router#<strong>show ip protocols</strong>    #查看当前启用的路由协议，以及其配置和相关信息</li>
<li>Router#<strong>show ip route</strong>    #显示 IP 路由表</li>
</ul>
<ol start="2">
<li>故障排除 RIPv2：</li>
</ol>
<ul>
<li>Router#<strong>debug ip rip</strong>   #显示RIP 路由更新的发送和接收过程</li>
<li>Router#<strong>undebug all</strong>    #（或 <strong>no debug all</strong>）：停止debug调试</li>
</ul>
<ol start="3">
<li><code>show ip protocols</code>实例</li>
</ol>
<ul>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-2.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<ol start="4">
<li><code>debug ip rip</code>命令<ol>
<li><code>debug ip rip</code>命令显示 <strong>RIP 路由更新的发送和接收</strong>。在本示例中，更新是通过 183.8.128.130 发送的</li>
<li>它报告了三台路由器，其中一台<strong>无法访问</strong>，因为其跳数大于 15。然后通过 183.8.128.2 广播了更新</li>
</ol>
</li>
</ol>
<ul>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-3.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<ol start="5">
<li><code>show ip route</code>查看路由表</li>
</ol>
<ul>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-5.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>Codes：表示对于路由协议类型的描述</li>
<li>每个路由的格式为：<strong>&lt;协议类型&gt;&#x2F;&lt;跳数&gt;</strong></li>
<li>120&#x2F;1：表示该路由通过 RIP 协议获取, 1 跳到达，120&#x2F;2：表示 2 跳到达</li>
</ul>
<h2 id="（三）RIPv1-和-RIPv2-之间的区别"><a href="#（三）RIPv1-和-RIPv2-之间的区别" class="headerlink" title="（三）RIPv1 和 RIPv2 之间的区别"></a>（三）RIPv1 和 RIPv2 之间的区别</h2><p><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-6.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>支持有类路由：可以携带子网掩码</li>
<li>使用多播地址进行发送广播：特定给 RIP 接受，避免了接受后发现没有启动 RIP 进程耽误时间</li>
<li>需要身份认证才确定是否继续进行接收</li>
</ul>
<hr>
<h1 id="OSPF-single-area"><a href="#OSPF-single-area" class="headerlink" title="OSPF(single area)"></a>OSPF(single area)</h1><ul>
<li>介绍单个区域（single-srea）OSPF 协议</li>
</ul>
<h2 id="1-OSPF概述"><a href="#1-OSPF概述" class="headerlink" title="1. OSPF概述"></a>1. OSPF概述</h2><ul>
<li><strong>Open Shortest Path First</strong></li>
</ul>
<ol>
<li>开放最短路径优先（OSPF）是一种基于开放标准的<strong>链路状态link-state</strong>路由协议。</li>
<li>标准描述：OSPF在多个互联网工程任务组（IETF）的标准中有所描述，最新的描述在RFC 2328中。</li>
<li><strong>可扩展性</strong>：与RIPv1和RIPv2相比，OSPF因其可扩展性而成为首选的<strong>内部网关协议（IGP）</strong>。</li>
</ol>
<h2 id="2-路由信息-Routing-information"><a href="#2-路由信息-Routing-information" class="headerlink" title="2. 路由信息 Routing information"></a>2. 路由信息 Routing information</h2><ul>
<li><strong>链路状态</strong>：The state of the link是<strong>对接口及其与邻居路由器关系的描述</strong>。</li>
<li><strong>链路状态数据库</strong>：链路状态的集合形成 link-state database，有时也称为<strong>拓扑数据库 topological database</strong>。</li>
<li><strong>SPF算法</strong>：路由器应用<strong>Dijkstra最短路径优先（SPF）算法</strong>来构建SPF树，以自身为根。</li>
<li><strong>路径计算</strong>：路由器通过SPF树计算最佳路径，然后选择最佳路径并将其放入<strong>路由表</strong>中。</li>
</ul>
<h2 id="3-OSPF-vs-RIP"><a href="#3-OSPF-vs-RIP" class="headerlink" title="3. OSPF vs. RIP"></a>3. OSPF vs. RIP</h2><p><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-7.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>OSPF使用带宽作为评价指标, 而RIP使用跳数</li>
<li>OSPF适合大型网络, 而RIP是为小型网络设计的</li>
<li>OSPF可以进一步把网络划分为小区域</li>
<li>OSPF支持VLSM，RIP v1不支持</li>
<li>OSPF快速收敛</li>
<li>OSPF支持多条等价的路径（多路负载均衡）</li>
</ol>
<ul>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-8.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>What is the Best Path from A to B?<ul>
<li>上面带宽大，2 跳达到，下面带宽小，1 跳到达。</li>
<li>OSPF 从上面走，RIP 从下面走，但是上面会快一些，因此 OSPF 选择的路径是更加优越的</li>
</ul>
</li>
</ul>
<h2 id="4-OSPF的特点"><a href="#4-OSPF的特点" class="headerlink" title="4. OSPF的特点"></a>4. OSPF的特点</h2><ul>
<li>More robust更健壮</li>
<li>更好的可扩展性 scalable</li>
<li><strong>分层设计 hierarchical design</strong>：大型OSPF网络使用分层设计</li>
</ul>
<h2 id="5-OSPF中的一些术语-Terminology"><a href="#5-OSPF中的一些术语-Terminology" class="headerlink" title="5. OSPF中的一些术语 Terminology"></a>5. OSPF中的一些术语 Terminology</h2><ol>
<li><strong>链路&#x2F;连接（Link）</strong>：<ul>
<li>两个网络设备之间的物理连接</li>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-9.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li><strong>链路状态（Link-State）</strong>：<ul>
<li>两个路由器之间的链路状态，包括路由器接口的信息及其与邻居路由器的关系、网络类型（点对点、多路复用）等</li>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-10.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ol>
<ul>
<li><strong>邻居（Neighbors）</strong>：相邻的路由器</li>
</ul>
<ol start="3">
<li><strong>开销（Cost）</strong>：<ul>
<li>不同网络链路处理的时候的代价，和链路带宽相关，成反比关系，一般是固定值除以带宽</li>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-11.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li><strong>区域（Area）</strong>：<ul>
<li>具有相同区域ID的网络&#x2F;路由器的集合</li>
<li>区域内的每个路由器都具有相同的链路状态信息</li>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-12.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li><strong>自治系统（Autonomous System，AS）</strong>：<ul>
<li>多个 Area 形成一个自治系统</li>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-14.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li><strong>邻接关系数据库（Neighborship Database）</strong>：<ul>
<li>列出路由器已建立双向通信的所有邻居</li>
</ul>
</li>
<li><strong>拓扑数据库（Topology Database）</strong>：<ul>
<li>列出所有路由 link-state</li>
<li>包含关于互联网络中所有其他路由器的信息，显示互联网络的拓扑结构</li>
</ul>
</li>
<li><strong>路由表（Routing Table）</strong>：<ul>
<li>列出最佳路由</li>
<li>有时称为转发数据库</li>
<li>每个路由器的路由表都是唯一的</li>
</ul>
</li>
<li><strong>指定路由器（Designated Router, DR）</strong>：<ul>
<li>在OSPF多访问网络中选举出的一个路由器，代表该网络中的所有路由器</li>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-15.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li><strong>备份指定路由器（Backup Designated Router, BDR）</strong>：</li>
</ol>
<ul>
<li>备用路由器，如果原始DR失效，它将成为DR</li>
</ul>
<hr>
<h2 id="6-OSPF-Area"><a href="#6-OSPF-Area" class="headerlink" title="6. OSPF Area"></a>6. OSPF Area</h2><ul>
<li><strong>区域定义</strong>：区域使用32位数字定义<ul>
<li>可以是 IP格式 或 单个十进制值</li>
<li>例如：Area 0 或 Area 0.0.0.0</li>
</ul>
</li>
<li><strong>区域 0</strong>：区域编号为0的单一区域</li>
<li><strong>分层模型</strong>：OSPF使用<strong>2 level hierarchical model</strong></li>
<li>在<strong>多区域OSPF网络</strong>中，所有区域都需要<strong>连接到区域0</strong>（主干）<br><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-16.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="7-OSPF操作步骤"><a href="#7-OSPF操作步骤" class="headerlink" title="7. OSPF操作步骤"></a>7. OSPF操作步骤</h2><ul>
<li>OSPF使用<em>邻居关系</em>来获取网络的完整信息。</li>
<li><strong>操作步骤</strong>：<ol>
<li>建立邻接关系 <strong>adjacency relationships</strong></li>
<li>选举DR和BDR（如果需要）（多路复用的时候才需要）</li>
<li>发现路由（路线 routes）</li>
<li>选择合适的路由</li>
<li>维护路由信息</li>
</ol>
</li>
<li><strong>OSPF的七个状态</strong>：<ul>
<li>Init 初始化</li>
<li>2Way 双向操作</li>
<li>ExStart 预先启动</li>
<li>Exchange 交换</li>
<li>Loading 加载</li>
<li>Full 完成</li>
</ul>
</li>
</ul>
<h2 id="8-最短路径算法"><a href="#8-最短路径算法" class="headerlink" title="8. 最短路径算法"></a>8. 最短路径算法</h2><ul>
<li>最短路径算法使用节点作为起点，依次检查其关于相邻节点的信息，计算出无环拓扑结构。</li>
<li>不根据跳数来进行选择，而是根据最小权和来寻找</li>
</ul>
<h2 id="9-选择-DR-和-BDR"><a href="#9-选择-DR-和-BDR" class="headerlink" title="9. 选择 DR 和 BDR"></a>9. 选择 DR 和 BDR</h2><ul>
<li><strong>OSPF网络类型</strong>：<ul>
<li>广播多访问网络，如以太网    需要选举DR</li>
<li>点对点网络                 不需要选举DR</li>
<li>非广播多访问网络（NBMA）    需要选举DR</li>
</ul>
</li>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-17.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>只有多路复用的实现方式需要 DR 和 BDR</li>
</ul>
<ol>
<li>然后，每个路由器与 DR 和 BDR 形成<strong>邻接关系</strong></li>
<li>对于所有 OSPF 路由器，DR 使用 224.0.0.5（自己的 IP）的<strong>主播地址</strong>向该网段上的所有其他路由器发送<strong>链接状态信息</strong></li>
<li>为确保 DR&#x2F;BDR 看到所有路由器在网段上发送的链接状态，<strong>使用了所有 DR&#x2F;BDR 的多播地址</strong> 224.0.0.6（DR 和 BDR 之间）</li>
</ol>
<h2 id="10-多路复用（Multi-Access-media）中的OSPF"><a href="#10-多路复用（Multi-Access-media）中的OSPF" class="headerlink" title="10. 多路复用（Multi-Access media）中的OSPF"></a>10. 多路复用（Multi-Access media）中的OSPF</h2><ol>
<li>Giga&#x2F;Fast&#x2F;Ethernet，FDDI，Token Ring<ul>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-18.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li><strong>几个 Area 有几个 DR 和 BDR</strong>（是在不同 Area 上）</li>
<li>DR 和 BDR 归属于区域</li>
</ol>
<h2 id="11-OSPF-Packets"><a href="#11-OSPF-Packets" class="headerlink" title="11. OSPF Packets"></a>11. OSPF Packets</h2><ul>
<li>OSPF路由协议有5种类型的数据包：<br><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-19.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li><strong>Hello</strong>：用于<strong>建立和维护邻接关系</strong></li>
<li><strong>数据库描述（DBD）</strong>：用于描述链路状态数据库的内容</li>
<li><strong>链路状态请求（LSR）</strong>：用于请求特定的链路状态信息</li>
<li><strong>链路状态更新（LSU）</strong>：用于发送链路状态信息</li>
<li><strong>链路状态确认（LSAck）</strong>：用于确认接收到的链路状态信息</li>
</ul>
<h3 id="1-Hello-协议"><a href="#1-Hello-协议" class="headerlink" title="1. Hello 协议"></a>1. Hello 协议</h3><ul>
<li>当路由器在接口上启动OSPF路由进程时，它会发送一个Hello数据包，并继续定期发送Hello数据包。</li>
<li>管理OSPF Hello数据包交换的规则称为Hello协议。</li>
<li>Hello数据包的地址是<strong>224.0.0.5</strong>。</li>
<li>在广播多访问和点对点网络上，默认<strong>每10秒</strong>发送一次Hello数据包。</li>
<li>在连接到非广播多访问（NBMA）网络（如帧中继）的接口上，默认时间为<strong>30秒</strong>。</li>
</ul>
<h3 id="2-OSPF-报文头部"><a href="#2-OSPF-报文头部" class="headerlink" title="2. OSPF 报文头部"></a>2. OSPF 报文头部</h3><p><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-20.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Hello 报文的 Type 字段设置为 1</li>
</ul>
<h3 id="3-哪个路由器将成为-DR？"><a href="#3-哪个路由器将成为-DR？" class="headerlink" title="3. 哪个路由器将成为 DR？"></a>3. 哪个路由器将成为 DR？</h3><ul>
<li><strong>优先级 + 路由器ID 最大</strong>：优先级和路由器ID<strong>最大</strong>的路由器成为DR，第二大的成为BDR。</li>
<li><strong>优先级</strong>：范围为1-255，默认值为1。</li>
<li><strong>路由器ID</strong>：<ul>
<li>使用回环IP地址作为路由器ID。</li>
<li>如果没有回环IP地址，则使用最高值的接口IP地址。</li>
</ul>
</li>
<li><strong>接口失效</strong>：如果接口失效，路由器必须重新建立邻接关系并重新发布LSA。</li>
</ul>
<h2 id="12-OSPF-操作的完整步骤"><a href="#12-OSPF-操作的完整步骤" class="headerlink" title="12. OSPF 操作的完整步骤"></a>12. OSPF 操作的完整步骤</h2><p><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-21.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>一开始的状态是 Down State</li>
<li>发送 <strong>Hello 报文</strong>（Init State）</li>
<li>B 收到 A 的报文（收到报文一定是邻居）：Hello 报文的 TTL 是 1，所以不会跨路由器传播，收到即丢弃</li>
<li>收到后，B 也会发送自己的 Hello，然后 A 收到后进入 Two Way 状态<br><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-22.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>准备交换数据库（Exstart Starts）</li>
<li>首先确认<strong>主方（发送方）、从方（接受方）</strong>，保证数据有序，简单就是谁的 Router ID <strong>高</strong></li>
<li>Router ID 高的（主方）发送自己 <strong>DBD 报文</strong>，从方对主方发送的 DBD 接受处理并发送（Exchange State）<br><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-23.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>交换完成后，各自检查自己是不是有全部的信息<ul>
<li>如果发现有没有的，则发送 <strong>LSR</strong>，等待 <strong>LSU</strong>（整个链路的详细信息，不是 LSA）来进行学习，之后收到完成后发送 <strong>LSAck</strong>（Loading State）</li>
<li>如果有完整的信息，则发送 <strong>LSAck</strong>（Full State）</li>
</ul>
</li>
</ol>
<h2 id="13-总结：OSPF操作"><a href="#13-总结：OSPF操作" class="headerlink" title="13. 总结：OSPF操作"></a>13. 总结：OSPF操作</h2><ol>
<li>Set up the adjacency relationships邻居关系</li>
<li>Elect DR and BDR（if needed）选举DR</li>
<li>Discover the routes 发路由</li>
<li>Choose appropriate routes 选路由</li>
<li>Maintain the route information 维持路由信息</li>
</ol>
<h3 id="步骤-1：建立邻居关系"><a href="#步骤-1：建立邻居关系" class="headerlink" title="步骤 1：建立邻居关系"></a>步骤 1：建立邻居关系</h3><ul>
<li>路由器按间隔发送Hello数据包。<ul>
<li>如果发现<strong>邻居</strong>：<ul>
<li>将邻居添加到邻接关系数据库。</li>
</ul>
</li>
<li>发现<strong>网络类型</strong>：<ul>
<li>如果是<strong>多访问网络</strong>，进入DR&#x2F;BDR选举过程并进入步骤2。</li>
<li>如果是<strong>点对点或点对多点网络</strong>，不选举DR&#x2F;BDR，跳过步骤2。</li>
<li>如果<strong>Hello数据包头中的DR&#x2F;BDR字段已被占用</strong>（即已存在DR&#x2F;BDR对），则不进行DR&#x2F;BDR选举，跳过步骤2。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="步骤-2：选举DR-BDR"><a href="#步骤-2：选举DR-BDR" class="headerlink" title="步骤 2：选举DR&#x2F;BDR"></a>步骤 2：选举DR&#x2F;BDR</h3><ul>
<li>如果没有其他路由器在线，该路由器成为DR。下一个上线的路由器将成为BDR。</li>
<li>如果有多个路由器（两个或更多）同时上线，则：<ul>
<li><strong>优先级</strong>最高的路由器成为DR。<ul>
<li>优先级为零表示“永不成为DR”。</li>
</ul>
</li>
<li>如果<strong>优先级相同</strong>，则<strong>路由器ID</strong>最高的路由器成为DR。<ul>
<li>路由器ID是最高的回环地址或接口IP地址。</li>
</ul>
</li>
<li>优先级或路由器ID第二高的路由器成为BDR。</li>
</ul>
</li>
<li>如果DR失效，BDR成为DR。</li>
<li>【注意！】但是，如果一个<strong>新的OSPF路由器加入</strong>网络，且其<strong>优先级或路由器ID更高</strong>，当前的DR和BDR<strong>不会改变</strong>。<ul>
<li>只有在当前DR失效时，它才会成为新的<em>BDR</em>；</li>
<li>或者在当前DR和BDR<strong>都失效</strong>时，它才会成为新的<em>DR</em>。</li>
</ul>
</li>
</ul>
<h3 id="步骤-3：发现路由"><a href="#步骤-3：发现路由" class="headerlink" title="步骤 3：发现路由"></a>步骤 3：发现路由</h3><ul>
<li>之前在ExStart到Full状态中解释过<ul>
<li>路由器确定“<strong>主&#x2F;从</strong>”关系</li>
<li>在多路复用网络中，<strong>DR&#x2F;BDR交换LSA</strong>，所有<strong>其他路由器</strong>将<strong>类型2的DBD发送给DR&#x2F;BDR</strong></li>
<li>如果需要，路由器可以通过发送<strong>LSR请求更多信息</strong>进入加载状态<ul>
<li>所有路由器必须在加载状态中等待，直到请求路由器完全更新</li>
</ul>
</li>
<li>路由器现在进入Full状态</li>
</ul>
</li>
</ul>
<h3 id="步骤-4：选择最佳路由"><a href="#步骤-4：选择最佳路由" class="headerlink" title="步骤 4：选择最佳路由"></a>步骤 4：选择最佳路由</h3><ul>
<li>现在网络上的所有路由器并行计算SPF算法。<ul>
<li>记住：<strong>在此之前</strong>，所有路由器必须具有<strong>相同的链路状态数据库</strong>。</li>
<li>SPF使用<strong>Cost作为度量</strong>。</li>
<li>SPF为每条从自身到目的地的路径累加开销，构建以路由器为根的树。</li>
<li>OSPF然后将最小开销路径安装到路由表中。</li>
<li><em>最多可以安装4条等成本路径进行负载共享</em>。</li>
</ul>
</li>
</ul>
<h3 id="步骤-5：维护路由信息"><a href="#步骤-5：维护路由信息" class="headerlink" title="步骤 5：维护路由信息"></a>步骤 5：维护路由信息</h3><ul>
<li>OSPF通过<strong>定期交换Hello数据包</strong>来检测<strong>新邻居或失效邻居</strong>。<ul>
<li><strong>根据网络类型</strong>，Hello数据包在<strong>不同的默认间隔</strong>发送。<ul>
<li>对于速度为T1（1.544 Mbps）或更高的链路，<strong>每10秒发送一次：广播多访问和点对点链路</strong>。</li>
<li>对于低于T1的链路，<strong>每30秒发送一次：非广播多访问链路</strong>。</li>
</ul>
</li>
<li>“失效间隔”是Hello间隔的四倍。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="14-Basic-OSPF-配置Configuration"><a href="#14-Basic-OSPF-配置Configuration" class="headerlink" title="14. Basic OSPF 配置Configuration"></a>14. Basic OSPF 配置Configuration</h2><ol>
<li>在<strong>路由器上启用OSPF</strong><ul>
<li><code>router ospf process-id</code></li>
<li>进程号 <strong>process-id</strong>：<ul>
<li>值范围为1到65535</li>
<li>用于标识路由器上的多个OSPF进程</li>
<li>通常在整个自治系统（AS）中保持相同的进程ID。</li>
</ul>
</li>
</ul>
</li>
<li><strong>标识路由器上的IP网络</strong><ul>
<li><code>network network-id wildcard-mask area area-id</code></li>
<li>network-id：网络地址，可以是整个网络、子网或接口地址。</li>
<li>wildcard-mask：通配符掩码。<ul>
<li>wildcardmask 和 subnet mask 相反</li>
<li>子网掩码是 255.255.255.0，则 Wild-card Address 就是 0.0.0.255</li>
</ul>
</li>
<li>area-id：区域ID，标识网络所属的OSPF区域<ul>
<li>只有一个 Area，则为 area0</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-24.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="15-配置回环地址-Loopback-Address"><a href="#15-配置回环地址-Loopback-Address" class="headerlink" title="15. 配置回环地址 Loopback Address"></a>15. 配置回环地址 Loopback Address</h2><ul>
<li>配置回环地址以增加OSPF路由器ID的稳定性<br>  <code>interface loopback number</code><br>  <code>ip address address subnet-mask</code><ul>
<li>number：回环接口编号。</li>
<li>address：回环接口的IP地址。</li>
<li>subnet-mask：子网掩码，建议使用&#x2F;32掩码以避免潜在的路由问题。</li>
</ul>
</li>
<li>回环接口必须在OSPF进程<strong>启动之前</strong>配置。</li>
<li>建议在基于OSPF的网络中的<strong>所有关键路由器上</strong>使用回环地址（私有或公共地址）。</li>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-25.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="16-更改OSPF路由器的优先级"><a href="#16-更改OSPF路由器的优先级" class="headerlink" title="16. 更改OSPF路由器的优先级"></a>16. 更改OSPF路由器的优先级</h2><ol>
<li><strong>操纵 DR&#x2F;BDR 选举</strong></li>
</ol>
<p><code>ip ospf priority number</code></p>
<ul>
<li>优先级越大越高</li>
<li>值范围：0 ~ 255，默认值为1</li>
<li>优先级为0表示接口不能被选为DR或BDR</li>
</ul>
<ol start="2">
<li><strong>监控OSPF接口优先级</strong></li>
</ol>
<p><code>show ip ospf [interface type number]</code></p>
<h2 id="17-OSPF-开销（Cost）-度量（Metric）"><a href="#17-OSPF-开销（Cost）-度量（Metric）" class="headerlink" title="17. OSPF 开销（Cost）&#x3D; 度量（Metric）"></a>17. OSPF 开销（Cost）&#x3D; 度量（Metric）</h2><ul>
<li><strong>开销应用于所有路由器链路路径</strong></li>
<li><strong>16位数字（1 – 65,535）</strong></li>
<li><strong>开销越低，路径越理想</strong></li>
<li><strong>路由决策基于路径的总开销</strong></li>
<li><strong>开销由带宽派生</strong><ul>
<li>公式：COST &#x3D; 100,000,000 &#x2F; 带宽</li>
<li>例如，T1链路的OSPF开销：100,000,000 &#x2F; 1,544,000 &#x3D; 64</li>
</ul>
</li>
</ul>
<h3 id="1-OSPF路径开销"><a href="#1-OSPF路径开销" class="headerlink" title="1. OSPF路径开销"></a>1. OSPF路径开销</h3><ul>
<li><strong>所有连接到同一链路的接口必须同意该链路的开销</strong>，否则链路将被视为断开。<ul>
<li>Cisco路由器的串行链路默认开销为1784（56Kbps带宽）。</li>
<li>开销范围：1 ~ 65535。</li>
</ul>
</li>
<li>配置OSPF开销</li>
</ul>
<p><code>ip ospf cost number</code></p>
<ul>
<li>如果线路速度较慢，必须指定实际链路速度</li>
</ul>
<p><code>bandwidth number</code></p>
<ul>
<li>在多供应商路由环境中，常见的需要更改开销的情况是确保一个供应商的开销值与另一个供应商的开销值匹配。</li>
<li>另一种情况是使用千兆以太网时。默认开销将最低开销值1分配给100 Mbps链路</li>
</ul>
<h3 id="2-配置OSPF计时器"><a href="#2-配置OSPF计时器" class="headerlink" title="2. 配置OSPF计时器"></a>2. 配置OSPF计时器</h3><ul>
<li><strong>所有OSPF区域内的路由器必须达成相同的Hello间隔和失效间隔</strong>，默认值：<ul>
<li>T1或更高带宽的链路（广播）：<strong>10秒</strong><ul>
<li>广播多访问和点对点链路</li>
</ul>
</li>
<li>低于T1的链路（非广播）：<strong>30秒</strong><ul>
<li>非广播多访问</li>
</ul>
</li>
<li><strong>失效间隔 &#x3D; 4 * Hello间隔</strong></li>
</ul>
</li>
<li>更改间隔的命令：</li>
</ul>
<p><code>ip ospf hello-interval seconds</code><br><code>ip ospf dead-interval seconds</code></p>
<ul>
<li>注意：失效间隔会自动调整为新的Hello间隔的四倍</li>
<li><img src="/2025/02/24/%E5%85%AB.RIP&OSPF/image-26.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>六、OSI第567层：会话、表示、应用层</title>
    <url>/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/</url>
    <content><![CDATA[<h1 id="06-会话、表示、应用层"><a href="#06-会话、表示、应用层" class="headerlink" title="06 会话、表示、应用层"></a>06 会话、表示、应用层</h1><ul>
<li>The Session Layer</li>
<li>The Presentation Layer</li>
<li>The Application Layer</li>
</ul>
<h1 id="一、第5层：会话层"><a href="#一、第5层：会话层" class="headerlink" title="一、第5层：会话层"></a>一、第5层：会话层</h1><ul>
<li>负责管理不同计算机之间的会话和数据交换。会话层主要关注如何建立、管理、终止会话以及如何确保数据传输的完整性和有效性。</li>
</ul>
<h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h2><p><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>会话层的核心作用是负责会话的<strong>建立、管理和终止</strong>，确保<strong>数据传输在不同设备间顺畅进行</strong>。主要包括：</li>
</ul>
<ol>
<li>基于令牌（Token）进行交互发言，通过数据同步保证数据完整性(应用逻辑)</li>
<li>进行数据分段、拼接，保证传输的有效。</li>
<li>同步技术，保证故障恢复</li>
</ol>
<h2 id="2-服务"><a href="#2-服务" class="headerlink" title="2. 服务"></a>2. 服务</h2><p><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-1.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><strong>双向同步通讯 TWA</strong>(Two-Way Alternate)<ul>
<li>全双工通信</li>
<li>半双工通信</li>
<li>单工通信</li>
</ul>
</li>
<li><strong>双向交替控制 TWS</strong>(Two-Way Simultaneous)<ul>
<li>会话连接、活动开始、数据校验（同步）</li>
<li>令牌转换等</li>
</ul>
</li>
<li>是否同步 synchronized 了您的会话的主题？<br><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-2.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<h2 id="3-同步点-CheckPoint"><a href="#3-同步点-CheckPoint" class="headerlink" title="3. 同步点 CheckPoint"></a>3. 同步点 CheckPoint</h2><ol>
<li>**同步点（CheckPoint）**用于分隔会话session的各个部分，以前称为对话（dialogues）<ul>
<li>同步点：发送一定数据后设置同步点</li>
<li>次同步点：作为同步点的一个子集，进行数据校验</li>
<li>主同步点：按照主同步点进行校验确认</li>
<li>如果错误，恢复到上次都已经同步的主同步点</li>
</ul>
</li>
<li>对话分隔（Seperation）：会话层通过同步点分隔不同的对话（会话段），确保各个会话部分的有序启动、进行与终止。尽量保证了数据交换的效率和可靠性。</li>
</ol>
<h2 id="4-Some-Applications-of-Layer-5"><a href="#4-Some-Applications-of-Layer-5" class="headerlink" title="4. Some Applications of Layer 5"></a>4. Some Applications of Layer 5</h2><p><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-3.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>NFS</li>
<li>SQL</li>
<li>RPC</li>
<li>X Window System</li>
<li>ASP</li>
<li>SCP</li>
</ol>
<hr>
<h1 id="二、第6层：表示层"><a href="#二、第6层：表示层" class="headerlink" title="二、第6层：表示层"></a>二、第6层：表示层</h1><ul>
<li>The Presentation Layer</li>
</ul>
<ol>
<li>表示层负责以<strong>接收设备可以理解的形式</strong>表示数据。<ul>
<li>传送语法协商</li>
<li>接受语法协商</li>
</ul>
</li>
<li>表示层具有 3 个<strong>主要功能</strong>：<ul>
<li><strong>数据格式化</strong>（formatting）</li>
<li><strong>数据压缩</strong>（compression）：早期网络比较慢，倾向于先压缩在发送</li>
<li><strong>数据加密</strong>（encryption）</li>
</ul>
</li>
</ol>
<h2 id="1-Data-Formatting-数据格式化"><a href="#1-Data-Formatting-数据格式化" class="headerlink" title="1. Data Formatting 数据格式化"></a>1. Data Formatting 数据格式化</h2><ol>
<li>想象两个不同（dissimilar）的系统。<ul>
<li>一种使用扩展二进制编码的十进制交换码（EBCDIC,Extended Binary Coded Decimal Interchange Code）格式化文本</li>
<li>另一种使用美国信息交换标准码（ASCII）格式化文本</li>
</ul>
</li>
<li>第六层提供了<strong>这两种</strong>不同类型的代码之间的<strong>转换</strong></li>
</ol>
<h3 id="1-1-Graphic-File-Formats-图形文件格式"><a href="#1-1-Graphic-File-Formats-图形文件格式" class="headerlink" title="1.1 Graphic File Formats 图形文件格式"></a>1.1 Graphic File Formats 图形文件格式</h3><ul>
<li>互联网通常使用两种<strong>二进制</strong>文件格式来显示图像：<ul>
<li>图形交换格式（GIF）</li>
<li>联合图像专家组（JPEG）</li>
</ul>
</li>
<li>任何具有GIF和JPEG文件格式阅读器的计算机都可以读取这些文件类型，无论计算机类型如何。</li>
</ul>
<h3 id="1-2-Multimedia-File-Format-多媒体文件格式"><a href="#1-2-Multimedia-File-Format-多媒体文件格式" class="headerlink" title="1.2 Multimedia File Format 多媒体文件格式"></a>1.2 Multimedia File Format 多媒体文件格式</h3><ul>
<li>多媒体文件格式是另一种类型的<strong>二进制</strong>文件，用于存储声音、音乐和视频。<ul>
<li>这些文件可以完全下载后播放，或者在下载的同时播放。</li>
<li>后一种方法称为流式音频。</li>
</ul>
</li>
</ul>
<h2 id="2-Encryption-Compression-数据加密-压缩"><a href="#2-Encryption-Compression-数据加密-压缩" class="headerlink" title="2. Encryption &amp; Compression 数据加密&amp;压缩"></a>2. Encryption &amp; Compression 数据加密&amp;压缩</h2><ul>
<li>第六层负责<strong>数据加密</strong>：<ul>
<li>数据加密可<strong>在信息传输过程中保护信息</strong>。</li>
</ul>
</li>
<li>表示层还负责文件的压缩。</li>
</ul>
<hr>
<h1 id="三、第7层：应用层"><a href="#三、第7层：应用层" class="headerlink" title="三、第7层：应用层"></a>三、第7层：应用层</h1><ul>
<li>The Application Layer<br><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-4.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>上图中各层的一些协议和使用：会话层对端口进行管理</li>
<li>第七层对应了应用界面，第六层对应了各种协议</li>
</ul>
<h2 id="1-职责"><a href="#1-职责" class="headerlink" title="1. 职责"></a>1. 职责</h2><ol>
<li>应用层（最接近用户）支持应用程序的<strong>通信组件</strong>。</li>
</ol>
<ul>
<li><strong>应用层</strong>：<ul>
<li>识别并建立预期通信伙伴的可用性</li>
<li>同步协作应用程序Synchronizes cooperating applications</li>
<li>就错误恢复程序达成一致</li>
<li>控制数据完整性 data integrity</li>
</ul>
</li>
</ul>
<h2 id="2-HTTP-超文本传输协议"><a href="#2-HTTP-超文本传输协议" class="headerlink" title="2. HTTP 超文本传输协议"></a>2. HTTP 超文本传输协议</h2><ul>
<li><strong>HyperText Transfer Protocol</strong><br><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-5.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="2-1-统一资源定位符URL-Uniform-Resource-Locator"><a href="#2-1-统一资源定位符URL-Uniform-Resource-Locator" class="headerlink" title="2.1 统一资源定位符URL (Uniform Resource Locator)"></a>2.1 统一资源定位符URL (Uniform Resource Locator)</h3><ul>
<li>统一资源定位符URL 是对可以从因特网上得到的资源的<strong>位置</strong>和<strong>访问方法</strong>的一种简洁的表示</li>
<li>URL 给<strong>资源的位置</strong>提供一种抽象的识别方法，并用这种方法给资源<strong>定位</strong></li>
<li>只要能够对资源定位，系统就可以对资源进行各种<strong>操作</strong>，如存取、更新、替换和查找其属性</li>
<li>URL 相当于<strong>一个文件名在网络范围的扩展</strong>。因此URL 是<strong>与因特网相连的机器上的任何可访问对象的一个指针</strong></li>
<li><code>&lt;URL的访问方式&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</code><ol>
<li>访问方式：协议 HTTPS 或者 HTTP</li>
<li>主机：域名的方式</li>
<li>端口对应进程</li>
<li>路径对应具体的文件</li>
</ol>
</li>
</ul>
<h3 id="2-2-HTTP"><a href="#2-2-HTTP" class="headerlink" title="2.2 HTTP"></a>2.2 HTTP</h3><ul>
<li>HTTP 是<strong>面向事务</strong>的客户服务器协议</li>
<li>HTTP 1.0 协议是<strong>无状态</strong>的(stateless)</li>
<li>HTTP 协议本身也是<strong>无连接</strong>的，虽然它使用了面向连接的TCP 向上提供的服务</li>
<li>万维网浏览器就是一个HTTP 客户，而在万维网服务器等待HTTP 请求的进程常称为HTTP daemon，有的文献将它缩写为HTTPD</li>
<li>HTTP daemon 在收到 HTTP 客户的请求后，把所需的文件返回给HTTP 客户</li>
</ul>
<h3 id="2-3-HTTP的报文结构-请求报文"><a href="#2-3-HTTP的报文结构-请求报文" class="headerlink" title="2.3 HTTP的报文结构(请求报文)"></a>2.3 HTTP的报文结构(请求报文)</h3><p><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-6.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>报文由三个部分组成，即<strong>开始行</strong>、<strong>首部行</strong>和<strong>实体主体</strong>。</li>
<li>在请求报文中，<strong>开始行就是请求行</strong>。</li>
</ol>
<h3 id="2-4-HTTP-请求报文的一些方法"><a href="#2-4-HTTP-请求报文的一些方法" class="headerlink" title="2.4 HTTP 请求报文的一些方法"></a>2.4 HTTP 请求报文的一些方法</h3><p><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-7.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="2-5-HTML-HyperText-Markup-Language-超文本标记语言"><a href="#2-5-HTML-HyperText-Markup-Language-超文本标记语言" class="headerlink" title="2.5 HTML(HyperText Markup Language) 超文本标记语言"></a>2.5 HTML(HyperText Markup Language) 超文本标记语言</h3><ul>
<li>定义了许多用于排版的命令（标签）</li>
<li>HTML 文档是一种可以用任何文本编辑器创建的ASCII 码文件</li>
<li>仅当HTML 文档是以.html 或.htm 为后缀时，浏览器才对此文档的各种标签进行解释</li>
<li>当浏览器从服务器读取HTML 文档，针对HTML 文档中的各种标签，根据浏览器所使用的显示器的尺寸和分辨率大小，重新进行排版并恢复出所读取的页面</li>
<li>HTML 用一对标签（一个开始标签和一个结束标签）或几对标签来标识一个元素</li>
</ul>
<h2 id="3-FTP-and-TFTP-文件传输协议"><a href="#3-FTP-and-TFTP-文件传输协议" class="headerlink" title="3. FTP and TFTP 文件传输协议"></a>3. FTP and TFTP 文件传输协议</h2><ul>
<li>File Transfer Protocol</li>
<li><strong>Trivial</strong> File Transfer Protocol 简单文件传输协议</li>
</ul>
<ol>
<li><strong>FTP</strong>： 是一种<em>可</em>靠的、面向连接<strong>的服务，使用</strong>TCP**传输文件。<ul>
<li>FTP首先在<strong>客户端和服务器</strong>之间建立<strong>控制连接</strong>（端口21）。</li>
<li>然后建立第二个连接，通过该连接在<strong>计算机之间传输数据</strong>（端口20）。</li>
</ul>
</li>
</ol>
<ul>
<li>Trivial File Transfer Protocol</li>
</ul>
<ol start="2">
<li><strong>TFTP</strong>：是一种<strong>无连接</strong>的服务，使用<strong>UDP</strong>。<ul>
<li>小巧且易于实现。</li>
<li>例如，TFTP用于路由器传输配置文件和Cisco IOS镜像。</li>
</ul>
</li>
</ol>
<h3 id="3-1-FTP主进程工作步骤"><a href="#3-1-FTP主进程工作步骤" class="headerlink" title="3.1 FTP主进程工作步骤"></a>3.1 FTP主进程工作步骤</h3><ol>
<li><strong>打开熟知端口</strong>（端口号为21），使客户进程能够连接上</li>
<li><strong>等待客户进程发出连接请求</strong></li>
<li>启动<strong>从属进程</strong>来处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程</li>
<li>回到<strong>等待</strong>状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是<strong>并发地进行</strong></li>
</ol>
<h3 id="3-2-FTP的屏幕信息举例"><a href="#3-2-FTP的屏幕信息举例" class="headerlink" title="3.2 FTP的屏幕信息举例"></a>3.2 FTP的屏幕信息举例</h3><ul>
<li>[01] ftp nic.ddn.mil<ul>
<li>用户要用 FTP 和远地主机（网络信息中心 NIC 上的主机）建立连接。域名：nic.ddn.mil</li>
</ul>
</li>
<li>[02] connected to nic.ddn.mil<ul>
<li>本地 FTP 发送的连接成功信息</li>
</ul>
</li>
<li>[03] 220 nic FTP server（Sunos 4.1）ready.<ul>
<li>从远地服务器返回的信息，220 表示“服务就绪”</li>
</ul>
</li>
<li>[04] Name： anonymous<ul>
<li>本地 FTP 提示用户键入名字。用户键入的名字表示“匿名”。用户只需键入 anonymous 即可（匿名）</li>
</ul>
</li>
<li>[05] 331 Guest login ok, send ident as password.<ul>
<li>数字 331 表示“用户名正确”，需要口令</li>
</ul>
</li>
<li>[06] Password： <a href="mailto:&#x61;&#x62;&#99;&#x40;&#x78;&#121;&#122;&#46;&#x6d;&#97;&#116;&#x68;&#46;&#121;&#97;&#x6c;&#101;&#46;&#x65;&#100;&#117;">abc@xyz.math.yale.edu</a><ul>
<li>本地 FTP 提示用户键入口令。用户这时可键入 guest 作为匿名的口令，也可以键入自己的电子邮件地址，即耶鲁大学数学系名为 xyz 的主机上的 abd（匿名密码是随意输入的）</li>
</ul>
</li>
<li>[07] 230 Guest login ok, access restrictions apply.<ul>
<li>数字 230 表示用户已经注册完毕</li>
</ul>
</li>
<li>[08] ftp&gt; cd rfc<ul>
<li>“ftp&gt;”是 FTP 的提示信息。用户键入的是将目录改变为包含 RFC 文件的目录</li>
</ul>
</li>
<li>[09] 250 CWD command successful.<ul>
<li>字符”CWD”是 FTP 的标准命令，表示 Change Working Directory</li>
</ul>
</li>
<li>[10] ftp&gt; get rfc1261.txt nicinfo<ul>
<li>用户要求将名为 rfc1261.txt 的文件复制到本地主机上，并改名为 nicinfo（get 获取到本地）</li>
</ul>
</li>
<li>[11] 200 PORT command successful.<ul>
<li>字符 PORT 是 FTP 的标准命令，表示要建立数据连接。200 表示“命令正确”</li>
</ul>
</li>
<li>[12] 150 ASCII data connection for rfc1261.txt（128.36.12.27,1401）（4318 bytes）.<ul>
<li>数字 150 表示”文件状态正确，即将建立数据连接”</li>
</ul>
</li>
<li>[13] 226 ASCII Transfer complete. local： nicinfo remote： rfc1261.txt 4488 bytes received in 15 seconds（0.3 Kbytes&#x2F;s）.<ul>
<li>数字 226 是“释放数据连接”，现在一个新的本地文件已经生成。</li>
</ul>
</li>
<li>[14] ftp&gt; quit<ul>
<li>用户键入退出命令。</li>
</ul>
</li>
<li>[15] 221 Goodbye.<ul>
<li>表示 FTP 工作结束</li>
</ul>
</li>
</ul>
<h2 id="4-Telnet-远程终端协议"><a href="#4-Telnet-远程终端协议" class="headerlink" title="4. Telnet 远程终端协议"></a>4. Telnet 远程终端协议</h2><ul>
<li>用于通过网络远程访问和控制另一台计算机</li>
<li>Telnet客户端软件提供“<strong>登录</strong>到<strong>运行Telnet服务器应用程序</strong>的<strong>远程互联网主机</strong>”的能力，然后从命令行执行命令。</li>
</ul>
<h2 id="5-SMTP-and-POP-收发邮件协议"><a href="#5-SMTP-and-POP-收发邮件协议" class="headerlink" title="5. SMTP and POP 收发邮件协议"></a>5. SMTP and POP 收发邮件协议</h2><ul>
<li>电子邮件服务器相互通信，使用<strong>SMTP</strong>协议<strong>发送</strong>邮件，使用<strong>POP3</strong>协议<strong>接收</strong>邮件。</li>
<li><strong>SMTP（Simple Mail Transfer Protocol）</strong>：邮件发送</li>
<li><strong>POP3（Post Office Protocol version 3）</strong>：邮件接收<br><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-8.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>发送者先登录到服务器，通过服务器根据SMTP传输到对应的服务器，然后用户登录后通过POP3协议收邮件到本地</li>
</ul>
<h3 id="5-1-MIME-和-SMTP-的关系"><a href="#5-1-MIME-和-SMTP-的关系" class="headerlink" title="5.1 MIME 和 SMTP 的关系"></a>5.1 MIME 和 SMTP 的关系</h3><ul>
<li>MIME（Multipurpose Internet Mail Extensions）<ul>
<li>是一种扩展了电子邮件格式的标准，它允许邮件发送<strong>非ASCII字符</strong>（如图像、音频、视频等二进制文件），并使邮件能够包含多种类型的内容。</li>
</ul>
</li>
<li>MIME 是通过<strong>对非 ASCII 内容进行编码</strong>，使其能够通过原本**仅支持 ASCII 的协议（如 SMTP）**进行传输。<br><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-10.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="5-2-MIME-增加-5-个新的邮件首部"><a href="#5-2-MIME-增加-5-个新的邮件首部" class="headerlink" title="5.2 MIME 增加 5 个新的邮件首部"></a>5.2 MIME 增加 5 个新的邮件首部</h3><ol>
<li>MIME-Version: 标志 MIME 的版本。现在的版本号是1.0。若无此行，则为英文文本<ul>
<li><code>MIME-Version: 1.0</code></li>
</ul>
</li>
<li>Content-Description: 这是可读字符串，说明此邮件主体是否是图像、音频或视频<ul>
<li><code>Content-Description: This is a picture of a cat</code></li>
</ul>
</li>
<li>Content-Id: 邮件的惟一标识符<ul>
<li><code>Content-Id: &lt;image1234@domain.com&gt;</code></li>
</ul>
</li>
<li>Content-Transfer-Encoding: 在传送时邮件的主体是如何编码的<ul>
<li><code>Content-Transfer-Encoding: base64</code></li>
</ul>
</li>
<li>Content-Type:说明邮件主体的数据类型和子类型<ul>
<li><code>Content-Type: text/plain; charset=&quot;UTF-8&quot;</code> 或 <code>Content-Type: image/jpeg</code></li>
</ul>
</li>
</ol>
<h2 id="6-SNMP-简单网络管理协议"><a href="#6-SNMP-简单网络管理协议" class="headerlink" title="6. SNMP 简单网络管理协议"></a>6. SNMP 简单网络管理协议</h2><ul>
<li><strong>Simple Network Management Protocol</strong><br><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-11.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>简单网络管理协议（SNMP）是一种<strong>应用层协议</strong>，促进网络设备之间管理信息的交换。</li>
<li><strong>NMS（Network Management System）：网管</strong>,通过下发请求对上网的所有的主机关于流量等等信息进行管理（监控）</li>
</ul>
<h2 id="7-DNS-域名系统-Domain-Name-System"><a href="#7-DNS-域名系统-Domain-Name-System" class="headerlink" title="7. DNS 域名系统 Domain Name System"></a>7. DNS 域名系统 Domain Name System</h2><ul>
<li>域名系统（DNS）是一种<strong>网络服务</strong>，<strong>管理域名</strong>并响应<strong>客户端请求——将域名转换为相应的IP地址</strong></li>
</ul>
<h3 id="7-1-Dnmain-Name-域名"><a href="#7-1-Dnmain-Name-域名" class="headerlink" title="7.1 Dnmain Name 域名"></a>7.1 Dnmain Name 域名</h3><p><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-12.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><p>使用圆点 <code>.</code> 将字符串进行分隔开，字符串不应该太长</p>
</li>
<li><p>越靠后域名级别越高</p>
</li>
<li><p>www 就是对应到主机群</p>
</li>
<li><p><strong>根域（Root Domain）</strong>：</p>
<ul>
<li>位于域名层次结构的顶端，表示为空字符串。</li>
<li>由一组根服务器管理，负责顶级域名的解析。</li>
</ul>
</li>
<li><p><strong>顶级域（Top-Level Domain, TLD）</strong>：</p>
<ul>
<li>位于根域之下，分为通用顶级域（gTLD）和国家顶级域（ccTLD）。</li>
<li>例如：.com、.org、.net（通用顶级域），.cn、.us、.uk（国家顶级域）。</li>
<li><strong>唯一的基础设施域</strong>：arpa，用于反向解析域名</li>
</ul>
</li>
<li><p><strong>二级域（Second-Level Domain, SLD）</strong>：</p>
<ul>
<li>位于顶级域之下，通常由组织或个人注册。</li>
<li>例如：example.com中的example。</li>
</ul>
</li>
<li><p><strong>子域（Subdomain）</strong>：</p>
<ul>
<li>位于二级域之下，可以由域名所有者自由创建。</li>
<li>例如：mail.example.com中的mail。</li>
</ul>
</li>
<li><p><strong>主机名（Hostname）</strong>：</p>
<ul>
<li>最具体的层次，指向具体的设备或服务。</li>
<li>例如：<a href="http://www.example.com中的www./">www.example.com中的www。</a></li>
</ul>
</li>
</ol>
<h3 id="7-2-TLD-顶级域-Top-Level-Domain"><a href="#7-2-TLD-顶级域-Top-Level-Domain" class="headerlink" title="7.2 TLD 顶级域 Top Level Domain"></a>7.2 TLD 顶级域 Top Level Domain</h3><ol>
<li>国家 TLD（nTLD）<ul>
<li>.cn（CHINA） 中国</li>
<li>.us（United States） 美国</li>
<li>.uk（United kingdom）, etc. 英国等等</li>
</ul>
</li>
<li>通用 TLD（gTLD），最早的域包括：<ul>
<li>.com Enterprises and companies 企业和公司</li>
<li>.net Network services providers 网络服务提供者</li>
<li>.org Nonprofit organizations 非盈利组织</li>
<li>.edu Educational facilities 教育机构</li>
</ul>
</li>
<li>基础设施领域（Infrastructure domain）<ul>
<li>Only one： <strong>arpa</strong>, for resolving domain names reversely 仅一个：arpa，用于<strong>反向解析域名</strong></li>
</ul>
</li>
<li>Recently, new TLD domain added：<ul>
<li>.aero（航空运输企业）</li>
<li>.biz（公司和企业）</li>
<li>.coop（合作团体）</li>
<li>.info（各种资讯）</li>
<li>.jobs（人力资源管理者）</li>
<li>.mobi（移动产品与服务的用户和提供者）</li>
<li>.museum（博物馆）</li>
<li>.name（个人）</li>
<li>.pro（经过认证的专业人员）</li>
<li>.travel（旅游业）</li>
</ul>
</li>
</ol>
<h3 id="7-3-域名服务器Domain-Name-Server-DNS"><a href="#7-3-域名服务器Domain-Name-Server-DNS" class="headerlink" title="7.3 域名服务器Domain Name Server (DNS)"></a>7.3 域名服务器Domain Name Server (DNS)</h3><p><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-13.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>顶级域名底下的域名就是由顶级域名下面进行管理</li>
<li>根域名服务器存储位置，所以子服务器知道根服务器的地址即可</li>
</ul>
<h3 id="7-4-结合域名服务器查找-IP-地址"><a href="#7-4-结合域名服务器查找-IP-地址" class="headerlink" title="7.4 结合域名服务器查找 IP 地址"></a>7.4 结合域名服务器查找 IP 地址</h3><ul>
<li>DNS 系统以层次（hierarchy）结构设置，该层次结构创建<strong>不同级别的 DNS 服务器</strong>。</li>
<li>此级别的 DNS 服务器<strong>判断其自身</strong>是否能够将<strong>域名</strong>转换为<strong>关联的 IP 地址</strong>：<ol>
<li>如果<strong>可以</strong>，则将<strong>结果返回给客户端</strong></li>
<li>如果<strong>没有</strong>，它将请求发送到更高级别。（<strong>向上级请求</strong>）<br><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-14.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
</li>
<li>请求分为两种：<ul>
<li>能够应答</li>
<li>不能够应答</li>
</ul>
</li>
<li>递归地进行查找：具体过程在上图</li>
<li>下面递归，上面迭代</li>
</ul>
<h2 id="8-应用层通信处理的两种方式"><a href="#8-应用层通信处理的两种方式" class="headerlink" title="8. 应用层通信处理的两种方式"></a>8. 应用层通信处理的两种方式</h2><ol>
<li><strong>第一种方式</strong>：（短连接）<ul>
<li>在这种模式下，客户端每次向服务器请求资源时，都会建立一次新的连接，并且在请求处理完成后，连接会立即断开。</li>
<li>当浏览器打开时，它连接到<strong>默认页面</strong>，并将<em>页面的文件传输到客户端</em>。</li>
<li>处理完成后，连接断开。</li>
</ul>
</li>
<li><strong>第二种方式</strong>：（长连接&#x2F;持久连接）<ul>
<li>长连接（也称持久连接）会在客户端和服务器之间建立一个持久的连接，在整个会话期间保持连接，直到客户端显式地断开连接。通常用于需要持续<strong>交互</strong>的应用。</li>
<li>如Telnet（远程登录）和FTP（文件传输），建立与服务器的连接，并保持该连接直到所有处理完成。</li>
<li>当用户确定已完成时，客户端终止连接。</li>
</ul>
</li>
</ol>
<ul>
<li>所有通信活动都属于这两种类别之一。<br><img src="/2025/02/24/%E5%85%AD%E3%80%81Layer567.Application/image-15.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>四、OSI第三层：数据链路层</title>
    <url>/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/</url>
    <content><![CDATA[<h1 id="第三层：网络层"><a href="#第三层：网络层" class="headerlink" title="第三层：网络层"></a>第三层：网络层</h1><ul>
<li>Overview of the Network Layer</li>
<li>IP Addresses and Subnets</li>
<li>Layer 3 Devices </li>
<li>ARP Protocol</li>
<li>Network Layer Services</li>
<li>Routed and Routing Protocols</li>
<li>VLSM</li>
<li>ICMP</li>
<li>为什么我们不用硬件地址进行通信?<ol>
<li>(设备数量问题)因为设备比较多，供应商也比较多</li>
<li>(规格问题)不同供应商的解决方案不同，所以使用硬件地址进行通信的通用性比较低。</li>
<li>(寻址问题)全球设备太多，如果使用硬件设备，那么进行定位比较复杂</li>
</ol>
<ul>
<li>因为如上情况我们选择使用IP地址(逻辑地址)。</li>
</ul>
</li>
</ul>
<h1 id="一、网络层概述"><a href="#一、网络层概述" class="headerlink" title="一、网络层概述"></a>一、网络层概述</h1><h2 id="1-第三层职责"><a href="#1-第三层职责" class="headerlink" title="1. 第三层职责"></a>1. 第三层职责</h2><ol>
<li><strong>通过网络移动数据</strong></li>
<li>使用<strong>分层寻址 hierarchical addressing</strong>方案(与MAC寻址相反，后者平坦)<ul>
<li>分层寻址（Hierarchical Addressing）是一种网络地址分配和管理方法，它将地址空间划分为多个层次，每个层次都有不同的作用和范围（网络+子网+主机）。</li>
</ul>
</li>
<li><strong>分段网络</strong>（segment network）和<strong>控制流量</strong>（control flow of traffic）<ul>
<li>根据网络的大小和流量需求，将大型网络分割成多个较小的子网络（子网）。这些子网通常使用子网掩码来划分。</li>
</ul>
</li>
<li><strong>减少交通拥堵</strong>（Reduce congestion）</li>
<li><strong>与其它网络通信</strong></li>
</ol>
<h2 id="2-Devices"><a href="#2-Devices" class="headerlink" title="2. Devices"></a>2. Devices</h2><ul>
<li><strong>Routers</strong>（重点！）<ul>
<li><strong>互连</strong>网段或网络(不同网段的分割)</li>
<li>根据<strong>IP地址</strong>做出合理的<strong>决定</strong></li>
<li>确定<strong>最佳路径</strong>（根据<strong>路由表</strong>）</li>
<li>将<strong>数据包</strong>从入站端口切换到<strong>出站端口</strong></li>
</ul>
</li>
</ul>
<h1 id="二、IP地址和子网划分-IP-Addresses-and-Subnets"><a href="#二、IP地址和子网划分-IP-Addresses-and-Subnets" class="headerlink" title="二、IP地址和子网划分(IP Addresses and Subnets)"></a>二、IP地址和子网划分(IP Addresses and Subnets)</h1><h2 id="1-Layer-3-Packet-Datagram-第三层数据报格式"><a href="#1-Layer-3-Packet-Datagram-第三层数据报格式" class="headerlink" title="1. Layer 3 Packet&#x2F;Datagram 第三层数据报格式"></a>1. Layer 3 Packet&#x2F;Datagram 第三层数据报格式</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-7.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>IP地址在报文中占据一部分(一个IP地址32bit)</li>
</ul>
<h2 id="2-IPv4报文主要结构"><a href="#2-IPv4报文主要结构" class="headerlink" title="2. IPv4报文主要结构"></a>2. IPv4报文主要结构</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><strong>首部部分</strong>：上面蓝框部分的整体<ul>
<li><strong>固定部分+可变部分</strong></li>
</ul>
</li>
<li><strong>版本号</strong>:占 <strong>4 bit</strong>，指IP协议的版本。目前的 IP 协议版本号为 <strong>4</strong> (即 IPv4)(6也就对应IPv6)</li>
<li><strong>首部长度</strong>:占 <strong>4 bit</strong>，可表示的最大数值是15个单位(一个单位为 4 字节)， 因此IP的首部长度的最大值是<strong>60字节（15个单位）</strong>。<ul>
<li>首部长度不确定，所以需要进行标识</li>
<li>4bit-&gt;15个单位；</li>
<li>首部长度的32 bit为一行，也就是4个字节为一个单位</li>
</ul>
</li>
<li><strong>服务类型</strong>:占<strong>8 bit</strong>，用来获得更好的服务，这个字段以前一直没有被人们使用。</li>
<li><strong>总长度</strong>:占 <strong>16 bit</strong>，指<strong>首部和数据之和</strong>的长度，单位为字节，因此数据报的最大长度为 <strong>65535 字节</strong>(由于放到帧里面，所以大多数不比1500字节长)。总长度必须不超过最大传送单元 MTU。</li>
<li><strong>标识</strong>(identification):占 <strong>16 bit</strong>，它是一个计数器，用来产生数据报的标识。</li>
<li><strong>标志</strong>：占 <strong>3 bit</strong>，最高位为 0;<ul>
<li>MF（More fragement）：MF 为 0 表示最后一个分片；1 是指后面还有分片</li>
<li>DF（Don’t fragement）：是否允许做分片，0 允许做分片，1 不允许做分片</li>
</ul>
</li>
<li><strong>片偏移</strong> (<strong>13 bit</strong>) 指出：较长的分组在分片后某片<em>在原分组中的相对位置</em>。<ul>
<li>片偏移以<strong>8个字节</strong>为<strong>偏移单位</strong><ul>
<li>分片：由于网络中传输的数据报可能会超过某些网络的最大传输单元（MTU），因此需要将较大的数据报分成多个较小的片段进行传输。</li>
<li>片偏移字段帮助接收方正确地<em>重组</em>这些片段。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>报文分片举例<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-8.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-9.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<ol start="9">
<li><strong>生存时间</strong>：<strong>8 bit</strong>，记为 TTL (Time To Live)，表示<strong>数据报在网络中可通过的路由器数的最大值</strong>。<ul>
<li>是通过计数的方式来进行统计</li>
<li>最大值是255(最多经过255个路由器)</li>
<li>路由器每转发一次，就会对生存时间-1</li>
<li>减小为0后，就会丢弃掉，并且通知给发送方我已经丢弃掉这个报文。</li>
<li>防止在环上进行传输，避免由于回路问题，造成过大的网络资源浪费</li>
</ul>
</li>
<li><strong>协议</strong>：<strong>8 bit</strong>，协议字段指出此数据报<em>携带的数据使用何种协议</em> ，以便目的主机的IP层将数据部分上交给哪个处理过程<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-1.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li><strong>首部检验和</strong>:<strong>(16 bit)<strong>只检验数据报的</strong>首部</strong>，不包括数据部分。<ul>
<li>这里不采用 CRC 检验码而采用简单的计算方法。算法过程如下(比较形式化的问题，并不能解决数据报错误的形式)<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-2.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li><strong>源地址和目的地址</strong>都各占 4 字节（32 bit）</li>
</ol>
<h2 id="3-网络层地址-Network-Layer-Addresses"><a href="#3-网络层地址-Network-Layer-Addresses" class="headerlink" title="3. 网络层地址 Network Layer Addresses"></a>3. 网络层地址 Network Layer Addresses</h2><ol>
<li><strong>IP地址</strong>为<strong>32位长</strong>（32 bits long）</li>
<li>它们以<em>点分十进制格式</em>表示为<strong>四个(八位)字节</strong>：133.14.17.0<ul>
<li>点分十进制：用十进制表示每个字节的值，然后用点（.）分隔这些字节</li>
</ul>
</li>
<li>IP地址包含两个组成部分：<ul>
<li><strong>网络ID(The network ID)</strong><ul>
<li>由ARIN（American Registry for Internet Numbers，<a href="http://www.arin.net)分配/">www.arin.net）分配</a></li>
<li>标识设备所连接(attached)的网络</li>
<li>可以由前三个八位位组(octets)中的一个，两个或三个来标识</li>
</ul>
</li>
<li><strong>主机ID(The host ID)</strong><ul>
<li>由网络管理员分配</li>
<li>识别该网络上的特定设备</li>
<li>可以由最后三个八位位组中的一个，两个或三个来标识</li>
</ul>
</li>
<li><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-3.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ol>
<h2 id="4-IP地址"><a href="#4-IP地址" class="headerlink" title="4. IP地址"></a>4. IP地址</h2><ol>
<li>不同的类地址为地址的网络部分和主机部分保留不同数量的位<ul>
<li>N是Net ID,H 是 Host ID</li>
</ul>
<ol>
<li>A: NHHH</li>
<li>B: NNHH</li>
<li>C: NNNH<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-4.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
</li>
</ol>
<h3 id="4-1-分类"><a href="#4-1-分类" class="headerlink" title="4.1 分类"></a>4.1 分类</h3><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-10.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>IP 地址主要通过<strong>第一个字节</strong>进行划分</li>
</ul>
<ol>
<li><strong>0–127</strong> （0xxxxxxx）：Class A address</li>
<li><strong>128-191</strong> （10xxxxxx）：Class B address</li>
<li><strong>192–223</strong> （110xxxxx）：Class C address</li>
<li>224–239 （1110xxxx）：Class D – Multicast 多播地址</li>
<li>240–255 （1111xxxx）：Class E - Research 研究地址</li>
</ol>
<ul>
<li><strong>host 不能全取 0，也不能全取 1</strong>。<ul>
<li>全取 0 时用来标识网段地址</li>
<li>全取 1 时用来标识网段的广播地址</li>
</ul>
</li>
</ul>
<h3 id="4-2-主机-Hosts-的数量"><a href="#4-2-主机-Hosts-的数量" class="headerlink" title="4.2 主机(Hosts)的数量"></a>4.2 主机(Hosts)的数量</h3><ul>
<li>每个类别的最大主机数量各不相同。（不包含网络号）</li>
</ul>
<ol>
<li>A 类拥有 16,777,214 个可用主机（<strong>2^24 - 2</strong>）</li>
<li>B 类具有 65,534 个可用主机（<strong>2^16 - 2</strong>）</li>
<li>C 类具有 254 个可用主机（<strong>2^8 -2</strong>）</li>
</ol>
<ul>
<li>为什么每一类地址中都要减去 2？<ul>
<li>每个网络中的<strong>第一个地址</strong>都保留用于<strong>该网络地址</strong>（全取1）<ul>
<li><strong>最后是.0</strong></li>
</ul>
</li>
<li><strong>最后一个地址</strong>是为<strong>广播地址</strong>保留的（全取1）。<ul>
<li><strong>最后是.255</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-3-保留-Reserved-地址"><a href="#4-3-保留-Reserved-地址" class="headerlink" title="4.3 保留(Reserved)地址"></a>4.3 保留(Reserved)地址</h3><ol>
<li><strong>网络地址</strong>：在地址的<strong>主机部分</strong>中<strong>以二进制 0 结尾</strong>的 IP 地址<ul>
<li>A 类网络地址示例：113.0.0.0</li>
<li>网络上的主机只有具有相同网络 ID 的其他主机才能直接通信。（用来确定是不是在一个网段里面）</li>
</ul>
</li>
<li><strong>广播地址</strong>：用于将数据发送到网络上的所有设备。（一般是一个网段之间的）<ul>
<li>广播 IP 地址在地址的<strong>主机部分</strong>中<strong>以二进制 1 结尾</strong>。</li>
<li>B 类地址的广播地址的示例：176.10.255.255（decimal 255 &#x3D; binary 11111111）</li>
</ul>
</li>
</ol>
<ul>
<li>类别示例</li>
</ul>
<ol>
<li>Class A<ul>
<li>99.0.0.0： a reserved network number</li>
<li>99.255.255.255： a broadcast number</li>
</ul>
</li>
<li>Class B<ul>
<li>156.1.0.0： a reserved network number</li>
<li>156.1.255.255： a broadcast number</li>
</ul>
</li>
<li>Class C<ul>
<li>203.1.17.0： a reserved network number</li>
<li>203.1.17.255：a broadcast number</li>
</ul>
</li>
</ol>
<h4 id="私有地址空间-Private-Address-Space"><a href="#私有地址空间-Private-Address-Space" class="headerlink" title="私有地址空间 Private Address Space"></a>私有地址空间 Private Address Space</h4><ul>
<li>私有IP地址是指在<strong>内部网络中使用的IP地址</strong>，这些地址在互联网中是不可路由的。</li>
<li>私有IP地址用于<strong>局域网（LAN）中的设备之间的通信</strong>，<strong>避免了公共IP地址的浪费</strong>。</li>
<li>私有IP地址与公网IP地址的区别：<ul>
<li>公网IP地址是<strong>唯一的、全球可访问</strong>的IP地址，用于设备之间的互联互通。</li>
<li>私有IP地址是<strong>保留给内网使用的</strong>，不会在互联网中传递，因此它们在全球范围内<strong>不唯一</strong>。多个不同的私有网络可以使用相同的私有IP地址范围。</li>
</ul>
</li>
<li>私有IP地址范围由IANA（互联网号码分配机构）定义，常见的私有IP地址范围包括：</li>
</ul>
<ol>
<li><strong>10.0.0.0 - 10.255.255.255</strong></li>
<li><strong>172.16.0.0 - 172.31.255.255</strong></li>
<li><strong>192.168.0.0 - 192.168.255.255</strong></li>
</ol>
<ul>
<li>**IP地址耗尽（IP address depletion）**及其解决方案：<ul>
<li>NAT（网络地址转换）<ul>
<li>通过在路由器或防火墙上将私有网络的IP地址转换为公网IP地址，使得多个内网设备可以共享一个公网IP地址访问互联网。</li>
</ul>
</li>
<li>CIDR（无类别域间路由）<ul>
<li>一种更灵活的IP地址分配方法，它突破了传统的类A、类B、类C的限制，通过可变子网掩码（VLSM）来实现更精细的IP地址划分，从而提高IP地址的利用率，延缓了IPv4地址的枯竭。</li>
</ul>
</li>
<li>IPv6<ul>
<li>是IPv4的继任者，采用128位的地址格式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-Subnet-子网"><a href="#5-Subnet-子网" class="headerlink" title="5. Subnet(子网)"></a>5. Subnet(子网)</h2><ul>
<li>网络管理员有时需要<strong>将网络划分为较小的网络</strong>，称为<strong>子网 subnet</strong>，以提供额外的灵活性.</li>
<li>从主机字段借来的位被指定为<strong>子网字段（Subnet Fields）</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">借的是Host字段从左往右开始数的位数！！</span><br><span class="line">Netwoek|Subnet|Host</span><br></pre></td></tr></table></figure>
<p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-11.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="5-1-Basics-of-Subnetting"><a href="#5-1-Basics-of-Subnetting" class="headerlink" title="5.1.Basics of Subnetting"></a>5.1.Basics of Subnetting</h3><ul>
<li>子网是网络的更小划分，提供<strong>地址灵活性</strong>。</li>
<li>子网地址是<strong>本地分配</strong>的，通常由网络管理员分配。</li>
<li>子网<strong>减少了广播域</strong>。</li>
</ul>
<h3 id="5-2-How-many-bits-can-I-borrow-可以借多少位给子网"><a href="#5-2-How-many-bits-can-I-borrow-可以借多少位给子网" class="headerlink" title="5.2.How many bits can I borrow(可以借多少位给子网)"></a>5.2.How many bits can I borrow(可以借多少位给子网)</h3><ul>
<li>可以借用的<strong>最小位数</strong>是<strong>2</strong>。<ul>
<li>如果只借用 1 位以创建一个子网，那么将只有一个<strong>网络号</strong>&lt;.0 网络&gt;和<strong>广播号</strong>&lt;.1 网络&gt;，没有可以使用的专用网络。</li>
<li>两位的时候，01 和 10 给 Host，00 表示网络 ID，11 表示广播地址</li>
<li>全 0 可能导致误判</li>
</ul>
</li>
<li>最大位数:<strong>保留至少2位主机号</strong>的<strong>任何</strong>数字<ul>
<li>原因也同上<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-5.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
<h3 id="5-3-子网划分的副产品：地址浪费Waste-Addresses"><a href="#5-3-子网划分的副产品：地址浪费Waste-Addresses" class="headerlink" title="5.3.子网划分的副产品：地址浪费Waste Addresses"></a>5.3.子网划分的副产品：地址浪费Waste Addresses</h3><ul>
<li>我们必须在<strong>所需的子网数</strong>，<strong>每个子网可接受的主机</strong>以及<strong>地址的浪费</strong>之间取得平衡（strike a balance）。</li>
<li>hostID 里面的全 0 和全 1 不能使用</li>
<li>subnet 不可以使用全 0 和全 1</li>
<li>借用 4 位是最高效率的，提升了划分灵活性，影响了效率</li>
<li>C类例图<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-6.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<ol>
<li><strong>（C类）</strong> 借用n位，则有了<strong>2^n-2个子网</strong>，每个子网可以有<strong>2^(8-n)-2台主机</strong>(host)<ul>
<li><strong>主机总数量&#x3D;子网数×每个子网的主机数</strong></li>
<li><strong>使用率&#x3D;主机总数量&#x2F;255</strong></li>
</ul>
</li>
</ol>
<h3 id="5-4-Subnet-Mask子网掩码"><a href="#5-4-Subnet-Mask子网掩码" class="headerlink" title="5.4 Subnet Mask子网掩码"></a>5.4 Subnet Mask子网掩码</h3><ul>
<li>把<strong>网络位全赋值为 1</strong>，<strong>host 位全部赋值为 0</strong>，这样我们就明白哪些位上面是 net，哪些位上面是 host</li>
</ul>
<ol>
<li>别名：扩展网络前缀</li>
<li>定义我们用来<strong>构建网络</strong>的位数，以及<strong>描述主机地址</strong>的位数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- Class A 255.0.0.0</span><br><span class="line">- Class B 255.255.0.0</span><br><span class="line">- Class C 255.255.255.0</span><br></pre></td></tr></table></figure>
<h2 id="6-计算子网"><a href="#6-计算子网" class="headerlink" title="6. 计算子网"></a>6. 计算子网</h2><p>例子: </p>
<ul>
<li>我们将对IP地址进行子网划分：<ul>
<li>223.14.17.0</li>
</ul>
</li>
<li>需要：13个子网，每个子网10台主机</li>
</ul>
<h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><ol>
<li>确定默认的子网掩码<ul>
<li>C类：192~223，所以此IP地址在C类</li>
</ul>
</li>
<li>C 类网络的默认子网掩码是：255.255.255.0</li>
</ol>
<h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><ol>
<li>通过从主机 ID 借用位来计算子网和主机的实际数量<ul>
<li>13 subnets</li>
<li>10 hosts on each subnet</li>
</ul>
<ol>
<li>2^4-2&#x3D;14，由此：子网借4位</li>
<li>每个子网10个主机, 也是至少需要4位(2^4 - 2 &#x3D;14), 主机位数为4位</li>
</ol>
</li>
<li>我们对每一个子网需要<strong>借用 4 位</strong>来满足一个子网有 <strong>10 台可用的主机</strong>。</li>
</ol>
<h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h3><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-12.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>产生16个子网和每个子网16台主机<ul>
<li>对于借用的 4 位，每个位可以是 1 或 0，从而有 16 种可能的组合。</li>
<li>4 个剩余主机位也是如此。</li>
</ul>
</li>
<li>【重要】<strong>每个子网上只有14个可用子网和14台主机</strong><ol>
<li>因为不能使用<strong>第一个和最后一个子网</strong>。（即全 0 和全 1）</li>
<li>因为不能使用<strong>每个子网中的第一个和最后一个地址</strong>。</li>
</ol>
<ul>
<li>对于每个，一个是广播地址，一个是网络地址。</li>
</ul>
</li>
</ol>
<h3 id="Step-4"><a href="#Step-4" class="headerlink" title="Step 4"></a>Step 4</h3><ol>
<li>确定子网掩码。<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-13.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>其中<strong>X表示用于子网划分的借用位</strong>。</li>
</ol>
<ul>
<li>将<strong>X的位值相加</strong>，得到子网掩码的最后一个八位字节的十进制值：128 + 64 + 32 + 16 &#x3D; 240<ul>
<li>也等于255-15</li>
</ul>
</li>
<li>子网掩码是：<strong>255.255.255.240</strong></li>
<li>子网掩码用于<strong>显示IP地址中的子网和主机地址字段</strong></li>
</ul>
<h3 id="Step-5"><a href="#Step-5" class="headerlink" title="Step 5"></a>Step 5</h3><ol>
<li>确定主机地址的范围<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-14.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-15.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>16个子网，14个可用子网</li>
<li>每个子网16个主机，14个可用主机</li>
</ol>
<h2 id="7-计算子网网络地址"><a href="#7-计算子网网络地址" class="headerlink" title="7. 计算子网网络地址"></a>7. 计算子网网络地址</h2><ol>
<li>第一步：将 <strong>IP 主机地址</strong>转换为<strong>二进制</strong>。</li>
<li>第二步：将<strong>子网掩码</strong>转换为<strong>二进制</strong>。</li>
<li>第三步：使用<strong>布尔运算符 AND</strong> 将两者进行运算。</li>
<li>第四步：将网络二进制地址<strong>转换为点分十进制</strong>。<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-16.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<ul>
<li>这是<em>子网的<strong>网络地址</strong></em></li>
<li>它可以帮助确定路径（即<strong>发送到哪一个具体的子网（网段）</strong>）：用来确定是否是一个网段，是否可以通过网关进行转发</li>
</ul>
<h3 id="7-1-路由器与IP地址"><a href="#7-1-路由器与IP地址" class="headerlink" title="7.1 路由器与IP地址"></a>7.1 路由器与IP地址</h3><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-17.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>为了找到子网的网络 ID，路由器必须采用 <strong>IP 地址</strong>和<strong>子网掩码</strong>，并且在逻辑上将它们取<strong>与</strong></li>
<li>131开头，说明是B类</li>
<li>上图中的子网掩码 255.255.255.0 是 255.255.0.0 借用了 8 位产生的（而不要理解成为 C 类地址的子网掩码）</li>
</ul>
<h3 id="实践：IP寻址问题"><a href="#实践：IP寻址问题" class="headerlink" title="实践：IP寻址问题"></a>实践：IP寻址问题</h3><ul>
<li>给定195.137.92.0并且需要8个可用子网，请找到子网号，主机号范围和子网广播号。</li>
<li>借用2位会产生2个可用子网，借用3位会产生6个可用子网，因此我们<strong>借用4位</strong>才能获得14个可用子网，其中我们需要8个可用地址。</li>
<li>这将使子网掩码为255.255.255.240。 因此，网络号为195.137.92.NNNN HHHH，其中Ns代表网络扩展位(子网)，Hs代表主机号。</li>
<li>接下来，我们必须为子网编号。 4位二进制数有16种组合，但它们在最后一个八位位组中保留其位置值。</li>
<li>借用<strong>4-6位都可以</strong>，因为<strong>并没有规定子网中主机数量</strong>。<ul>
<li><strong>为什么是6位</strong>是因为<strong>一个子网中最少用2位给主机</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="三、第三层设备"><a href="#三、第三层设备" class="headerlink" title="三、第三层设备"></a>三、第三层设备</h1><ul>
<li><strong>路由器</strong></li>
<li>路由器2个功能：<ol>
<li><strong>路径选择</strong></li>
<li><strong>路径转发</strong></li>
</ol>
</li>
</ul>
<h2 id="1-路径选择-Path-determination"><a href="#1-路径选择-Path-determination" class="headerlink" title="1. 路径选择 Path determination"></a>1. 路径选择 Path determination</h2><ul>
<li>路由器根据链路带宽、跳数、延迟等因素，选择数据包到达目的地路径中的下一跳。<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-18.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="2-IP-地址"><a href="#2-IP-地址" class="headerlink" title="2. IP 地址"></a>2. IP 地址</h2><ul>
<li>IP地址在软件中实现，指的是<strong>设备所在的网络</strong>。<ul>
<li>IP地址是网络中每个设备的<em>唯一标识符</em>。每个设备（例如电脑、手机、服务器等）在连接到网络时都会被分配一个IP地址。</li>
<li>IP地址通过软件协议来进行分配、识别和管理，而非硬件本身决定的。</li>
</ul>
</li>
<li>路由器连接网络，每个网络必须<strong>有一个唯一的网络号</strong>，以确保路由成功。<ul>
<li>路由器根据<em>IP地址</em>和<em>子网掩码</em>来判断数据包应该发送到哪个网络。</li>
</ul>
</li>
<li><strong>唯一的网络号</strong>被包含在分配给<strong>连接到该网络的每个设备的IP地址</strong>中。<ul>
<li>假设一个设备的IP地址是 192.168.1.5，并且子网掩码是 &#x2F;24，这表示：<ul>
<li>网络号是 192.168.1.0</li>
<li>主机号是 5</li>
</ul>
</li>
<li><strong>所有属于同一网络的设备的IP地址都会共享相同的网络号</strong></li>
</ul>
</li>
</ul>
<h2 id="3-路由器端口-Router-Interface"><a href="#3-路由器端口-Router-Interface" class="headerlink" title="3. 路由器端口 Router Interface"></a>3. 路由器端口 Router Interface</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-19.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>路由器端口记录了<strong>网段的 IP 地址</strong>（和连接的地方是相同的）</li>
<li>在计算<strong>需要分配的端口总数</strong>时，注意<strong>路由器端口也需要被计算上</strong></li>
</ol>
<h2 id="4-路由器发送的过程-Router-function"><a href="#4-路由器发送的过程-Router-function" class="headerlink" title="4. 路由器发送的过程 Router function"></a>4. 路由器发送的过程 Router function</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-20.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>A5 主机发送报文给 B5 主机，这个报文的 IP 地址是 B5 所在的 IP 地址，形成帧，然后放上总线。</li>
</ol>
<ul>
<li>路由器剥离由帧携带的<strong>数据链路层头部</strong>。<ul>
<li>（数据链路层头部包含<strong>源和目的地的MAC地址</strong>。）<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-21.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
<ol start="2">
<li>路由器收到帧，然后进行理解，看到报文，知道目的地是B5(解封装)</li>
</ol>
<ul>
<li><strong>检查网络层地址以确定目的网络</strong>。<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-22.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<ol start="3">
<li>检查自己的<strong>路由表</strong>，找到目的地对应的<strong>端口</strong></li>
</ol>
<ul>
<li>查询其<strong>路由表</strong>以确定将使用哪个<strong>接口</strong>发送数据，以便到达目的网络。<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-23.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<ol start="4">
<li>在B1端口进行转发，形成新的帧</li>
</ol>
<ul>
<li>通过接口B1发送数据，路由器会<em>将数据封装在适当的数据链路层帧</em>中。<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-24.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<ol start="5">
<li>形成一个全新的帧，<strong>这个帧的MAC地址是B1的MAC的地址</strong>。</li>
</ol>
<h2 id="5-路由器端口示例"><a href="#5-路由器端口示例" class="headerlink" title="5. 路由器端口示例"></a>5. 路由器端口示例</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-25.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>接口是路由器连接到网络的方式，在IP路由中也可以称为<strong>端口</strong>。</li>
<li><strong>每个接口</strong>必须有一个<strong>单独的、唯一的网络地址</strong>。<ul>
<li>比如上图中 S1 和 S2 不能是相同的 IP 地址</li>
<li>路由器的连接的网段一定要是不同的</li>
</ul>
</li>
</ol>
<h2 id="6-IP地址分配-IP-address-assignment"><a href="#6-IP地址分配-IP-address-assignment" class="headerlink" title="6. IP地址分配 IP address assignment"></a>6. IP地址分配 IP address assignment</h2><ol>
<li><strong>静态地址分配（Static addressing）</strong></li>
</ol>
<ul>
<li>为每个设备配置一个IP地址。</li>
<li>你应该保持非常详细的记录，因为使用重复的IP地址可能会导致问题。</li>
</ul>
<ol start="2">
<li><strong>动态地址分配（Dynamic addressing）</strong></li>
</ol>
<ul>
<li>有几种不同的方法可以用来动态分配IP地址：<ul>
<li>RARP: 反向地址解析协议（Reverse Address Resolution Protocol）</li>
<li>BOOTP: 引导协议（BOOTstrap Protocol）</li>
<li>DHCP: 动态主机配置协议（Dynamic Host Configuration Protocol）</li>
</ul>
</li>
</ul>
<hr>
<h1 id="四、ARP-Protocol"><a href="#四、ARP-Protocol" class="headerlink" title="四、ARP Protocol"></a>四、ARP Protocol</h1><h2 id="1-Address-Resolution-Protocol（ARP）地址解析协议"><a href="#1-Address-Resolution-Protocol（ARP）地址解析协议" class="headerlink" title="1. Address Resolution Protocol（ARP）地址解析协议"></a>1. Address Resolution Protocol（ARP）地址解析协议</h2><ol>
<li>为了使设备能够通信，<strong>发送设备</strong>需要<strong>目标设备</strong>的<strong>IP地址和MAC地址</strong>。</li>
</ol>
<ul>
<li>ARP使计算机能够找到<strong>与IP地址关联的计算机的MAC地址</strong>。</li>
</ul>
<h2 id="2-ARP示例"><a href="#2-ARP示例" class="headerlink" title="2. ARP示例"></a>2. ARP示例</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-26.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>source主机访问destination</li>
<li>不知道目的主机在哪里</li>
</ol>
<h2 id="3-ARP表的缓存"><a href="#3-ARP表的缓存" class="headerlink" title="3. ARP表的缓存"></a>3. ARP表的缓存</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-27.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>可以通过lookup命令进行。</li>
<li>在RAM里面，如果ARP没有本条目的对应MAC地址。</li>
<li>MAC地址在ARP中是有时效性的。到时间不更新不激活就会删除</li>
</ol>
<h2 id="4-ARP-操作"><a href="#4-ARP-操作" class="headerlink" title="4. ARP 操作"></a>4. ARP 操作</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-28.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>使用ARP机制</li>
<li>上图中是一个示意图</li>
<li>此时ARP table中<strong>没有缓存</strong></li>
<li>图的一个问题:目的MAC地址应该在前面，源MAC地址在后面</li>
</ol>
<ul>
<li>步骤如下</li>
</ul>
<h3 id="4-1-ARP-request"><a href="#4-1-ARP-request" class="headerlink" title="4.1 ARP request"></a>4.1 ARP request</h3><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-29.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><strong>向目的方请求MAC地址</strong><br>2。 命令如图：<strong>广播询问</strong>找谁是这个主机，你的MAC地址是啥</li>
<li><strong>将MAC地址设置为全1，作为广播发送</strong></li>
</ol>
<h3 id="4-2-Checking"><a href="#4-2-Checking" class="headerlink" title="4.2 Checking"></a>4.2 Checking</h3><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-30.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>10.0.2.5发现不是自己的主机，那么解析到这里<strong>丢掉</strong>就行，同样会记录下来对应的发送方的MAC地址。(攻击原理)</li>
<li>10.0.2.9<strong>发现自己的MAC地址</strong>，然后形成<strong>ARP应答</strong></li>
<li>同时10.0.2.9会同时记录下A主机的MAC地址，更新到自己ARP地址中去(会记录对方的)</li>
</ol>
<h3 id="4-3-ARP-reply"><a href="#4-3-ARP-reply" class="headerlink" title="4.3 ARP reply"></a>4.3 ARP reply</h3><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-31.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>向A主机进行MAC地址应答</li>
</ol>
<h3 id="4-4-Caching"><a href="#4-4-Caching" class="headerlink" title="4.4 Caching"></a>4.4 Caching</h3><ol>
<li>A的主机将刚刚得到的目标主机的<strong>MAC地址和IP地址的映射关系</strong>存储到ARP Table中</li>
<li>然后再次形成一个数据帧发送出去即可。</li>
</ol>
<h3 id="总结-ARP协议工作原理"><a href="#总结-ARP协议工作原理" class="headerlink" title="总结 ARP协议工作原理:"></a>总结 ARP协议工作原理:</h3><ol>
<li>ARP请求:<ol>
<li>数据链路层中目标地址(MAC地址)未知, 网络层中目标地址(IP地址)已知, 广播询问IP地址为目标地址(IP地址)的主机</li>
<li>你的MAC地址是多少</li>
</ol>
</li>
<li>ARP检查<ol>
<li>目标主机发现, 这个IP地址就是自己</li>
</ol>
</li>
<li>ARP回复<ol>
<li>目标主机将自己的MAC地址回复给源主机</li>
</ol>
</li>
<li>ARP缓存<ol>
<li>将刚刚得到的目标主机的MAC地址和IP地址的映射关系存储到ARP表中</li>
</ol>
</li>
</ol>
<h2 id="5-ARP-Destination-local-目的地址为本地"><a href="#5-ARP-Destination-local-目的地址为本地" class="headerlink" title="5. ARP: Destination local 目的地址为本地"></a>5. ARP: Destination local 目的地址为本地</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-32.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>当目标设备在<strong>本地网络</strong>中时，ARP协议用于解析目标设备的MAC地址。</li>
<li><strong>发送设备</strong>会<strong>广播ARP请求</strong>，询问<em>目标IP地址</em> 对应的<em>MAC地址</em>。</li>
<li><strong>目标设备</strong>收到ARP请求后，会<strong>回复其MAC地址</strong>。</li>
<li>发送设备将目标设备的IP地址和MAC地址映射关系<strong>存储在ARP缓存</strong>中，以便后续通信使用。</li>
</ul>
<h2 id="6-ARP-Internetwork-Communication-网络交流"><a href="#6-ARP-Internetwork-Communication-网络交流" class="headerlink" title="6. ARP: Internetwork Communication 网络交流"></a>6. ARP: Internetwork Communication 网络交流</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-33.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>如何与<strong>不在同一物理网段上的设备</strong>通信？如下是两种解决方案。<ul>
<li>Default gateway <strong>默认网关</strong></li>
<li>Proxy ARP <strong>代理ARP</strong></li>
</ul>
</li>
</ol>
<h3 id="6-1-默认网关-Default-gateway"><a href="#6-1-默认网关-Default-gateway" class="headerlink" title="6.1 默认网关 Default gateway:"></a>6.1 默认网关 Default gateway:</h3><ul>
<li>为了使设备能够与<strong>另一个网络上</strong>的设备通信，必须为其提供一个<strong>默认网关</strong>。</li>
<li>默认网关是<strong>路由器上连接到源主机所在网络段</strong>的<strong>接口的IP地址</strong>。</li>
<li>为了使设备将数据发送到另一个网络段上的设备地址，<strong>源设备将数据发送到默认网关</strong>。</li>
</ul>
<h3 id="6-2-Proxy-ARP-代理ARP："><a href="#6-2-Proxy-ARP-代理ARP：" class="headerlink" title="6.2 Proxy ARP 代理ARP："></a>6.2 Proxy ARP 代理ARP：</h3><ul>
<li>代理ARP代理ARP是ARP的一种变体。</li>
<li>在源主机没有配置默认网关的情况下，代理ARP可以发挥作用。<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-34.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>发送ARP请求，然后路由器给你一个ARP的reply，告诉你MAC地址(一般为本端口的IP地址)</li>
</ul>
<ol>
<li><strong>源主机发送ARP请求</strong>：<ul>
<li>当源主机没有配置默认网关时，它会发送ARP请求，询问目标IP地址的MAC地址。</li>
</ul>
</li>
<li><strong>路由器响应ARP请求</strong>：<ul>
<li>路由器配置了代理ARP功能，会拦截并响应这个ARP请求。</li>
<li><strong>路由器会回复其自己的MAC地址</strong>，作为目标IP地址的MAC地址。</li>
</ul>
</li>
<li><strong>源主机发送数据</strong>：<ul>
<li>源主机接收到路由器的ARP回复后，会将数据发送到路由器的MAC地址。</li>
</ul>
</li>
<li><strong>路由器转发数据</strong>：<ul>
<li>路由器接收到数据后，会根据其路由表将数据<strong>转发</strong>到目标网络上的实际目标设备。</li>
</ul>
</li>
</ol>
<h2 id="7-ARP-Destination-not-local"><a href="#7-ARP-Destination-not-local" class="headerlink" title="7. ARP: Destination not local"></a>7. ARP: Destination not local</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-35.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>路由器会把<strong>Router MAC</strong>的地址给你(连接本网段的MAC地址)</li>
</ul>
<h2 id="8-ARP-Flowchart-ARP流程图"><a href="#8-ARP-Flowchart-ARP流程图" class="headerlink" title="8. ARP Flowchart ARP流程图"></a>8. ARP Flowchart ARP流程图</h2><h2 id><a href="#" class="headerlink" title></a><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-36.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></h2><h1 id="五、网络层服务"><a href="#五、网络层服务" class="headerlink" title="五、网络层服务"></a>五、网络层服务</h1><h2 id="1-面向连接的网络服务-Connection-oriented"><a href="#1-面向连接的网络服务-Connection-oriented" class="headerlink" title="1. 面向连接的网络服务 Connection-oriented"></a>1. 面向连接的网络服务 Connection-oriented</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-37.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>在数据传输之前先建立连接</li>
</ul>
<h2 id="1-1-电路交换-Circuit-switched"><a href="#1-1-电路交换-Circuit-switched" class="headerlink" title="1.1 电路交换 Circuit-switched"></a>1.1 电路交换 Circuit-switched</h2><ol>
<li>面向连接vs电路交换<ul>
<li>这两个术语并不相同</li>
</ul>
</li>
</ol>
<ul>
<li>面向连接：首先与接收方建立连接，然后开始数据传输。</li>
<li>电路交换：所有数据包依次通过相同的通道传输，或者更常见的是，通过<strong>相同的虚拟电路</strong>传输。</li>
</ul>
<h2 id="2-无连接的网络服务-Connectionless"><a href="#2-无连接的网络服务-Connectionless" class="headerlink" title="2. 无连接的网络服务 Connectionless"></a>2. 无连接的网络服务 Connectionless</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-38.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>他们<strong>分别separately</strong>对待每个数据包。</li>
<li><strong>IP 是无连接系统</strong>。 IP 就是提供无连接的网络服务</li>
</ol>
<ul>
<li>不要求发送方和接收方在发送前先建立一个连接(不打招呼)。</li>
</ul>
<h2 id="2-1-数据包交换-Packet-switched"><a href="#2-1-数据包交换-Packet-switched" class="headerlink" title="2.1 数据包交换 Packet switched"></a>2.1 数据包交换 Packet switched</h2><ol>
<li>无连接网络vs数据包交换<ul>
<li>这两个术语并不相同</li>
</ul>
</li>
<li>当数据包从源传输到目的地时，它们可以：<ul>
<li><strong>切换</strong>到不同的<strong>路径</strong>。</li>
<li>到达<strong>顺序可能不同</strong>。</li>
</ul>
</li>
<li>设备会<strong>根据多种标准</strong>为每个数据包<strong>确定传输路径</strong>。某些标准可能会因数据包而异。</li>
</ol>
<hr>
<h1 id="六、Routed-and-Routing-protocol-路由和路由协议"><a href="#六、Routed-and-Routing-protocol-路由和路由协议" class="headerlink" title="六、Routed and Routing protocol 路由和路由协议"></a>六、Routed and Routing protocol 路由和路由协议</h1><ul>
<li>网络协议操作<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-39.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="1-Routed-protocol-被动可路由协议"><a href="#1-Routed-protocol-被动可路由协议" class="headerlink" title="1. Routed protocol 被动可路由协议"></a>1. Routed protocol 被动可路由协议</h2><ol>
<li>为网络层提供支持的协议称为<strong>路由协议</strong>或<strong>可路由协议</strong>。</li>
<li>IP 是网络层协议，因此，它可以通过互联网进行路由。</li>
</ol>
<h2 id="2-Non-routable-protocol-不可路由协议"><a href="#2-Non-routable-protocol-不可路由协议" class="headerlink" title="2. Non-routable protocol 不可路由协议"></a>2. Non-routable protocol 不可路由协议</h2><ol>
<li>不支持第三层</li>
<li>这些不可路由协议中最常见的是 NetBEUI。</li>
<li>NetBEUI 是一种小型，快速且高效的协议，仅限于在一个网段上运行。</li>
</ol>
<h2 id="3-被动可路由协议的寻址-Addressing-of-a-routable-protocol"><a href="#3-被动可路由协议的寻址-Addressing-of-a-routable-protocol" class="headerlink" title="3. 被动可路由协议的寻址 Addressing of a routable protocol"></a>3. 被动可路由协议的寻址 Addressing of a routable protocol</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-40.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-41.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>路由器连接三个网段(列出来的是网络号)</li>
</ul>
<ol>
<li>目的主机131.108.2.2</li>
<li>将目的主机和掩码进行逻辑AND操作，得到对应的网段，为131.108.2.0</li>
<li>请求路由表可以发现，E2端口为目的网段</li>
<li>再次将报文封装，转发给对应的主机</li>
<li>路由表是存储在内存中的</li>
</ol>
<h2 id="4-路由协议分类1：Static-and-Dynamic-静态和动态"><a href="#4-路由协议分类1：Static-and-Dynamic-静态和动态" class="headerlink" title="4. 路由协议分类1：Static and Dynamic 静态和动态"></a>4. 路由协议分类1：Static and Dynamic 静态和动态</h2><ol>
<li>静态路由 Static routes：<ul>
<li><strong>网络管理员</strong>在路由器中<strong>手动输入</strong>路由信息。</li>
</ul>
</li>
<li>动态路由 Dynamic routes：<ul>
<li>路由器可以在运行过程中互相学习信息。</li>
<li>使用**路由协议 (routing protocol)**更新路由信息。</li>
<li>RIP, IGRP, EIGRP, OSPF …</li>
<li>人工维护的代价比较大</li>
</ul>
</li>
</ol>
<ul>
<li>区别：</li>
</ul>
<ol>
<li>静态路由<ul>
<li>用于隐藏部分网络。安全(不必进行路由表的交换)</li>
<li>测试网络中的特定链接。</li>
<li>用于在只有一条路径到目标网络时维护路由表。</li>
</ul>
</li>
<li>动态路由<ul>
<li>维护路由表。</li>
<li>以路由更新的形式及时分发信息。</li>
<li>依靠路由协议共享知识。</li>
<li>路由器可以调整以适应不断变化的网络状况。</li>
<li>打开后会启动进程，按照不同的协议，和网上的不同设备学习信息，然后根据算法生成路由表</li>
</ul>
</li>
</ol>
<h3 id="4-1-Routing-protocol-主动路由协议-Routing"><a href="#4-1-Routing-protocol-主动路由协议-Routing" class="headerlink" title="4.1 Routing protocol 主动路由协议(Routing)"></a>4.1 Routing protocol 主动路由协议(Routing)</h3><ol>
<li>Routing protocols <em>确定</em> routed protocols遵循的到达目的地的路径。</li>
<li>是用来<strong>构建路由表</strong>的，<strong>所以叫做routing</strong></li>
<li>公平、简单、适应变化等特点</li>
</ol>
<h3 id="4-2-Routed-vs-Routing-protocol"><a href="#4-2-Routed-vs-Routing-protocol" class="headerlink" title="4.2 Routed vs. Routing protocol"></a>4.2 Routed vs. Routing protocol</h3><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-42.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><strong>Routed Portocol</strong> 用于路由器之间，用来保证路由器之间连通（完成转发），保证路由器有效连通。<ul>
<li><ul>
<li><strong>功能</strong>：实际承载和传输数据。</li>
</ul>
</li>
<li>示例：IP、IPX等</li>
</ul>
</li>
<li><strong>Routing Protocol</strong> 用于做各自的<strong>路由表的生成</strong>：路由器彼此交换信息。<ul>
<li><ul>
<li><strong>功能</strong>：帮助路由器构建和维护路由表。</li>
</ul>
</li>
<li>示例：RIP、OSPF、EIGRP、BGP等。</li>
</ul>
</li>
</ol>
<ul>
<li>Routing Protocol 决定 Routed Protocals</li>
</ul>
<ol start="3">
<li>简单来说，路由协议(routing)用于<strong>帮助路由器决定数据包的最佳传输路径</strong>，而路由协议(routed)是<strong>实际用于传输数据</strong>的协议。</li>
</ol>
<h2 id="5-路由协议分类2（动态路由协议）：IGP-and-EGP"><a href="#5-路由协议分类2（动态路由协议）：IGP-and-EGP" class="headerlink" title="5. 路由协议分类2（动态路由协议）：IGP and EGP"></a>5. 路由协议分类2（动态路由协议）：IGP and EGP</h2><ul>
<li>皆为动态路由</li>
</ul>
<ol>
<li><strong>内部网关协议 IGP</strong>(Interior Gateway Protocols)</li>
</ol>
<ul>
<li>示例：RIP、IGRP、EIGRP、OSPF</li>
<li>用途：在<strong>一个自治系统内</strong>使用，例如公司网络、学校网络或政府机构网络。</li>
</ul>
<ol start="2">
<li><strong>外部网关协议 EGP</strong>(Exterior Gateway Protocols)</li>
</ol>
<ul>
<li>示例：EGP、BGP</li>
<li>用途：在<strong>不同自治系统之间路由数据包</strong>，例如跨组织或跨地区的互联网连接。</li>
</ul>
<h2 id="6-路由协议分类3（内部网关协议）：DVP-and-LSP"><a href="#6-路由协议分类3（内部网关协议）：DVP-and-LSP" class="headerlink" title="6. 路由协议分类3（内部网关协议）：DVP and LSP"></a>6. 路由协议分类3（内部网关协议）：DVP and LSP</h2><ol>
<li><strong>距离矢量协议 (Distance-Vector Protocols)：RIP, IGRP</strong></li>
</ol>
<ul>
<li>从<strong>邻居的角度</strong>查看网络拓扑。</li>
<li>添加从路由器到路由器的<strong>距离+矢量</strong>。<ul>
<li>距离 (Distance)：通常是路由器与目标网络之间的<strong>跳数</strong>（hop count）。每个跳数代表从一个路由器到另一个路由器的路径。</li>
<li>矢量 (Vector)：在距离矢量协议中，矢量通常指的是<em>从源路由器到目标路由器的下一跳信息</em>。每个路由器会保存一张路由表，记录到每个目标网络的最短跳数和下一跳路由器。</li>
</ul>
</li>
<li><strong>频繁、定期periodic更新</strong>。<ul>
<li>周期性地交换路由信息来计算最佳路径<ol>
<li>到达每个目标网络的跳数（距离）。</li>
<li>用于到达目标网络的下一跳路由器（方向）。</li>
</ol>
</li>
</ul>
</li>
<li>将<strong>路由表的副本</strong>传递给邻居路由器。</li>
</ul>
<ol start="2">
<li><strong>链路状态协议 (Link State Protocols)：OSPF</strong>*</li>
</ol>
<ul>
<li>每个路由器获取<strong>整个网络拓扑</strong>的共同视图。</li>
<li><strong>计算</strong>到其他路由器的<strong>最短路径</strong>。</li>
<li><strong>事件触发更新</strong>。</li>
<li>传递<strong>链路状态路由更新</strong>到其他路由器。</li>
</ul>
<h3 id="6-1-距离矢量协议DVP的示例"><a href="#6-1-距离矢量协议DVP的示例" class="headerlink" title="6.1 距离矢量协议DVP的示例"></a>6.1 距离矢量协议DVP的示例</h3><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-43.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>初始的时候，各自持有的是黑色的部分（直连的线路）</li>
<li>定时路由表会相互交换给邻居，下一时刻 C 学习到 B，B 学习到 AC，A 学习到 B，在下一刻进行再次的转发。</li>
<li>DVP 只知道<strong>到达一个网段的最少跳数hops</strong>（但是不知道最佳路径）。</li>
<li>可能导致问题：生成路由回路</li>
</ul>
<h4 id="6-1-1-RIP-Route-Information-Protocol-路由信息协议"><a href="#6-1-1-RIP-Route-Information-Protocol-路由信息协议" class="headerlink" title="6.1.1 RIP (Route Information Protocol)路由信息协议"></a>6.1.1 RIP (Route Information Protocol)路由信息协议</h4><ul>
<li>最流行的协议。</li>
<li><strong>内部网关协议TGP</strong>。</li>
<li><strong>距离矢量协议DVP</strong>。</li>
<li>唯一的度量是跳数hops。</li>
<li>最大跳数为15。</li>
<li>每30秒更新一次。</li>
<li>并不总是选择最快的路径。</li>
<li>生成大量网络流量。</li>
<li>RIP v2是RIP v1的改进版本。</li>
</ul>
<h4 id="6-1-2-IGRP-Interior-Gateway-Route-Protocol-and-EIGRP-Enhanced-IGRP"><a href="#6-1-2-IGRP-Interior-Gateway-Route-Protocol-and-EIGRP-Enhanced-IGRP" class="headerlink" title="6.1.2 IGRP (Interior Gateway Route Protocol) and EIGRP (Enhanced IGRP)"></a>6.1.2 IGRP (Interior Gateway Route Protocol) and EIGRP (Enhanced IGRP)</h4><ul>
<li>IGRP（内部网关路由协议）和EIGRP（增强型IGRP）</li>
<li>Cisco专有协议。</li>
<li><strong>内部网关协议IGP</strong>。</li>
<li><strong>距离矢量协议DVP</strong>。</li>
<li>度量由带宽、负载、延迟和可靠性组成。</li>
<li>最大跳数为255。</li>
<li>每90秒更新一次。</li>
<li>EIGRP是IGRP的高级版本，是一种混合路由协议。</li>
</ul>
<h3 id="6-2-链路状态协议LSP的示例"><a href="#6-2-链路状态协议LSP的示例" class="headerlink" title="6.2 链路状态协议LSP的示例"></a>6.2 链路状态协议LSP的示例</h3><ul>
<li>下图中的 Routing table 应该叫做初始时刻的 Routing Table（本图的问题）<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-44.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<ol>
<li>彼此交换连接情况，<strong>交换的是Link state</strong>而不是路由表，包含 link 的信息，以 NetID 作为主键（无相同网段），包含的是 link 上的路由器邻接关系、链路类型（4 种）、链路带宽，会指定谁连接了谁，这个条目就被称为 Database（表）。这样子就不仅仅知道链路，还知道更多的全局信息。</li>
<li>LSP 操作过程：<ul>
<li>相互交换彼此学到对应的 Tpological Database（是全局的信息）</li>
<li>之后使用 SPF 算法，以自己为根，通过最短路径优先算法，生成以自己为根的树</li>
<li>根据这一个树再生成路由表（了解全局的信息），逻辑是树的逻辑。</li>
</ul>
</li>
<li>LSP 不是进行定时进行交换的，而是<em>初始的时候进行交换</em>，稳定之后，根据<strong>事件触发</strong>的时候才会更新数据。<ul>
<li>更新后发送给所有的路由器，需要将 Database 发送给所有的路由器</li>
<li>收到的路由器的，根据 database 更新自己的树，然后再次生成路由表。</li>
</ul>
</li>
<li>LSP 是指从所有可达的道路上找到代价最小的路径。</li>
<li>全局可能会比较大，考虑负载进行处理</li>
<li>但是没有路由回路，单域内一般不超过 20 个路由器</li>
<li>路由表一般只保存一个最优的转发点的（负载均衡）</li>
</ol>
<h4 id="6-2-1-OSPF（Open-Shortest-Path-First）开放最短路径优先"><a href="#6-2-1-OSPF（Open-Shortest-Path-First）开放最短路径优先" class="headerlink" title="6.2.1 OSPF（Open Shortest Path First）开放最短路径优先"></a>6.2.1 OSPF（Open Shortest Path First）开放最短路径优先</h4><ul>
<li>开放最短路径优先。</li>
<li><strong>内部网关协议IGP</strong>。</li>
<li><strong>链路状态协议LSP</strong>。</li>
<li>度量由成本、速度、流量、可靠性和安全性组成。</li>
<li>事件触发更新。</li>
</ul>
<h1 id="七、VLSM-可变长度子网掩码"><a href="#七、VLSM-可变长度子网掩码" class="headerlink" title="七、VLSM 可变长度子网掩码"></a>七、VLSM 可变长度子网掩码</h1><ul>
<li>Variable Length Subnet Mask</li>
</ul>
<h2 id="1-Classful-Routing（类路由）"><a href="#1-Classful-Routing（类路由）" class="headerlink" title="1. Classful Routing（类路由）"></a>1. Classful Routing（类路由）</h2><ol>
<li>类路由协议要求<strong>一个网络</strong>使用<strong>相同的子网掩码</strong>。</li>
<li>例如：如果网络是 192.168.187.0，那么它必须使用一个单一的子网掩码，如 255.255.255.0。</li>
</ol>
<ul>
<li>也就是说，类路由协议不允许在同一个网络中存在多个子网掩码，<strong>所有子网都需要使用相同的掩码</strong>。</li>
<li>类路由的这种特性比较简单，但它不具备灵活性，无法根据需求进行更精细的子网划分。<ul>
<li>会造成一些浪费</li>
</ul>
</li>
</ul>
<h2 id="2-VLSM-—-Variable-Length-Subnet-Mask"><a href="#2-VLSM-—-Variable-Length-Subnet-Mask" class="headerlink" title="2. VLSM — Variable Length Subnet Mask"></a>2. VLSM — Variable Length Subnet Mask</h2><ol>
<li>VLSM是一种允许在<strong>同一个自治系统内使用不同子网掩码</strong>的特性。<ul>
<li>有效地解决浪费问题</li>
</ul>
</li>
<li>为什么要使用VLSM<ul>
<li>VLSM允许一个组织在同一个网络地址空间内使用多个子网掩码。</li>
<li>实施VLSM通常被称为“子网的子网”，可以用来最大化地址分配的效率。</li>
<li>VLSM是帮助弥合IPv4和IPv6之间差距的修改之一。</li>
</ul>
</li>
<li>优点<ul>
<li>高效使用IP地址 Efficient use of IP addresses</li>
<li>更好的路由聚合 Better route aggregation</li>
</ul>
</li>
<li>支持VLSM的 Routing Protocol：<ul>
<li>开放最短路径优先Open Shortest Path First (OSPF) </li>
<li>集成中间系统到中间系统 Integrated Intermediate System to Intermediate System (Integrated IS-IS) </li>
<li>增强型内部网关路由协议 Enhanced Interior Gateway Routing Protocol (EIGRP)</li>
<li>RIP v2 </li>
<li>静态路由 Static routing</li>
</ul>
</li>
<li>缺点：<ul>
<li>地址空间的浪费:广播地址和网络号都无法被使用。<ul>
<li>过去，建议不要使用第一个和最后一个子网。但从Cisco IOS 12.0版本开始，可以使用子网0。</li>
<li>从IOS 12.0版本开始，Cisco路由器默认使用子网0。</li>
</ul>
</li>
<li>如果想要禁止零子网，使用该指令:<code>router(config)#no ip subnet-zero()</code><br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-45.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ol>
<ul>
<li>上图解释了子网长度相同会造成怎样的浪费(在路由器所在的子网段我们只需要满足2个主机，也就是需要2位的主机号就可以完成操作)</li>
</ul>
<h2 id="3-如何使用VLSM"><a href="#3-如何使用VLSM" class="headerlink" title="3. 如何使用VLSM"></a>3. 如何使用VLSM</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-47.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li><strong>斜杠的含义</strong>是指<strong>前面多少位保留给网络位</strong></li>
<li><strong>此时也就是&#x2F;30 就可以满足路由器之间的网络连通所需（减少浪费），剩下的网络地址可以在以后网络进行扩展</strong><ul>
<li>这个例子中不使用 VLSM 还是可以进行解决的<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-48.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
<h3 id="3-0-划分背景"><a href="#3-0-划分背景" class="headerlink" title="3.0 划分背景"></a>3.0 划分背景</h3><ul>
<li>已分配 192.168.10.0&#x2F;24 的 C 类地址。<ul>
<li>珀斯、悉尼和新加坡有一个到吉隆坡（KL）的广域网连接。</li>
<li>珀斯需要60个主机。</li>
<li>吉隆坡需要28个主机。</li>
<li>悉尼和新加坡各需要12个主机。</li>
</ul>
</li>
</ul>
<ol>
<li>要计算 VLSM，子网和相应的主机首先从地址范围中分配<strong>最大的要求</strong>。需求级别应<strong>从大到小</strong>列出。</li>
</ol>
<h3 id="3-1-第一步：满足珀斯的主机需求（需求最大）"><a href="#3-1-第一步：满足珀斯的主机需求（需求最大）" class="headerlink" title="3.1 第一步：满足珀斯的主机需求（需求最大）"></a>3.1 第一步：满足珀斯的主机需求（需求最大）</h3><ol>
<li>珀斯需要60个主机。</li>
<li>2^6-2&#x3D;62个可用主机地址，所以使用6位<ul>
<li>将从第四个八位位组开始使用 2 位来表示&#x2F;26 的扩展网络前缀，其余 6 位将用于主机地址。</li>
</ul>
</li>
<li>在地址 192.168.10.0&#x2F;24 上应用 VLSM 可得到：<ul>
<li><strong>子网掩码：255.255.255.192</strong>（<strong>&#x2F;26</strong>）</li>
<li><strong>子网地址：192.168.10.0&#x2F;26</strong></li>
<li><strong>可用地址范围：192.168.10.1 - 192.168.10.62</strong></li>
<li><strong>广播地址: 192.168.10.63</strong><br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-49.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ol>
<ul>
<li>第一个给 Perth 使用，剩下的用作保留未使用的</li>
</ul>
<h3 id="3-2-第二步：为吉隆坡划分子网（需求第二）"><a href="#3-2-第二步：为吉隆坡划分子网（需求第二）" class="headerlink" title="3.2 第二步：为吉隆坡划分子网（需求第二）"></a>3.2 第二步：为吉隆坡划分子网（需求第二）</h3><ol>
<li>吉隆坡需要28个主机<ul>
<li>下一个可用地址是192.168.10.64&#x2F;26。</li>
<li><strong>01</strong>00 0000</li>
</ul>
</li>
<li>由于需要28个主机，<strong>5位</strong>将用于主机地址，2^5 - 2 &#x3D; 30个可用主机地址。</li>
<li>因此，<strong>5位用于表示主机</strong>，<strong>3位用于表示扩展网络前缀&#x2F;27</strong>。</li>
<li>在地址 192.168.10.64&#x2F;26 上应用VLSM可得到<ul>
<li>子网掩码：255.255.255.<strong>224（&#x2F;27）</strong><ul>
<li>1110 0000</li>
</ul>
</li>
<li><strong>子网地址：192.168.10.64&#x2F;27</strong><ul>
<li>192.168.10.<strong>010 hhhhh</strong> &#x2F;27</li>
</ul>
</li>
<li><strong>可用地址范围：192.168.10.65 - 192.168.10.94</strong></li>
<li><strong>广播地址：192.168.10.95</strong><br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-50.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ol>
<h3 id="3-3-第三步：为悉尼和新加坡进行分配地址（需求第三）"><a href="#3-3-第三步：为悉尼和新加坡进行分配地址（需求第三）" class="headerlink" title="3.3 第三步：为悉尼和新加坡进行分配地址（需求第三）"></a>3.3 第三步：为悉尼和新加坡进行分配地址（需求第三）</h3><ol>
<li>悉尼和新加坡各需要12个主机：<ul>
<li>下一个可用地址是192.168.10.96&#x2F;27。</li>
</ul>
</li>
<li>由于需要12个主机，<strong>4位</strong>将用于主机地址，2^4 &#x3D; 16，16 - 2 &#x3D; 14个可用主机地址。</li>
<li>因此，<strong>4位用于表示主机</strong>，4位用于表示扩展<strong>网络前缀&#x2F;28</strong>。</li>
<li>在地址 192.168.10.96&#x2F;27 上应用 VLSM 可得到：<ul>
<li>子网掩码：255.255.255.<strong>240（&#x2F;28）</strong><ul>
<li>1111 0000</li>
</ul>
</li>
<li><strong>子网地址：192.168.10.96&#x2F;28</strong><ul>
<li>192.168.10.<strong>0110 hhhh</strong>&#x2F;28</li>
</ul>
</li>
<li><strong>可用地址范围：192.168.10.97 - 192.168.10.110</strong></li>
<li><strong>广播地址：192.168.10.111</strong></li>
</ul>
</li>
</ol>
<ul>
<li>新加坡同理（12个主机）：<ul>
<li>下一个可用地址是192.168.10.112&#x2F;28</li>
<li>需要12个主机——4位表示主机，4位表示扩展网络前缀</li>
</ul>
</li>
</ul>
<ol start="5">
<li>在地址192.168.10.112&#x2F;28上应用VLSM得到：<ul>
<li>子网掩码：255.255.255.<strong>240（&#x2F;28）</strong><ul>
<li>1111 0000</li>
</ul>
</li>
<li>子网地址：192.168.10.112&#x2F;28<ul>
<li>192.168.10.<strong>0111</strong> hhhh&#x2F;28</li>
</ul>
</li>
<li>可用地址范围：192.168.10.113 - 192.168.10.126</li>
<li>广播地址：192.168.10.127<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-51.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ol>
<h3 id="3-4-第四步：为之间的路由地址进行划分"><a href="#3-4-第四步：为之间的路由地址进行划分" class="headerlink" title="3.4 第四步：为之间的路由地址进行划分"></a>3.4 第四步：为之间的路由地址进行划分</h3><ol>
<li>现在为 WAN 连接分配地址。请记住，<strong>每个 WAN 连接都需要两个 IP 地址</strong>。<ul>
<li>下一个可用的子网是 192.168.10.128&#x2F;28。</li>
</ul>
</li>
<li>由于每个 WAN 链路需要 2 个网络地址，因此主机地址需要 2 位，即 2^2 -2 &#x3D; 2 个可用地址。</li>
<li>因此，2位用于表示链接，6位用于表示扩展网络前缀&#x2F;30。</li>
<li>在 192.168.10.128&#x2F;28 上应用 VLSM 可得到：<ul>
<li>子网掩码：255.255.255.252（&#x2F;30）<ul>
<li>1111 1100</li>
</ul>
</li>
<li>子网地址：192.168.10.128&#x2F;30<ul>
<li>192.168.10.<strong>011000</strong> hh &#x2F;30</li>
</ul>
</li>
<li>可用地址范围：192.168.10.129 - 192.168.10.130</li>
<li>广播地址：192.168.10.131<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-52.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-53.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li><strong>下一个WAN链接</strong>：<ul>
<li>子网地址：192.168.10.132&#x2F;30</li>
<li>可用地址范围：192.168.10.133 - 192.168.10.134</li>
<li>广播地址：192.168.10.135</li>
</ul>
</li>
<li><strong>下一个WAN链接</strong>：<ul>
<li>子网地址：192.168.10.136&#x2F;30</li>
<li>可用地址范围：192.168.10.137 - 192.168.10.138</li>
<li>广播地址：192.168.10.139</li>
</ul>
</li>
</ol>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><strong>重要的是要记住，只有未使用的子网才能进一步子网划分。</strong></li>
<li>如果子网中的任何地址已被使用，则该子网不能进一步子网划分。</li>
<li>一般是从<strong>主机多到主机少</strong>（路由间网络）进行划分</li>
<li>最后<strong>不要忘了路由地址的划分</strong></li>
</ul>
<h2 id="4-Route-Aggregation-路由聚合"><a href="#4-Route-Aggregation-路由聚合" class="headerlink" title="4. Route Aggregation 路由聚合"></a>4. Route Aggregation 路由聚合</h2><ol>
<li>使用<strong>无类域间路由</strong>(<strong>CIDR</strong>，Classless InterDomain Routing)和<strong>VLSM</strong>不仅可以防止地址浪费，而且还可以促进路由聚合或汇总。</li>
<li>路由聚合（也称为路由汇总）是一种将<strong>多个连续的IP地址块</strong>合并为<strong>一个单一的路由条目</strong>的技术。<ul>
<li>通过路由聚合，可以减少路由表中的条目数量，从而简化路由器的处理和提高网络效率。</li>
</ul>
</li>
<li>优点：<ol>
<li>减少<strong>路由表</strong>条目的数量。</li>
<li>可用于<strong>隔离拓扑更改</strong><ul>
<li>当网络拓扑发生变化时，路由聚合可以帮助隔离这些变化，减少对整个网络的影响。</li>
</ul>
</li>
</ol>
</li>
<li>为了使路由聚合正常工作，需要以<strong>层次化</strong>的方式仔细分配地址，以确保<strong>汇总地址能够共享相同的高阶位</strong>（高位部分）。</li>
<li>VLSM可以通过基于地址的**高阶位（左边高位部分）**来实现路由的汇总和灵活性，即使网络地址不一定是连续的。</li>
</ol>
<ul>
<li>比如下图：3个&#x2F;24的子网合并成一个&#x2F;16的网络高速远端<br><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-54.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h3 id="4-0-例子"><a href="#4-0-例子" class="headerlink" title="4.0 例子"></a>4.0 例子</h3><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-55.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="4-1-如何进行路由聚合"><a href="#4-1-如何进行路由聚合" class="headerlink" title="4.1 如何进行路由聚合"></a>4.1 如何进行路由聚合</h3><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-56.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>将尽可能多的位进行聚集，将之后的不通过的位置，作为 Host 位，就得到了上图的结果</li>
</ul>
<hr>
<h1 id="八、ICMP-因特网控制报文协议"><a href="#八、ICMP-因特网控制报文协议" class="headerlink" title="八、ICMP 因特网控制报文协议"></a>八、ICMP 因特网控制报文协议</h1><ol>
<li>ICMP (<strong>Internet Control Message Protocol</strong>)：为了提高<br>IP 数据报交付成功的机会</li>
<li>ICMP 允许主机或路由器<strong>报告差错情况</strong>和提供有关异常情况<br>的报告</li>
<li>ICMP 只是IP 层的协议</li>
<li>ICMP 报文作为IP 层数据报的数据，加上数据报的首部，组成IP 数据报发送出去</li>
</ol>
<h2 id="1-ICMP-报文的格式"><a href="#1-ICMP-报文的格式" class="headerlink" title="1. ICMP 报文的格式"></a>1. ICMP 报文的格式</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-57.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>前4个字节和普通数据报的格式一样<ul>
<li>类型</li>
<li>代码</li>
<li>检验和</li>
</ul>
</li>
<li>后面都是要根据类型</li>
</ol>
<h2 id="2-两种ICMP报文"><a href="#2-两种ICMP报文" class="headerlink" title="2. 两种ICMP报文"></a>2. 两种ICMP报文</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-58.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>查询报文：一般这种情况不是很多</li>
<li>差错报告报文：一般这种类型会多一些</li>
</ol>
<h2 id="3-目的站不可到达"><a href="#3-目的站不可到达" class="headerlink" title="3. 目的站不可到达"></a>3. 目的站不可到达</h2><ul>
<li><p>网络不可到达（net unreachable）</p>
</li>
<li><p>主机不可到达（host unreachable）</p>
</li>
<li><p>协议不可到达（protocol unreachable）</p>
</li>
<li><p>端口不可到达（port unreachable）</p>
</li>
<li><p>源路由选择不能完成（source route failed）</p>
</li>
<li><p>目的网络不可知（unknown destination network）</p>
</li>
<li><p>目的主机不可知（unknown destination host）</p>
</li>
<li><p>注：不可知是完全不可以解析，不可达是可以解析但是不可以到达</p>
</li>
</ul>
<h2 id="4-ICMP-差错报告报文的数据字段的内容"><a href="#4-ICMP-差错报告报文的数据字段的内容" class="headerlink" title="4. ICMP 差错报告报文的数据字段的内容"></a>4. ICMP 差错报告报文的数据字段的内容</h2><p><img src="/2025/02/24/%E5%9B%9B%E3%80%81NetworkLayer/image-59.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>一般会把原始的 IP 数据报文的数据报首部 + 8 字节（数据的，可能会包含端口信息）作为 ICMP 的数据部分</li>
<li>ICMP 的前 8 个字节的是确定的（前 4 个字节是类型，校验位，后面四个字节是确定的）</li>
<li>然后添加一个首部作为 IP 数据报进行发送。</li>
</ol>
<h2 id="5-不应发生ICMP差错报告报文的几种情况"><a href="#5-不应发生ICMP差错报告报文的几种情况" class="headerlink" title="5. 不应发生ICMP差错报告报文的几种情况"></a>5. 不应发生ICMP差错报告报文的几种情况</h2><ol>
<li>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文</li>
<li>对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文</li>
<li>对具有多播地址的数据报都不发送 ICMP 差错报告报文</li>
<li>对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送 ICMP 差错报告报文</li>
</ol>
<h2 id="6-PING（Packet-InterNet-Groper）"><a href="#6-PING（Packet-InterNet-Groper）" class="headerlink" title="6. PING（Packet InterNet Groper）"></a>6. PING（Packet InterNet Groper）</h2><ul>
<li>PING 是用**ICMP的”Echo request”和”Echo reply”**消息来实现的</li>
<li>PING 用来<strong>测试两个主机之间的连通性</strong></li>
<li>PING 使用了ICMP 回送请求与回送回答报文</li>
<li>PING 是<strong>应用层直接使用网络层 ICMP 的例子</strong>，它没有通过运输层的TCP或UDP</li>
</ul>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
