<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1-十进制二进制浮点数转换</title>
    <url>/2025/02/20/1-%E5%8D%81%E8%BF%9B%E5%88%B6%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="一、十进制整数-二进制补码"><a href="#一、十进制整数-二进制补码" class="headerlink" title="一、十进制整数-&gt;二进制补码"></a>一、十进制整数-&gt;二进制补码</h2><h3 id="1-用2整除的方式（正数）"><a href="#1-用2整除的方式（正数）" class="headerlink" title="1. 用2整除的方式（正数）"></a>1. 用2整除的方式（正数）</h3><ol>
<li>用2整除十进制整数，得到一个<strong>商</strong>和<strong>余数</strong>；</li>
<li>再<strong>用2去除商</strong>，又会得到一个商和余</li>
<li>如此重复，直到<strong>商为小于1</strong>时为止，</li>
<li>然后把<strong>先得到余数</strong>作为二进制数的<strong>低位有效位</strong>，<strong>后得到的余数</strong>作为二进制数的<strong>高位有效位</strong>，以此排列起来。<br><img src="/2025/02/20/1-%E5%8D%81%E8%BF%9B%E5%88%B6%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BD%AC%E6%8D%A2/image.png" alt="alt"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<h3 id="2-负数转化为其补码——（其绝对值转化成二进制后）逐位取反-加一"><a href="#2-负数转化为其补码——（其绝对值转化成二进制后）逐位取反-加一" class="headerlink" title="2. 负数转化为其补码——（其绝对值转化成二进制后）逐位取反+加一"></a>2. 负数转化为其补码——（其绝对值转化成二进制后）逐位取反+加一</h3><ol>
<li>将负数的<strong>绝对值</strong>转换为二进制。</li>
<li>对二进制数进行<strong>逐位取反</strong>（0变1，1变0）。</li>
<li>对<strong>取反后的二进制数加1</strong>。</li>
</ol>
<h3 id="3-将字符数组转换为字符串"><a href="#3-将字符数组转换为字符串" class="headerlink" title="3. 将字符数组转换为字符串"></a>3. 将字符数组转换为字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">binary</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(binaryStr);</span><br></pre></td></tr></table></figure>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>将字符串转换为整数：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">numInt</span> <span class="operator">=</span> Integer.parseInt(numStr);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>初始化一个长度为32的字符数组</strong>，用于存储二进制表示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] binaryStr = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">32</span>];</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>设置符号位</li>
<li>处理正数：使用除2取余法。从数组的末尾开始填充二进制位。</li>
<li>处理负数：<ul>
<li>先将负数转换为其<strong>绝对值</strong>。</li>
<li>使用<strong>除2取余法</strong>，将绝对值转换为二进制表示。</li>
<li>对二进制表示<strong>逐位取反</strong>。</li>
<li>对<strong>取反后的二进制数加一</strong>。注意<code>ifplus</code></li>
</ul>
</li>
<li>将<strong>字符数组转换为字符串</strong>并返回</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">binary</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(binaryStr);</span><br></pre></td></tr></table></figure>
<h3 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">intToBinary</span><span class="params">(String numStr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> numInt=Integer.parseInt(numStr);<span class="comment">//转成int</span></span><br><span class="line">    <span class="type">char</span> []binaryStr = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">if</span>(numInt&gt;=<span class="number">0</span>)&#123;<span class="comment">//符号位</span></span><br><span class="line">        binaryStr[<span class="number">0</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        binaryStr[<span class="number">0</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (numInt&gt;=<span class="number">0</span>)&#123;<span class="comment">//正数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numInt%<span class="number">2</span>==<span class="number">1</span>)&#123;<span class="comment">//余数是1</span></span><br><span class="line">                binaryStr[<span class="number">32</span>-i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//余数是0</span></span><br><span class="line">                binaryStr[<span class="number">32</span>-i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            numInt=numInt/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;<span class="comment">//负数，等于其正数的二进制数，逐位取反，再加一</span></span><br><span class="line">        numInt = -numInt;<span class="comment">//转正</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numInt % <span class="number">2</span> == <span class="number">1</span>) &#123;<span class="comment">//余数是1</span></span><br><span class="line">                binaryStr[<span class="number">32</span> - i] = <span class="string">&#x27;0&#x27;</span>;<span class="comment">//取反</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//余数是0</span></span><br><span class="line">                binaryStr[<span class="number">32</span> - i] = <span class="string">&#x27;1&#x27;</span>;<span class="comment">//取反</span></span><br><span class="line">            &#125;</span><br><span class="line">            numInt = numInt / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加一</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ifplus</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binaryStr[i] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; ifplus) &#123;</span><br><span class="line">                    binaryStr[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    ifplus = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (binaryStr[i] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; ifplus) &#123;</span><br><span class="line">                    binaryStr[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">binary</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(binaryStr);</span><br><span class="line">  <span class="keyword">return</span> binary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、二进制补码-十进制整数"><a href="#二、二进制补码-十进制整数" class="headerlink" title="二、二进制补码-&gt;十进制整数"></a>二、二进制补码-&gt;十进制整数</h2><h3 id="错误方法-无法通过最大-最小值测试"><a href="#错误方法-无法通过最大-最小值测试" class="headerlink" title="错误方法-无法通过最大&#x2F;最小值测试"></a>错误方法-无法通过最大&#x2F;最小值测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">binaryToInt</span><span class="params">(String binStr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(binStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>)&#123;<span class="comment">//正数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> temp=Integer.parseInt(String.valueOf(binStr.charAt(i)));</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">32</span>-i;j++)&#123;</span><br><span class="line">                temp*=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           temp/=<span class="number">2</span>;</span><br><span class="line">            num+=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;<span class="comment">//负数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> temp=Integer.parseInt(String.valueOf(binStr.charAt(i)));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">32</span>-i;j++)&#123;</span><br><span class="line">                temp*=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp/=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>) &#123;</span><br><span class="line">                num += temp;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num-=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String numStr=String.valueOf(num);</span><br><span class="line">    <span class="keyword">return</span> numStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-逐位累加（！！从左边开始！！）"><a href="#1-逐位累加（！！从左边开始！！）" class="headerlink" title="1.逐位累加（！！从左边开始！！）"></a>1.逐位累加（！！从左边开始！！）</h3><ul>
<li>逐位累加实现二进制转十进制的过程就是将二进制字符串中的每一位数字（<strong>从左到右</strong>）根据其所在的位置转换为相应的十进制值，并累加到最终结果中。</li>
</ul>
<ol>
<li>从二进制字符串的<strong>左边</strong>开始，对每个字符进行处理。</li>
<li>对每个字符，计算其<strong>对应的二进制值(1&#x2F;0)</strong>，然后将其加到累积结果中。</li>
<li>在处理每个字符时，将<strong>当前的累积值乘以 2</strong>，并<strong>加上当前字符所表示的数字（0 或 1）</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num = num * <span class="number">2</span> + (binStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>这样，最终的结果就是二进制转换成的十进制数。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (binStr.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>) &#123; <span class="comment">// 正数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        num = num * <span class="number">2</span> + (binStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-char转int"><a href="#2-char转int" class="headerlink" title="2. char转int"></a>2. char转int</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num = num * <span class="number">2</span> + (binStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="3-处理负数"><a href="#3-处理负数" class="headerlink" title="3. 处理负数"></a>3. 处理负数</h3><ol>
<li><strong>逐位取反</strong>：将二进制字符串逐位取反。</li>
<li><strong>加一</strong>：对取反后的二进制数加一。</li>
<li>累加计算：从第0位到第31位，逐位计算二进制数对应的十进制值。</li>
<li>取反：将结果取负。</li>
</ol>
<ul>
<li>注意：<strong>二进制负数取反后加一</strong>等价于相当于<strong>二进制负数先减一，再取反</strong></li>
</ul>
<h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol>
<li>正数处理：<ul>
<li>从第0位到第31位，逐位计算二进制数对应的十进制值。</li>
<li>num*2+(dinStr.charAt(i)-‘0’);</li>
</ul>
</li>
<li>负数处理：<ul>
<li>取反：将二进制字符串逐位取反。</li>
<li>加一：对取反后的二进制数加一。</li>
<li>累加计算：从第0位到第31位，逐位计算二进制数对应的十进制值。</li>
<li>取反：将结果取负。</li>
</ul>
</li>
<li>返回结果：<ul>
<li>将计算得到的十进制整数转换为字符串并返回。</li>
</ul>
</li>
</ol>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">binaryToInt</span><span class="params">(String binStr)</span> &#123;</span><br><span class="line">       <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span>(binStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>)&#123;<span class="comment">//正数</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;<span class="comment">//从0或者1开始都行，没影响</span></span><br><span class="line">               num=num*<span class="number">2</span>+(binStr.charAt(i)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;<span class="comment">//负数</span></span><br><span class="line">          <span class="comment">//1. 取反</span></span><br><span class="line">           <span class="type">char</span>[]binstr=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">32</span>];</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">               <span class="keyword">if</span> (binStr.charAt(i)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                   binstr[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   binstr[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//2. 加一</span></span><br><span class="line">           <span class="type">boolean</span> is_plus=<span class="literal">true</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">               <span class="keyword">if</span>(binstr[i]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;is_plus)&#123;</span><br><span class="line">                   binstr[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                   is_plus=<span class="literal">false</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(binstr[i]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;is_plus)&#123;</span><br><span class="line">                   binstr[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//3. 累加计算</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;<span class="comment">//从0或者1开始都行，没影响</span></span><br><span class="line">               num=num*<span class="number">2</span>+(binstr[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//4. 取反</span></span><br><span class="line">           num=-num;</span><br><span class="line">       &#125;</span><br><span class="line">       String numStr=String.valueOf(num);</span><br><span class="line">       <span class="keyword">return</span> numStr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结：二进制补码和十进制整数相互转换："><a href="#总结：二进制补码和十进制整数相互转换：" class="headerlink" title="总结：二进制补码和十进制整数相互转换："></a>总结：二进制补码和十进制整数相互转换：</h2><ol>
<li>负数补码和对应正数补码转换<ul>
<li><strong>负数转补码</strong>：<ol>
<li>将负数的<strong>绝对值转换为二进制</strong>。</li>
<li>对二进制数<em><strong>逐位取反</strong></em>（0变1，1变0）。</li>
<li>对取反后的<strong>二进制数加1</strong>。</li>
</ol>
</li>
<li><strong>补码转负数</strong>：<ol>
<li>对<strong>补码逐位取反</strong>（0变1，1变0）。</li>
<li>对取反后的<strong>二进制数加1</strong>。</li>
<li>将结果int<strong>取负</strong>。</li>
</ol>
</li>
</ul>
</li>
<li>十进制整数转二进制补码：<ul>
<li>正数：<ol>
<li>使用<strong>除2取余法</strong>，从<strong>低位到高位依次填充</strong>二进制位。</li>
<li>符号位为0。</li>
</ol>
</li>
<li>负数：<ol>
<li>将负数的<strong>绝对值</strong>转换为二进制。</li>
<li>对二进制数逐位取反（0变1，1变0）。</li>
<li>对取反后的二进制数加1。</li>
<li>符号位为1。</li>
</ol>
</li>
</ul>
</li>
<li>二进制补码转十进制整数：<ul>
<li>正数：<ul>
<li>从<strong>第0位到第31位（从左开始！！）</strong>，<strong>逐位计算</strong>二进制数对应的十进制值。</li>
</ul>
</li>
<li>负数：<ol>
<li>对二进制数逐位取反（0变1，1变0）。</li>
<li>对取反后的二进制数加1。</li>
<li>从第0位到第31位，逐位计算二进制数对应的十进制值。</li>
<li>将结果取负。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="三、十进制整数的真值转化成NBCD"><a href="#三、十进制整数的真值转化成NBCD" class="headerlink" title="三、十进制整数的真值转化成NBCD"></a>三、十进制整数的真值转化成NBCD</h2><h3 id="1-NBCD"><a href="#1-NBCD" class="headerlink" title="1. NBCD"></a>1. NBCD</h3><ol>
<li>NBCD格式：<ol>
<li>符号位<ul>
<li><strong>正数：1100</strong></li>
<li><strong>负数：1101</strong></li>
</ul>
</li>
<li>每个十进制数字用4位二进制数表示。</li>
<li>确保NBCD表示一定是32位。<ul>
<li>在<strong>符号位和有效位之间</strong>填充<strong>0</strong>!</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="2-将单位十进制数字转化为4位二进制形式"><a href="#2-将单位十进制数字转化为4位二进制形式" class="headerlink" title="2.将单位十进制数字转化为4位二进制形式"></a>2.将单位十进制数字转化为4位二进制形式</h3><ul>
<li>除2取余法<ul>
<li><strong>先得到的余数</strong>作为<strong>低位有效位</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">CharTo4bit</span><span class="params">(Character character)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> character-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="type">char</span>[] stringOf4=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        stringOf4[i] = <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 初始化字符数组为&#x27;0&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//转换为二进制[除二取余法]</span></span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            stringOf4[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(stringOf4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-步骤"><a href="#3-步骤" class="headerlink" title="3. 步骤"></a>3. 步骤</h3><ol>
<li>将字符串转换为<strong>整数</strong>。</li>
<li>初始化一个 StringBuilder 用于构建NBCD字符串。</li>
<li>根据整数的符号设置<strong>符号位</strong>：<ul>
<li>正数：1100</li>
<li>负数：1101</li>
</ul>
</li>
<li>计算需要<strong>填充的零</strong>的数量，以确保NBCD表示是<strong>32位</strong>。</li>
<li>将<strong>每个十进制数字转换为4位二进制形式</strong>，并<strong>添加</strong>到 StringBuilder 中。</li>
<li>返回NBCD字符串。</li>
</ol>
<h3 id="4-【注意】语法"><a href="#4-【注意】语法" class="headerlink" title="4. 【注意】语法"></a>4. 【注意】语法</h3><ol>
<li>return <strong>new String(stringOf4)</strong>;<ul>
<li>适用于将<strong>字符数组char[]转换为字符串</strong>的场景</li>
</ul>
</li>
<li>return <strong>nbcdStr.toString()</strong>;<ul>
<li>适用于将<strong>StringBuilder对象转换为字符串</strong>的场景</li>
</ul>
</li>
</ol>
<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">decimalToNBCD</span><span class="params">(String decimalStr)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">nbcdStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(decimalStr);</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> decimalStr.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">zero_length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        zero_length=<span class="number">28</span>-<span class="number">4</span>*length;</span><br><span class="line">        nbcdStr.append(<span class="number">1100</span>);<span class="comment">//符号位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;zero_length;i++)&#123;<span class="comment">//填充零</span></span><br><span class="line">            nbcdStr.append(<span class="number">0000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            nbcdStr.append(CharTo4bit(decimalStr.charAt(i)));<span class="comment">//转换每个十进制数字,并添加到 StringBuilder 中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        zero_length=<span class="number">28</span>-<span class="number">4</span>*(length-<span class="number">1</span>);</span><br><span class="line">        nbcdStr.append(<span class="number">1101</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;zero_length;i++)&#123;</span><br><span class="line">            nbcdStr.append(<span class="number">0000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;<span class="comment">//把负号跳过</span></span><br><span class="line">            nbcdStr.append(CharTo4bit(decimalStr.charAt(i)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nbcdStr.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、-NBCD（符号位用4位表示）转化成十进制整数的真值"><a href="#四、-NBCD（符号位用4位表示）转化成十进制整数的真值" class="headerlink" title="四、 NBCD（符号位用4位表示）转化成十进制整数的真值"></a>四、 NBCD（符号位用4位表示）转化成十进制整数的真值</h2><h3 id="1-4位二进制-转-1位十进制：bit4ToChar"><a href="#1-4位二进制-转-1位十进制：bit4ToChar" class="headerlink" title="1. 4位二进制 转 1位十进制：bit4ToChar"></a>1. 4位二进制 转 1位十进制：bit4ToChar</h3><ul>
<li>从左到右，累加</li>
<li>num&#x3D;num*2+(<strong>bit4.charAt(i)-‘0’</strong>);</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">bit4ToChar</span><span class="params">(String bit4)</span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        num=num*<span class="number">2</span>+(bit4.charAt(i)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>初始化一个 StringBuilder 用于构建十进制字符串。</li>
<li>从第4位开始，<strong>每4位表示一个十进制数字</strong>，使用 <strong>bit4ToChar</strong> 方法将其转换为<strong>对应的十进制字符</strong>，并添加到 StringBuilder 中。</li>
<li><strong>去除前面多余的0</strong>（<strong>保留至少一位，以满足数为0</strong>）。</li>
<li>将 StringBuilder 转换为字符串，并解析为整数。</li>
<li>根据符号位确定结果<strong>是否为负数</strong>。</li>
<li>返回十进制字符串。</li>
</ol>
<h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">NBCDToDecimal</span><span class="params">(String NBCDStr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    StringBuilder num_sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();   <span class="comment">//初始化 StringBuilder</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>;i&lt;<span class="number">32</span>;i+=<span class="number">4</span>)&#123;       <span class="comment">//转换每个4位二进制数字</span></span><br><span class="line">        num_sb.append(bit4ToChar(NBCDStr.substring(i,i+<span class="number">4</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去除前面多余的0（留一位，以满足数为0）</span></span><br><span class="line">    <span class="type">int</span> length=num_sb.length();</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num_sb.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>&amp;&amp;length!=<span class="number">1</span>)&#123;       <span class="comment">//去除前面多余的0(留1位)</span></span><br><span class="line">        num_sb.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">        length=num_sb.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">demical</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(num_sb);</span><br><span class="line">    num=Integer.parseInt(demical);      <span class="comment">//解析为整数</span></span><br><span class="line">    <span class="keyword">if</span> (NBCDStr.substring(<span class="number">0</span>, <span class="number">4</span>).equals(<span class="string">&quot;1101&quot;</span>))&#123;    <span class="comment">//负数判断</span></span><br><span class="line">        num=-num;</span><br><span class="line">    &#125;</span><br><span class="line">    demical=String.valueOf(num);        <span class="comment">//转为字符串</span></span><br><span class="line">    <span class="keyword">return</span> demical;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将4位二进制字符串转换为对应的十进制字符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">bit4ToChar</span><span class="params">(String binStr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        num = num * <span class="number">2</span> + (binStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>) (num + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、将浮点数真值转化成32位单精度浮点数表示"><a href="#五、将浮点数真值转化成32位单精度浮点数表示" class="headerlink" title="五、将浮点数真值转化成32位单精度浮点数表示"></a>五、将浮点数真值转化成32位单精度浮点数表示</h2><h3 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h3><ul>
<li>如果<strong>8位指数位全为0</strong>, 就代表当前数是个<strong>非规格数</strong>. 或者说, 形如 * 00000000 *********************** 格式的数就是非规格数.<ul>
<li>用于表示0, 以及非常靠近0的数, 比如1E-38.</li>
<li><strong>非规格数的实际指数固定为-126</strong></li>
</ul>
</li>
<li>如果<strong>8位指数位全为1</strong>, 就代表当前数是个<strong>特殊数</strong>. 或者说, 形如 * 11111111 *********************** 格式的数就是特殊数.<ul>
<li><strong>无穷大</strong>和<strong>NaN</strong></li>
</ul>
</li>
</ul>
<h3 id="1-0"><a href="#1-0" class="headerlink" title="1. 0"></a>1. 0</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (num == <span class="number">0.0f</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;00000000000000000000000000000000&quot;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="2-NaN"><a href="#2-NaN" class="headerlink" title="2.NaN"></a>2.NaN</h3><ol>
<li>符号位：0或1</li>
<li>指数位：<strong>11111111</strong></li>
<li>尾数位：任意非零值（通常为<strong>10000000000000000000000</strong>）</li>
</ol>
<ul>
<li>一般表示用：<strong>0 11111111 10000000000000000000000</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Float.isNaN(num)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;01111111110000000000000000000000&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-无穷大"><a href="#3-无穷大" class="headerlink" title="3. 无穷大"></a>3. 无穷大</h3><ol>
<li>8位指数位全为1：<strong>11111111</strong></li>
<li>23位尾数位全为0：<strong>00000000000000000000000</strong></li>
</ol>
<ul>
<li>正无穷：01111111100000000000000000000000</li>
<li>负无穷：11111111100000000000000000000000</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (num == Float.POSITIVE_INFINITY)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;+Inf&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&lt;=Float.NEGATIVE_INFINITY)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;-Inf&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-非规格数"><a href="#4-非规格数" class="headerlink" title="4. 非规格数"></a>4. 非规格数</h3><h3 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h3><ol>
<li>特殊情况处理<ol>
<li>零</li>
<li>正负无穷：num &#x3D;&#x3D; <strong>Float.POSITIVE_INFINITY</strong></li>
<li>NaN: <strong>if (Float.isNaN(num))</strong></li>
</ol>
</li>
<li>正常情况处理<ol>
<li>正负</li>
<li>调整尾数到1.f~2.f范围：（指数初始为0）<ul>
<li>尾数偏大时，除以2，指数加1。<code>while (num &gt;= 2.0f)</code></li>
<li>尾数偏小时，乘以2，指数减1。<code>while (num &lt; 1.0f &amp;&amp; exponent &gt; -126)</code><ul>
<li>如果指数减小到了<code>-126</code>，则<strong>非规格化数</strong>！</li>
</ul>
</li>
</ul>
</li>
<li>规格化判断<ul>
<li>非规格化数：如果<strong>实际指数为-126，则指数部分全为0</strong>，<strong>尾数不变</strong>（已经小于1.0f了）。</li>
<li>规格化数：尾数<strong>减去1.0f</strong>，指数<strong>加偏移量127</strong>。</li>
</ul>
</li>
<li>构建IEEE 754二进制字符串：<ul>
<li>符号位：1位</li>
<li>指数位：8位——<strong>除二取余法</strong></li>
<li><strong>尾数位</strong>：23位——<strong>乘二减一法</strong>：<ul>
<li>如果乘二之后大于1.0f，则1；否则0。</li>
<li>先出现的在左！</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">floatToBinary</span><span class="params">(String floatStr)</span> &#123;</span><br><span class="line">       <span class="type">float</span> <span class="variable">num</span> <span class="operator">=</span> Float.parseFloat(floatStr);</span><br><span class="line">       <span class="comment">//1、0</span></span><br><span class="line">       <span class="keyword">if</span>(num==<span class="number">0</span>)&#123;</span><br><span class="line">           String zeroStr=<span class="string">&quot;00000000000000000000000000000000&quot;</span>;</span><br><span class="line">           <span class="keyword">return</span> zeroStr;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2.+Inf和-Inf（正负无穷）</span></span><br><span class="line">       <span class="keyword">if</span> (num == Float.POSITIVE_INFINITY)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;+Inf&quot;</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&lt;=Float.NEGATIVE_INFINITY)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;-Inf&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3.NaN</span></span><br><span class="line">       <span class="keyword">if</span>(Float.isNaN(num))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;01111111110000000000000000000000&quot;</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Float.isNaN(-num))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;11111111110000000000000000000000&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//4. 正常情况</span></span><br><span class="line">       <span class="comment">//4.1判断正负</span></span><br><span class="line">       <span class="type">boolean</span> is_neg=<span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">if</span>(num&lt;<span class="number">0</span>)&#123;</span><br><span class="line">           is_neg=<span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> exponent=<span class="number">0</span>;<span class="comment">//指数</span></span><br><span class="line">       <span class="comment">//尾数</span></span><br><span class="line">       <span class="type">int</span> offset=<span class="number">127</span>;;<span class="comment">//偏移量</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//4.2 调整尾数到1.f~2.f范围</span></span><br><span class="line">       <span class="keyword">if</span>(num&lt;<span class="number">0</span>)&#123;</span><br><span class="line">           num=-num;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (num&gt;=<span class="number">2.0f</span>)&#123;   <span class="comment">//尾数偏大</span></span><br><span class="line">           num/=<span class="number">2.0f</span>;</span><br><span class="line">           exponent++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (num&lt;<span class="number">1.0f</span>&amp;&amp;exponent&gt;-<span class="number">126</span>)&#123;    <span class="comment">//尾数偏小</span></span><br><span class="line">           num*=<span class="number">2.0f</span>;</span><br><span class="line">           exponent--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//4.3 规格化判断</span></span><br><span class="line">       <span class="keyword">if</span> (exponent &lt;=-<span class="number">126</span>) &#123;</span><br><span class="line">           exponent = <span class="number">0</span>; <span class="comment">// 非规格化数，指数部分全为0(实际指数固定为-126)</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           num -= <span class="number">1.0f</span>; <span class="comment">// 规格化数，尾数减去1</span></span><br><span class="line">           exponent += offset; <span class="comment">// 加偏移量</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//4.4 化为IEEE</span></span><br><span class="line">       StringBuilder binFloat=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">       <span class="comment">//符号位</span></span><br><span class="line">       <span class="keyword">if</span> (is_neg)&#123;</span><br><span class="line">           binFloat.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           binFloat.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//指数位</span></span><br><span class="line">       <span class="type">char</span>[] exp = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">8</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">7</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">           <span class="keyword">if</span>(exponent%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">               exp[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               exp[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           exponent/=<span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//尾数位</span></span><br><span class="line">       <span class="type">char</span>[]wei=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">23</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">23</span>;i++)&#123;</span><br><span class="line">           num*=<span class="number">2.0f</span>;</span><br><span class="line">           <span class="keyword">if</span>(num&gt;=<span class="number">1.0f</span>)&#123;</span><br><span class="line">               wei[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">               num-=<span class="number">1.0f</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               wei[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">expStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(exp);</span><br><span class="line">       String weiStr=<span class="keyword">new</span> <span class="title class_">String</span>(wei);</span><br><span class="line">       binFloat.append(expStr);</span><br><span class="line">       binFloat.append(weiStr);</span><br><span class="line">       <span class="keyword">return</span> binFloat.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、32位单精度浮点数表示转化成浮点数真值"><a href="#六、32位单精度浮点数表示转化成浮点数真值" class="headerlink" title="六、32位单精度浮点数表示转化成浮点数真值"></a>六、32位单精度浮点数表示转化成浮点数真值</h2><h3 id="1-特殊情况"><a href="#1-特殊情况" class="headerlink" title="1. 特殊情况"></a>1. 特殊情况</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 0</span></span><br><span class="line">        <span class="keyword">if</span>(binStr==<span class="string">&quot;00000000000000000000000000000000&quot;</span>)&#123;</span><br><span class="line">            <span class="type">Float</span> <span class="variable">zero</span> <span class="operator">=</span> <span class="number">0.0f</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(zero);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. NaN</span></span><br><span class="line">        <span class="keyword">if</span>(binStr==<span class="string">&quot;01111111110000000000000000000000&quot;</span>)&#123;</span><br><span class="line">           <span class="type">Float</span> <span class="variable">nan</span> <span class="operator">=</span> Float.NaN;</span><br><span class="line">           <span class="keyword">return</span> String.valueOf(nan);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 正负无穷</span></span><br><span class="line">        <span class="keyword">if</span>(binStr==<span class="string">&quot;01111111100000000000000000000000&quot;</span>)&#123;</span><br><span class="line">           Float pos_inf=Float.POSITIVE_INFINITY;</span><br><span class="line">           <span class="keyword">return</span> String.valueOf(pos_inf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(binStr==<span class="string">&quot;11111111100000000000000000000000&quot;</span>)&#123;</span><br><span class="line">            Float neg_inf=Float.NEGATIVE_INFINITY;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(neg_inf);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-正常情况（规格化数-非规格化数）"><a href="#2-正常情况（规格化数-非规格化数）" class="headerlink" title="2. 正常情况（规格化数+非规格化数）"></a>2. 正常情况（规格化数+非规格化数）</h3><ol>
<li>符号位</li>
<li>指数位<ul>
<li>提取指数位的8位二进制数，并转换为整数。</li>
<li>对于<strong>规格化数</strong>，<strong>减去偏移量127</strong>。</li>
<li>对于<strong>非规格化数（指数位等于0）</strong>，<strong>实际指数为-126</strong>。</li>
</ul>
</li>
<li>尾数位：<ul>
<li>提取尾数位的23位二进制数，并转换为浮点数。</li>
<li>对于规格化数，尾数部分隐含一个1。<strong>规格化数，加1.0f</strong></li>
</ul>
</li>
<li>计算浮点数值：<ul>
<li>根据指数调整尾数的值&#x2F;直接算（注意<strong>double和float的转换</strong>）<ul>
<li><em><em>float num&#x3D;weishu</em>(float)Math.pow(2,exponent);</em>*</li>
</ul>
</li>
<li>如果符号位为1，则结果为负数。</li>
</ul>
</li>
</ol>
<h3 id="完整代码-4"><a href="#完整代码-4" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">binaryToFloat</span><span class="params">(String binStr)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 0</span></span><br><span class="line">        <span class="keyword">if</span>(binStr==<span class="string">&quot;00000000000000000000000000000000&quot;</span>)&#123;</span><br><span class="line">            <span class="type">Float</span> <span class="variable">zero</span> <span class="operator">=</span> <span class="number">0.0f</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(zero);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. NaN</span></span><br><span class="line">        <span class="keyword">if</span>(binStr==<span class="string">&quot;01111111110000000000000000000000&quot;</span>)&#123;</span><br><span class="line">           <span class="type">Float</span> <span class="variable">nan</span> <span class="operator">=</span> Float.NaN;</span><br><span class="line">           <span class="keyword">return</span> String.valueOf(nan);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 正负无穷</span></span><br><span class="line">        <span class="keyword">if</span>(binStr==<span class="string">&quot;01111111100000000000000000000000&quot;</span>)&#123;</span><br><span class="line">           Float pos_inf=Float.POSITIVE_INFINITY;</span><br><span class="line">           <span class="keyword">return</span> String.valueOf(pos_inf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(binStr==<span class="string">&quot;11111111100000000000000000000000&quot;</span>)&#123;</span><br><span class="line">            Float neg_inf=Float.NEGATIVE_INFINITY;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(neg_inf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4. 正常情况</span></span><br><span class="line">        <span class="comment">//4.1 正负</span></span><br><span class="line">        <span class="type">boolean</span> is_neg=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(binStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            is_neg=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.2指数</span></span><br><span class="line">        <span class="type">int</span> exponent=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">            exponent=exponent*<span class="number">2</span>+(binStr.charAt(i+<span class="number">1</span>)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(exponent!=<span class="number">0</span>)&#123;</span><br><span class="line">            exponent-=<span class="number">127</span>;<span class="comment">//规格数</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            exponent=-<span class="number">126</span>;<span class="comment">//非规格数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.3 尾数</span></span><br><span class="line">        <span class="type">float</span> weishu=<span class="number">0.0f</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">Add</span> <span class="operator">=</span> <span class="number">0.5f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">9</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(binStr.charAt(i)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                weishu+=Add;</span><br><span class="line">            &#125;</span><br><span class="line">            Add/=<span class="number">2.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exponent!=-<span class="number">126</span>)&#123;<span class="comment">//规格化数，加1.0f</span></span><br><span class="line">            weishu+=<span class="number">1.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.计算</span></span><br><span class="line">        <span class="keyword">while</span> (exponent&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            weishu*=<span class="number">2.0f</span>;</span><br><span class="line">            exponent--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (exponent&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            weishu/=<span class="number">2.0f</span>;</span><br><span class="line">            exponent++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(is_neg)&#123;</span><br><span class="line">            weishu=-weishu;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//法2：直接算</span></span><br><span class="line"><span class="comment">//        float num=weishu*(float)Math.pow(2,exponent);</span></span><br><span class="line"><span class="comment">//        if (is_neg)&#123;</span></span><br><span class="line"><span class="comment">//            num=-num;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">return</span> String.valueOf(weishu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>2-补码加减乘除</title>
    <url>/2025/02/22/2.%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/</url>
    <content><![CDATA[<h2 id="一-计算两个32位二进制整数补码真值的和"><a href="#一-计算两个32位二进制整数补码真值的和" class="headerlink" title="一. 计算两个32位二进制整数补码真值的和"></a>一. 计算两个32位二进制整数补码真值的和</h2><h3 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1. 步骤"></a>1. 步骤</h3><ol>
<li>初始化：将 src 和 dest 转换为字符串形式，并初始化一个 StringBuilder 来存储结果。</li>
<li>逐位相加：从最低位（第31位）开始逐位相加，<strong>考虑进位情况</strong>。</li>
<li>处理进位：根据<strong>当前位的和以及是否有进位</strong>，决定<strong>当前位的结果和是否产生新的进位</strong>。</li>
<li><strong>结果反转</strong>：由于结果是从最低位开始添加的，<strong>最终需要反转字符串以得到正确的顺序</strong>。</li>
<li>返回结果：将结果转换为 DataType 并返回。<ul>
<li>DataType ans &#x3D; <strong>new DataType(ansStr)</strong>;</li>
</ul>
</li>
</ol>
<h3 id="2-【注意】结果反转"><a href="#2-【注意】结果反转" class="headerlink" title="2. 【注意】结果反转"></a>2. 【注意】结果反转</h3><ul>
<li><code>String ans = ansStr.reverse().toString();</code></li>
<li><strong>StringBulider</strong>才能用<code>.reverse()</code>; String不能用</li>
</ul>
<h3 id="3-完整代码"><a href="#3-完整代码" class="headerlink" title="3. 完整代码"></a>3. 完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">add</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">       String srcStr=src.toString();</span><br><span class="line">       String destStr=dest.toString();</span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">ansStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">destInt</span> <span class="operator">=</span> destStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           <span class="type">int</span> <span class="variable">srcInt</span> <span class="operator">=</span> srcStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           <span class="keyword">if</span> (!carry) &#123;<span class="comment">//无进位</span></span><br><span class="line">               <span class="keyword">if</span> (destInt + srcInt == <span class="number">2</span>) &#123;</span><br><span class="line">                   carry = <span class="literal">true</span>;</span><br><span class="line">                   ansStr.append(<span class="number">0</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span>(destInt+srcInt==<span class="number">1</span>)&#123;</span><br><span class="line">                   ansStr.append(<span class="number">1</span>);</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   ansStr.append(<span class="number">0</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;<span class="comment">//有进位</span></span><br><span class="line">               <span class="keyword">if</span> (destInt + srcInt == <span class="number">2</span>) &#123;</span><br><span class="line">                   ansStr.append(<span class="number">1</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span>(destInt+srcInt==<span class="number">1</span>)&#123;</span><br><span class="line">                   ansStr.append(<span class="number">0</span>);</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   ansStr.append(<span class="number">1</span>);</span><br><span class="line">                   carry=<span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">DataType</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(ansStr.reverse().toString());</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-更简单："><a href="#4-更简单：" class="headerlink" title="4. 更简单："></a>4. 更简单：</h3><ul>
<li>int sum &#x3D; num1 + num2 + carry;</li>
<li>result.append(sum % 2);</li>
<li>carry &#x3D; sum &#x2F; 2;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">add</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">srcStr</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">destStr</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> srcStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> destStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> num1 + num2 + carry;</span><br><span class="line">        result.append(sum % <span class="number">2</span>);</span><br><span class="line">        carry = sum / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(result.reverse().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、计算两个32位二进制整数补码真值的差"><a href="#二、计算两个32位二进制整数补码真值的差" class="headerlink" title="二、计算两个32位二进制整数补码真值的差"></a>二、计算两个32位二进制整数补码真值的差</h2><ul>
<li>dest表示被减数，src表示减数(即计算dest - src)</li>
</ul>
<h3 id="1-取反操作"><a href="#1-取反操作" class="headerlink" title="1. 取反操作"></a>1. 取反操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">negation</span><span class="params">(String beforeStr)</span>&#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">afterStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">//逐位取反</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (beforeStr.charAt(i)==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            afterStr.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            afterStr.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加1</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(carry)&#123;<span class="comment">//有进位</span></span><br><span class="line">            <span class="keyword">if</span>(afterStr.charAt(i)==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                afterStr.replace(i,i+<span class="number">1</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                carry=<span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                afterStr.replace(i,i+<span class="number">1</span>,<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> afterStr.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-完整代码"><a href="#2-完整代码" class="headerlink" title="2.完整代码"></a>2.完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">sub</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    String srcStr=src.toString();</span><br><span class="line">    srcStr=negation(srcStr);</span><br><span class="line">    src = <span class="keyword">new</span> <span class="title class_">DataType</span>(srcStr);</span><br><span class="line">    <span class="keyword">return</span> add(src,dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、两个二进制整数的乘积-布斯乘法，结果低位截取后32位"><a href="#三、两个二进制整数的乘积-布斯乘法，结果低位截取后32位" class="headerlink" title="三、两个二进制整数的乘积(布斯乘法，结果低位截取后32位)"></a>三、两个二进制整数的乘积(布斯乘法，结果低位截取后32位)</h2><h3 id="1-布斯乘法"><a href="#1-布斯乘法" class="headerlink" title="1.布斯乘法"></a>1.布斯乘法</h3><ol>
<li>正负数处理：<ul>
<li>检查 src 和 dest 是否为负数，如果是负数，则将其<strong>转换为正数</strong>。</li>
</ul>
</li>
<li>初始化：<ol>
<li>初始化 <strong>resultStr</strong> 为<strong>65位字符串</strong>，其中<strong>前32位为0，后32位为 dest，并在末尾添一个0</strong>。<ul>
<li><strong>32个0+dest+0</strong></li>
</ul>
</li>
</ol>
</li>
<li>迭代计算：<ul>
<li>对 resultStr 进行<strong>32次迭代</strong>；第一次是<strong>0-最低位</strong></li>
<li>每次根据 resultStr 的最低位和次低位的组合（<strong>最低位-次低位</strong>）决定是否进行加法或减法操作。<ul>
<li>如果组合为 <strong>01（1）</strong>，则将 <strong>resultStr的高32位 + src</strong>。</li>
<li>如果组合为 10（-1），则将<strong>resultStr的高32位 - src</strong>。</li>
<li>如果组合为 11或00（0），则不变。</li>
<li>进行<strong>算术右移操作（保留符号位）</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>重复：<ul>
<li>重复上述迭代步骤，直到处理完乘数的所有位。</li>
</ul>
</li>
<li>结果：<ul>
<li>截取 resultStr 的**低32位（33~64）**作为最终结果</li>
<li>如果原始 src 和 dest 中有一个是负数，则将结果取反。</li>
</ul>
</li>
</ol>
<h3 id="2-算术右移方法："><a href="#2-算术右移方法：" class="headerlink" title="2. 算术右移方法："></a>2. 算术右移方法：</h3><ol>
<li>符号位不变</li>
<li>原本的64位整体右移</li>
</ol>
<ul>
<li>相当于<strong>前面变成两个符号位，最后一位丢掉</strong></li>
</ul>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">mul</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    String srcStr=src.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">destStr</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="comment">//1.判断正负，如果负，则标记并转为正</span></span><br><span class="line">    <span class="type">boolean</span> srcNeg=<span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> destNeg=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(srcStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">        srcNeg=<span class="literal">true</span>;</span><br><span class="line">        srcStr=negation(srcStr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(destStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">        destNeg=<span class="literal">true</span>;</span><br><span class="line">        destStr=negation(destStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.初始化</span></span><br><span class="line">    StringBuilder resultStr=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;0&quot;</span>.repeat(<span class="number">32</span>)+destStr+<span class="string">&quot;0&quot;</span>);<span class="comment">//result，32个0+dest+0组成</span></span><br><span class="line">    <span class="comment">//3.计算</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">32</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        DataType src1=<span class="keyword">new</span> <span class="title class_">DataType</span>(srcStr);</span><br><span class="line">        DataType dest1=<span class="keyword">new</span> <span class="title class_">DataType</span>(resultStr.substring(<span class="number">0</span>,<span class="number">32</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">32</span>)&#123;<span class="comment">//第1位（补充了一个0）</span></span><br><span class="line">            <span class="keyword">if</span>(destStr.charAt(<span class="number">31</span>)-<span class="string">&#x27;0&#x27;</span>==<span class="number">0</span>)&#123;<span class="comment">//0：右移</span></span><br><span class="line">                resultStr= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(rightshift(resultStr.toString()));<span class="comment">//右移</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//-1：减src，再右移</span></span><br><span class="line">                resultStr.replace(<span class="number">0</span>,<span class="number">32</span>,sub(src1,dest1).toString());</span><br><span class="line">                resultStr= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(rightshift(resultStr.toString()));<span class="comment">//右移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//其它位</span></span><br><span class="line">            <span class="keyword">if</span>(destStr.charAt(i)-destStr.charAt(i-<span class="number">1</span>)==<span class="number">0</span>)&#123;<span class="comment">//0：右移</span></span><br><span class="line">                resultStr= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(rightshift(resultStr.toString()));<span class="comment">//右移</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>  <span class="keyword">if</span>(destStr.charAt(i)-destStr.charAt(i-<span class="number">1</span>)==<span class="number">1</span>)&#123;<span class="comment">//1：加src，再右移</span></span><br><span class="line">                resultStr.replace(<span class="number">0</span>,<span class="number">32</span>,add(src1,dest1).toString());</span><br><span class="line">                resultStr= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(rightshift(resultStr.toString()));<span class="comment">//右移</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//-1：减src，再右移</span></span><br><span class="line">                resultStr.replace(<span class="number">0</span>,<span class="number">32</span>,sub(src1,dest1).toString());</span><br><span class="line">                resultStr= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(rightshift(resultStr.toString()));<span class="comment">//右移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.结果：截取低32位</span></span><br><span class="line">    String result=resultStr.substring(<span class="number">32</span>,<span class="number">64</span>);</span><br><span class="line">    <span class="comment">//正负调整</span></span><br><span class="line">    <span class="keyword">if</span>((srcNeg&amp;&amp;!destNeg)||(!srcNeg&amp;&amp;destNeg))&#123;</span><br><span class="line">        result =negation(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">rightshift</span><span class="params">(String beforeStr)</span>&#123;<span class="comment">//右移</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">afterStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    afterStr.append(beforeStr.charAt(<span class="number">0</span>));<span class="comment">//保留符号位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">64</span>;i++)&#123;</span><br><span class="line">        afterStr.append(beforeStr.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> afterStr.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、两个二进制整数的除法"><a href="#四、两个二进制整数的除法" class="headerlink" title="四、两个二进制整数的除法"></a>四、两个二进制整数的除法</h2><ul>
<li><strong>恢复余数除法</strong>和<strong>不恢复余数除法</strong>均可</li>
<li>dest ÷ src</li>
<li>将32位余数正确储存在余数寄存器remainderReg中</li>
<li>除数为0，且被除数不为0时要求能够正确抛出ArithmeticException<strong>异常</strong>。</li>
</ul>
<h3 id="1-恢复余数除法"><a href="#1-恢复余数除法" class="headerlink" title="1. 恢复余数除法"></a>1. 恢复余数除法</h3><ol start="0">
<li>（此代码中）正负调整(【Datatype】src和【String】srcStr都要)</li>
<li>初始化：<ul>
<li>被除数（Dividend）和除数（Divisor）分别存储在寄存器中。</li>
<li><strong>余数</strong>寄存器（Remainder）初始化为<strong>32位的0</strong>。</li>
<li><strong>商</strong>寄存器（Quotient）初始化为<strong>被除数</strong>。</li>
</ul>
</li>
<li>迭代：对<strong>被除数的每一位</strong>进行处理，从<strong>最高位到最低位</strong>。<ol>
<li>将<strong>余数左移一位</strong>，并将<strong>被除数的当前位移入余数的最低位</strong>。</li>
<li><strong>余数减去&#x2F;加上除数</strong>。<ul>
<li>如果余数<strong>与原本异号</strong>，则<strong>恢复余数（加回除数）</strong>，并将<strong>商的当前位设为0</strong>。</li>
<li>如果余数<strong>与原本同号</strong>，则将商的当前位<strong>设为1</strong>。</li>
</ul>
</li>
</ol>
</li>
<li>结果：<ul>
<li>（此代码中）调整<strong>余数和商的符号</strong></li>
<li>迭代完成后，商寄存器中存储的值即为商，余数寄存器中存储的值即为余数。</li>
</ul>
</li>
</ol>
<h3 id="2-不恢复余数除法"><a href="#2-不恢复余数除法" class="headerlink" title="2. 不恢复余数除法"></a>2. 不恢复余数除法</h3><ol>
<li>初始化：<ul>
<li>被除数（Dividend）和除数（Divisor）分别存储在寄存器中。</li>
<li>余数寄存器（Remainder）初始化为0。</li>
<li>商寄存器（Quotient）初始化为被除数。</li>
</ul>
</li>
<li>迭代： 对被除数的每一位进行处理，从最高位到最低位。<ol>
<li>将<strong>余数左移一位</strong>，并将<strong>被除数的当前位移入余数的最低位</strong>。</li>
<li>余数减去&#x2F;加上除数。<ul>
<li>如果余数<strong>与原本异号</strong>，则将商的当前位设为0，并在<strong>下一次迭代中将余数加回除数</strong>。</li>
<li>如果余数<strong>与原本同号</strong>，则将商的当前位设为1，并在<strong>下一次迭代中继续减去除数</strong>。</li>
</ul>
</li>
</ol>
</li>
<li>结果：<ul>
<li>根据被除数和除数的符号，调整商和余数的符号：<ul>
<li><strong>被除数和除数同号：余数+除数</strong>，商为正</li>
<li><strong>被除数和除数异号：余数-除数</strong>，商为负</li>
</ul>
</li>
<li>迭代完成后，商寄存器中存储的值即为商，余数寄存器中存储的值即为余数。</li>
</ul>
</li>
</ol>
<h3 id="3-调整余数和商的符号"><a href="#3-调整余数和商的符号" class="headerlink" title="3. 调整余数和商的符号"></a>3. 调整余数和商的符号</h3><ol>
<li><strong>余数和被除数同号</strong></li>
<li>其中<strong>一方为负，则商取负</strong></li>
</ol>
<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataType remainderReg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回两个二进制整数的除法结果</span></span><br><span class="line"><span class="comment"> * dest ÷ src</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src  32-bits</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest 32-bits</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 32-bits</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//用恢复余数除法</span></span><br><span class="line"><span class="keyword">public</span> DataType <span class="title function_">div</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">srcStr</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">destStr</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="comment">//0.判断除0情况</span></span><br><span class="line">    <span class="keyword">if</span>(srcStr.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;除0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 判断正负，如果是负就转正，并标记</span></span><br><span class="line">    <span class="type">boolean</span> srcNeg=<span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">destNeg</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(srcStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">        srcStr=negation(srcStr);</span><br><span class="line">        src=<span class="keyword">new</span> <span class="title class_">DataType</span>(srcStr);<span class="comment">//保证src也变号</span></span><br><span class="line">        srcNeg=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(destStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">        destStr=negation(destStr);</span><br><span class="line">        dest = <span class="keyword">new</span> <span class="title class_">DataType</span>(destStr);<span class="comment">//保证dest也变号</span></span><br><span class="line">        destNeg=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 初始化-商和余数寄存器</span></span><br><span class="line">    StringBuilder Shang=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(destStr);<span class="comment">//商，初始化为被除数</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">Yu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;0&quot;</span>.repeat(<span class="number">32</span>));<span class="comment">//余数，初始化为32个0</span></span><br><span class="line">    <span class="comment">//3. 计算</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//3.1左移</span></span><br><span class="line">        Yu=leftshift(Yu.toString());</span><br><span class="line">        Yu.append(Shang.charAt(<span class="number">0</span>));</span><br><span class="line">        Shang=leftshift(Shang.toString());</span><br><span class="line">        <span class="comment">//3.2 余数减去除数</span></span><br><span class="line">        String tmp=sub(src,<span class="keyword">new</span> <span class="title class_">DataType</span>(Yu.toString())).toString();</span><br><span class="line">        <span class="keyword">if</span>(tmp.charAt(<span class="number">0</span>)==<span class="string">&#x27;1&#x27;</span>)&#123;<span class="comment">//为负</span></span><br><span class="line">            Shang.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//非负</span></span><br><span class="line">            Yu=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(tmp);</span><br><span class="line">            Shang.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.结果</span></span><br><span class="line">    String YuStr= Yu.toString();</span><br><span class="line">    String ShangStr= Shang.toString();</span><br><span class="line">    <span class="comment">//被除数和余数同号</span></span><br><span class="line">    <span class="keyword">if</span>(!srcNeg&amp;&amp;destNeg)&#123;<span class="comment">//除数正，被除数负</span></span><br><span class="line">        YuStr=negation(YuStr);</span><br><span class="line">        ShangStr=negation(ShangStr);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (srcNeg&amp;&amp;!destNeg) &#123;<span class="comment">//除数负，被除数正</span></span><br><span class="line">        ShangStr=negation(YuStr);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(srcNeg&amp;&amp;destNeg)&#123;<span class="comment">//都是负</span></span><br><span class="line">        YuStr=negation(YuStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remainderReg=<span class="keyword">new</span> <span class="title class_">DataType</span>(YuStr);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(ShangStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左移</span></span><br><span class="line"><span class="keyword">public</span> StringBuilder <span class="title function_">leftshift</span><span class="params">(String beforeStr)</span>&#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">afterStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">32</span>;i++)&#123;<span class="comment">//跳过第一位</span></span><br><span class="line">        afterStr.append(beforeStr.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> afterStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>3-浮点数加减乘除</title>
    <url>/2025/02/22/3.%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/</url>
    <content><![CDATA[<h2 id="一、计算两个浮点数真值的和"><a href="#一、计算两个浮点数真值的和" class="headerlink" title="一、计算两个浮点数真值的和"></a>一、计算两个浮点数真值的和</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol start="0">
<li><p><strong>边界情况</strong>处理：NaN、0和无穷大</p>
</li>
<li><p><strong>提取</strong>浮点数的符号位、指数和尾数</p>
<ul>
<li>假设有两个浮点数 A 和 B，它们的 IEEE 32 位表示分别为：</li>
<li>A: 符号位 S_A，指数 E_A，尾数 M_A；</li>
<li>B: 符号位 S_B，指数 E_B，尾数 M_B。</li>
</ul>
</li>
<li><p><strong>对齐指数</strong></p>
<ul>
<li>若两个数的指数不相等，则需要调整尾数，使两个数的指数相同。</li>
<li>比较 A 和 B 的指数：（变<strong>更小的</strong>）<ul>
<li>如果<strong>E_A &gt; E_B</strong>，则将<strong>B的尾数右移E_A-E_B位</strong>，直到它们的指数对齐。</li>
<li>如果<strong>E_A &lt; E_B</strong>，则将<strong>A的尾数右移E_B-E_A位</strong>，直到它们的指数对齐。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>尾数执行加法或减法</strong></p>
<ul>
<li>如果尾数隐藏位1被右移了，那么<strong>默认补0</strong></li>
<li>检查符号位并进行相应的运算：</li>
</ul>
<ol>
<li><strong>加法</strong>：<ul>
<li>如果A和B<strong>同号</strong>，则<strong>直接将尾数相加</strong>。</li>
<li>如果A和B<strong>异号</strong>，则<strong>将尾数相减</strong>，<strong>符号位为较大尾数的符号</strong>。</li>
</ul>
</li>
<li><strong>减法</strong>：<ul>
<li>如果A和B<strong>异号</strong>，则同样是<strong>尾数相加</strong>，<strong>符号位为较大尾数的符号</strong>。</li>
<li>如果A和B<strong>同号</strong>，则进行<strong>尾数的减法</strong>，<strong>符号位为较大尾数的符号</strong>。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>规范化</strong>结果</p>
<ol>
<li><strong>溢出</strong>处理：<ul>
<li>如果尾数<strong>长度超过27位</strong>，说明需要<strong>右移尾数并增加阶码</strong>。</li>
<li>如果阶码<strong>超过255（即8位全为1）</strong>，则发生溢出，返回<strong>正无穷或负无穷</strong>。</li>
</ul>
</li>
<li><strong>下溢</strong>处理：<ul>
<li>如果尾数<strong>长度小于27位</strong>，需要<strong>左移尾数并减少阶码</strong>，直到<strong>尾数达到27位或阶码减为0</strong>。</li>
<li>如果<strong>阶码减为0</strong>，说明结果是<strong>非规格化数</strong>，<strong>尾数需要去掉最高位</strong>。</li>
</ul>
</li>
<li>eg<ul>
<li>例如，如果计算结果是 0.101…（即头部是0），则需要左移尾数1位，并将指数调整（阶码-1）。</li>
<li>例如，如果计算结果是 10.101…（即头部是10），则需要右移尾数1位，并将指数调整（阶码+1）。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>截断尾数并舍入</strong>（不要求掌握，给出了函数）</p>
<ol>
<li>确定舍入位：找到需要舍入的位，即尾数的第24位（对于单精度浮点数）。</li>
<li>检查舍入位及其后面的位：<ul>
<li>如果舍入位是0，则直接截断，不需要舍入。</li>
<li>如果舍入位是1，则需要进一步检查其后的位。</li>
</ul>
</li>
<li>根据舍入规则进行舍入：<ul>
<li>如果舍入位后的所有位都是0，则直接截断。</li>
<li>如果舍入位后的位不全是0，或者舍入位前的位是奇数，则向上舍入，即尾数加1。</li>
</ul>
</li>
</ol>
</li>
<li><p>组合符号、指数和尾数</p>
<ul>
<li>最后，将计算后的符号位、指数（加上 127 偏移量）和尾数组合成最终的 IEEE 32 位浮点数。</li>
</ul>
</li>
</ol>
<h3 id="处理溢出-下溢情况"><a href="#处理溢出-下溢情况" class="headerlink" title="处理溢出&#x2F;下溢情况"></a>处理溢出&#x2F;下溢情况</h3><ol>
<li>溢出处理<ul>
<li>当计算结果的阶码超过了浮点数的最大可表示值时，发生溢出。处理方法通常是将结果设为正无穷或负无穷，具体取决于结果的符号。</li>
</ul>
</li>
<li>下溢处理<br>当计算结果的阶码小于浮点数的最小可表示值时，发生下溢。处理方法通常是将结果设为0，或者在某些情况下，使用次正规数（Subnormal Numbers）来表示非常小的值。</li>
</ol>
<h3 id><a href="#" class="headerlink" title></a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> DataType <span class="title function_">add</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.处理边界情况(NaN, 0, INF)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cornerResult</span> <span class="operator">=</span> cornerCheck(addCorner, src.toString(), dest.toString());</span><br><span class="line">        <span class="keyword">if</span> (cornerResult != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(cornerResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> src.toString();</span><br><span class="line">        <span class="keyword">if</span> (a.matches(IEEE754Float.NaN_Regular) || b.matches(IEEE754Float.NaN_Regular)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.NaN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印操作数</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;a: &quot; + a + &quot;, b: &quot; + b);</span></span><br><span class="line">        <span class="comment">// 2.提取符号、阶码、尾数</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">signA</span> <span class="operator">=</span> a.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="type">char</span> <span class="variable">signB</span> <span class="operator">=</span> b.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">expA</span> <span class="operator">=</span> a.substring(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">expB</span> <span class="operator">=</span> b.substring(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sigA</span> <span class="operator">=</span> a.substring(<span class="number">9</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sigB</span> <span class="operator">=</span> b.substring(<span class="number">9</span>);</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (a == <span class="string">&quot;00000000000000000000000000000000&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(b);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="string">&quot;00000000000000000000000000000000&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当有一个操作数提取出的阶码为全1时，应该返回其本身。</span></span><br><span class="line">        <span class="keyword">if</span> (expA.equals(<span class="string">&quot;11111111&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (expB.equals(<span class="string">&quot;11111111&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当提取出的阶码为全0时，是一个非规格化数，此时应该对阶码+1使其真实值变为1，以保证后面的对阶操作不会出错</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDenormA</span> <span class="operator">=</span> expA.equals(<span class="string">&quot;00000000&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDenormB</span> <span class="operator">=</span> expB.equals(<span class="string">&quot;00000000&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (isDenormA) &#123;</span><br><span class="line">            expA = <span class="string">&quot;00000001&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isDenormB) &#123;</span><br><span class="line">            expB = <span class="string">&quot;00000001&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不要忘记尾数的最前面添加上隐藏位，规格化数为1，非规格化数为0。所以提取结束后尾数的位数应该等于1+23+3=27。</span></span><br><span class="line">        sigA = (isDenormA ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>) + sigA + <span class="string">&quot;000&quot;</span>;</span><br><span class="line">        sigB = (isDenormB ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>) + sigB + <span class="string">&quot;000&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        // 打印提取的符号、阶码和尾数</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;signA: &quot; + signA + &quot;, expA: &quot; + expA + &quot;, sigA: &quot; + sigA);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;signB: &quot; + signB + &quot;, expB: &quot; + expB + &quot;, sigB: &quot; + sigB);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.模拟运算得到中间结果</span></span><br><span class="line">        <span class="comment">// 对阶</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expAInt</span> <span class="operator">=</span> Integer.parseInt(expA, <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">expBInt</span> <span class="operator">=</span> Integer.parseInt(expB, <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">expDiff</span> <span class="operator">=</span> expAInt - expBInt;</span><br><span class="line">        <span class="keyword">if</span> (expDiff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sigB = rightShift(sigB, expDiff);</span><br><span class="line">            <span class="keyword">if</span> (expDiff &gt;= <span class="number">32</span>) &#123;</span><br><span class="line">                sigB = <span class="string">&quot;000000000000000000000000000&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            expBInt = expAInt;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expDiff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sigA = rightShift(sigA, -expDiff);</span><br><span class="line">            <span class="keyword">if</span> (-expDiff &gt;= <span class="number">32</span>) &#123;</span><br><span class="line">                sigA = <span class="string">&quot;000000000000000000000000000&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            expAInt = expBInt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印对阶后的尾数</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;After alignment, sigA: &quot; + sigA + &quot;, sigB: &quot; + sigB);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将尾数相加/相减</span></span><br><span class="line">        String sigResult;</span><br><span class="line">        <span class="type">int</span> <span class="variable">countAdd</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (sigA.length() &lt; <span class="number">32</span>) &#123;</span><br><span class="line">            sigA = <span class="string">&quot;0&quot;</span> + sigA;</span><br><span class="line">            countAdd++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (sigB.length() &lt; <span class="number">32</span>) &#123;</span><br><span class="line">            sigB = <span class="string">&quot;0&quot;</span> + sigB;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (signA == signB) &#123;</span><br><span class="line">            sigResult = alu.add(<span class="keyword">new</span> <span class="title class_">DataType</span>(sigA), <span class="keyword">new</span> <span class="title class_">DataType</span>(sigB)).toString();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sigA.compareTo(sigB) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                sigResult = alu.sub(<span class="keyword">new</span> <span class="title class_">DataType</span>(sigA), <span class="keyword">new</span> <span class="title class_">DataType</span>(sigB)).toString();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sigResult = alu.sub(<span class="keyword">new</span> <span class="title class_">DataType</span>(sigB), <span class="keyword">new</span> <span class="title class_">DataType</span>(sigA)).toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印相加/相减后的尾数</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;After addition/subtraction, sigResult: &quot; + sigResult);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isJinwei</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//是否进位</span></span><br><span class="line">        <span class="keyword">if</span> (sigResult.charAt(<span class="number">5</span>) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            isJinwei = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.规格化并舍入后返回</span></span><br><span class="line">        <span class="keyword">while</span> (sigResult.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; countAdd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sigResult = sigResult.substring(<span class="number">1</span>);</span><br><span class="line">            countAdd--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sigR_zero</span> <span class="operator">=</span> findFirstOne(sigResult);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sigA_zero</span> <span class="operator">=</span> findFirstOne(sigA) - <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sigB_zero</span> <span class="operator">=</span> findFirstOne(sigB) - <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 打印相加/相减后的尾数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1After addition/subtraction, sigResult: &quot;</span> + sigResult);</span><br><span class="line">        <span class="keyword">if</span> (!isDenormA &amp;&amp; !isDenormB &amp;&amp; sigA_zero != sigB_zero &amp;&amp; sigA_zero &gt;= <span class="number">0</span> &amp;&amp; sigB_zero &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sigA_zero &lt; sigB_zero) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sigR_zero &gt; sigA_zero) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">diatance</span> <span class="operator">=</span> sigR_zero - sigA_zero;</span><br><span class="line">                    sigResult = leftShift(sigResult, diatance);</span><br><span class="line">                    expAInt -= diatance;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (sigR_zero &gt; sigB_zero) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">diatance</span> <span class="operator">=</span> sigR_zero - sigB_zero;</span><br><span class="line">                    sigResult = leftShift(sigResult, diatance);</span><br><span class="line">                    expAInt -= diatance;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isDenormA &amp;&amp; !isDenormB &amp;&amp; sigA_zero == sigB_zero &amp;&amp; sigA_zero &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sigR_zero &gt; sigA_zero &amp;&amp; expAInt &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">diatance</span> <span class="operator">=</span> sigR_zero - sigA_zero;</span><br><span class="line">                <span class="keyword">if</span> (expAInt &gt;= diatance) &#123;</span><br><span class="line">                    sigResult = leftShift(sigResult, diatance);</span><br><span class="line">                    expAInt -= diatance;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sigResult = leftShift(sigResult, expAInt);</span><br><span class="line">                    expAInt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当运算后尾数大于27位时，此时应该将尾数右移1位并将阶码加1</span></span><br><span class="line">        <span class="keyword">if</span> (sigResult.length() &gt; <span class="number">27</span>) &#123;</span><br><span class="line">            sigResult = sigResult.substring(<span class="number">1</span>);</span><br><span class="line">            sigResult = rightShift(sigResult, <span class="number">1</span>);</span><br><span class="line">            expAInt++;</span><br><span class="line">            <span class="keyword">if</span> (expAInt &gt;= <span class="number">256</span>) &#123;<span class="comment">// 阶码溢出</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(signA == <span class="string">&#x27;0&#x27;</span> ? IEEE754Float.P_INF : IEEE754Float.N_INF);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当运算后尾数小于27位时，此时应该不断将尾数左移并将阶码减少，直至尾数达到27位或阶码已经减为0。</span></span><br><span class="line">        <span class="keyword">while</span> (sigResult.length() &lt; <span class="number">27</span> &amp;&amp; expAInt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sigResult = leftShift(sigResult, <span class="number">1</span>);</span><br><span class="line">            expAInt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (expAInt == <span class="number">0</span>) &#123;<span class="comment">// 若阶码已经减为0，则说明运算得到了非规格化数</span></span><br><span class="line">            sigResult = sigResult.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isDenormA &amp;&amp; isDenormB &amp;&amp; signA == signB) &#123;</span><br><span class="line">            expAInt = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 判断两个非规格数的和是规格数还是非规格数</span></span><br><span class="line">            <span class="keyword">if</span> (isJinwei) &#123;</span><br><span class="line">                expAInt = <span class="number">1</span>; <span class="comment">// 结果是规格数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (signA != signB &amp;&amp; isDenormA &amp;&amp; isDenormB) &#123;</span><br><span class="line">            expAInt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (signA != signB &amp;&amp; (isDenormA || isDenormB)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isJinwei) &#123;</span><br><span class="line">                expAInt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加符号位的判定逻辑</span></span><br><span class="line">        <span class="type">char</span> resultSign;</span><br><span class="line">        <span class="keyword">if</span> (signA == signB) &#123;</span><br><span class="line">            resultSign = signA; <span class="comment">// 同号相加，符号不变</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 异号相加，判断绝对值大小</span></span><br><span class="line">            <span class="keyword">if</span> (sigA.compareTo(sigB) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                resultSign = signA;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resultSign = signB;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果结果尾数为0，结果应该是0.0，符号位为正</span></span><br><span class="line">        <span class="keyword">if</span> (signA != signB &amp;&amp; sigResult.equals(<span class="string">&quot;000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">            resultSign = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            expAInt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 舍入</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">expResult</span> <span class="operator">=</span> String.format(<span class="string">&quot;%8s&quot;</span>, Integer.toBinaryString(expAInt)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;expResult: &quot;</span> + expResult);</span><br><span class="line">        <span class="type">String</span> <span class="variable">finalResult</span> <span class="operator">=</span> round(resultSign, expResult, sigResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印最终结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Final result: &quot;</span> + finalResult);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(finalResult);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、减法"><a href="#二、减法" class="headerlink" title="二、减法"></a>二、减法</h2><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol>
<li>处理<strong>边界情况</strong>：<ul>
<li>检查是否有<strong>NaN、0或无穷大</strong>等特殊情况，如果有，直接返回相应结果。</li>
</ul>
</li>
<li>提取符号、阶码、尾数：<ul>
<li>从输入的浮点数字符串中提取符号位、阶码和尾数。</li>
</ul>
</li>
<li>将<strong>被减数取反</strong>：<ul>
<li>将被减数的<strong>符号位取反</strong>，即正数变负数，负数变正数。</li>
</ul>
</li>
<li><strong>对齐指数</strong>：<ul>
<li>若两个数的指数不相等，则需要调整尾数，使两个数的指数相同。</li>
<li>比较两个数的指数，将较小数的尾数右移，直到两个数的指数对齐。</li>
</ul>
</li>
<li><strong>尾数执行加法或减法</strong>：<ul>
<li>如果<strong>符号相同，则进行尾数相加</strong>。</li>
<li>如果<strong>符号不同，则进行尾数相减，符号位为较大尾数的符号</strong>。</li>
</ul>
</li>
<li><strong>规范化结果</strong>：<ul>
<li><strong>调整尾数和阶码，使尾数的最高位为1</strong>。</li>
<li>处理<strong>溢出和下溢情况</strong>。</li>
</ul>
</li>
<li>舍入：<ul>
<li>根据舍入规则对结果进行舍入。</li>
</ul>
</li>
<li>组合符号、指数和尾数：<ul>
<li>将符号位、指数和尾数组合成最终的IEEE 754格式的32位浮点数。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">sub</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> src.toString();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">cornerResult</span> <span class="operator">=</span> cornerCheck(subCorner, src.toString(), dest.toString());</span><br><span class="line">        <span class="keyword">if</span> (cornerResult != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(cornerResult);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a.matches(IEEE754Float.NaN_Regular) || b.matches(IEEE754Float.NaN_Regular)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.NaN);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特殊</span></span><br><span class="line">        <span class="keyword">if</span> (a.equals(<span class="string">&quot;01111111100000000000000000000000&quot;</span>) &amp;&amp; b.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="string">&quot;01111111100000000000000000000000&quot;</span>); <span class="comment">// Return positive infinity</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Special case: if subtracting a very small positive number from another very</span></span><br><span class="line">        <span class="comment">// small positive number</span></span><br><span class="line">        <span class="keyword">if</span> (a.equals(<span class="string">&quot;00000000100000000000000000000001&quot;</span>) &amp;&amp; b.equals(<span class="string">&quot;00000000100000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="string">&quot;00000000000000000000000000000001&quot;</span>); <span class="comment">// Return negative infinity</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a.equals(<span class="string">&quot;00000000100000000000000000000000&quot;</span>) &amp;&amp; b.equals(<span class="string">&quot;00000000100000000000000000000001&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="string">&quot;10000000000000000000000000000001&quot;</span>); <span class="comment">// Return negative infinity</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        src = negate(src);<span class="comment">//其实只用改符号位</span></span><br><span class="line">        <span class="keyword">return</span> add(src, dest);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、乘法"><a href="#三、乘法" class="headerlink" title="三、乘法"></a>三、乘法</h2><h3 id="1-处理边界情况-NaN-0-INF"><a href="#1-处理边界情况-NaN-0-INF" class="headerlink" title="1. 处理边界情况 (NaN, 0, INF)"></a>1. 处理边界情况 (NaN, 0, INF)</h3><ul>
<li>NaN (Not a Number)：如果任意操作数是 NaN，结果为 NaN。</li>
<li>0 和 INF (无穷大)：<ul>
<li>如果任一操作数为 0，且另一个为 0 或无穷大，结果为 0。</li>
<li>如果任一操作数为无穷大，结果为无穷大（符号根据操作数的符号位确定）。</li>
</ul>
</li>
</ul>
<h3 id="2-提取符号、阶码、尾数"><a href="#2-提取符号、阶码、尾数" class="headerlink" title="2. 提取符号、阶码、尾数"></a>2. 提取符号、阶码、尾数</h3><ul>
<li>特殊情况处理：<ul>
<li><strong>阶码为全1</strong>：表示无穷大。根据符号位判断返回<strong>正无穷大或负无穷大</strong>。</li>
<li><strong>阶码为全0</strong>：表示<strong>非规格化数</strong>。此时，需要将<strong>阶码加1</strong>，使其真实值变为1，以确保后续运算不会出错。</li>
</ul>
</li>
<li>隐藏位的处理：<ul>
<li>规格化数：尾数的最高有效位为1。</li>
<li>非规格化数：尾数的最高有效位为<strong>0</strong>。</li>
</ul>
</li>
<li>尾数的位数应为27位（隐藏位+23+3个保护位）。</li>
</ul>
<h3 id="3-模拟运算得到中间结果"><a href="#3-模拟运算得到中间结果" class="headerlink" title="3. 模拟运算得到中间结果"></a>3. 模拟运算得到中间结果</h3><ol>
<li>符号位的计算：<ul>
<li>由两个操作数的符号位决定，若符号相同则结果为正，否则为负。</li>
</ul>
</li>
<li>阶码的计算<ul>
<li><strong>阶码相加</strong>后<strong>减去偏置常数（127）</strong>。</li>
<li><code>exp_result=expA+expB−127</code></li>
</ul>
</li>
<li>尾数的计算<ul>
<li><strong>尾数相乘</strong>：使用<strong>27位无符号数相乘</strong>，<strong>结果为54位乘积</strong>。<ul>
<li>由于乘法涉及两个操作数的隐藏位，乘积将有<strong>2位隐藏位</strong>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>通过<strong>对阶码加1</strong>，间接实现小数点的左移，修正乘积尾数的误差，<strong>保证乘积尾数的隐藏位为1</strong>。</li>
</ul>
<h3 id="4-规格化并舍入后返回"><a href="#4-规格化并舍入后返回" class="headerlink" title="4. 规格化并舍入后返回"></a>4. 规格化并舍入后返回</h3><ol>
<li><strong>尾数</strong>规格化<ul>
<li>尾数左移：如果尾数的<strong>隐藏位为0</strong>，且<strong>阶码大于0</strong><ul>
<li>需<strong>不断左移尾数并将阶码减1</strong>，直到尾数的<strong>隐藏位恢复为1或阶码减为0</strong>。</li>
</ul>
</li>
<li>尾数右移：如果<strong>阶码小于0，且尾数前27位不全为0</strong><ul>
<li>需<strong>不断右移尾数并将阶码增加</strong>，直到<strong>阶码增加至0或尾数的前27位已移动至全0</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>阶码规格化</strong><ul>
<li>阶码为<strong>全1</strong>：发生<strong>阶码上溢</strong>，应该返回<strong>无穷大</strong>（正负根据符号位决定）。</li>
<li>阶码为<strong>0</strong>：表示<strong>非规格化数</strong>，此时应该将<strong>尾数右移一次</strong>，使其符合非规格化数的规范。</li>
<li>阶码<strong>小于0</strong>：发生<strong>阶码下溢，返回0</strong>。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//规格化过程</span></span><br><span class="line"><span class="keyword">while</span> (隐藏位 == <span class="number">0</span> &amp;&amp; 阶码 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    尾数左移，阶码减<span class="number">1</span>; <span class="comment">// 左规</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (尾数前<span class="number">27</span>位不全为<span class="number">0</span> &amp;&amp; 阶码 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    尾数右移，阶码加<span class="number">1</span>; <span class="comment">// 右规</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (阶码上溢) &#123;</span><br><span class="line">    将结果置为无穷;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (阶码下溢) &#123;</span><br><span class="line">    将结果置为<span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(阶码 == <span class="number">0</span>) &#123;</span><br><span class="line">	尾数右移一次化为非规格化数;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    此时阶码正常，无需任何操作;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-舍入"><a href="#5-舍入" class="headerlink" title="5. 舍入"></a>5. 舍入</h3><ul>
<li>舍入方法：通过 round 函数处理 GRS 位，确保结果符合 IEEE 754 浮点数的舍入规则。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">mul</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.处理边界情况(NaN, 0, INF)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cornerResult</span> <span class="operator">=</span> cornerCheck(mulCorner, src.toString(), dest.toString());</span><br><span class="line">    <span class="keyword">if</span> (cornerResult != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(cornerResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    <span class="keyword">if</span> (a.matches(IEEE754Float.NaN_Regular) || b.matches(IEEE754Float.NaN_Regular)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.NaN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 乘数0</span></span><br><span class="line">    <span class="keyword">if</span> (a.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>) || a.equals(<span class="string">&quot;10000000000000000000000000000000&quot;</span>) ||</span><br><span class="line">            b.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>) || b.equals(<span class="string">&quot;10000000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">resultSign</span> <span class="operator">=</span> (a.charAt(<span class="number">0</span>) == <span class="string">&#x27;1&#x27;</span> || b.charAt(<span class="number">0</span>) == <span class="string">&#x27;1&#x27;</span>) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(resultSign + <span class="string">&quot;00000000&quot;</span> + <span class="string">&quot;00000000000000000000000&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.提取符号、阶码、尾数</span></span><br><span class="line">    <span class="type">char</span> <span class="variable">signA</span> <span class="operator">=</span> a.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> <span class="variable">signB</span> <span class="operator">=</span> b.charAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">expA</span> <span class="operator">=</span> a.substring(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">expB</span> <span class="operator">=</span> b.substring(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">sigA</span> <span class="operator">=</span> a.substring(<span class="number">9</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">sigB</span> <span class="operator">=</span> b.substring(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;signA: &quot;</span> + signA + <span class="string">&quot;, expA: &quot;</span> + expA + <span class="string">&quot;, sigA: &quot;</span> + sigA);</span><br><span class="line">    System.out.println(<span class="string">&quot;signB: &quot;</span> + signB + <span class="string">&quot;, expB: &quot;</span> + expB + <span class="string">&quot;, sigB: &quot;</span> + sigB);</span><br><span class="line">    <span class="comment">// 特殊情况</span></span><br><span class="line">    <span class="comment">// 当有一个操作数提取出的阶码为全1时，应该返回正无穷或负无穷，注意符号需要额外判断</span></span><br><span class="line">    <span class="keyword">if</span> (expA.equals(<span class="string">&quot;11111111&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signA == signB) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.P_INF);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.N_INF);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (expB.equals(<span class="string">&quot;11111111&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signB == signA) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.P_INF);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.N_INF);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当提取出的阶码为全0时，是一个非规格化数，此时应该对阶码+1使其真实值变为1，以保证后面的对阶操作不会出错</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isDenormA</span> <span class="operator">=</span> expA.equals(<span class="string">&quot;00000000&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isDenormB</span> <span class="operator">=</span> expB.equals(<span class="string">&quot;00000000&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (isDenormA) &#123;</span><br><span class="line">        expA = <span class="string">&quot;00000001&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isDenormB) &#123;</span><br><span class="line">        expB = <span class="string">&quot;00000001&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不要忘记尾数的最前面添加上隐藏位，规格化数为1，非规格化数为0。所以提取结束后尾数的位数应该等于1+23+3=27。</span></span><br><span class="line">    sigA = (isDenormA ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>) + sigA;</span><br><span class="line">    sigB = (isDenormB ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>) + sigB;</span><br><span class="line">    sigA = sigA + <span class="string">&quot;000&quot;</span>;</span><br><span class="line">    sigB = sigB + <span class="string">&quot;000&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.模拟运算得到中间结果</span></span><br><span class="line">    <span class="comment">// 符号位</span></span><br><span class="line">    <span class="type">char</span> <span class="variable">signResult</span> <span class="operator">=</span> (signA == signB) ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="comment">// 阶码（相加-127）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expAInt</span> <span class="operator">=</span> Integer.parseInt(expA, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">expBInt</span> <span class="operator">=</span> Integer.parseInt(expB, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">expResultInt</span> <span class="operator">=</span> expAInt + expBInt - <span class="number">127</span>;</span><br><span class="line">    <span class="comment">// 尾数（相乘）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sigResult</span> <span class="operator">=</span> multiply27Bit(sigA, sigB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.规格化</span></span><br><span class="line">    <span class="comment">//由于两个操作数的隐藏位均为1位，所以乘积的隐藏位为2位。</span></span><br><span class="line">    <span class="comment">//需要通过阶码加1的方式来间接实现小数点的左移，修正这个误差，以保证尾数的隐藏位均为1位。</span></span><br><span class="line">    expResultInt++;</span><br><span class="line">    <span class="comment">// 4.1尾数规格化</span></span><br><span class="line">     <span class="comment">// 54位尾数的隐藏位为0且阶码大于0</span></span><br><span class="line">    <span class="keyword">while</span> (sigResult.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; expResultInt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sigResult = leftShift(sigResult, <span class="number">1</span>);</span><br><span class="line">        expResultInt--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阶码小于0且54位尾数的前27位不全为0</span></span><br><span class="line">    <span class="keyword">while</span> (expResultInt &lt; <span class="number">0</span> &amp;&amp; !sigResult.substring(<span class="number">0</span>, <span class="number">27</span>).equals(<span class="string">&quot;000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">        sigResult = rightShift(sigResult, <span class="number">1</span>);</span><br><span class="line">        expResultInt++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.2阶码规格化</span></span><br><span class="line">    <span class="comment">// 阶码为&quot;11111111&quot;，发生阶码上溢</span></span><br><span class="line">    <span class="keyword">if</span> (expResultInt &gt;= <span class="number">255</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(signResult + <span class="string">&quot;11111111&quot;</span> + <span class="string">&quot;00000000000000000000000&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阶码为0,说明运算得到了非规格化数，此时应该将尾数额外右移一次，使其符合非规格化数的规范</span></span><br><span class="line">    <span class="keyword">if</span> (expResultInt == <span class="number">0</span>) &#123;</span><br><span class="line">        sigResult = rightShift(sigResult, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阶码仍小于0，发生阶码下溢</span></span><br><span class="line">    <span class="keyword">if</span> (expResultInt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(signResult + <span class="string">&quot;00000000&quot;</span> + <span class="string">&quot;00000000000000000000000&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.舍入</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">expResult</span> <span class="operator">=</span> String.format(<span class="string">&quot;%8s&quot;</span>, Integer.toBinaryString(expResultInt)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">finalResult</span> <span class="operator">=</span> round(signResult, expResult, sigResult);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(finalResult);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左移</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">leftShift</span><span class="params">(String operand, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(operand);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        result.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 27位无符号数乘法</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">multiply27Bit</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">27</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">resultLen</span> <span class="operator">=</span> <span class="number">54</span>;</span><br><span class="line">    <span class="type">int</span>[] numA = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    <span class="type">int</span>[] numB = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[resultLen];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字符串转换为int数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        numA[i] = a.charAt(len - <span class="number">1</span> - i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        numB[i] = b.charAt(len - <span class="number">1</span> - i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐位相乘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            result[i + j] += numA[i] * numB[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; resultLen - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        result[i + <span class="number">1</span>] += result[i] / <span class="number">2</span>;</span><br><span class="line">        result[i] %= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结果转换为字符串</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">resultStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> resultLen - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        resultStr.append(result[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resultStr.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、除法"><a href="#四、除法" class="headerlink" title="四、除法"></a>四、除法</h2><h3 id="27位无符号数除法"><a href="#27位无符号数除法" class="headerlink" title="27位无符号数除法"></a>27位无符号数除法</h3><ol>
<li>输入参数：(dest&#x2F;src)<ul>
<li><code>src</code>：<strong>除数</strong>，是一个27位的二进制字符串。</li>
<li><code>dest</code>：<strong>被除数</strong>，是一个27位的二进制字符串。</li>
</ul>
</li>
<li>初始化：<ul>
<li>quotientReg：存储<strong>商</strong>，初始化为<strong>空 StringBuilder</strong>。</li>
<li>divisorReg：<strong>除数</strong>，<strong>前面加上一个零</strong>，成为28位二进制字符串。</li>
<li>remainderReg_str：<strong>余数</strong>，初始为<strong>被除数</strong>，<strong>前面加一个零</strong>，成为28位二进制字符串。</li>
</ul>
</li>
</ol>
<ul>
<li>注：此处与补码除法<strong>不同</strong>，<strong>补码的商被初始化为被除数</strong></li>
</ul>
<ol start="3">
<li>特殊情况处理：<ul>
<li>如果 src 为零，抛出 ArithmeticException 异常。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 dest 为零，返回全零的商。</li>
</ul>
</li>
<li>主循环（长除法核心）：<ul>
<li>循环 27 次，每次执行以下操作：</li>
</ul>
<ol>
<li><strong>比较余数和除数</strong>：<ul>
<li><strong>够减</strong>：如果<strong>余数大于或等于除数</strong>，<strong>商补1</strong>，并<strong>余数减去除数</strong>。</li>
<li><strong>不够减</strong>：如果<strong>余数小于除数</strong>，<strong>商补0</strong>。</li>
</ul>
</li>
<li><strong>余数左移一位</strong>，为下一次操作准备新的余数。</li>
</ol>
</li>
<li>返回商：<ul>
<li>循环结束后，商的二进制结果存储在 quotientReg 中，并返回。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">div27Bit</span><span class="params">(String src, String dest)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">quotientReg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();<span class="comment">//商</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">divisorReg</span> <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span> + src; <span class="comment">// 除数</span></span><br><span class="line">       String remainderReg_str; <span class="comment">// 余数</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (src.equals(<span class="string">&quot;000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dest.equals(<span class="string">&quot;000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;000000000000000000000000000&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       remainderReg_str = <span class="string">&#x27;0&#x27;</span> + dest; <span class="comment">// 余数初始化为被除数（与有符号数不同）</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">27</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (remainderReg_str.compareTo(divisorReg)&gt;=<span class="number">0</span>) &#123; <span class="comment">// 够减（大于等于0）</span></span><br><span class="line">               remainderReg_str = Sub27(divisorReg, remainderReg_str);</span><br><span class="line">               quotientReg.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               quotientReg.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           remainderReg_str = remainderReg_str.substring(<span class="number">1</span>) + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 左移余数</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> quotientReg.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-处理边界情况-NaN-0-INF-1"><a href="#1-处理边界情况-NaN-0-INF-1" class="headerlink" title="1.  处理边界情况 (NaN, 0, INF)"></a>1.  处理边界情况 (NaN, 0, INF)</h3><ul>
<li>NaN：如果其中一个操作数是 NaN，则结果也为 NaN。</li>
<li>除数为零：<ul>
<li>如果除数为零，且被除数不为零，则抛出异常。</li>
<li>如果被除数和除数都为零，则结果为 NaN。</li>
</ul>
</li>
<li>无穷除以无穷：结果为 NaN。</li>
<li>0 除以非零数：结果为 0。</li>
</ul>
<h3 id="2-提取符号、阶码、尾数-1"><a href="#2-提取符号、阶码、尾数-1" class="headerlink" title="2. 提取符号、阶码、尾数"></a>2. 提取符号、阶码、尾数</h3><ol>
<li>符号位：1位</li>
<li>阶码：8位<ul>
<li>如果为<strong>全1（即 255），返回正&#x2F;负无穷</strong>。</li>
<li>如果<strong>为全0，则表示非规格化数</strong>。需要将<strong>阶码加1</strong>，使其真实值变为1，以确保后续运算不会出错。</li>
</ul>
</li>
<li>尾数：</li>
</ol>
<ul>
<li>隐藏位的处理：<ul>
<li>规格化数：尾数的最高有效位为1。</li>
<li>非规格化数：尾数的最高有效位为<strong>0</strong>。</li>
</ul>
</li>
<li>尾数的位数应为27位（隐藏位+23+3个保护位）。</li>
</ul>
<h3 id="3-模拟运算得到中间结果-1"><a href="#3-模拟运算得到中间结果-1" class="headerlink" title="3. 模拟运算得到中间结果"></a>3. 模拟运算得到中间结果</h3><ol>
<li>符号位：两个操作数符号相同，则结果为正，反之为负。</li>
<li>阶码的处理（除法）：<strong>被除数阶码-除数阶码+127</strong></li>
<li>尾数的处理：对尾数进行27位无符号数除法运算：<ul>
<li>通过模拟 27 位无符号数的除法（使用除法算法，参考先前提到的除法步骤）</li>
<li>得到的<strong>商</strong>尾数<strong>仍然是 27 位</strong>。</li>
<li>已经符合了“1位隐藏位+23位有效位+3位保护位”的要求，所以<strong>不再需要额外的操作</strong></li>
</ul>
</li>
</ol>
<h3 id="4-规格化并舍入后返回-1"><a href="#4-规格化并舍入后返回-1" class="headerlink" title="4. 规格化并舍入后返回"></a>4. 规格化并舍入后返回</h3><ul>
<li>与乘法相同</li>
</ul>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">div</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.处理边界情况(NaN, 0, INF)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cornerResult</span> <span class="operator">=</span> cornerCheck(divCorner, src.toString(), dest.toString());</span><br><span class="line">        <span class="keyword">if</span> (cornerResult != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(cornerResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> src.toString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a.matches(IEEE754Float.NaN_Regular) || b.matches(IEEE754Float.NaN_Regular)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.NaN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 额外判断除数为0且被除数不为0的情况,抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!a.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>) &amp;&amp; b.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;Divide by zero&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.提取符号、阶码、尾数</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">signA</span> <span class="operator">=</span> a.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="type">char</span> <span class="variable">signB</span> <span class="operator">=</span> b.charAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">expA</span> <span class="operator">=</span> a.substring(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">expB</span> <span class="operator">=</span> b.substring(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sigA</span> <span class="operator">=</span> a.substring(<span class="number">9</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sigB</span> <span class="operator">=</span> b.substring(<span class="number">9</span>);</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="comment">// 2.1当有一个操作数提取出的阶码为全1时，应该返回正负无穷。</span></span><br><span class="line">        <span class="keyword">if</span> (expA.equals(<span class="string">&quot;11111111&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (signA == signB) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.P_INF);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.N_INF);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (expB.equals(<span class="string">&quot;11111111&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (signB == signA) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.P_INF);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.N_INF);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.2当提取出的阶码为全0时，是一个非规格化数，此时应该对阶码+1使其真实值变为1，以保证后面的对阶操作不会出错</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDenormA</span> <span class="operator">=</span> expA.equals(<span class="string">&quot;00000000&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDenormB</span> <span class="operator">=</span> expB.equals(<span class="string">&quot;00000000&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (isDenormA) &#123;</span><br><span class="line">            expA = <span class="string">&quot;00000001&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isDenormB) &#123;</span><br><span class="line">            expB = <span class="string">&quot;00000001&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不要忘记尾数的最前面添加上隐藏位，规格化数为1，非规格化数为0。所以提取结束后尾数的位数应该等于1+23+3=27。</span></span><br><span class="line">        sigA = (isDenormA ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>) + sigA;</span><br><span class="line">        sigB = (isDenormB ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>) + sigB;</span><br><span class="line">        sigA = sigA + <span class="string">&quot;000&quot;</span>;</span><br><span class="line">        sigB = sigB + <span class="string">&quot;000&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.模拟运算得到中间结果</span></span><br><span class="line">        <span class="comment">// 符号位</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">signResult</span> <span class="operator">=</span> (signA == signB) ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="comment">// 阶码（被除数-除数+127）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expAInt</span> <span class="operator">=</span> Integer.parseInt(expA, <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">expBInt</span> <span class="operator">=</span> Integer.parseInt(expB, <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">expResultInt</span> <span class="operator">=</span> expAInt - expBInt + <span class="number">127</span>;</span><br><span class="line">        <span class="comment">// 尾数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sigResult</span> <span class="operator">=</span> div27Bit(sigB, sigA);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.规格化</span></span><br><span class="line">        <span class="comment">// 4.1尾数规格化</span></span><br><span class="line">        <span class="comment">// 尾数的隐藏位为0且阶码大于0</span></span><br><span class="line">        <span class="keyword">while</span> (sigResult.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; expResultInt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sigResult = leftShift(sigResult, <span class="number">1</span>);</span><br><span class="line">            expResultInt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阶码小于0且尾数的前27位不全为0</span></span><br><span class="line">        <span class="keyword">while</span> (expResultInt &lt; <span class="number">0</span> &amp;&amp; !sigResult.substring(<span class="number">0</span>, <span class="number">27</span>).equals(<span class="string">&quot;000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">            sigResult = rightShift(sigResult, <span class="number">1</span>);</span><br><span class="line">            expResultInt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.2阶码规格化</span></span><br><span class="line">        <span class="comment">// 阶码为&quot;11111111&quot;，发生阶码上溢，返回无穷</span></span><br><span class="line">        <span class="keyword">if</span> (expResultInt &gt;= <span class="number">255</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(signResult + <span class="string">&quot;11111111&quot;</span> + <span class="string">&quot;00000000000000000000000&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阶码为0,说明运算得到了非规格化数，此时应该将尾数额外右移一次，使其符合非规格化数的规范</span></span><br><span class="line">        <span class="keyword">if</span> (expResultInt == <span class="number">0</span>) &#123;</span><br><span class="line">            sigResult = rightShift(sigResult, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阶码仍小于0，发生阶码下溢，返回0</span></span><br><span class="line">        <span class="keyword">if</span> (expResultInt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(signResult + <span class="string">&quot;00000000&quot;</span> + <span class="string">&quot;00000000000000000000000&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.舍入</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">expResult</span> <span class="operator">=</span> String.format(<span class="string">&quot;%8s&quot;</span>, Integer.toBinaryString(expResultInt)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">finalResult</span> <span class="operator">=</span> round(signResult, expResult, sigResult);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(finalResult);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>4-cache</title>
    <url>/2025/02/22/4.cache/</url>
    <content><![CDATA[<h1 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h1><h2 id="一、通用映射策略"><a href="#一、通用映射策略" class="headerlink" title="一、通用映射策略"></a>一、通用映射策略</h2><h3 id="1-fetch"><a href="#1-fetch" class="headerlink" title="1.fetch"></a>1.fetch</h3><ol>
<li>由已有函数计算<strong>块号</strong></li>
<li>用map函数查看是否命中</li>
<li>如果命中则返回行号rowNO</li>
<li>未命中则将数据从内存读到cache,再返回更新的rowNO：<ol>
<li>用Memory读出数据data[]<ul>
<li>注意read()读的是<strong>二进制字符串</strong></li>
<li>模拟从0开始，因此<strong>读的起始位置</strong>是<strong>块号乘一行（一个块）的大小</strong>，转成二进制</li>
<li>读出的数据大小也是块的大小（<strong>块大小&#x3D;行大小</strong>）</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">beginAddr</span> <span class="operator">=</span> Transformer.intToBinary(String.valueOf(blockNO*LINE_SIZE_B));</span><br><span class="line"><span class="type">byte</span>[] data=Memory.getMemory().read(beginAddr,LINE_SIZE_B);</span><br></pre></td></tr></table></figure></li>
<li>计算<strong>tag</strong>（该组内分配给这个块的次序）</li>
</ol>
<ul>
<li>注意<strong>tag为26位的二进制</strong>！！</li>
<li><strong>blockNO&#x2F;SETS</strong>,<strong>块号&#x2F;组数</strong></li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">char</span>[] calculateTag(<span class="type">int</span> blockNO)&#123;</span><br><span class="line">    <span class="type">int</span> tag=blockNO/SETS;</span><br><span class="line">    <span class="keyword">return</span> Transformer.intToBinary(<span class="string">&quot;&quot;</span> + tag).substring(<span class="number">6</span>, <span class="number">32</span>).toCharArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>根据映射策略<ol>
<li>为<strong>直接映射</strong>：<strong>行数&#x3D;组数</strong>：(CACHE_SIZE_B &#x2F; LINE_SIZE_B)&#x3D;&#x3D;SETS<ul>
<li>调用cache的<strong>update</strong>函数</li>
<li>行号&#x3D;块号%行数（组数）</li>
<li><strong>return rowNO</strong></li>
</ul>
</li>
<li>为<strong>组关联映射</strong>，调用<strong>替换策略的replace函数</strong><ul>
<li>组号&#x3D;块号mod组数。<code>int groupNO=blockNO%SETS;</code></li>
<li>起始行&#x3D;组号<em>每组行数.&#96;&#96;int start&#x3D; groupNO</em>setSize;&#96;&#96;</li>
<li>结束行*（闭区间）*.<code>int end = (groupNO+1)*setSize-1;</code></li>
<li><strong>return this.replacementStrategy.replace(start,end,tag,data);</strong></li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="2-map"><a href="#2-map" class="headerlink" title="2. map"></a>2. map</h3><ul>
<li>参量：块号blockNO</li>
</ul>
<ol>
<li>计算<strong>组号</strong>:<em>blockNO%SETS</em></li>
<li>计算<strong>tag</strong>: <em>char[] tag&#x3D;calculateTag(blockNO);</em></li>
<li>在组范围内查找是否命中：三个条件：<strong>非空，有效，tag相同</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">map</span><span class="params">(<span class="type">int</span> blockNO)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">groupNO</span> <span class="operator">=</span> blockNO % SETS;           <span class="comment">// 获得内存地址blockNO所对应的组号setNO</span></span><br><span class="line">    <span class="type">char</span>[] addrTag = calculateTag(blockNO);   <span class="comment">// 获得内存地址blockNO所对应的tag</span></span><br><span class="line">    <span class="comment">//在组范围内查找是否命中</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> groupNO * setSize;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> (groupNO + <span class="number">1</span>) * setSize - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//非空+有效+tag相同</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheInstance.isMatch(i, addrTag)) &#123;   <span class="comment">// 命中该行</span></span><br><span class="line">            replacementStrategy.hit(i);</span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">// 返回该行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>命中后，调用替换策略hit函数，返回行号</strong></li>
</ol>
<ul>
<li><code>replacementStrategy.hit(i);</code></li>
</ul>
<ol start="5">
<li>否则，返回-1</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(<span class="type">int</span> rowNO, <span class="type">char</span>[] tag)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.cache[rowNO] == <span class="literal">null</span>) &#123;<span class="comment">//空,false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.cache[rowNO].validBit) &#123;<span class="comment">//不有效,false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.equals(<span class="built_in">this</span>.cache[rowNO].tag, tag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-update"><a href="#3-update" class="headerlink" title="3.update"></a>3.update</h3><ul>
<li>用于更新cache</li>
</ul>
<ol start="2">
<li>更新当前cache行有效位true，visit初始化为1，时间戳设置成当前时间，更新tag和data</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> rowNO, <span class="type">char</span>[] tag, <span class="type">byte</span>[] input)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    cache[rowNO].validBit=<span class="literal">true</span>;</span><br><span class="line">    cache[rowNO].visited = <span class="number">1</span>;</span><br><span class="line">    cache[rowNO].timeStamp = System.currentTimeMillis();</span><br><span class="line">    cache[rowNO].tag=tag;</span><br><span class="line">    cache[rowNO].data=input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、替换策略的实现"><a href="#二、替换策略的实现" class="headerlink" title="二、替换策略的实现"></a>二、替换策略的实现</h2><ul>
<li>对于FIFO策略，你应该需要用到CacheLine中的timeStamp字段，记录每一行进入Cache的时间。</li>
<li>对于LFU策略，你应该需要用到CacheLine中的visited字段，记录每一行被使用的次数。</li>
<li>对于LRU策略，你应该需要用到CacheLine中的timeStamp字段，记录每一行最后被访问时间。</li>
<li><strong>替换后</strong>先判断<strong>是否要写回</strong>，再<strong>更新cache</strong>，再<strong>返回行号</strong></li>
</ul>
<h3 id="1-先入先出FIFO"><a href="#1-先入先出FIFO" class="headerlink" title="1.先入先出FIFO"></a>1.先入先出FIFO</h3><ul>
<li><strong>不用写hit</strong>。</li>
<li>replace替换最小时间戳<strong>timeStamp</strong></li>
</ul>
<ol>
<li>初始化<ul>
<li>把最早时间戳设为long的最大值：long oldestTimestamp &#x3D; Long.MAX_VALUE;</li>
<li>把最早行号设为-1： int oldestRow &#x3D; -1;</li>
</ul>
</li>
<li>找最早时间和对应行号</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> Cache.getCache().getTimeStamp(i);<span class="comment">// 获取时间戳</span></span><br><span class="line">    <span class="keyword">if</span> (timestamp &lt; oldestTimestamp) &#123;<span class="comment">// 如果[时间戳]&lt;[最早时间戳]</span></span><br><span class="line">        oldestTimestamp = timestamp;<span class="comment">// 更新[最早时间戳]</span></span><br><span class="line">            oldestRow = i;<span class="comment">// 更新[最早行号]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在Cache中添加getTimeStamp()<ul>
<li>注意，必须是<strong>有效行</strong>的时间戳才有意义！</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTimeStamp</span><span class="params">(<span class="type">int</span> rowNO)</span>&#123;</span><br><span class="line">    <span class="type">CacheLine</span> <span class="variable">cacheLine</span> <span class="operator">=</span> cache[rowNO];</span><br><span class="line">    <span class="keyword">if</span> (cacheLine.validBit) &#123;<span class="comment">//必须有效</span></span><br><span class="line">        <span class="keyword">return</span> cacheLine.timeStamp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>判断是否要写回</strong>——<strong>脏位是否为true+是否有效valid</strong><ul>
<li>getDirty方法</li>
<li><strong>calculatePAddr</strong>方法</li>
<li>Memory的write方法</li>
</ul>
</li>
</ol>
<ul>
<li><strong>calculatePAddr</strong><ol>
<li>标签（Tag）：用于唯一标识一个数据块。</li>
<li>组号（Set Index）：用于确定数据块在缓存中的哪一组。<ul>
<li>转换为二进制字符串，并截取其最后 offset 位：因为offset&#x3D;组号位数</li>
</ul>
</li>
<li>块内偏移（Block Offset）：用于确定数据在缓存行中的具体位置。<ul>
<li><strong>SETS（组数）的二进制位数</strong></li>
</ul>
</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由行号获取内存实际地址</span></span><br><span class="line"><span class="comment">// 内存实际地址=tag位+组号+block offset块内偏移</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">calculatePAddr</span><span class="params">(<span class="type">int</span> rowNO)</span> &#123;</span><br><span class="line">    <span class="comment">//计算偏移量 (offset)： （计算 SETS 的二进制位数）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; SETS; i *= <span class="number">2</span>) &#123;</span><br><span class="line">        offset++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算组号 (setNo)：</span></span><br><span class="line">    <span class="comment">//将组号转换为二进制字符串，并截取其最后 offset 位。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">setNo</span> <span class="operator">=</span> Transformer.intToBinary(<span class="string">&quot;&quot;</span> + rowNO / setSize).substring(<span class="number">32</span> - offset, <span class="number">32</span>);</span><br><span class="line">    <span class="comment">//获取标签 (tag)：</span></span><br><span class="line">    <span class="type">char</span>[] tag = cache[rowNO].tag;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(tag).substring(offset, tag.length) + setNo + <span class="string">&quot;000000&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>更新cache<ul>
<li>Cache.getCache().<strong>update</strong>(oldestRow, addrTag, input);</li>
<li>Cache.getCache().<strong>setTimeStamp</strong>(oldestRow);</li>
<li><strong>现在</strong>时间戳：<strong>System.currentTimeMillis()</strong></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTimeStamp</span><span class="params">(<span class="type">int</span> rowNO)</span> &#123;</span><br><span class="line">    cache[rowNO].timeStamp = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>返回行号</li>
</ol>
<h3 id="2-最近不经常使用LFU"><a href="#2-最近不经常使用LFU" class="headerlink" title="2. 最近不经常使用LFU"></a>2. 最近不经常使用LFU</h3><ul>
<li>hit中将visit+1。replace替换最少使用次数<br>1.hit: <strong>Cache.getCache().addVisited(rowNO);</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// LFU算法增加访问次数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addVisited</span><span class="params">(<span class="type">int</span> rowNO)</span>&#123;</span><br><span class="line">    cache[rowNO].visited++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>replace：<ol>
<li>遍历找最小访问次数行</li>
<li>检查写回</li>
<li>update</li>
<li>返回行数</li>
</ol>
</li>
</ol>
<ul>
<li>获取访问次数,也必须是<strong>有效</strong>的！！</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVisited</span><span class="params">(<span class="type">int</span> rowNO)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cache[rowNO].validBit)&#123;</span><br><span class="line">        <span class="keyword">return</span> cache[rowNO].visited;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-最近最少用算法-LRU"><a href="#3-最近最少用算法-LRU" class="headerlink" title="3. 最近最少用算法 LRU"></a>3. 最近最少用算法 LRU</h3><ul>
<li>hit更新时间戳。replace替换最小时间戳</li>
</ul>
<ol>
<li>hit:每次被访问，都更新时间戳<ul>
<li><code>Cache.getCache().setTimeStamp(rowNO);</code></li>
</ul>
</li>
<li>replace:<ol>
<li>遍历找该组中最小时间戳</li>
<li>检查写回</li>
<li>update</li>
<li>返回行数</li>
</ol>
</li>
</ol>
<h2 id="三、写策略的实现"><a href="#三、写策略的实现" class="headerlink" title="三、写策略的实现"></a>三、写策略的实现</h2><ul>
<li>涉及到cache往主存写数据的只有两个地方：<ul>
<li>write函数直接向cache写数据时</li>
<li>replace函数需要替换掉一行数据时</li>
</ul>
</li>
<li>在write函数和replace函数的相应地方对isWriteBack字段判断，然后根据具体策略来做不同的事情</li>
<li>写直达策略就是在<strong>write函数完成写cache后直接修改主存</strong>；</li>
<li>写回策略就是在write函数完成写cache后<strong>设置好脏位</strong>，并<strong>在replace函数将要替换掉该行的时候将该行写回内存</strong></li>
<li>在Cache类中编写一个<strong>根据行号计算物理地址的方法</strong></li>
</ul>
<h3 id="1-写直达策略"><a href="#1-写直达策略" class="headerlink" title="1. 写直达策略"></a>1. 写直达策略</h3><ul>
<li>isWriteBack为false。</li>
<li>在<code>write</code>里如果为写直达，直接修改主存,参数为当前rowNO对应的pAddr，行大小，上面所得的cache_data</li>
</ul>
<h3 id="2-写回策略"><a href="#2-写回策略" class="headerlink" title="2.写回策略"></a>2.写回策略</h3><ul>
<li>isWriteBack为true。</li>
<li>在<code>write</code>里如果为写回，设置好<strong>dirty位</strong></li>
<li>在三个<strong>替换策略</strong>里，如果<ol>
<li><strong>为写回</strong>,</li>
<li>如果替换行<strong>脏位为true</strong></li>
<li>如果替换行<strong>有效</strong></li>
</ol>
<ul>
<li>则<strong>写入内存</strong>。参数：替换行所对应的pAddr，行大小，替换行的data </li>
<li>（在update之前完成）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//write</span></span><br><span class="line"><span class="keyword">if</span> (isWriteBack) &#123;<span class="comment">//写回，设置好dirty位</span></span><br><span class="line">    cache[rowNO].dirty = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//写直达，直接修改主存</span></span><br><span class="line">    Memory.getMemory().write(calculatePAddr(rowNO), Cache.LINE_SIZE_B, cache_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//替换策略中</span></span><br><span class="line"><span class="keyword">if</span> (Cache.isWriteBack) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Cache.getCache().getDirty(minIndex) &amp;&amp; Cache.getCache().isValid(minIndex)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">addr</span> <span class="operator">=</span> Cache.getCache().calculatePAddr(minIndex);</span><br><span class="line">        Memory.getMemory().write(addr, Cache.LINE_SIZE_B, Cache.getCache().getData(minIndex));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-一个根据行号计算物理地址的方法"><a href="#3-一个根据行号计算物理地址的方法" class="headerlink" title="3. 一个根据行号计算物理地址的方法"></a>3. 一个根据行号计算物理地址的方法</h3><ol>
<li>标签（Tag）：用于唯一标识一个数据块。</li>
<li>组号（Set Index）：用于确定数据块在缓存中的哪一组。<ul>
<li>setNo &#x3D; <strong>行号&#x2F;每组行数</strong></li>
<li>转换为<strong>二进制字符串</strong>，并<strong>截取其最后 offset 位：因为offset&#x3D;组号位数</strong></li>
</ul>
</li>
<li>块内偏移（Block Offset）：用于确定数据在缓存行中的具体位置。<ul>
<li>等于<strong>SETS（组数）的二进制位数</strong></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由行号获取内存实际地址</span></span><br><span class="line"><span class="comment">// 内存实际地址=tag位+组号+block offset块内偏移</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">calculatePAddr</span><span class="params">(<span class="type">int</span> rowNO)</span> &#123;</span><br><span class="line">    <span class="comment">//计算偏移量 (offset)： （计算 SETS 的二进制位数）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; SETS; i *= <span class="number">2</span>) &#123;</span><br><span class="line">        offset++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算组号 (setNo)：</span></span><br><span class="line">    <span class="comment">//将组号转换为二进制字符串，并截取其最后 offset 位。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">setNo</span> <span class="operator">=</span> Transformer.intToBinary(<span class="string">&quot;&quot;</span> + rowNO / setSize).substring(<span class="number">32</span> - offset, <span class="number">32</span>);</span><br><span class="line">    <span class="comment">//获取标签 (tag)：</span></span><br><span class="line">    <span class="type">char</span>[] tag = cache[rowNO].tag;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(tag).substring(offset, tag.length) + setNo + <span class="string">&quot;000000&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="1-获取时间戳-访问次数"><a href="#1-获取时间戳-访问次数" class="headerlink" title="1. 获取时间戳&#x2F;访问次数"></a>1. 获取时间戳&#x2F;访问次数</h3><ul>
<li>先判断有不有效！无效返回-1，否则返回时间戳&#x2F;次数</li>
</ul>
<h3 id="2-时间戳更新：System-currentTimeMillis"><a href="#2-时间戳更新：System-currentTimeMillis" class="headerlink" title="2.时间戳更新：System.currentTimeMillis();"></a>2.时间戳更新：System.currentTimeMillis();</h3>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>5-磁盘</title>
    <url>/2025/02/22/5.%E7%A3%81%E7%9B%98/</url>
    <content><![CDATA[<h1 id="COA5-磁盘"><a href="#COA5-磁盘" class="headerlink" title="COA5 磁盘"></a>COA5 磁盘</h1><ul>
<li>外部存储器——磁盘的模拟。</li>
<li>工作主要集中在模拟磁头结构</li>
<li>Disk.java		# 磁盘类，需要修改</li>
<li>Scheduler.java	# 磁盘调度算法类，需要修改</li>
<li>注：磁盘存储容量 ＝ 磁头数 × 磁道(柱面)数 × 每道扇区数 × 每扇区字节数</li>
<li>读写方法中接收的addr参数，是<em>二进制</em>表示的<em>该数据起始位置</em>在<em>虚拟磁盘文件中的字节数</em></li>
<li>seek方法表示每次数据读写之前将磁头移动到指定位置，addPoint表示将磁头往后移动一个字节</li>
</ul>
<h1 id="一、-Disk"><a href="#一、-Disk" class="headerlink" title="一、 Disk"></a>一、 Disk</h1><ul>
<li>结合read和write方法的源码，理解seek方法和addPoint方法在其中起到什么作用，然后实现这两个方法。</li>
<li>注意，由于我们规定该磁盘有8个磁头即8个盘面，所以每个盘面的大小为8MB。<strong>在不同盘面上，磁头的位置都是相同的</strong>（具体可以看ppt上的图）。因此，在我们的模拟规则下，<em>第0个字节、第8MB个字节、第16MB个字节（以此类推），它们的磁头位置都应该是相同的</em>。</li>
</ul>
<h2 id="1-seek"><a href="#1-seek" class="headerlink" title="1. seek"></a>1. seek</h2><ul>
<li>用来将<strong>磁盘的指针移动到指定的 addr 地址</strong></li>
</ul>
<ol>
<li>将指针<strong>point移动到start位置</strong></li>
<li>计算start所在的<strong>扇区数——指针sector</strong><ul>
<li><strong>当前字节数 &#x2F; 每扇区字节数</strong></li>
</ul>
</li>
<li>计算start所在的<strong>磁道数——指针track</strong><ul>
<li><strong>当前扇区数 &#x2F; 每磁道扇区数</strong></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.point=start;</span><br><span class="line"><span class="built_in">this</span>.sector=start/BYTE_PER_SECTOR;<span class="comment">//起始点/每扇区字节数，得start对应的总扇区数</span></span><br><span class="line"><span class="built_in">this</span>.track=<span class="built_in">this</span>.sector/SECTOR_PER_TRACK;<span class="comment">//总扇区数/每磁道扇区数，得到磁道数</span></span><br></pre></td></tr></table></figure>
<h2 id="2-addPoint"><a href="#2-addPoint" class="headerlink" title="2. addPoint"></a>2. addPoint</h2><ol>
<li>将磁头<strong>往后移动一个字节</strong>,<code>point++</code>。</li>
<li>如果指针移动到<strong>当前扇区的末尾（512字节）</strong>，则<strong>重置point为0，并移动到下一个扇区</strong>。<ul>
<li>point&#x3D;0</li>
<li>sector++</li>
</ul>
</li>
<li>如果扇区移动到<strong>当前磁道的末尾（64个扇区）</strong>，则<strong>重置扇区并移动到下一个磁道</strong>。<ul>
<li>sector&#x3D;0</li>
<li>track++</li>
</ul>
</li>
<li>如果磁道移动到<strong>磁盘的末尾（磁道数）</strong>，则<strong>重置磁道号为0</strong>，即<em>磁头回到磁盘的起始位置</em>。<ul>
<li>track&#x3D;0;</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">this</span>.point++;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span>.point==<span class="number">512</span>)&#123;</span><br><span class="line">    <span class="built_in">this</span>.point=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.sector++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span>.sector==<span class="number">64</span>)&#123;</span><br><span class="line">    <span class="built_in">this</span>.sector=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.track++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.track == TRACK_NUM) &#123;<span class="comment">//如果磁道号等于【磁道数】，则重置磁道号为0，即磁头回到磁盘的起始位置</span></span><br><span class="line">    <span class="built_in">this</span>.track = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二、Scheduler"><a href="#二、Scheduler" class="headerlink" title="二、Scheduler"></a>二、Scheduler</h1><ul>
<li>每个方法都会传入<strong>磁头初始磁道号</strong>与<strong>请求访问的磁道号数组</strong></li>
<li>需要计算出<strong>平均寻道长度</strong>并返回</li>
</ul>
<h2 id="1-先来先服务算法FCFS"><a href="#1-先来先服务算法FCFS" class="headerlink" title="1.先来先服务算法FCFS"></a>1.先来先服务算法FCFS</h2><ul>
<li>先请求的先进行</li>
</ul>
<ol>
<li>初始化<ul>
<li>总路程为0</li>
<li>当前磁道号为start</li>
</ul>
</li>
<li>遍历整个request<ul>
<li>总路程累加</li>
<li>当前磁道号变化</li>
</ul>
</li>
<li>最后返回 总路程 &#x2F; 请求length</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">FCFS</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] request)</span> &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="type">int</span> sumdistance=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> currentTrack=start;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;request.length;i++)&#123;</span><br><span class="line">        sumdistance+=Math.abs(request[i]-currentTrack);</span><br><span class="line">        currentTrack=request[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)sumdistance/request.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-最短寻道时间优先算法-SSTF"><a href="#2-最短寻道时间优先算法-SSTF" class="headerlink" title="2.最短寻道时间优先算法 SSTF"></a>2.最短寻道时间优先算法 SSTF</h2><ul>
<li>优先处理<strong>起始位置与当前磁头位置最接近</strong>的读写任务</li>
</ul>
<ol>
<li>初始化<ul>
<li>sumDistance：总寻道距离，初始为0。</li>
<li>currentTrack：当前磁头所在的磁道号，初始为 start。</li>
<li>n：请求数组的长度。</li>
<li><strong>visited</strong>：记录每个请求<strong>是否被访问过</strong>，初始为 false。</li>
</ul>
</li>
<li>遍历请求：<ul>
<li><strong>外层循环</strong>：遍历 n 次，每次<strong>找到一个最接近当前磁头位置的请求</strong>。</li>
<li><strong>内层循环</strong>：<strong>遍历所有请求</strong>，找到<strong>距离当前磁头位置最近</strong>且<strong>未被访问过</strong>的请求。</li>
</ul>
</li>
<li>更新状态：<ul>
<li><strong>标记</strong>找到的请求visited为<strong>true</strong>。</li>
<li><strong>累加</strong>最短距离到 sumDistance。</li>
<li><strong>更新 currentTrack</strong> 为找到的请求位置。</li>
</ul>
</li>
<li>返回平均寻道长度：<ul>
<li>返回 sumDistance 除以请求数组的长度。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">SSTF</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] request)</span> &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sumDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">currentTrack</span> <span class="operator">=</span> start;<span class="comment">//当前磁头所在的磁道号</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> request.length;</span><br><span class="line">    <span class="type">boolean</span>[] visited=<span class="keyword">new</span> <span class="title class_">boolean</span>[n];<span class="comment">//是否访问过</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">closest</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">//最接近当前磁头位置的请求 下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minDistance</span> <span class="operator">=</span> Integer.MAX_VALUE;<span class="comment">//每一次先初始化为最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;<span class="comment">//遍历找最短距离</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[j]&amp;&amp;Math.abs(currentTrack-request[j])&lt;minDistance)&#123;<span class="comment">//没被访问过+距离最近</span></span><br><span class="line">                minDistance=Math.abs(currentTrack-request[j]);</span><br><span class="line">                closest=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到，更新</span></span><br><span class="line">        visited[closest]=<span class="literal">true</span>;</span><br><span class="line">        sumDistance+=minDistance;</span><br><span class="line">        currentTrack=request[closest];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)sumDistance/request.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-扫描算法-SCAN"><a href="#3-扫描算法-SCAN" class="headerlink" title="3. 扫描算法 SCAN"></a>3. 扫描算法 SCAN</h2><ul>
<li>总是按照<strong>一个方向</strong>进行磁盘调度，直到该方向上的<strong>边缘</strong>，然后<strong>改变方向</strong></li>
<li>磁道总数，这个数字需要与Disk类中的TRACK_NUM保持一致。（256）</li>
<li><code>Arrays.sort(request);</code> 对请求数组进行<strong>升序排序</strong></li>
</ul>
<ol>
<li>初始化：<ul>
<li>sumDistance：总寻道距离，初始为0。</li>
<li>n：请求数组的长度。</li>
<li><strong>对请求数组进行升序排序</strong>：Arrays.sort(request);。</li>
</ul>
</li>
<li>判断初始移动方向：(题上说了true是增大方向)<ol>
<li>如果 <code>direction</code> 为 true，表示初始移动方向是<em>增大</em>方向。<ul>
<li>start &lt;&#x3D; request[0]，表示磁头在<strong>最小请求之前</strong>，直接移动到<strong>最大请求位置</strong>。<ul>
<li>易错：不是直接移动到磁道最后！</li>
</ul>
</li>
<li>start <strong>在请求数组中间</strong>，先移动到<strong>磁道最大</strong>位置(<code>255</code>)，再返回到<strong>最小请求</strong>位置。</li>
</ul>
</li>
<li>如果 direction 为 false，表示初始移动方向是<em>减小</em>方向。<ul>
<li>start &gt;&#x3D; request[n - 1]，表示磁头在<strong>最大请求之后</strong>，直接移动到<strong>最小请求位置</strong>。</li>
<li>start 在请求数组中间，先移动到<strong>磁道最小</strong>位置，再返回到<em>最大请求</em>位置。</li>
</ul>
</li>
</ol>
</li>
<li>返回平均寻道长度：<ul>
<li>返回 sumDistance 除以请求数组的长度。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">SCAN</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] request, <span class="type">boolean</span> direction)</span> &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sumDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> request.length;</span><br><span class="line">    Arrays.sort(request);<span class="comment">//升序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(direction)&#123;<span class="comment">//初始移动方向是增大方向</span></span><br><span class="line">        <span class="keyword">if</span>(start&lt;=request[<span class="number">0</span>])&#123;</span><br><span class="line">            sumDistance+=request[n-<span class="number">1</span>]-start;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//在中间</span></span><br><span class="line">            sumDistance+=(<span class="number">255</span>-start)+(<span class="number">255</span>-request[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//初始移动方向是减小方向</span></span><br><span class="line">        <span class="keyword">if</span>(start&gt;=request[n-<span class="number">1</span>])&#123;</span><br><span class="line">            sumDistance+=start-request[<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sumDistance+=start+request[n-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)sumDistance/n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-C-SCAN算法：默认磁头向磁道号增大方向移动"><a href="#4-C-SCAN算法：默认磁头向磁道号增大方向移动" class="headerlink" title="4. C-SCAN算法：默认磁头向磁道号增大方向移动"></a>4. C-SCAN算法：默认磁头向磁道号增大方向移动</h2><ul>
<li>只有磁头朝某个方向移动时才会响应请求，<strong>移动到边缘后立即让磁头返回起点</strong>，返回途中不做任何处理</li>
</ul>
<ol>
<li>初始化<ul>
<li>sumDistance：总寻道距离，初始为0。</li>
<li>currentTrack：当前磁头所在的磁道号，初始为 start。</li>
<li>n：请求数组的长度。</li>
<li>对请求数组进行升序排序：Arrays.sort(request);。</li>
</ul>
</li>
<li><strong>查找当前磁头位置</strong>：<ul>
<li>使用 <strong>Arrays.binarySearch(request, currentTrack)</strong> 查找<strong>当前磁头位置在请求数组中的索引</strong>。</li>
<li>如果未找到，计算当前磁头位置应该插入的位置：index &#x3D; -index - 1。</li>
</ul>
</li>
<li>初始移动方向是增大方向：<ul>
<li>如果 start &lt;&#x3D; request[0]，表示磁头<strong>在最小请求之前</strong>，直接移动到<strong>最大请求</strong>位置。</li>
<li>如果 start <strong>在请求数组中间或者右边</strong>，先移动到<strong>磁道最大</strong>位置，再<strong>返回到起点</strong>，然后<strong>移动到start前一个位置</strong>。<ul>
<li>易错：路径记得<strong>加上磁道最右到最左距离</strong>！</li>
</ul>
</li>
</ul>
</li>
<li>返回平均寻道长度</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">CSCAN</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span>[] request)</span>&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sumDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> request.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">currentTrack</span> <span class="operator">=</span> start;<span class="comment">//当前磁头所在的磁道号</span></span><br><span class="line">    Arrays.sort(request);<span class="comment">//升序</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(request, currentTrack);<span class="comment">//查找当前磁头位置在请求中的索引</span></span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span>)&#123;<span class="comment">//如果当前磁头位置不在请求中</span></span><br><span class="line">        index = -index-<span class="number">1</span>;<span class="comment">//计算当前磁头位置应该插入的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始移动方向是增大方向</span></span><br><span class="line">        <span class="keyword">if</span>(start&lt;=request[<span class="number">0</span>])&#123;</span><br><span class="line">            sumDistance+=request[n-<span class="number">1</span>]-start;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//在中间 或者 右边</span></span><br><span class="line">            sumDistance+=(<span class="number">255</span>-start)+<span class="number">255</span>+(request[index-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)sumDistance/n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-LOOK算法"><a href="#5-LOOK算法" class="headerlink" title="5.LOOK算法"></a>5.LOOK算法</h2><ul>
<li>SCAN算法的升级，只要磁头移动方向上不再有请求就<strong>立即改变磁头的方向</strong></li>
</ul>
<ol>
<li>初始化：<ul>
<li>sumDistance：总寻道距离，初始为0。</li>
<li>n：请求数组的长度。</li>
<li><strong>对请求数组进行升序排序：Arrays.sort(request);</strong></li>
</ul>
</li>
<li>查找当前磁头位置：<ul>
<li>使用 <strong>Arrays.binarySearch(request, start)</strong> 查找当前磁头位置在请求数组中的索引。</li>
<li>如果<strong>未找到，返回一个负数</strong>，该负数的<strong>绝对值减一</strong>即为<strong>start 应该插入的位置</strong>。<ul>
<li>计算当前磁头位置应该插入的位置：<code>index = -index - 1。</code></li>
</ul>
</li>
</ul>
</li>
<li>判断初始移动方向：<ol>
<li>如果 direction 为 true，表示初始移动方向是<strong>增大</strong>方向。<ul>
<li>从 <strong>index</strong> 开始向右遍历请求数组，累加距离。<ul>
<li><code>sumDistance += Math.abs(currentTrack - request[i])</code>;</li>
</ul>
</li>
<li>然后从 <strong>index - 1</strong> 开始向左遍历请求数组，累加距离。</li>
</ul>
</li>
<li>如果 direction 为 false，表示初始移动方向是<strong>减小</strong>方向。<ul>
<li>从 <strong>index - 1</strong> 开始向左遍历请求数组，累加距离。</li>
<li>然后从 <strong>index</strong> 开始向右遍历请求数组，累加距离。</li>
</ul>
</li>
</ol>
</li>
</ol>
<ul>
<li>返回平均寻道长度</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">LOOK</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span>[] request,<span class="type">boolean</span> direction)</span>&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sumDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> request.length;</span><br><span class="line">    Arrays.sort(request);<span class="comment">//升序</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(request, start);<span class="comment">//查找当前磁头位置在请求中的索引</span></span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span>)&#123;<span class="comment">//如果当前磁头位置不在请求中</span></span><br><span class="line">        index = -index-<span class="number">1</span>;<span class="comment">//计算当前磁头位置应该插入的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(direction)&#123;<span class="comment">//初始移动方向是增大方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; n; i++) &#123;</span><br><span class="line">            sumDistance += Math.abs(start - request[i]);</span><br><span class="line">            start = request[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            sumDistance += Math.abs(start - request[i]);</span><br><span class="line">            start = request[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//初始移动方向是减小方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            sumDistance += Math.abs(start - request[i]);</span><br><span class="line">            start = request[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;  i &lt;n; i++) &#123;</span><br><span class="line">            sumDistance += Math.abs(start - request[i]);</span><br><span class="line">            start = request[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)sumDistance/n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-C-LOOK算法"><a href="#6-C-LOOK算法" class="headerlink" title="6.C-LOOK算法"></a>6.C-LOOK算法</h2><ul>
<li><strong>默认</strong>磁头向磁道号<strong>增大方向</strong>移动</li>
<li>C-SCAN算法的改进，只要在磁头移动方向上<strong>不再有请求</strong>，就立即让磁头<strong>返回起点</strong></li>
</ul>
<ol>
<li>初始化<ul>
<li>sumDistance：总寻道距离，初始为0。</li>
<li>currentTrack：当前磁头所在的磁道号，初始为 start。</li>
<li>n：请求数组的长度。</li>
<li>对请求数组进行<strong>升序排序：Arrays.sort(request);</strong>。</li>
</ul>
</li>
<li><strong>查找当前磁头位置</strong>：<ul>
<li>使用 <strong>Arrays.binarySearch(request, currentTrack)</strong> 查找<strong>当前磁头位置在请求数组中的索引</strong>。</li>
<li>如果未找到，计算当前磁头位置应该插入的位置：<strong>index &#x3D; -index - 1。</strong></li>
</ul>
</li>
<li>初始移动方向是增大方向：<ul>
<li>从 index 开始向右遍历请求数组，累加距离。</li>
<li>然后从 0 开始向右遍历到 index - 1，累加距离。</li>
</ul>
</li>
<li>返回平均寻道长度</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">CLOOK</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span>[] request)</span>&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sumDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> request.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">currentTrack</span> <span class="operator">=</span> start;<span class="comment">//当前磁头所在的磁道号</span></span><br><span class="line">    Arrays.sort(request);<span class="comment">//升序</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(request, currentTrack);<span class="comment">//查找当前磁头位置在请求中的索引</span></span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span>)&#123;<span class="comment">//如果当前磁头位置不在请求中</span></span><br><span class="line">        index = -index-<span class="number">1</span>;<span class="comment">//计算当前磁头位置应该插入的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始移动方向是增大方向</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=index;i&lt;n;i++)&#123;</span><br><span class="line">        sumDistance+=Math.abs(currentTrack-request[i]);</span><br><span class="line">        currentTrack=request[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;=index-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        sumDistance+=Math.abs(currentTrack-request[i]);</span><br><span class="line">        currentTrack=request[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)sumDistance/n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>6-虚拟存储器</title>
    <url>/2025/02/22/6.%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    <content><![CDATA[<h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><ul>
<li>分别实现<strong>实模式、分段式、段页式</strong>三种内存的地址转换与数据加载功能。</li>
</ul>
<ol>
<li>地址转换<ul>
<li>在MMU类中，实现三个地址转换的方法，将逻辑地址转换为线性地址再转换为物理地址。</li>
<li>private String toRealLinearAddr(String logicAddr)</li>
<li>private String toSegLinearAddr(String logicAddr)</li>
<li>private String toPagePhysicalAddr(String linearAddr)</li>
</ul>
</li>
<li>数据加载<ul>
<li>在Memory类中，实现三个数据加载方法。</li>
<li>public void real_load(String pAddr, int len)</li>
<li>public void seg_load(int segIndex)</li>
<li>public void page_load(int vPageNo)</li>
</ul>
</li>
<li>融合cache与TLB<ul>
<li>将cache与TLB融合到MMU中。</li>
</ul>
</li>
</ol>
<ul>
<li>逻辑地址：<strong>指令</strong>中给出的地址， 48 位(16位段寄存器 + 32位段内偏移量)。<ul>
<li>CPU在运行指令时，如果想要访问内存，它并不是用直接使用内存的地址访问，而是给出一个由 16 位段寄存器和 32 位段内偏移量拼起来的 48 位的逻辑地址。<ul>
<li>比如，如果CPU想知道当前指令的地址，他给出的逻辑地址应该是(CS:EIP)。</li>
<li>其中，CS是 16 位代码段寄存器，EIP是 32 位指令指针寄存器（也就是程序计数器PC）。</li>
</ul>
</li>
</ul>
</li>
<li>线性地址：逻辑地址到物理地址的中间层， 32 位。<ul>
<li>如果<strong>没有启用分页机制</strong>，那么线性地址就<strong>等于物理地址</strong>。</li>
<li>如果启用了分页机制，那么线性地址需要通过再一次变换才能得到物理地址。</li>
</ul>
</li>
<li>物理地址：<strong>内存</strong>中的地址， 32 位。</li>
</ul>
<h1 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h1><h2 id="Memory的real-load方法"><a href="#Memory的real-load方法" class="headerlink" title="Memory的real_load方法"></a>Memory的<code>real_load</code>方法</h2><ul>
<li>SEGMENT和PAGE均为false时，为实模式</li>
<li>变量：<code>pAddr</code>与<code>len</code></li>
</ul>
<ol>
<li>直接用地址和长度从磁盘disk.read加载data</li>
<li>把data再写进内存(注意实模式下，内存地址对应磁盘地址，即pAddr)</li>
</ol>
<ul>
<li><code>System.arraycopy(data, 0, memory, start, len);</code><ul>
<li>将<strong>原数组</strong>data从<strong>起始位置</strong>0，复制到<strong>目标数组</strong>memory的start<strong>位置开始</strong>，复制的<strong>元素数量</strong>为len</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实模式下从磁盘中加载数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pAddr 实模式下，内存地址对应磁盘地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> len   数据段长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">real_load</span><span class="params">(String pAddr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] data = disk.read(pAddr, len);<span class="comment">//从磁盘中读取数据(方法在Disk.java中）</span></span><br><span class="line">    <span class="comment">//更新数据</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(pAddr));<span class="comment">//start,为内存地址</span></span><br><span class="line">    System.arraycopy(data, <span class="number">0</span>, memory, start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h2><ul>
<li>&#96;&#96;toRealLinearAddr&#96;方法: 逻辑地址转线性地址。<ul>
<li>段寄存器左移4位 + 段内偏移量的低16位 再补齐32位</li>
</ul>
</li>
</ul>
<ol>
<li><strong>截取前16位段寄存器</strong>；再<strong>截取offset低16位（实际截取32位）</strong>，转成int。<ul>
<li>在实际计算中，我们把高 16 位看作基址，低 32 位看作偏移量（实际有用的只有低 16 位）</li>
</ul>
</li>
<li>将段寄存器和偏移量<strong>化为整数</strong></li>
<li><strong>段寄存器左移4位</strong><ul>
<li>可以直接使用Java中的&lt;&lt;运算符将整数左移4位</li>
</ul>
</li>
<li>两个数字相加，转成二进制，高位补0到32位</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 实模式下的逻辑地址转线性地址</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> logicAddr 48位 = 16位段寄存器 + 32位offset，计算公式为：①(16-bits段寄存器左移4位 + offset的低16-bits) = 20-bits物理地址 ②高位补0到32-bits</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 32-bits实模式线性地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> String <span class="title function_">toRealLinearAddr</span><span class="params">(String logicAddr)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">segReg</span> <span class="operator">=</span> logicAddr.substring(<span class="number">0</span>, <span class="number">16</span>);<span class="comment">//取逻辑地址的前16位作为段寄存器</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">offset</span> <span class="operator">=</span> logicAddr.substring(<span class="number">16</span>, <span class="number">48</span>);<span class="comment">//取逻辑地址的后32位作为偏移量</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//将段寄存器和偏移量化为整数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">segRegInt</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(segReg));</span><br><span class="line">       <span class="type">int</span> <span class="variable">offsetLow16</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(offset));</span><br><span class="line"></span><br><span class="line">       <span class="comment">//计算20位物理地址</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">physicalAddr</span> <span class="operator">=</span> (segRegInt &lt;&lt; <span class="number">4</span>) + offsetLow16;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将20位物理地址转换为32位</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">linearAddr</span> <span class="operator">=</span> String.format(<span class="string">&quot;%32s&quot;</span>, Integer.toBinaryString(physicalAddr)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>);<span class="comment">//转换为32位，并用0填充高位</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> linearAddr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="分段式"><a href="#分段式" class="headerlink" title="分段式"></a>分段式</h1><h2 id="Memory类：实现seg-load段加载方法"><a href="#Memory类：实现seg-load段加载方法" class="headerlink" title="Memory类：实现seg_load段加载方法"></a>Memory类：实现seg_load段加载方法</h2><ol>
<li>从磁盘上加载该段的数据到内存。<ul>
<li>如何从磁盘上<strong>读取一整段</strong>呢？你应该使用<strong>段基址</strong>作为访问磁盘的地址，用**段限长（即段大小）**作为读取的长度。</li>
<li>至于段基址和段限长是多少，参考我们3.2.3的规定。<ul>
<li>private char[] base &#x3D; new char[32];  &#x2F;&#x2F; 32位基地址</li>
<li>private char[] limit &#x3D; new char[20]; &#x2F;&#x2F; 20位限长</li>
</ul>
</li>
<li>那么加载过来之后<strong>写到内存的哪里</strong>呢？由于分段式下每个段大小只有1MB，不会超出内存大小，所以我们<strong>默认把数据放在物理地址为 0 的地方</strong>。</li>
</ul>
</li>
<li>除了加载数据，你还需要<strong>填好全局描述符表GDT</strong>，需要填入的内容还是按照3.2.3的规定进行填写。下面为该规定的原文。<ul>
<li>每个由MMU装载进入GDT的段，<strong>其段基址均为全 0 ，其限长均为全 1</strong> ，<strong>未开启分页时粒度为false，开启分页后粒度为true</strong>。</li>
</ul>
</li>
</ol>
<ul>
<li>变量：segIndex段索引</li>
</ul>
<ol>
<li>获取段描述符：<ul>
<li>(有方法)通过 segIndex 获取对应的段描述符 segDes</li>
</ul>
</li>
<li>获取段基址和段限长：<ul>
<li><strong>段基址：32位全0</strong></li>
<li><strong>段限长：20位全1</strong></li>
</ul>
</li>
<li>判断是否开启分页<ul>
<li>如果<strong>未开启分页模式</strong>（PAGE 为 false），</li>
<li>则<strong>从磁盘中读取数据</strong>，并将数据<strong>写入内存</strong>的<strong>物理地址为0</strong>的地方。</li>
<li>注意，<strong>段限长</strong><em>是从0开始计数</em>，因此<strong>读取长度需要加1</strong>。</li>
</ul>
</li>
<li>更新段描述符：<ul>
<li>基址</li>
<li>限长</li>
<li>有效位：validBit 设置为 true 表示段已在内存中</li>
<li>粒度：granularity 设置为 PAGE（未开启分页时粒度为false，开启分页后粒度为true）</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 段式存储模式下，从磁盘中加载数据.段页式存储中，不用从磁盘中加载数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> segIndex 段索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//在段页式存储管理下，从磁盘加载数据应该是以页为单位的，不再是以段为单位。</span></span><br><span class="line"><span class="comment">// 开启分页之后，一个段应该是4GB。因此开启分页之后，seg_load应该跳过加载数据这一步，它的作用在开启分页之后仅仅是填写GDT，加载数据的任务应该交给page_load来完成。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">seg_load</span><span class="params">(<span class="type">int</span> segIndex)</span> &#123;</span><br><span class="line">    <span class="comment">//获取段描述符</span></span><br><span class="line">    <span class="type">SegDescriptor</span> <span class="variable">segDes</span> <span class="operator">=</span> getSegDescriptor(segIndex);</span><br><span class="line">   <span class="comment">//获取段基址(访问磁盘的地址)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">segBase</span> <span class="operator">=</span> <span class="string">&quot;00000000000000000000000000000000&quot;</span>; <span class="comment">// 32位基址，全0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">baseInt</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(segBase));</span><br><span class="line">    <span class="comment">//获取段限长(读取的长度)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="string">&quot;11111111111111111111&quot;</span>; <span class="comment">// 20位限长，全1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">limitInt</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(limit));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!PAGE) &#123;<span class="comment">//未开启分页,段式存储，要从磁盘中加载数据，并且写到内存的物理地址为0的地方</span></span><br><span class="line">        <span class="comment">//从磁盘中加载数据</span></span><br><span class="line">        <span class="type">byte</span>[] data = disk.read(segBase, limitInt + <span class="number">1</span>);<span class="comment">//注：段限长是一个从 0 开始的计数，因此需要+1才能表示实际的字节数</span></span><br><span class="line">        <span class="comment">//更新数据,写到内存的物理地址(destPost)为0的地方</span></span><br><span class="line">        System.arraycopy(data, <span class="number">0</span>, memory, <span class="number">0</span>, limitInt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填好全局描述符表GDT</span></span><br><span class="line">    segDes.base = segBase.toCharArray();</span><br><span class="line">    segDes.limit = limit.toCharArray();</span><br><span class="line">    segDes.validBit = <span class="literal">true</span>;<span class="comment">//有效位,为true表示被占用（段已在内存中）</span></span><br><span class="line">    segDes.granularity = PAGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MMU类：​​​​toSegLinearAddr​​​​-逻辑地址转线性地址。"><a href="#MMU类：​​​​toSegLinearAddr​​​​-逻辑地址转线性地址。" class="headerlink" title="MMU类：​​​​toSegLinearAddr​​​​ 逻辑地址转线性地址。"></a>MMU类：​​​​toSegLinearAddr​​​​ 逻辑地址转线性地址。</h2><ul>
<li>在分段式下，逻辑地址转线性地址应该要查全局描述符表GDT，按照2.3.4的流程进行计算。<ul>
<li>48 位的逻辑地址包含 16 位的段选择符和 32 位的段内偏移量。</li>
<li>MMU首先通过段选择符内的 13 位<strong>索引值</strong>，</li>
<li>从段描述符表中找到对应的段描述符，从中取出 32 位的<strong>基地址</strong>，与逻辑地址中 32 位的<strong>段内偏移量</strong>相加，就得到 32 位线性地址。</li>
</ul>
</li>
<li>注意，不要以为可以偷懒直接把逻辑地址的前 16 位去掉</li>
</ul>
<ol>
<li>直接调用已有的函数获得<strong>段索引</strong>​​​​segIndex​​​​</li>
<li>根据段索引获得<strong>段基址</strong>，也是直接调用函数。将段基址<strong>转成int</strong></li>
<li>截取32位段内偏移​​​​offset​​​​，<strong>转成int</strong></li>
<li>段基址与段内偏移<strong>相加</strong>，<strong>转成32位二进制</strong>，得到线性地址</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 分段模式下的逻辑地址转线性地址</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> logicAddr 48位 = 16位段选择符(高13位index选择段表项) + 32位段内偏移</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 32-bits 线性地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String <span class="title function_">toSegLinearAddr</span><span class="params">(String logicAddr)</span> &#123;</span><br><span class="line">       <span class="comment">//获取段索引(高13位index选择段表项)</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">segIndex</span> <span class="operator">=</span> getSegIndex(logicAddr);</span><br><span class="line">       <span class="comment">//从全局描述符表GDT中获取段描述符中的段基址base</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">segBaseAddr</span> <span class="operator">=</span> String.valueOf(Memory.getMemory().getBaseOfSegDes(segIndex));</span><br><span class="line">       <span class="comment">//提取段内偏移（32位）</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">offset</span> <span class="operator">=</span> logicAddr.substring(<span class="number">16</span>, <span class="number">48</span>);</span><br><span class="line">       <span class="comment">//将段基址和段内偏移转换为整数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">segBaseAddrInt</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(segBaseAddr));</span><br><span class="line">       <span class="type">int</span> <span class="variable">offsetInt</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(offset));</span><br><span class="line">       <span class="comment">//计算线性地址</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">linearAddr</span> <span class="operator">=</span> segBaseAddrInt + offsetInt;</span><br><span class="line">       <span class="comment">//将线性地址转换为32位</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">linearAddrStr</span> <span class="operator">=</span> String.format(<span class="string">&quot;%32s&quot;</span>, Integer.toBinaryString(linearAddr)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">       <span class="keyword">return</span> linearAddrStr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h1><h2 id="Memory类：page-load页加载方法。"><a href="#Memory类：page-load页加载方法。" class="headerlink" title="Memory类：page_load页加载方法。"></a>Memory类：page_load页加载方法。</h2><ol>
<li>从磁盘上加载该页数据到内存。<ul>
<li>如何在磁盘上读取该页数据呢？你应该使用<strong>该虚页的起始地址</strong>作为作为访问磁盘的地址，用<strong>页大小</strong>作为读取的长度。</li>
<li>至于<strong>该虚页的起始地址</strong>是多少，可以直接根据<strong>虚页号</strong>得到。</li>
<li>那么加载过来之后写到内存的哪里呢？这就需要你找出一个<strong>空闲的物理页框</strong>然后放下去啦。</li>
</ul>
</li>
<li>除了加载数据，你还需要<strong>填好页表</strong>，如果你使用有效位数组的话还需要<strong>填好有效位数组</strong>。</li>
</ol>
<ul>
<li>变量：​​​​vPageNo​​​​ 虚拟页号</li>
</ul>
<h3 id="1-加载页数据"><a href="#1-加载页数据" class="headerlink" title="1. 加载页数据"></a>1. 加载页数据</h3><ol>
<li>使用<strong>该虚页的起始地址</strong>作为访问磁盘的地址，<strong>起始地址&#x3D;虚页号×一页大小</strong></li>
<li>由于<strong>一页的大小是4KB</strong>，需要把虚拟页号乘以<strong>2的12次方</strong>，<ul>
<li>即转为二进制作为地址，<strong>二进制后面加12个0</strong></li>
</ul>
</li>
<li>从<strong>磁盘读</strong>出一页数据data。（长度为​​​​PAGE_SIZE_B​​​​页长）</li>
</ol>
<h3 id="2-写入内存"><a href="#2-写入内存" class="headerlink" title="2. 写入内存"></a>2. 写入内存</h3><ol>
<li>寻找<strong>空闲内存的物理页框</strong>——遍历valid找false。</li>
</ol>
<ul>
<li>范围<code>​​​​0 ~ pageValid.length​​​</code>​，<ul>
<li>当​​​pageValid[i]​​​​<strong>为​false​​​​，说明不在内存中，即空闲</strong>，将其<strong>改为占用</strong>，并<strong>记录页框号​​​​frameNO</strong>​​​​。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>接着将<em>数据装入页框</em>。将<strong>页框号×页大小</strong>，获得<strong>物理地址</strong>，将数据写入内存。（长度为​​​​PAGE_SIZE_B​​​​页长）</li>
</ol>
<h3 id="3-填页表"><a href="#3-填页表" class="headerlink" title="3. 填页表"></a>3. 填页表</h3><ol>
<li>由虚拟页号获得该页（​​​​getPageItem(vPageNo)​​​​），</li>
</ol>
<ul>
<li>将​​​​pageFrame​​​​设为页框号二进制的低20位转成的数组（物理页框号）</li>
<li>将​​​​isInMem​​​​设为true。（装入了内存）</li>
</ul>
<ol start="2">
<li>填好有效位（刚刚占用的设为true）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 段页式存储下，从磁盘中加载数据</span></span><br><span class="line"><span class="comment"> * 不考虑16MB内存用满的情况</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> vPageNo 虚拟页号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">page_load</span><span class="params">(<span class="type">int</span> vPageNo)</span> &#123;</span><br><span class="line">    <span class="comment">//虚拟页号的起始地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">vPageStartAddr</span> <span class="operator">=</span> Transformer.intToBinary(String.valueOf(vPageNo)).substring(<span class="number">12</span>) + <span class="string">&quot;000000000000&quot;</span>;</span><br><span class="line">    <span class="comment">//页大小作为读取的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> PAGE_SIZE_B;</span><br><span class="line">    <span class="comment">//从磁盘中加载数据</span></span><br><span class="line">    <span class="type">byte</span>[] data = disk.read(vPageStartAddr, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找出一个空闲的物理页框</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">freePageFrame</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;pageValid.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pageValid[i])&#123;<span class="comment">//如果该页不在内存中,即valid=false</span></span><br><span class="line">            freePageFrame = i;<span class="comment">//找到空闲的物理页框i</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (freePageFrame == -<span class="number">1</span>)&#123;<span class="comment">//无空闲</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;No free page frame&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据写到内存的物理地址为freePageFrame的地方</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">phyAddr</span> <span class="operator">=</span> freePageFrame * PAGE_SIZE_B;<span class="comment">//物理地址，即物理页框号*页大小</span></span><br><span class="line">    System.arraycopy(data, <span class="number">0</span>, memory, phyAddr, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填好页表</span></span><br><span class="line">    <span class="type">PageItem</span> <span class="variable">pageItem</span> <span class="operator">=</span> getPageItem(vPageNo);</span><br><span class="line">    pageItem.pageFrame = Transformer.intToBinary(String.valueOf(freePageFrame)).substring(<span class="number">12</span>).toCharArray();<span class="comment">//物理页框号</span></span><br><span class="line">    pageItem.isInMem = <span class="literal">true</span>;<span class="comment">//装入位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//填好有效位数组</span></span><br><span class="line">    pageValid[freePageFrame] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修改seg-load方法。"><a href="#修改seg-load方法。" class="headerlink" title="修改seg_load方法。"></a>修改seg_load方法。</h2><ul>
<li>因此开启分页之后，seg_load应该跳过加载数据这一步，它的作用在开启分页之后仅仅是填写GDT，加载数据的任务应该交给page_load来完成。</li>
<li>即<strong>if(!PAGE)</strong> {加载数据}</li>
</ul>
<h2 id="MMU类：toPagePhysicalAddr页级地址转换方法"><a href="#MMU类：toPagePhysicalAddr页级地址转换方法" class="headerlink" title="MMU类：toPagePhysicalAddr页级地址转换方法"></a>MMU类：toPagePhysicalAddr页级地址转换方法</h2><ul>
<li>在段页式下，线性地址转物理地址需要查页表，然后进行虚拟页号到物理页号的替换，具体流程可以参考课件。</li>
</ul>
<ol>
<li>从<strong>线性地址</strong>中<strong>提取前 20 位作为虚拟页号</strong>，<strong>后 12 位作为页内偏移</strong>。</li>
<li><strong>物理页号的获取</strong>（TLB是否可用）：都是使用 <code>getFrameOfPage</code> 函数，区别在于类不同<ol>
<li>如果开启了tlb，TLB<ul>
<li>调用<strong>tlb类的函数</strong>，由虚拟页号获取</li>
</ul>
</li>
<li>未开启，内存<ul>
<li>调用<strong>Memory类的函数</strong>，由虚拟页号获取</li>
</ul>
</li>
</ol>
</li>
<li>最后，将<strong>物理页号与页内偏移拼接</strong>获得物理地址。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 段页式下的线性地址转物理地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> linearAddr 32位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 32-bits 物理地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">toPagePhysicalAddr</span><span class="params">(String linearAddr)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="comment">//获取虚拟页号（线性地址的高20位）+获取页内偏移（线性地址的低12位）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">vPageNo</span> <span class="operator">=</span> linearAddr.substring(<span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">offset</span> <span class="operator">=</span> linearAddr.substring(<span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">vPageNoInt</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(vPageNo));</span><br><span class="line">    <span class="comment">//查页表，获取物理页号</span></span><br><span class="line">    <span class="type">char</span>[] pageFrame;</span><br><span class="line">    <span class="keyword">if</span>(TLB.isAvailable)&#123;</span><br><span class="line">        <span class="comment">//如果TLB可用，从TLB中获取物理页号</span></span><br><span class="line">        pageFrame = TLB.getTLB().getFrameOfPage(vPageNoInt);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果TLB不可用，从内存中获取物理页号</span></span><br><span class="line">        pageFrame = Memory.getMemory().getFrameOfPage(vPageNoInt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">pageFrameStr</span> <span class="operator">=</span> String.valueOf(pageFrame);</span><br><span class="line">    <span class="comment">//将物理页号和页内偏移拼接为物理地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">physicalAddr</span> <span class="operator">=</span> pageFrameStr + offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> physicalAddr;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> add tlb here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-cache与TLB的融合"><a href="#4-cache与TLB的融合" class="headerlink" title="4. cache与TLB的融合"></a>4. cache与TLB的融合</h1><h2 id="a-将cache融合进MMU中"><a href="#a-将cache融合进MMU中" class="headerlink" title="a. 将cache融合进MMU中"></a>a. 将cache融合进MMU中</h2><ul>
<li>这一步相对简单。需要注意，由于cache是memory的缓存，所以任何涉及到访问主存数据的地方都要添加对cache的调用。</li>
<li>只有两个标了todo的地方需要改，MMU类的read和write。直接加入<strong>当cache有效时，通过cache读&#x2F;写</strong>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] read(String logicAddr, <span class="type">int</span> length) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">physicalAddr</span> <span class="operator">=</span> addressTranslation(logicAddr, length);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> add cache here</span></span><br><span class="line">    <span class="keyword">if</span> (Cache.isAvailable) &#123;<span class="comment">//如果cache可用</span></span><br><span class="line">        <span class="keyword">return</span> cache.read(physicalAddr, length);<span class="comment">//从cache中读取数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果cache不可用,直接从内存中读取数据</span></span><br><span class="line">    <span class="keyword">return</span> memory.read(physicalAddr, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String logicAddr, <span class="type">int</span> length, <span class="type">byte</span>[] data)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">physicalAddr</span> <span class="operator">=</span> addressTranslation(logicAddr, length);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> add cache here</span></span><br><span class="line">    <span class="keyword">if</span> (Cache.isAvailable) &#123;<span class="comment">//如果cache可用</span></span><br><span class="line">        cache.write(physicalAddr, length, data);<span class="comment">//将数据写入cache</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无论cache是否可用，都要将数据写入内存</span></span><br><span class="line">    memory.write(physicalAddr, length, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="b-将TLB融合进MMU中"><a href="#b-将TLB融合进MMU中" class="headerlink" title="b. 将TLB融合进MMU中"></a>b. 将TLB融合进MMU中</h2><ol>
<li>MMU类<code>addressTranslation</code>函数。在标出的地方判断<ul>
<li>若TLB有效：若<strong>tlb中没有该页</strong>且<strong>内存中没有该页</strong>，缺页中断<ul>
<li>内存从磁盘加载该页的数据。</li>
<li>并且将该页写入tlb。<code>tlb.write(i);</code></li>
</ul>
</li>
<li>若TLB无效：<strong>直接判断内存</strong>中有没有该页（应该是有代码的）</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> add tlb here</span></span><br><span class="line"><span class="comment">//1. 启用TLB之后，判断是否缺页的工作应该首先交给TLB来完成。</span></span><br><span class="line"><span class="comment">//2. 如果发生缺页，page_load方法会进行填页表，填页表之后不要忘记填TLB。</span></span><br><span class="line"><span class="keyword">if</span> (TLB.isAvailable)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tlb.isValidPage(i))&#123;<span class="comment">//如果TLB中不存在该页</span></span><br><span class="line">    <span class="comment">// 缺页中断，该页不在内存中，内存从磁盘加载该页的数据</span></span><br><span class="line">        memory.page_load(i);<span class="comment">//从磁盘中加载数据,并填写页表</span></span><br><span class="line">        tlb.write(i);<span class="comment">//填写TLB</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (!memory.isValidPage(i)) &#123;</span><br><span class="line">    <span class="comment">// 缺页中断，该页不在内存中，内存从磁盘加载该页的数据</span></span><br><span class="line">    memory.page_load(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>toPagePhysicalAddr</code>方法，上面讲过了。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(TLB.isAvailable)&#123;</span><br><span class="line">    <span class="comment">//如果TLB可用，从TLB中获取物理页号</span></span><br><span class="line">    pageFrame = TLB.getTLB().getFrameOfPage(vPageNoInt);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果TLB不可用，从内存中获取物理页号</span></span><br><span class="line">    pageFrame = Memory.getMemory().getFrameOfPage(vPageNoInt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>7-控制器</title>
    <url>/2025/02/22/7.%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<h1 id="COA7-控制器"><a href="#COA7-控制器" class="headerlink" title="COA7 控制器"></a>COA7 控制器</h1><ul>
<li>完成tick方法，在每个时钟周期内根据ICC的状态进行对应操作</li>
<li>完成取指、间址、执行、中断四种操作</li>
</ul>
<h1 id="一、tick"><a href="#一、tick" class="headerlink" title="一、tick"></a>一、tick</h1><h2 id="1-时钟周期的实现"><a href="#1-时钟周期的实现" class="headerlink" title="1. 时钟周期的实现"></a>1. 时钟周期的实现</h2><ul>
<li>每个时钟周期中，我们需要完成三件事：<ol>
<li><strong>判断ICC中内容</strong>，得到当前处于哪个时钟周期</li>
<li>执行对应周期的<strong>指令微操作</strong>序列</li>
<li>根据指令执行情况<strong>判断ICC的下一个状态</strong></li>
</ol>
</li>
<li>ICC是一个2位的寄存器</li>
</ul>
<h3 id="00-取指"><a href="#00-取指" class="headerlink" title="00:取指"></a>00:取指</h3><ol>
<li>调用取指getInstruct();</li>
<li>判断下一步（间址 &#x2F; 执行）<ol>
<li>如果opcode为<strong>1101110</strong>，把ICC设为01，间址</li>
<li>不是的话，ICC设为10，执行</li>
</ol>
</li>
</ol>
<ul>
<li>注意1：<strong>IR是指令寄存器</strong>（Instruction Register），<em>取指后指令存在IR</em>。</li>
<li>注意2：<strong>opcode</strong>为指令的<strong>前8位</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ICC[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;ICC[<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">    getInstruct();</span><br><span class="line">    <span class="comment">//判断是否进入间址周期</span></span><br><span class="line">    <span class="comment">//额外规定一种间址指令addc，opcode为1101110</span></span><br><span class="line">    <span class="type">char</span>[] opcode=Arrays.copyOfRange(IR,<span class="number">0</span>,<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span> <span class="title class_">String</span>(opcode).equals(<span class="string">&quot;1101110&quot;</span>))&#123;</span><br><span class="line">        ICC[<span class="number">1</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ICC[<span class="number">0</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="01：间址"><a href="#01：间址" class="headerlink" title="01：间址"></a>01：间址</h3><ol>
<li>调用间址findOperand();</li>
<li>ICC设为10，执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ICC[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;ICC[<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">    findOperand();</span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    ICC[<span class="number">0</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    ICC[<span class="number">1</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10：执行"><a href="#10：执行" class="headerlink" title="10：执行"></a>10：执行</h3><ol>
<li>调用执行</li>
<li><strong>判断是否允许中断</strong>：（中断 &#x2F; 取指）<ul>
<li>通过<code>interruptController.signal</code>是否为true判断</li>
</ul>
<ol>
<li>中断则11</li>
<li>否则00，取指</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ICC[<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;ICC[<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">    operate();</span><br><span class="line">    <span class="comment">//是否允许中断</span></span><br><span class="line">    <span class="keyword">if</span>(interruptController.signal)&#123;</span><br><span class="line">        ICC[<span class="number">1</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ICC[<span class="number">0</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11：中断"><a href="#11：中断" class="headerlink" title="11：中断"></a>11：中断</h3><ol>
<li>执行中断</li>
<li>设为00，取指</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ICC[<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;ICC[<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">    interrupt();</span><br><span class="line">    <span class="comment">//设为00，取值</span></span><br><span class="line">    ICC[<span class="number">0</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    ICC[<span class="number">1</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-取指微操作序列"><a href="#2-取指微操作序列" class="headerlink" title="2. 取指微操作序列"></a>2. 取指微操作序列</h2><ol>
<li>将PC中的内容加载到MAR<ul>
<li><code>Arrays.copyOf(PC,32);</code></li>
</ul>
</li>
<li>根据MAR中保存的地址，读取memory中对应内容到MBR（请注意memory中读出的数据是byte数组类型，而寄存器类型是char数组）<ul>
<li>有给出的函数<code>getFromMemory(new String(MAR));</code></li>
</ul>
</li>
<li>增加PC到下一条指令的位置（此时PC应该加上多少？为什么？考虑指令的长度）<ul>
<li>PC<strong>加4</strong>（32位&#x3D;4字节）</li>
<li>用alu.add</li>
</ul>
</li>
<li>将MBR中的内容装载到IR中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getInstruct</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    MAR=Arrays.copyOf(PC,<span class="number">32</span>);</span><br><span class="line">    MBR=getFromMemory(<span class="keyword">new</span> <span class="title class_">String</span>(MAR));</span><br><span class="line"></span><br><span class="line">    String nextPC=alu.add(<span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="keyword">new</span> <span class="title class_">String</span>(PC)),<span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="string">&quot;00000000000000000000000000000100&quot;</span>)).toString();</span><br><span class="line">    PC=nextPC.toCharArray();</span><br><span class="line"></span><br><span class="line">    IR=Arrays.copyOf(MBR,<span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-间址周期的实现"><a href="#3-间址周期的实现" class="headerlink" title="3. 间址周期的实现"></a>3. 间址周期的实现</h2><ol>
<li>将<strong>rs2中的内容</strong>加载到MAR中<ul>
<li><strong>rs2: IR中的20~24位</strong></li>
<li>rs2中的内容：<strong>GPR[rs2]</strong><ul>
<li>化为int：<code>int rs2_int=getRegister(rs2);</code></li>
<li>读<strong>GPR[rs2_int]</strong></li>
</ul>
</li>
</ul>
</li>
<li>根据<strong>MAR中的地址</strong>读出内存中对应数据存回rs2中<ul>
<li>MAR中的地址:<code>getFromMemory()</code></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findOperand</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="comment">//1. 将rs2中的内容加载到MAR中</span></span><br><span class="line">        <span class="comment">//rs2：20到24位</span></span><br><span class="line">    <span class="type">char</span>[] rs2=Arrays.copyOfRange(IR,<span class="number">20</span>,t25);</span><br><span class="line">    <span class="type">int</span> rs2_int=getRegister(rs2);</span><br><span class="line">    MAR=Arrays.copyOf(GPR[rs2_int],<span class="number">32</span>);</span><br><span class="line">    <span class="comment">//2. 根据MAR中的地址读出内存中对应数据存回rs2中</span></span><br><span class="line">    GPR[rs2_int]=getFromMemory(<span class="keyword">new</span> <span class="title class_">String</span>(MAR));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-执行周期的实现"><a href="#4-执行周期的实现" class="headerlink" title="4. 执行周期的实现"></a>4. 执行周期的实现</h2><ul>
<li>根据不同的opcode进行不同的操作</li>
<li>add指令可以调用ALU中已经实现好的加法进行</li>
<li>对应结果存到相应的位置中</li>
<li>特殊关注：<ul>
<li>jalr: 保存并跳转指令。在改变PC之前，我们要先将返回的位置保存到ra寄存器中，我们规定GPR的第1个寄存器是返回地址寄存器（第0个GPR寄存器保存0）</li>
<li>ecall: 系统调用中断指令。同样要保存返回位置，同时要设置中断控制器。</li>
</ul>
</li>
<li>寄存器和立即数的下标在指令中为了方便处理采用大端存储的方式，即从低到高直接截取转化为十进制即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="type">char</span>[] opcode=Arrays.copyOfRange(IR,<span class="number">0</span>,<span class="number">7</span>);</span><br><span class="line">    String opcode_str=<span class="keyword">new</span> <span class="title class_">String</span>(opcode);</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1100110&quot;</span>))&#123;<span class="comment">//add</span></span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1110110&quot;</span>))&#123;<span class="comment">//lui</span></span><br><span class="line">        lui();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1100000&quot;</span>))&#123;<span class="comment">//lw</span></span><br><span class="line">        lw();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1100100&quot;</span>))&#123;<span class="comment">//addi</span></span><br><span class="line">        addi();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1101110&quot;</span>))&#123;<span class="comment">//addc但是add</span></span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1110011&quot;</span>))&#123;<span class="comment">//jalr</span></span><br><span class="line">        jalr();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1100111&quot;</span>))&#123;<span class="comment">//ecall</span></span><br><span class="line">        ecall();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><ul>
<li><strong>rs1:15-19位</strong></li>
<li><strong>rs2:20-24位</strong></li>
<li><strong>rd:7-11</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//rs1:15-19位</span></span><br><span class="line">    <span class="comment">//rs2:20-24位</span></span><br><span class="line">    <span class="comment">//rd:7-11</span></span><br><span class="line">    <span class="type">char</span>[] rs1=Arrays.copyOfRange(IR,<span class="number">15</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="type">char</span>[] rs2=Arrays.copyOfRange(IR,<span class="number">20</span>,<span class="number">25</span>);</span><br><span class="line">    <span class="type">char</span>[] rd =Arrays.copyOfRange(IR,<span class="number">7</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rs1_num=getRegister(rs1);</span><br><span class="line">    <span class="type">int</span> rs2_num=getRegister(rs2);</span><br><span class="line">    <span class="type">int</span> rd_num=getRegister(rd);</span><br><span class="line"></span><br><span class="line">    GPR[rd_num]=alu.add(<span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="keyword">new</span> <span class="title class_">String</span>(GPR[rs1_num])),<span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="keyword">new</span> <span class="title class_">String</span>(GPR[rs2_num]))).toString().toCharArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lui：将12-31位的20位立即数加载到目标寄存器的高20位，低12位全0"><a href="#lui：将12-31位的20位立即数加载到目标寄存器的高20位，低12位全0" class="headerlink" title="lui：将12-31位的20位立即数加载到目标寄存器的高20位，低12位全0"></a>lui：将12-31位的20位立即数加载到目标寄存器的高20位，低12位全0</h3><ul>
<li>将一个 <strong>20 位的立即数</strong>加载到<strong>寄存器的高 20 位</strong>，而<strong>低 12 位则被置为 0</strong></li>
<li><strong>rd:7-11位</strong></li>
<li><strong>imm：12-31位</strong></li>
<li><strong>int IMM&#x3D;Integer.valueOf(String.valueOf(imm_num),2)&lt;&lt;12</strong>;<ul>
<li><code>String.valueOf(imm_num)</code>：将 imm_num 转换为字符串。</li>
<li><code>Integer.valueOf(String.valueOf(imm_num), 2)</code>：将上一步得到的字符串<strong>作为二进制数解析</strong>，并转换为一个<strong>整数</strong>。这里的 <strong>2 表示二进制</strong>。</li>
<li><code>&lt;&lt; 12</code>：将解析得到的整数<strong>左移 12 位</strong>。左移 12 位相当于将该整数乘以 2 的 12 次方（4096），这<strong>会将原来的低 12 位置为 0，并将高 20 位保留</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lui</span><span class="params">()</span>&#123;<span class="comment">//将一个 20 位的立即数加载到寄存器的高 20 位，而低 12 位则被置为 0</span></span><br><span class="line">    <span class="comment">//rd:7-11</span></span><br><span class="line">    <span class="comment">//imm:12-31</span></span><br><span class="line">    <span class="type">char</span>[] rd=Arrays.copyOfRange(IR,<span class="number">7</span>,<span class="number">12</span>);</span><br><span class="line">    <span class="type">char</span>[] imm=Arrays.copyOfRange(IR,<span class="number">12</span>,<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rd_num=getRegister(rd);</span><br><span class="line">    <span class="type">int</span> imm_num=getRegister(imm);</span><br><span class="line">    <span class="type">int</span> IMM=Integer.valueOf(String.valueOf(imm_num),<span class="number">2</span>)&lt;&lt;<span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    GPR[rd_num]=Transformer.intToBinary(String.valueOf(IMM)).toCharArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lw：基址寄存器内的值-偏移量得到新地址，将新地址内的值存到目标寄存器中"><a href="#lw：基址寄存器内的值-偏移量得到新地址，将新地址内的值存到目标寄存器中" class="headerlink" title="lw：基址寄存器内的值+偏移量得到新地址，将新地址内的值存到目标寄存器中"></a>lw：基址寄存器内的值+偏移量得到新地址，将新地址内的值存到目标寄存器中</h3><ol>
<li>提取指令字段<ul>
<li>基址寄存器rs1：15-19位</li>
<li>立即数（偏移量）imm：20-31位</li>
<li>目标寄存器rd：7-11位</li>
</ul>
</li>
<li>获取寄存器编号：getRegister()</li>
<li>计算<strong>新内存地址</strong>offset<ul>
<li>将 imm 转换为二进制整数 IMM。（变string，再string变二进制int）</li>
<li>将基址寄存器 GPR[rs1_num] 的值转换为二进制整数 RS1。</li>
<li>计算内存地址 offset，即 IMM 加上 RS1。</li>
</ul>
</li>
<li>从内存中读取数据<ul>
<li>使用 <code>Transformer.intToBinary</code> 方法将 offset 转换为二进制字符串。</li>
<li>调用 <code>getFromMemory</code> 方法从内存中读取数据，并将其存储到目标寄存器 GPR[rd_num] 中。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lw</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//rs1:15-19位</span></span><br><span class="line">    <span class="comment">//imm：20-31位</span></span><br><span class="line">    <span class="comment">//rd:7-11位</span></span><br><span class="line">    <span class="type">char</span>[] rs1=Arrays.copyOfRange(IR,<span class="number">15</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="type">char</span>[] imm=Arrays.copyOfRange(IR,<span class="number">20</span>,<span class="number">32</span>);</span><br><span class="line">    <span class="type">char</span>[] rd =Arrays.copyOfRange(IR,<span class="number">7</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rs1_num=getRegister(rs1);</span><br><span class="line">    <span class="type">int</span> rd_num=getRegister(rd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> IMM=Integer.valueOf(String.valueOf(imm),<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> RS1=Integer.valueOf(String.valueOf(GPR[rs1_num]),<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> offset=IMM+RS1;</span><br><span class="line"></span><br><span class="line">    GPR[rd_num]=getFromMemory(Transformer.intToBinary(String.valueOf(offset)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="addi-源寄存器内的值-偏移量，存入目标寄存器"><a href="#addi-源寄存器内的值-偏移量，存入目标寄存器" class="headerlink" title="addi 源寄存器内的值+偏移量，存入目标寄存器"></a>addi 源寄存器内的值+偏移量，存入目标寄存器</h3><ol>
<li>提取指令字段<ul>
<li>源寄存器rs1：15-19位</li>
<li>立即数（偏移量）imm：20-31位</li>
<li>目标寄存器rd：7-11位</li>
</ul>
</li>
<li>获取寄存器编号：getRegister()</li>
<li>计算<em>立即数</em>和<em>源寄存器内数据</em>的值，转换为<strong>二进制整数</strong></li>
<li>计算结果：立即数+源寄存器内数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addi</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//rs1:15-19位</span></span><br><span class="line">    <span class="comment">//imm：20-31位</span></span><br><span class="line">    <span class="comment">//rd:7-11位</span></span><br><span class="line">    <span class="type">char</span>[] rs1=Arrays.copyOfRange(IR,<span class="number">15</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="type">char</span>[] imm=Arrays.copyOfRange(IR,<span class="number">20</span>,<span class="number">32</span>);</span><br><span class="line">    <span class="type">char</span>[] rd =Arrays.copyOfRange(IR,<span class="number">7</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rs1_num=getRegister(rs1);</span><br><span class="line">    <span class="type">int</span> rd_num=getRegister(rd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> IMM=Integer.valueOf(String.valueOf(imm),<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> RS1=Integer.valueOf(String.valueOf(GPR[rs1_num]),<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=IMM+RS1;</span><br><span class="line"></span><br><span class="line">    GPR[rd_num]=Transformer.intToBinary(String.valueOf(res)).toCharArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="addc：直接add（间址）"><a href="#addc：直接add（间址）" class="headerlink" title="addc：直接add（间址）"></a>addc：直接add（间址）</h3><h3 id="jalr：保存当前程序计数器（PC）的值到返回地址寄存器（ra），然后跳转到新的地址"><a href="#jalr：保存当前程序计数器（PC）的值到返回地址寄存器（ra），然后跳转到新的地址" class="headerlink" title="jalr：保存当前程序计数器（PC）的值到返回地址寄存器（ra），然后跳转到新的地址"></a>jalr：保存当前程序计数器（PC）的值到返回地址寄存器（ra），然后跳转到新的地址</h3><ul>
<li>在<strong>改变PC之前</strong>，我们要先<strong>将返回的位置保存到ra寄存器</strong>中，我们<strong>规定GPR的第1个寄存器是返回地址寄存器</strong>（第0个GPR寄存器保存0）</li>
</ul>
<ol>
<li>提取指令字段<ul>
<li>基质寄存器rs1：15-19位</li>
<li>立即数（偏移量）imm：20-31位</li>
<li>返回地址寄存器ra：7-11位a</li>
</ul>
</li>
<li>获取寄存器编号</li>
<li>计算立即数IMM和基址寄存器内数RS1的值(化为二进制整数)</li>
<li>计算<strong>新地址</strong>，即 <strong>IMM 加上 RS1</strong></li>
<li><strong>保存当前 PC 到ra，并跳转到新地址</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jalr</span><span class="params">()</span>&#123;<span class="comment">//保存并跳转指令</span></span><br><span class="line">    <span class="comment">//rs1:15-19位</span></span><br><span class="line">    <span class="comment">//imm：20-31位</span></span><br><span class="line">    <span class="comment">//ra:7-11位</span></span><br><span class="line">    <span class="type">char</span>[] rs1=Arrays.copyOfRange(IR,<span class="number">15</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="type">char</span>[] imm=Arrays.copyOfRange(IR,<span class="number">20</span>,<span class="number">32</span>);</span><br><span class="line">    <span class="type">char</span>[] ra =Arrays.copyOfRange(IR,<span class="number">7</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rs1_num=getRegister(rs1);</span><br><span class="line">    <span class="type">int</span> ra_num=getRegister(ra);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> IMM=Integer.valueOf(String.valueOf(imm),<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> RS1=Integer.valueOf(String.valueOf(GPR[rs1_num]),<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> newAddr=IMM+RS1;</span><br><span class="line"></span><br><span class="line">    GPR[ra_num]=Arrays.copyOf(PC,<span class="number">32</span>);</span><br><span class="line">    PC=Transformer.intToBinary(String.valueOf(newAddr)).toCharArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ecall：系统调用中断指令。保存当前程序计数器（PC）的值，并设置中断控制器。"><a href="#ecall：系统调用中断指令。保存当前程序计数器（PC）的值，并设置中断控制器。" class="headerlink" title="ecall：系统调用中断指令。保存当前程序计数器（PC）的值，并设置中断控制器。"></a>ecall：系统调用中断指令。保存当前程序计数器（PC）的值，并设置中断控制器。</h3><ul>
<li>规定GPR的第1个寄存器是返回地址寄存器</li>
</ul>
<ol>
<li>PC保存到GPR[1]中</li>
<li>中断信号设置为true</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ecall</span><span class="params">()</span>&#123;<span class="comment">//系统调用中断指令。同样要保存返回位置，同时要设置中断控制器。</span></span><br><span class="line">    interruptController.signal=<span class="literal">true</span>;</span><br><span class="line">    GPR[<span class="number">1</span>]=Arrays.copyOf(PC,<span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-中断"><a href="#5-中断" class="headerlink" title="5. 中断"></a>5. 中断</h2><ul>
<li>使用ecall指令来模拟中断操作。在中断发生时，系统要保存程序的返回位置（是多少？），以便完成中断处理程序后返回原有程序。</li>
</ul>
<ol>
<li>此处我们使用<strong>handleInterrupt</strong>来模拟中断程序的实现。</li>
<li>执行完中断操作后，将<strong>允许中断位改为false</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    interruptController.handleInterrupt();</span><br><span class="line">    interruptController.signal=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/02/20/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
  </entry>
  <entry>
    <title>一、计算机网络及其参考模型</title>
    <url>/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="互联网计算"><a href="#互联网计算" class="headerlink" title="互联网计算"></a>互联网计算</h1><h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p> 10% 大作业 + 40% 上机 + 50% 期末</p>
<h2 id="课程资料"><a href="#课程资料" class="headerlink" title="课程资料"></a>课程资料</h2><p>219.219.113.233<br>用户:net<br>密码:net</p>
<h1 id="一、计算机网络概述"><a href="#一、计算机网络概述" class="headerlink" title="一、计算机网络概述"></a>一、计算机网络概述</h1><h3 id="1-What-is-a-network"><a href="#1-What-is-a-network" class="headerlink" title="1. What is a network?"></a>1. What is a network?</h3><ul>
<li>物体,事物,设备,人的连接</li>
<li><strong>LAN</strong>(Local Area Networks) 局域网</li>
<li><strong>WAN</strong>(Wide Area Networks) 广域网</li>
</ul>
<h2 id="2-数据网络分类：LAN-WAN"><a href="#2-数据网络分类：LAN-WAN" class="headerlink" title="2. 数据网络分类：LAN&#x2F;WAN"></a>2. 数据网络分类：LAN&#x2F;WAN</h2><ol>
<li>LANs 局域网 广播方式通信<ol>
<li>Operate locally</li>
<li>Multi-user access 连接可以被共享</li>
<li>High speeds expected 最高达到800G (距离短)</li>
<li>Error rate is easily controlled 因为范围小好判断出错</li>
</ol>
</li>
<li>WANs 广域网<ul>
<li>先于 LAN 网络产生</li>
</ul>
<ol>
<li>Operate over larger areas 现在主要使用光纤</li>
<li>Access over serial links, optical links, etc. <strong>点对点的连接</strong></li>
<li>Traditionally, have <strong>lower</strong> speeds</li>
<li>Error rate can <strong>not</strong> be easily controlled</li>
</ol>
</li>
<li>网络抽象模型<ul>
<li>node：节点</li>
<li>link：链路</li>
</ul>
</li>
</ol>
<h3 id="2-1-局域网和广域网差别"><a href="#2-1-局域网和广域网差别" class="headerlink" title="2.1 局域网和广域网差别"></a>2.1 局域网和广域网差别</h3><ol>
<li>局域网<ul>
<li>作用<strong>范围比较窄</strong></li>
<li>多用户<strong>同时复用链路介质</strong></li>
<li>网络<strong>性能比较高</strong>（一般是一个公司来管理处理，可以达到 GPS 甚至是 10GPS）</li>
<li><strong>出错率</strong>相对比较容易控制（<strong>低</strong>）</li>
</ul>
</li>
<li>广域网<ul>
<li>在比较<strong>大的地理范围</strong>上进行连接</li>
<li>要么<strong>串行连接（serial links）</strong>，要么<strong>光链路连接（optical links）</strong></li>
<li>传统上，<strong>传输速率比较低</strong>，因为一般是多公司管理，标准和介质等都不同</li>
<li><strong>出错率</strong>相对比较<strong>高</strong></li>
</ul>
</li>
</ol>
<h3 id="2-2-LAN-Devices-局域网设备"><a href="#2-2-LAN-Devices-局域网设备" class="headerlink" title="2.2 LAN Devices 局域网设备"></a>2.2 LAN Devices 局域网设备</h3><ol>
<li>Hub 集线器：工作在第一层<ul>
<li>多端口中继器（Reapter），连接 PC</li>
<li>重复信号</li>
</ul>
</li>
<li>Bridge 网桥：工作在第二层<ul>
<li>将局域网分段</li>
<li>进行 MAC 地址的计算</li>
</ul>
</li>
<li>Switch 交换机，多端口网桥：工作在第二层<ul>
<li>多端口网桥</li>
<li>全带宽（满带宽）</li>
<li>大规模集成电路实现：相对于网桥的优点</li>
</ul>
</li>
<li>Router 路由器 ：工作在第三层<ul>
<li>路径选择</li>
<li>分组交换<br><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-1.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ol>
<h3 id="2-3-WAN-Devices-广域网设备"><a href="#2-3-WAN-Devices-广域网设备" class="headerlink" title="2.3 WAN Devices 广域网设备"></a>2.3 WAN Devices 广域网设备</h3><ol>
<li>Router 路由器<ul>
<li>路径选择</li>
<li>分组交换</li>
</ul>
</li>
<li>Modem: 调制解调器</li>
<li>CSU&#x2F;DSU: 通道服务单元&#x2F;数据服务单元</li>
<li>TA&#x2F;NT1: 终端适配器&#x2F;网络终端1</li>
</ol>
<ul>
<li>234都是将<em>模拟信号转换为数字信号</em>, 还可以进行<em>远程局域网连接</em></li>
</ul>
<h3 id="2-4-LAN-Services-and-WAN-Services"><a href="#2-4-LAN-Services-and-WAN-Services" class="headerlink" title="2.4 LAN Services and WAN Services"></a>2.4 LAN Services and WAN Services</h3><ol>
<li>LAN Service: <strong>Ethernet</strong> (以太网) 最流行的局域网服务</li>
<li>WAN Service: 有很多,不是本节课重点</li>
</ol>
<h2 id="3-Internet-互联网"><a href="#3-Internet-互联网" class="headerlink" title="3. Internet 互联网"></a>3. Internet 互联网</h2><ol>
<li>简介</li>
</ol>
<ul>
<li>互联网, 全球性的计算机网络系统, 将世界各地的局域网（LAN）,广域网（WAN）和其他类型的网络连接在一起</li>
<li>全球最大的开放性广域网</li>
<li>TCP&#x2F;IP 作为参考标准</li>
<li>从 ARPNET 发展出来</li>
</ul>
<h3 id="3-1-Internet-with-Multi-layer-ISP-structure（多层-ISP-结构的-Internet"><a href="#3-1-Internet-with-Multi-layer-ISP-structure（多层-ISP-结构的-Internet" class="headerlink" title="3.1 Internet with Multi-layer ISP structure（多层 ISP 结构的 Internet"></a>3.1 Internet with Multi-layer ISP structure（多层 ISP 结构的 Internet</h3><ol>
<li><strong>Internet Service Providers（ISP）：互联网服务提供商</strong><ul>
<li>user——ISP——Internet</li>
</ul>
</li>
<li>具有多层 ISP 结构的 Internet<ul>
<li>主机A → 本地 ISP → 第二层 ISP → NAP → 第一层 ISP → NAP → 第二层 ISP → 本地 ISP → 主机B<br><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-2.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ol>
<ul>
<li><strong>第一层 ISP 是核心层</strong>，主要负责<strong>远距离连通。</strong></li>
<li>这种多层 ISP 结构可以将大量的流量本地化</li>
<li>NAP（Network Access Point）：第一二层之间的接入点，也可以是 google（大公司）直接和第一层 ISP 进行链接</li>
<li>ICP（Internet Content Provider）：互联网内容提供商，不提供接入服务</li>
<li>在低层次的 ISP 可以解决的问题就不进入上一层进行解决，将大量的流量分流。</li>
</ul>
<h1 id="二、计算机网络基本概念"><a href="#二、计算机网络基本概念" class="headerlink" title="二、计算机网络基本概念"></a>二、计算机网络基本概念</h1><h2 id="1-Data数据"><a href="#1-Data数据" class="headerlink" title="1. Data数据"></a>1. Data数据</h2><ul>
<li>Data is sent in bits, 1s and 0s.<ul>
<li><strong>数据按位（1 和 0）为单位发送</strong></li>
</ul>
</li>
<li>Data is not the information itself.<ul>
<li><strong>数据不是信息本身</strong>，不同方式解析数据会是不同信息<ul>
<li>数据都是 0-1 序列，需要按照一定编码格式翻译转码才成为信息</li>
</ul>
</li>
</ul>
</li>
<li>Data is an encoded form of information which is a series of electrical impulses&#x2F;optical signals into which information is transmitted for sending.<ul>
<li><strong>数据是信息的一种编码形式</strong>，它是一系列电脉冲&#x2F;光信号，信息被传输到其中进行发送</li>
</ul>
</li>
</ul>
<h3 id="1-1-Data-Packets数据包"><a href="#1-1-Data-Packets数据包" class="headerlink" title="1.1 Data Packets数据包"></a>1.1 Data Packets数据包</h3><ol>
<li>为了传输，计算机数据通常被分解成<strong>小的、易于传输的单元</strong><ul>
<li>使用 OSI 模型</li>
<li>这些单元可以称为：包packets、帧frames、段segments</li>
<li>具体取决于OSI模型的不同层次<ul>
<li>网络层称为 packets 报文，数据链路层称为 frames 帧，数据段层称为 segments 段</li>
</ul>
</li>
</ul>
</li>
<li>why data packets? 为什么使用数据包？<ul>
<li>Computers can take turns sending packets<ul>
<li><strong>计算机可以轮流发送数据包</strong>，分时段处理不同报文，使得<em>多进程</em>处理事务。</li>
</ul>
</li>
<li>If packet is lost, only small amount of data must be retransmitted重新传输.<ul>
<li>如果数据包<strong>丢失，则只需重新传输少量数据</strong></li>
</ul>
</li>
<li>Data can take different paths.<ul>
<li>数据可以采用<strong>不同的路径</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="1-2-Protocol协议"><a href="#1-2-Protocol协议" class="headerlink" title="1.2 Protocol协议"></a>1.2 Protocol协议</h3><ol>
<li>It is possible for different types of computer systems to communicate<ul>
<li><strong>不同类型的计算机系统可</strong>以进行<strong>通信</strong></li>
</ul>
</li>
<li>All devices must speak the same “language” or use the same <strong>protocol</strong> (use same set of rules).<ul>
<li>所有设备必须使用<strong>相同的“语言”或使用相同的协议</strong>（使用同一套规则）。</li>
</ul>
</li>
</ol>
<h3 id="1-3-Source-and-Destination源地址和目标地址"><a href="#1-3-Source-and-Destination源地址和目标地址" class="headerlink" title="1.3 Source and Destination源地址和目标地址"></a>1.3 Source and Destination源地址和目标地址</h3><ul>
<li><strong>源地址</strong> Source address specifies the identity of the computer sending the packet.<ul>
<li><strong>发送数据包</strong>的计算机的身份</li>
</ul>
</li>
<li><strong>目标地址</strong> Destination address specifies the identity of the computer designated to receive the packet.<ul>
<li><strong>接收数据包</strong>的计算机的身份</li>
</ul>
</li>
</ul>
<h3 id="1-4-传输介质-Media-Types"><a href="#1-4-传输介质-Media-Types" class="headerlink" title="1.4 传输介质 Media Types"></a>1.4 传输介质 Media Types</h3><ol>
<li>Media—material through which data packets travel<ul>
<li>介质是数据包传输所通过的介质。</li>
</ul>
</li>
<li><strong>带宽 Bandwidth</strong>：<ul>
<li>is the measure of how much information can flow from one place to another in a given amount of time.带宽是指在单位时间内可以传输的最大数据量</li>
<li>Measured in: bits&#x2F;second (bps)通常以比特每秒（bps）为单位。<ul>
<li>单位：bps，计算时注意要<strong>将字转换为位</strong></li>
</ul>
</li>
<li>作用: 带宽决定了网络的最大传输能力。带宽越高，网络能够传输的数据量就越大。</li>
<li>类比: 可以将带宽类比为高速公路的车道数，车道越多，能够同时通过的车辆就越多。</li>
</ul>
</li>
<li>通量 Throughput：<ul>
<li>Actual measured bandwidth at a specific time <em>单位时间</em>内<strong>实际</strong>传输的数据量，也以*比特每秒（bps）*为单位。</li>
<li><strong>Throughput &lt;&#x3D; Bandwidth</strong></li>
<li>作用: 通量反映了网络的实际性能，通常会受到网络拥塞、延迟、丢包等因素的影响。</li>
<li>类比: 通量可以类比为高速公路上实际通过的车辆数，即使高速公路有很多车道，但如果有交通堵塞，实际通过的车辆数也会减少。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="三、OSI-参考模型"><a href="#三、OSI-参考模型" class="headerlink" title="三、OSI 参考模型"></a>三、OSI 参考模型</h1><h2 id="1-OSI-Open-System-Interconnection-Model开放系统互连参考模型"><a href="#1-OSI-Open-System-Interconnection-Model开放系统互连参考模型" class="headerlink" title="1. OSI (Open System Interconnection) Model开放系统互连参考模型"></a>1. OSI (Open System Interconnection) Model开放系统互连参考模型</h2><ul>
<li>由国际标准化组织 （ISO） 提议 </li>
<li>是一个<strong>分层的网络架构模型</strong>，用于<em>标准化网络通信的功能</em></li>
<li>帮助网络构建者实现<strong>可以通信和协同工作</strong>的网络模型 </li>
<li>描述<em>信息或数据</em>如何<em>通过网络</em>从一台计算机<em>移动到另一台计算机</em> </li>
<li><strong>分层通信</strong>过程：每一层执行一项特定任务</li>
</ul>
<h2 id="2-The-OSI-Reference-Model层次模型"><a href="#2-The-OSI-Reference-Model层次模型" class="headerlink" title="2. The OSI Reference Model层次模型"></a>2. The OSI Reference Model层次模型</h2><p>+——————-+<br>|   应用层 (Layer 7)<br>|   Application<br>+——————-+<br>|   表示层 (Layer 6)<br>|   Presentation<br>+——————-+<br>|   会话层 (Layer 5)<br>|   Session<br>+——————-+<br>|   传输层 (Layer 4)<br>|   Transport<br>+——————-+<br>|   网络层 (Layer 3)<br>|   Network<br>+——————-+<br>|   数据链路层 (Layer 2)<br>|   Data Link<br>+——————-+<br>|   物理层 (Layer 1)<br>|   Physical<br>+——————-+</p>
<h2 id="3-OSI模型的七层结构"><a href="#3-OSI模型的七层结构" class="headerlink" title="3. OSI模型的七层结构"></a>3. OSI模型的七层结构</h2><ul>
<li><ol>
<li><strong>物理层</strong> (Physical Layer)</li>
</ol>
<ul>
<li>Keywords: <strong>Signal and Media 信号和介质</strong></li>
<li>Binary transmission 二进制传输</li>
<li>功能: 负责传输原始的比特流。</li>
</ul>
</li>
<li><ol start="2">
<li><strong>数据链路层</strong> (Data Link Layer)</li>
</ol>
<ul>
<li>Keywords: <strong>frame, media access control 帧和介质访问控制</strong></li>
<li>Access to media 介质访问</li>
<li>功能: 负责节点之间的可靠传输。负责帧的创建、传输和错误检测。</li>
</ul>
</li>
<li><ol start="3">
<li><strong>网络层</strong> (Network Layer)</li>
</ol>
<ul>
<li>Keywords: <strong>Path selection路径选择, Routing路由, Addressing寻址</strong></li>
<li>Addresses and best path <strong>路径选择，最优路径</strong></li>
<li>功能: 在进行路由的两个终端系统之间提供连接和路径选择</li>
</ul>
</li>
<li><ol start="4">
<li><strong>传输层</strong> (Transport Layer)</li>
</ol>
<ul>
<li>Keywords: <strong>Reliability可靠性, Flow control流量控制, Error correction纠错</strong></li>
<li>End-to-end connections 终端到终端通信</li>
<li>功能: 负责终端节点之间的可靠网络通信，负责数据传输的流量控制，并为虚拟电路的建立、维护和终止、传输故障检测和恢复提供机制</li>
</ul>
</li>
<li><ol start="5">
<li><strong>会话层</strong> (Session Layer)</li>
</ol>
<ul>
<li>Keywords: <strong>Dialog and Conversations 对话和交流</strong></li>
<li>Inter-host connection 进程之间通信如何用户交流</li>
<li>功能: 管理和控制（建立、维护和终止）应用程序之间的会话；manages data exchange between presentation layer entities管理表示层实体之间的数据交换。</li>
</ul>
</li>
<li><ol start="6">
<li><strong>表示层</strong> (Presentation Layer)</li>
</ol>
<ul>
<li>Keywords:<strong>Common Format 标准</strong></li>
<li>Data presentation and encryption 展示</li>
<li>功能: 负责数据的格式化、加密和解密，确保数据的语法和语义正确。</li>
</ul>
</li>
<li><ol start="7">
<li><strong>应用层</strong> (Application Layer)</li>
</ol>
<ul>
<li>Keyword: <strong>Browser 浏览</strong></li>
<li>User interface 给用户展示交互接口</li>
<li>功能: 提供网络服务和应用程序接口，直接为用户和应用程序提供服务。</li>
</ul>
</li>
</ul>
<h2 id="4-分组"><a href="#4-分组" class="headerlink" title="4. 分组"></a>4. 分组</h2><ul>
<li>（1）application layers<strong>应用层</strong><ul>
<li>Application应用</li>
<li>Presentation展示</li>
<li>Session会话</li>
<li>deal with the user interface, data formatting, and the application access<ul>
<li>处理了用户接口，数据格式和应用权限</li>
</ul>
</li>
</ul>
</li>
<li>（2）data flow layers<strong>数据流层</strong><ul>
<li>Transport传输<br> Network网络<br> Data Link数据链路<br> Physical物理</li>
<li>control the physical delivery of messages over the network.<ul>
<li>控制着通过网络传输的数据信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-Data-Encapsulation数据封装"><a href="#5-Data-Encapsulation数据封装" class="headerlink" title="5. Data Encapsulation数据封装"></a>5. Data Encapsulation数据封装</h2><ul>
<li><p>定义：<br>数据封装是指在网络通信中，数据在传输过程中<code>通过各层协议逐层添加协议头（header）和协议尾（trailer）</code>的过程。每一层协议都在数据包的<code>前面或后面添加特定的信息</code>，以便在接收端能够正确地解析和处理数据。</p>
</li>
<li><p>基本步骤：</p>
<ol start="7">
<li>应用层（Application Layer）：<br> 数据生成并准备传输。</li>
<li>表示层（Presentation Layer）：<br> 数据格式化和加密。</li>
<li>会话层（Session Layer）：<br> 管理会话和数据交换。</li>
<li>传输层（Transport Layer）：<br> 添加<strong>传输层头部</strong>（如TCP&#x2F;UDP头），用于数据分段和重组。</li>
<li>网络层（Network Layer）：<br> 添加网<strong>络层头部</strong>（如IP头），用于路由和寻址。</li>
<li>数据链路层（Data Link Layer）：<br> 添加<strong>数据链路层头部和尾部</strong>（如MAC地址和帧<em>校验</em>序列），用于帧的传输和错误检测。</li>
<li>物理层（Physical Layer）：<br> 将数据转换为电信号或光信号，通过物理介质传输。</li>
</ol>
</li>
<li><p>数据封装过程</p>
<ul>
<li>5-&gt;4：添加首部 H5，应用程序数据作为数据部分</li>
<li>4-&gt;3：添加首部 H4，第五层的作为数据部分</li>
<li>3-&gt;2：添加首部 H3，第四层的作为数据部分</li>
<li>2-&gt;1：添加首部 H2 和尾部 T2（校验位），第三层的作为数据部分</li>
<li>1：转成比特流进行发送</li>
</ul>
</li>
<li><p>在接收端，数据封装的过程将逆向进行，即逐层剥离协议头和协议尾，直到还原出原始数据。</p>
</li>
</ul>
<h2 id="6-Peer-to-Peer-Communications-点对点通信"><a href="#6-Peer-to-Peer-Communications-点对点通信" class="headerlink" title="6. Peer-to-Peer Communications 点对点通信"></a>6. Peer-to-Peer Communications 点对点通信</h2><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/peertopeer%20communications.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h1 id="四、TCP-IP-Model"><a href="#四、TCP-IP-Model" class="headerlink" title="四、TCP&#x2F;IP Model"></a>四、TCP&#x2F;IP Model</h1><h2 id="1-组成"><a href="#1-组成" class="headerlink" title="1. 组成"></a>1. 组成</h2><ul>
<li>含有<strong>四层</strong><ul>
<li>应用层Application</li>
<li>传输层Transport</li>
<li>网络层Internet</li>
<li>网络访问层Network Access</li>
</ul>
</li>
</ul>
<h2 id="2-功能"><a href="#2-功能" class="headerlink" title="2.功能"></a>2.功能</h2><ul>
<li>（1）<strong>Application Layer 应用层</strong><ul>
<li>处理高级协议、表示、编码和会话控制问题<ul>
<li>包含[OSI]中上三层（应用层、表示层、会话层）的全部功能</li>
</ul>
</li>
<li>Handles <strong>high-level protocols</strong>, issues of <strong>representation, encoding, and session control</strong></li>
<li>TCP&#x2F;IP将所有与应用程序相关的问题合并到一个层中，并确保这些数据被正确打包到下一层。</li>
</ul>
</li>
<li>（2）<strong>Transport Layer 传输层</strong><ul>
<li>处理服务质量问题，如可靠性、流量控制和错误校正 <ul>
<li>对应[OSI]中第4层：传输层</li>
</ul>
</li>
<li>Deals with the quality-of-service issues of <strong>reliability, flow control, and error correction</strong>.</li>
</ul>
</li>
<li>（3）<strong>Internet Layer 网络层</strong><ul>
<li>最优路径的选择（报文从一方发送给另一方，报文传输经过<em>路由器</em>进行路径选择）<ul>
<li>对应[OSI]中第3层：网络层</li>
</ul>
</li>
<li><strong>Best path determination and packet switching</strong></li>
</ul>
</li>
<li>（4）<strong>Network Access 网络接入层</strong><ul>
<li>也称为<strong>host-to-network layer 主机到网络层</strong>。 <ul>
<li>包含[OSI]中下两层：物理层和数据链路层</li>
</ul>
</li>
<li>它关注 IP 分组实际建立物理链路，然后建立另一个物理链路所需的所有问题。</li>
<li>它包括 LAN 和 WAN 技术的细节，以及 OSI 物理和数据链路层中的所有细节。</li>
</ul>
</li>
</ul>
<h2 id="3-名词解释——常见的TCP-IP协议"><a href="#3-名词解释——常见的TCP-IP协议" class="headerlink" title="3.名词解释——常见的TCP&#x2F;IP协议"></a>3.名词解释——常见的TCP&#x2F;IP协议</h2><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-3.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>FTP <ul>
<li>File Transfer Protocol 文件传输协议</li>
</ul>
</li>
<li>HTTP <ul>
<li>Hypertext Transfer Protocol 超文本传输协议</li>
<li>主要用于浏览器</li>
</ul>
</li>
<li>SMTP <ul>
<li>Simple Mail Transfer protocol 简单邮件传输协议</li>
</ul>
</li>
<li>DNS <ul>
<li>Domain Name System 域名解析系统</li>
<li>将域名解析成IP地址</li>
</ul>
</li>
<li>TFTP <ul>
<li>Trivial File Transfer Protocol 简单文件传输协议</li>
<li>基于UDP，在局域网发送较小文件</li>
</ul>
</li>
</ul>
<h2 id="4-TCP-IP-和-OSI-的相似点"><a href="#4-TCP-IP-和-OSI-的相似点" class="headerlink" title="4. TCP&#x2F;IP 和 OSI 的相似点"></a>4. TCP&#x2F;IP 和 OSI 的相似点</h2><ul>
<li>both have layers, networking professionals need to know both<ul>
<li>层次</li>
</ul>
</li>
<li>both have application layers, though they include very different services <ul>
<li>应用层（虽然服务不同）</li>
</ul>
</li>
<li>both have comparable transport and network layers <ul>
<li>相同的传输层和网络层</li>
</ul>
</li>
<li>packet-switched (not circuit-switched) technology is assumed <ul>
<li>假设采用<strong>分组交换（非电路交换）技术</strong></li>
</ul>
</li>
<li>OSI 是<strong>基于报文交换</strong>来进行实现的，TCP&#x2F;IP 也是基于报文交换来完成实现的。</li>
</ul>
<h2 id="5-TCP-IP-和-OSI-的不同点"><a href="#5-TCP-IP-和-OSI-的不同点" class="headerlink" title="5.TCP&#x2F;IP 和 OSI 的不同点"></a>5.TCP&#x2F;IP 和 OSI 的不同点</h2><ol>
<li>TCP&#x2F;IP 看起来更简单，因为它有更少的层</li>
<li><strong>TCP&#x2F;IP 协议是因特网发展的标准，因此 TCP&#x2F;IP 模型正是因为它的协议才获得了可信性</strong>。</li>
<li>通常网络不是建立在 OSI 协议之上的，即使 OSI 模型被用作指南。</li>
<li><strong>TCP&#x2F;IP 标准是大家都在使用的标准（实施标准）</strong>，5 层和 7 层都只是讲课使用的</li>
<li>本课程我们一般使用<strong>5 层</strong>来进行分割讲解。<br><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-4.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<hr>
<h1 id="五-Network-Topology-网络拓扑"><a href="#五-Network-Topology-网络拓扑" class="headerlink" title="五.Network Topology 网络拓扑"></a>五.Network Topology 网络拓扑</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><ul>
<li>网络拓扑是指<strong>网络中各个节点</strong>（如计算机、路由器、交换机等）之间的<strong>物理或逻辑连接方式</strong>。不同的网络拓扑结构有不同的特点和适用场景。</li>
</ul>
<h2 id="2-常见的网络拓扑结构包括："><a href="#2-常见的网络拓扑结构包括：" class="headerlink" title="2.常见的网络拓扑结构包括："></a>2.常见的网络拓扑结构包括：</h2><ul>
<li>物理拓扑：导线（介质）的实际布局<ul>
<li>总线、星形、环形、扩展星形、分层（树形）、渔网型（mesh）</li>
<li>如何把节点具体连接起来<br><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-5.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li>逻辑拓扑：定义主机如何访问媒体<ul>
<li>令牌传递，使用 token 来获取通信的权利</li>
<li>主要涉及到管理介质如何被访问</li>
</ul>
</li>
<li>逻辑拓扑：主要是指如何在逻辑上如何控制网络</li>
</ul>
<h3 id="1-总线拓扑（Bus-Topology）"><a href="#1-总线拓扑（Bus-Topology）" class="headerlink" title="1. 总线拓扑（Bus Topology）"></a>1. 总线拓扑（Bus Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-6.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Physical Perspective：<ul>
<li><strong>所有节点通过一条主干电缆连接</strong>。</li>
<li>数据在主干电缆上传输，所有节点都能接收到数据。</li>
<li>优点：<ul>
<li>所有主机都可以直接通信。</li>
</ul>
</li>
<li>缺点：<ul>
<li>主干电缆故障会导致整个网络瘫痪，断开主机之间的连接。</li>
</ul>
</li>
</ul>
</li>
<li>Logical Perspective：<ul>
<li>Every networking device to see all signals from all other devices</li>
<li><strong>每个网络设备都可以看到来自所有其他设备的所有信号</strong>，实际上是广播式传播</li>
<li>优点：比较简单，所有的设备都可以监听到总线的信号。</li>
<li>缺点：<ul>
<li>信号冲突，需要进行复杂的介质访问权限控制来保证通信正常</li>
<li>如果<strong>一处断开，则全部无法</strong>进行网络传输</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-环形拓扑（Ring-Topology）"><a href="#2-环形拓扑（Ring-Topology）" class="headerlink" title="2. 环形拓扑（Ring Topology）"></a>2. 环形拓扑（Ring Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-7.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Physical Perspective：<ul>
<li><strong>所有的设备直接首尾相连，组成一个菊花链（daisy-chain）</strong></li>
<li>数据沿着环路单向或双向传输。</li>
<li>优点：<ul>
<li>数据传输延迟较小。</li>
<li>适用于负载均衡。</li>
</ul>
</li>
<li>缺点：<ul>
<li><strong>任意一个节点或连接故障都会影响整个网络</strong>。</li>
<li>故障定位和修复较为复杂。</li>
</ul>
</li>
</ul>
</li>
<li>Logical Perspective<ul>
<li>为了使信息流动，每个站点必须将信息传递给其相邻的站点。</li>
<li>我们需要对于链路进行访问控制，防止很多设备同时使用环，我们使用 token 来进行控制访问权力</li>
</ul>
</li>
</ul>
<h3 id="3-双环拓扑（Dual-Ring-Topology）"><a href="#3-双环拓扑（Dual-Ring-Topology）" class="headerlink" title="3. 双环拓扑（Dual Ring Topology）"></a>3. 双环拓扑（Dual Ring Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-8.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Physical Perspective<ul>
<li>每个节点通过两条环形链路连接到相邻节点，形成<code>两个</code>独立的环。</li>
<li>双环拓扑是指一个节点有两个点，同时只能一个环在传输信息，两个环的传输时的方向是不能确定的。</li>
</ul>
</li>
<li>Logical Perspective<ul>
<li>双环拓扑就像两个独立的环，<strong>同一时间只有一个环被应用</strong>。</li>
<li>有 token 令牌才有发送权力发送信息（使用总线）</li>
</ul>
</li>
<li>优点:<ul>
<li>提供可靠性和灵活性</li>
<li>容错性：一个环出现故障时，数据可以通过另一个环继续传输，确保网络的可靠性。</li>
</ul>
</li>
<li>Eg.优先使用外环，如果外环出现物理错误，则切换到内环上使用，并且对外环进行物理修复。</li>
</ul>
<h3 id="4-星型拓扑（Star-Topology）"><a href="#4-星型拓扑（Star-Topology）" class="headerlink" title="4. 星型拓扑（Star Topology）"></a>4. 星型拓扑（Star Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-9.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Physical Perspective：<ul>
<li>星型拓扑结构有一个<strong>中心节点</strong>，所有的链路都从它辐射（radiating）出去。</li>
</ul>
</li>
<li>Logical Perspective<ul>
<li><strong>所有信息的流动将通过一个设备</strong>。</li>
</ul>
</li>
<li>优点：<ul>
<li>它允许所有其他节点相互通信，方便。出于安全或限制访问的原因，它也可能是可取的</li>
</ul>
</li>
<li>缺点：<ul>
<li><strong>中央节点故障会导致整个网络瘫痪</strong>。</li>
<li>根据使用的网络设备类型，冲突可能是一个问题，中心点会有很大的负担，并且容易造成通信阻塞</li>
</ul>
</li>
</ul>
<h3 id="5-树形拓扑（Tree-Topology）"><a href="#5-树形拓扑（Tree-Topology）" class="headerlink" title="5. 树形拓扑（Tree Topology）"></a>5. 树形拓扑（Tree Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-10.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>树拓扑使用一个主干节点（Trunk Node），从该节点分支到其他节点。</li>
<li>物理观点：主干是一条有几层分支的电线。</li>
<li>逻辑观点：信息流是层次性的。</li>
<li>在根一级数据节点可以对数据进行汇总和统计</li>
</ul>
<h3 id="6-渔网状拓扑（Mesh-Topology）"><a href="#6-渔网状拓扑（Mesh-Topology）" class="headerlink" title="6. 渔网状拓扑（Mesh Topology）"></a>6. 渔网状拓扑（Mesh Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-11.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Physical Perspective：</li>
<li><strong>每个节点</strong>与网络中的<strong>其他节点直接相连</strong>。<ul>
<li>优点：<ul>
<li>高度冗余，任意节点或连接故障不会影响网络整体。</li>
<li>高可靠性和稳定性。 the maximum connectivity and reliability.</li>
</ul>
</li>
<li>缺点：<ul>
<li>结构复杂，成本高。</li>
<li>需要大量的电缆和端口。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-蜂窝拓扑（Cellular-Topology）"><a href="#7-蜂窝拓扑（Cellular-Topology）" class="headerlink" title="7. 蜂窝拓扑（Cellular Topology）"></a>7. 蜂窝拓扑（Cellular Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-12.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>物理视角（Physical Perspective）<ul>
<li>蜂窝拓扑结构是用于<strong>无线技术</strong>的拓扑结构</li>
<li>有时接收节点移动（如<em>手机</em>），有时发送节点移动（如<em>卫星</em>）</li>
</ul>
</li>
<li>逻辑视角（Logical Perspective）<ul>
<li>节点之间直接通信（尽管有时非常困难），或者只与相邻的单元通信，这是<strong>非常低效</strong>的。</li>
<li>每一个节点都是无线的连通方式：远节点需要进行转发。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="六-Network-Devices-网络设备"><a href="#六-Network-Devices-网络设备" class="headerlink" title="六.Network Devices 网络设备"></a>六.Network Devices 网络设备</h1><h2 id="1-LAN-Devices-in-a-Topology"><a href="#1-LAN-Devices-in-a-Topology" class="headerlink" title="1.LAN Devices in a Topology"></a>1.LAN Devices in a Topology</h2><ul>
<li>主机<strong>Hosts</strong> （网络终端设备）：<ul>
<li><strong>直接连接到网段的设备</strong></li>
<li>打印机、计算机、服务器、传真机、复印机</li>
</ul>
</li>
<li>Hosts（网络中间设备）<ul>
<li><strong>主机不属于任何层</strong>，但 OSI 模型的功能在主机内部的软件中执行</li>
</ul>
</li>
</ul>
<h2 id="2-NIC-网络接口卡-–-Layer-2（Data-Link数据链路层）"><a href="#2-NIC-网络接口卡-–-Layer-2（Data-Link数据链路层）" class="headerlink" title="2.NIC 网络接口卡 – Layer 2（Data Link数据链路层）"></a>2.NIC 网络接口卡 – Layer 2（Data Link数据链路层）</h2><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-13.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>NIC，第二层，网卡（Network Interface Controller），<strong>网络终端设备</strong></li>
<li>携带称为 MAC 地址的唯一代码，固定地址，在芯片上</li>
<li>用于控制网络上主机的数据通信</li>
<li>将计算机产生的并行信号转换成串行格式通过网络发送</li>
<li>用于转换信号以及发送和接收比特的收发器</li>
<li>提供主机对媒体的访问权限</li>
<li>为什么是第二层的设备：<ul>
<li>可以识别帧</li>
<li>帮助主机接入网络</li>
</ul>
</li>
<li>计算机母线：并行通信；网卡总线：串行通信<ul>
<li>所以网卡需要完成两者之间的交换。</li>
</ul>
</li>
<li>也是可以完成第一层的工作的</li>
</ul>
<h2 id="3-Media介质-–-Layer-1"><a href="#3-Media介质-–-Layer-1" class="headerlink" title="3.Media介质 – Layer 1"></a>3.Media介质 – Layer 1</h2><ul>
<li>网络中间设备，第一层</li>
</ul>
<ol>
<li><strong>以位为单位携带信息流</strong></li>
<li>信号从一个网络设备传送到另一个网络设备的方式</li>
<li>0-1 信号变为电信号或者无线电波光信号等。</li>
</ol>
<h2 id="4-Repeaters中继器-Layer-1（物理层）"><a href="#4-Repeaters中继器-Layer-1（物理层）" class="headerlink" title="4.Repeaters中继器 - Layer 1（物理层）"></a>4.Repeaters中继器 - Layer 1（物理层）</h2><ul>
<li>网络中间设备</li>
<li>主要功能：<ul>
<li><strong>延长网络长度</strong>：<ul>
<li>用于延长网络的物理长度，实现传输超出一段介质传输的介质</li>
</ul>
</li>
<li>清理、放大和重发信号：<ul>
<li>清理、放大和重发由于长电缆传输而减弱的信号。</li>
</ul>
</li>
<li>信号再生和重定时：<ul>
<li>在<em>比特级别</em>重新生成（放大）和重定时网络信号（<strong>数字信号</strong>），以允许它们在媒体上传播更长的距离</li>
</ul>
</li>
<li>不进行过滤：<ul>
<li>中继器不对数据包进行任何过滤或处理，只是简单地转发信号。</li>
</ul>
</li>
</ul>
</li>
<li>这些功能确保了信号在长距离传输中的完整性和可靠性。</li>
</ul>
<h2 id="5-Hubs（集线器）-–-Layer-1"><a href="#5-Hubs（集线器）-–-Layer-1" class="headerlink" title="5.Hubs（集线器） – Layer 1"></a>5.Hubs（集线器） – Layer 1</h2><ul>
<li>网络中间设备</li>
<li>信号再生和重定时：用于重新生成和重定时网络信号，连接多个端口，可以比中继器做更多的事情</li>
<li>传播信号propagate signals<ul>
<li><code>不能过滤流量</code>cannot filter traffic</li>
<li><code>不能确定最佳路径</code>cannot determine the best path</li>
<li>网络中心节点used as network concentration points</li>
<li>有时称为多端口中继器sometimes called multiport repeaters</li>
</ul>
</li>
<li>逻辑拓扑：<strong>总线方式连接</strong>，一个端口入，所有端口出</li>
<li>不允许总线上同时有两路信号进行传输</li>
<li>冲突域：可能出现冲突的区域，但是集线器不进行这些控制，而是由交换机或者路由器来完成控制，不能降低冲突概率</li>
<li>而放大器方法的是模拟信号。</li>
</ul>
<h3 id="Repeaters-Hubs-Difference中继器和集线器的不同"><a href="#Repeaters-Hubs-Difference中继器和集线器的不同" class="headerlink" title="Repeaters&#x2F;Hubs - Difference中继器和集线器的不同"></a>Repeaters&#x2F;Hubs - Difference中继器和集线器的不同</h3><ul>
<li>中继器通常只有两个端口，而集线器通常有4个到20个或更多端口。</li>
<li>中继器在<strong>一个端口接收</strong>信号，并在<strong>另一个端口重复</strong>信号，而集线器在<strong>一个端口接收</strong>信号并在<strong>所有其他端口传输</strong>信号。</li>
<li>集线器最常见于以太网10Base-T或100Base-T网络中。</li>
<li>都是转发，<strong>都不做过滤功能</strong></li>
<li>两个设备之间最多有 4 个集线器和网桥</li>
</ul>
<h2 id="6-Bridges（网桥）-–-Layer-2（数据链路层）"><a href="#6-Bridges（网桥）-–-Layer-2（数据链路层）" class="headerlink" title="6.Bridges（网桥） – Layer 2（数据链路层）"></a>6.Bridges（网桥） – Layer 2（数据链路层）</h2><ul>
<li>网络中间设备</li>
</ul>
<ol>
<li>目的是在 LAN 上过滤流量，以保持本地流量，但允许连接到 LAN 的其他部分以定向到那里的流量</li>
<li>跟踪网桥两侧的 MAC 地址，并根据此 MAC 地址列表进行决策<ul>
<li>目的地址如果在同一端，就不进行转发（不必进行转发，MAC Table）</li>
<li>而在不同侧（不同的 segments）就进行尽量向外转发</li>
</ul>
</li>
<li>比集线器更智能</li>
<li>收集并在段之间传递数据包</li>
<li>创建冲突域<ul>
<li>通过网桥划分冲突域</li>
<li>每个冲突域中都有一定的主机</li>
<li>第一层以上的设备才能划分冲突域</li>
</ul>
</li>
<li>维护地址表</li>
</ol>
<ul>
<li>这些功能使得网桥在局域网中能够有效地管理和优化流量，提高网络的整体性能和效率。</li>
</ul>
<h2 id="7-Switches（交换机）-–-Layer-2"><a href="#7-Switches（交换机）-–-Layer-2" class="headerlink" title="7.Switches（交换机） – Layer 2"></a>7.Switches（交换机） – Layer 2</h2><ul>
<li>网络中间设备</li>
<li>集中连接 used to concentrate connectivity</li>
<li>结合集线器的连接性和网桥的流量调节 combine the connectivity of a hub with the traffic regulation of a bridge</li>
<li>switch frames from incoming ports to outgoing ports providing each port with full bandwidth 根据MAC地址表将帧从输入端口切换到相应的输出端口，为每个端口提供全带宽。</li>
<li>provide separate data paths 为每个连接的设备提供独立的数据路径，避免冲突，提高网络性能。</li>
</ul>
<h2 id="8-Routers路由器-–-Layer-3"><a href="#8-Routers路由器-–-Layer-3" class="headerlink" title="8.Routers路由器 – Layer 3"></a>8.Routers路由器 – Layer 3</h2><ul>
<li>网络中间设备</li>
<li>在大型网络中调节流量。</li>
<li>基于网络地址（如IP地址）做出转发决策。<ul>
<li>主要是进行网段的划分，根据网络地址（包含在 IP 地址中）进行转化</li>
</ul>
</li>
<li>检查数据包的第三层数据，选择最佳路径，并通过适当的输出端口转发数据包。</li>
<li><code>主要目的</code>：<ul>
<li>用于<strong>路径选择</strong>和<strong>将数据包切换到最佳路由</strong>。</li>
</ul>
</li>
</ul>
<h2 id="9-Evolution-of-Networking-Devices-and-the-OSI-Layers"><a href="#9-Evolution-of-Networking-Devices-and-the-OSI-Layers" class="headerlink" title="9.Evolution of Networking Devices and the OSI Layers"></a>9.Evolution of Networking Devices and the OSI Layers</h2><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>网络设备的工作层次和主机情况<ul>
<li>物理层：<strong>介质、中继器、集线器</strong></li>
<li>数据链路层：<strong>网桥、交换机、电路交换设备</strong></li>
<li>网络层：<strong>路由器</strong></li>
</ul>
</li>
</ol>
<ul>
<li>高层设备可以识别低层设备的信号，但是低层设备不能识别高层次的数据逻辑</li>
<li>Host 下层通过网卡进行实现，上层通过网络操作系统、应用实现</li>
</ul>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>二、OSI第一层：物理层</title>
    <url>/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<h1 id="OSI第一层：物理层"><a href="#OSI第一层：物理层" class="headerlink" title="OSI第一层：物理层"></a>OSI第一层：物理层</h1><h1 id="一、网络连接类型"><a href="#一、网络连接类型" class="headerlink" title="一、网络连接类型"></a>一、网络连接类型</h1><p><img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image-4.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><strong>多路复用共享机制</strong></li>
</ol>
<ul>
<li><strong>多个主机可以访问同一介质</strong></li>
<li>它们都使用相同的传输介质—即使这个传输介质是<strong>非屏蔽双绞线（UTP）</strong>，它也包含四对线来传输数据。</li>
</ul>
<ol start="2">
<li><strong>点对点网络</strong></li>
</ol>
<ul>
<li><strong>一个设备通过链路连接到另一个设备</strong></li>
<li>最广泛地应用于拨号网络连接，也是你最熟悉的一种。使用电信号来完成传输。</li>
</ul>
<h1 id="二、LAN-Media局域网介质"><a href="#二、LAN-Media局域网介质" class="headerlink" title="二、LAN Media局域网介质"></a>二、LAN Media局域网介质</h1><p><img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image-5.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>功能是<strong>传输数据</strong></li>
<li>光信号、无线信号等传输过程称为<strong>编码</strong></li>
<li><strong>电缆类型</strong>包括<strong>STP(有屏蔽双绞线)、UTP(无屏蔽双绞线)、同轴电缆、光纤</strong></li>
<li>调节频率、电压、相位等方式来实现不同01编码</li>
</ol>
<h2 id="1-STP和ScTP-屏蔽双绞线-抗干扰能力强"><a href="#1-STP和ScTP-屏蔽双绞线-抗干扰能力强" class="headerlink" title="1. STP和ScTP: 屏蔽双绞线, 抗干扰能力强"></a>1. STP和ScTP: 屏蔽双绞线, 抗干扰能力强</h2><ul>
<li>STP:<code>Shielded Twisted Pair</code></li>
</ul>
<ol>
<li>4对线布线，结合了屏蔽和通过线缆扭绞实现的消除效应。</li>
<li>通常是一种150欧姆的电缆</li>
<li>能够减少串扰、EMI（电磁干扰）和RFI（射频干扰）</li>
<li>比UTP（非屏蔽双绞线）提供更好的<strong>对所有类型外部干扰的保护</strong>。</li>
</ol>
<ul>
<li>ScTP：<code>Screened Twisted Pair</code></li>
</ul>
<ol>
<li>包裹在金属箔屏蔽层或屏蔽网中</li>
<li>通常是100或120欧姆的电缆。</li>
<li>STP和ScTP都能防止外来的电磁波在数据线上产生噪声，并且还能最大限度地减少向外辐射的电磁波。</li>
</ol>
<ul>
<li>缺点: <ol>
<li>信号不被中继的情况下, 传输距离较近</li>
<li>绝缘大大增加了电缆的尺寸、重量和成本</li>
<li>屏蔽材料使端接更加困难，并且容易受到工艺不良的影响</li>
</ol>
</li>
</ul>
<h2 id="2-UTP-非屏蔽双绞线-Unshielded-Twisted-Pair"><a href="#2-UTP-非屏蔽双绞线-Unshielded-Twisted-Pair" class="headerlink" title="2. UTP (非屏蔽双绞线 Unshielded Twisted Pair)"></a>2. UTP (非屏蔽双绞线 Unshielded Twisted Pair)</h2><ul>
<li>由<strong>八根子线</strong>组成,<strong>两个线组合成一组</strong>，<strong>共四组</strong>，可以保证每一组电流抵消电磁波干扰（抗干扰能力有限）</li>
</ul>
<ol>
<li>仅（solely）依赖于消除效应，由双绞线对产生，以限制由 EMI 和 RFI 引起的信号退化</li>
<li>有四对铜线，阻抗（impedance）为 100 欧姆，频率低、接口小、布线更加方便</li>
<li>一般认为有效范围为 100m</li>
</ol>
<ul>
<li>优点<ul>
<li><em>易于安装且成本较低</em>，线薄接口小</li>
<li>每米成本低于任何其他类型的局域网布线</li>
<li>较小的外径不能像其他类型的电缆那样迅速地填满布线管道（duct）</li>
<li>使用 RJ 连接器安装，因此可以大大减少潜在的网络噪声源，并确保良好的可靠连接</li>
</ul>
</li>
<li>缺点：<ul>
<li>与其他类型的网络媒体相比，电缆更容易产生电噪声和干扰</li>
<li>双绞线的信号增强距离比同轴电缆（Coaxial）和光纤（Fiber-Optic）短</li>
</ul>
</li>
</ul>
<h2 id="3-同轴电缆-Coaxial-Cable"><a href="#3-同轴电缆-Coaxial-Cable" class="headerlink" title="3. 同轴电缆 Coaxial Cable"></a>3. 同轴电缆 Coaxial Cable</h2><ol>
<li><em>Thinnet&#x2F;thicknet</em></li>
<li>与双绞线twisted-pair相比，不使用中继器的网络运行时间更长</li>
<li>比光纤便宜但比双绞线贵</li>
</ol>
<h2 id="4-光纤-Fiber-Optic-Cable"><a href="#4-光纤-Fiber-Optic-Cable" class="headerlink" title="4. 光纤 Fiber Optic Cable"></a>4. 光纤 Fiber Optic Cable</h2><ol>
<li>传导调制（modulated）光传输</li>
<li>不易受到电磁干扰或射频干扰，并且能够比其他网络媒体更高的数据速率</li>
<li>电磁波（electromagnetic wave）通过光纤被引导</li>
<li>比较可靠，中间是二氧化硅（光导体），外面是塑料套，两个接口一个接收一个发送</li>
<li>成本比较高</li>
</ol>
<h3 id="模式1：单模光纤（Single-Mode-Fiber-SMF）"><a href="#模式1：单模光纤（Single-Mode-Fiber-SMF）" class="headerlink" title="模式1：单模光纤（Single-Mode Fiber, SMF）"></a>模式1：单模光纤（Single-Mode Fiber, SMF）</h3><ul>
<li>也称为轴向光纤axial：光沿着光纤的轴线传播。</li>
<li>比多模光纤更快：因为多模光纤中存在色散</li>
<li>通常用于<strong>广域网（WANs）</strong>：单模光纤常用于需要<strong>长距离、高速传输的广域网</strong>。</li>
<li>直径比多模光纤小：色散较少，因此信号传输更稳定。</li>
<li>使用激光二极管（ILD）最常见，但也使用发光二极管（LED）</li>
</ul>
<h3 id="模式2：多模光纤（Multi-Mode-Fiber-MMF）"><a href="#模式2：多模光纤（Multi-Mode-Fiber-MMF）" class="headerlink" title="模式2：多模光纤（Multi-Mode Fiber, MMF）"></a>模式2：多模光纤（Multi-Mode Fiber, MMF）</h3><ul>
<li>非轴向传播：光以不同角度进入玻璃管</li>
<li>直径比单模光纤大：多模光纤的直径比单模光纤大，通常用于<strong>局域网（LANs）</strong>。</li>
<li>更容易受到色散的影响</li>
</ul>
<h2 id="5-无线通信（Wireless-Communication）"><a href="#5-无线通信（Wireless-Communication）" class="headerlink" title="5. 无线通信（Wireless Communication）"></a>5. 无线通信（Wireless Communication）</h2><ul>
<li>区分不同电磁波的主要方法是通过它们的<strong>频率</strong>。（频率多路复用）</li>
<li>把信号编码成为电磁波的方式<ul>
<li>不同设备使用不同频段，可以互不干扰</li>
</ul>
</li>
</ul>
<h2 id="6-无线传输手段（Wireless-Transmission-Methods）"><a href="#6-无线传输手段（Wireless-Transmission-Methods）" class="headerlink" title="6. 无线传输手段（Wireless Transmission Methods）"></a>6. 无线传输手段（Wireless Transmission Methods）</h2><ol>
<li>激光：<ul>
<li>输出相干（coherent）电磁场：所有波的频率相同且相位对齐。</li>
</ul>
</li>
<li>红外线（Infrared）：激光通常使用红外线。<ul>
<li>通常是视距技术：激光通常需要视距传输，但可以通过反射或重定向来传输。</li>
<li>不能穿透不透明物体。</li>
</ul>
</li>
<li>无线电（Radio）：<ul>
<li>传输数据信号：无线电可以传输数据信号，并且这些信号可以穿透墙壁。</li>
<li>地面和卫星无线电技术：无线电技术包括地面无线电和卫星无线电两种。</li>
</ul>
</li>
</ol>
<h1 id="三、UTP-for-Ethernet-以太网中的非屏蔽双绞线"><a href="#三、UTP-for-Ethernet-以太网中的非屏蔽双绞线" class="headerlink" title="三、UTP for Ethernet 以太网中的非屏蔽双绞线"></a>三、UTP for Ethernet 以太网中的非屏蔽双绞线</h1><h2 id="1-非屏蔽双绞线的分类"><a href="#1-非屏蔽双绞线的分类" class="headerlink" title="1. 非屏蔽双绞线的分类"></a>1. 非屏蔽双绞线的分类</h2><ol>
<li>一类线：主要用于语音传输，不用于数据传输</li>
<li>二类线：传输频率1MHz，用于语音和最高4Mbps的数据传输，常见于令牌网</li>
<li><strong>三类线</strong>：EIA&#x2F;TIA568标准指定电缆，传输频率16MHz，用于语音传输及最高传输速率为10Mbps的数据传输，主要用于10BASE-T</li>
<li>四类线：传输频率为20MHz，用于语音传输和最高传输速率16Mbps的数据传输，主要用于令牌网和10BASE-T&#x2F;100BASE-T</li>
<li><strong>五类线</strong>：增加了绕线密度，外套高质量绝缘材料，用于语音和数据传输(主要为100&#x2F;1000BASE-T)，是最常用的以太网电缆</li>
<li><strong>超五类线</strong>：衰减小，串扰少，具有更高的衰减&#x2F;串扰比和信噪比、更小的时延误差，主要用于1000BASE-T</li>
<li><strong>六类线</strong>：传输频率为1MHz～250MHz，性能远高于超五类标准，适用于高于1Gbps的应用</li>
<li>七类线：带宽为600MHz，可能用于今后的10G比特以太网</li>
</ol>
<h2 id="2-Type-of-Cable-线的类型"><a href="#2-Type-of-Cable-线的类型" class="headerlink" title="2. Type of Cable 线的类型"></a>2. Type of Cable 线的类型</h2><ul>
<li><strong>直通线 Straight Cable</strong><ol>
<li><strong>用途</strong>：用于连接<strong>不同类型的设备</strong>，如计算机和交换机、计算机和路由器。</li>
<li>连接方式：直通电缆的两端使用<em>相同的线序标准</em>进行连接，常见的标准有T568A和T568B。</li>
</ol>
</li>
<li><strong>反转线 Rollover Cable</strong><ol>
<li><strong>用途</strong>：用于连接<strong>终端设备和控制台端口</strong>，通常用于配置路由器或交换机。</li>
<li><strong>连接方式</strong>：一端的线序完全反转，即1对8、2对7、3对6、4对5。</li>
</ol>
</li>
<li><strong>交叉线Crossover Cable</strong><ol>
<li><strong>用途</strong>：用于连接<strong>相同类型的设备</strong>，如计算机和计算机、交换机和交换机。</li>
<li><strong>连接方式</strong>：两端的线序<em>不同</em>，一端使用T568A标准，另一端使用T568B标准。</li>
</ol>
</li>
</ul>
<h1 id="四、Media-and-signal-Problems介质和信号问题"><a href="#四、Media-and-signal-Problems介质和信号问题" class="headerlink" title="四、Media and signal Problems介质和信号问题"></a>四、Media and signal Problems介质和信号问题</h1><h2 id="1-Collisions-and-Collision-Domains-碰撞和碰撞域"><a href="#1-Collisions-and-Collision-Domains-碰撞和碰撞域" class="headerlink" title="1. Collisions and Collision Domains 碰撞和碰撞域"></a>1. Collisions and Collision Domains 碰撞和碰撞域</h2><ol>
<li><strong>碰撞（Collisions）</strong><ul>
<li>在网络中，碰撞是指两个或多个设备<strong>同时尝试发送数据</strong>时，<strong>数据包在网络介质上相互干扰的现象</strong>。</li>
</ul>
</li>
<li><strong>碰撞域（Collision Domains）</strong><ul>
<li>碰撞域是指在网络中，数据包碰撞可能发生的范围或区域。在同一个碰撞域内，所有设备共享同一个通信介质，因此它们可能会发生碰撞。</li>
<li><strong>拓展碰撞域</strong>：添加<strong>中继器（repeaters）和集线器（hubs）</strong></li>
<li><strong>限制碰撞域</strong>：通过添加智能设备如<strong>网桥（bridges）、交换机（switches）和路由器（routers）</strong>，可以对网络进行<em>分段</em>。</li>
</ul>
</li>
</ol>
<ul>
<li>当网络中的延迟超过一定限制时，<em>晚碰撞</em>的数量会显著增加。</li>
<li>晚碰撞（<code>Late Collision</code>）：是指在帧的前64字节传输之后发生的碰撞。</li>
<li>消耗延迟（<code>Consumption Delay</code>）：这些晚碰撞帧会增加一种称为消耗延迟的延迟。<br>网络性能：</li>
<li>随着消耗延迟和延迟（Latency）的增加，网络性能会下降。</li>
</ul>
<h2 id="2-5-4-3-2-1规则"><a href="#2-5-4-3-2-1规则" class="headerlink" title="2. 5-4-3-2-1规则"></a>2. 5-4-3-2-1规则</h2><ul>
<li>5-4-3-2-1规则是以太网网络设计中的一个指导原则，用于确保网络性能和减少冲突。具体内容如下：</li>
</ul>
<ol>
<li><strong>5个网段</strong>：在一个以太网网络中，最多可以有5个网段。</li>
<li><strong>4个中继器&#x2F;集线器</strong>：在这5个网段之间，最多可以有4个repeaters或hubs。</li>
<li><strong>3个有源网段</strong>：在这5个网段中，最多可以有3个”mixing” sections（即连接了计算机或其他设备）。</li>
<li><strong>2个无源网段</strong>：其余的2个网段必须是link sections（即只用于信号传输，不连接任何设备）。</li>
<li><strong>1个冲突域</strong>：整个网络必须在一个冲突域内，确保所有设备都能检测到冲突。</li>
</ol>
<h1 id="五、-Basic-Knowledge-of-Data-Communication数据通信基本知识"><a href="#五、-Basic-Knowledge-of-Data-Communication数据通信基本知识" class="headerlink" title="五、 Basic Knowledge of Data Communication数据通信基本知识"></a>五、 Basic Knowledge of Data Communication数据通信基本知识</h1><h2 id="1-数据通信的理论基础"><a href="#1-数据通信的理论基础" class="headerlink" title="1. 数据通信的理论基础"></a>1. 数据通信的理论基础</h2><h3 id="1-1-基本术语"><a href="#1-1-基本术语" class="headerlink" title="1.1 基本术语"></a>1.1 基本术语</h3><ul>
<li>信号(signal)——数据的电气的或电磁的表现<ol>
<li>模拟的(analogous)——消息的参数的取值是连续的<ul>
<li>模拟信号是随时间变化而平稳变化的连续波形式</li>
</ul>
</li>
<li>数字的(digital)——消息的参数的取值是离散的<ul>
<li>数字信号是离散信号，可能包含有限的几个预定值</li>
</ul>
</li>
</ol>
</li>
<li>码元(code)——在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形</li>
</ul>
<h3 id="1-2-信号处理"><a href="#1-2-信号处理" class="headerlink" title="1.2 信号处理"></a>1.2 信号处理</h3><h3 id="1-3-波特率和比特率"><a href="#1-3-波特率和比特率" class="headerlink" title="1.3 波特率和比特率"></a>1.3 波特率和比特率</h3><ul>
<li>波特率（baud）和比特率（bit）<ul>
<li>波特率（调制速率）：信号每秒钟变化的次数</li>
<li>比特率：每秒钟传送的二进制位数</li>
</ul>
</li>
</ul>
<h2 id="2-数据通信技术"><a href="#2-数据通信技术" class="headerlink" title="2. 数据通信技术"></a>2. 数据通信技术</h2><h3 id="2-1-数据通信系统的模型"><a href="#2-1-数据通信系统的模型" class="headerlink" title="2.1 数据通信系统的模型"></a>2.1 数据通信系统的模型</h3><p><img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image-6.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="2-3-数字数据编码"><a href="#2-3-数字数据编码" class="headerlink" title="2.3 数字数据编码"></a>2.3 数字数据编码</h3><ul>
<li>将数字数据转换到模拟信号：调制</li>
<li>将数字数据转换到数字信号：线路编码, 线路编码是指将二进制数据转换为可以在物理通信链路上传播的形式，例如电线上的电脉冲、光纤上的光脉冲或太空中的电磁波</li>
</ul>
<h3 id="2-4-编码方式"><a href="#2-4-编码方式" class="headerlink" title="2.4 编码方式"></a>2.4 编码方式</h3><ul>
<li>可以分为三类</li>
</ul>
<ol>
<li>单极性编码<ul>
<li>用0电平表示”0”，正电平表示”1”</li>
</ul>
</li>
<li>极化编码<ol>
<li>不归零制码(NRZ: Non-Return to Zero)<ul>
<li>不归零电平编码：用负电平表示“0”，正电平表示“1”（或相反）</li>
<li>不归零反相编码：信号电平的一次翻转代表比特1，无电平变化代表0</li>
</ul>
</li>
<li>归零制码（RZ: Return to Zero）<ul>
<li>原理：用负电平表示“0”，正电平表示“1”（或相反），比特中位跳变到零电平，从而提供同步</li>
</ul>
</li>
<li></li>
</ol>
</li>
<li>双极性编码</li>
</ol>
<h3 id="2-5-数据通信技术：多路复用"><a href="#2-5-数据通信技术：多路复用" class="headerlink" title="2.5 数据通信技术：多路复用"></a>2.5 数据通信技术：多路复用</h3><ul>
<li>多路复用技术<ul>
<li>由于一条传输线路的能力远远超过传输一个用户信号所需的能力，为了提高线路利用率，经常让多个信号共用一条物理线路</li>
</ul>
</li>
</ul>
<h4 id="a-时分复用-TDM-（Time-Division-Multiplexing）"><a href="#a-时分复用-TDM-（Time-Division-Multiplexing）" class="headerlink" title="a. 时分复用 TDM （Time Division Multiplexing）"></a>a. 时分复用 TDM （Time Division Multiplexing）</h4><ul>
<li>时分复用是将时间划分为一段段等长的<strong>时分复用（TDM ）帧</strong>，每个时分复用的用户在每个TDM 帧中占用固定序号的时隙。</li>
<li>每一个用户所占用的时隙是周期性地出现</li>
<li>TDM 信号也称为<strong>等时(isochronous)信号</strong></li>
<li><strong>时分复用的所有用户在不同的时间占用同样的带宽资源</strong></li>
<li>可能会造成线路资源的浪费<br><img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image-7.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h4 id="b-频分复用-FDM（Frequency-Division-Multiplexing）"><a href="#b-频分复用-FDM（Frequency-Division-Multiplexing）" class="headerlink" title="b. 频分复用 FDM（Frequency Division Multiplexing）"></a>b. 频分复用 FDM（Frequency Division Multiplexing）</h4><ul>
<li>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带</li>
<li><strong>频分复用的所有用户在同样的时间占用不同的带宽资源</strong><br><img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image-1.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h4 id="c-波分复用-WDM-Wavelength-Division-Multiplexing"><a href="#c-波分复用-WDM-Wavelength-Division-Multiplexing" class="headerlink" title="c. 波分复用 WDM (Wavelength Division Multiplexing)"></a>c. 波分复用 WDM (Wavelength Division Multiplexing)</h4><ul>
<li>就是<strong>光的频分复用</strong><br><img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image-2.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br><img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image-3.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h4 id="d-码分复用-CDM-Code-Division-Multiplexing"><a href="#d-码分复用-CDM-Code-Division-Multiplexing" class="headerlink" title="d. 码分复用 CDM (Code Division Multiplexing)"></a>d. 码分复用 CDM (Code Division Multiplexing)</h4><ul>
<li>更常用的名词是<strong>码分多址 CDMA</strong> (Code Division<br>Multiple Access)</li>
<li>各用户使用经过特殊挑选的<strong>不同码型</strong>，因此<strong>各用户之间不会造成干扰</strong></li>
<li>有很强的<strong>抗干扰能力</strong>，其频谱类似于白噪声，不易被敌人发现</li>
</ul>
<h2 id="2-6-数据通信技术：通信方式"><a href="#2-6-数据通信技术：通信方式" class="headerlink" title="2.6 数据通信技术：通信方式"></a>2.6 数据通信技术：通信方式</h2><ul>
<li>分类：<ul>
<li>单工Simplex Transmission<ul>
<li>信号只能在一个方向传播</li>
</ul>
</li>
<li>半双工Half-Duplex Transmission<ul>
<li>可以双向传播，但不能同时</li>
</ul>
</li>
<li>全双工Full-Duplex Transmission<ul>
<li>可以双向同时传播</li>
</ul>
</li>
</ul>
</li>
<li>并行传输与串行传输<ul>
<li>并行传输：0、1组成的二进制数据。组成每组n比特的位组，同时发送这种位组（8根线一次发送01010101）</li>
<li>串行传输：每次传输1位比特（一根线8次发送01010101）<br>  <img src="/2025/02/24/%E4%BA%8C%E3%80%81OSI%E7%AC%AC%E4%B8%80%E5%B1%82%20%E7%89%A9%E7%90%86%E5%B1%82/image-8.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>三、OSI第二层：数据链路层</title>
    <url>/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<h1 id="Layer2-Data-Link-Layer"><a href="#Layer2-Data-Link-Layer" class="headerlink" title="Layer2:Data Link Layer"></a>Layer2:Data Link Layer</h1><ul>
<li>Overview</li>
<li>Ethernet and CSMA&#x2F;CD<ul>
<li>LLC and MAC Sub-layers</li>
<li>Media Access Control in MAC Sub-layer</li>
</ul>
</li>
<li>Wireless LAN and CSMA&#x2F;CA</li>
<li>Layer 2 Devices</li>
</ul>
<h1 id="一、数据链路层-Overview"><a href="#一、数据链路层-Overview" class="headerlink" title="一、数据链路层 Overview"></a>一、数据链路层 Overview</h1><ul>
<li>数据链路层使用的信道：<ul>
<li>点对点信道：一对一</li>
<li>广播信道：一对多</li>
</ul>
</li>
<li>本章研究：局域网的数据链路层的技术标准</li>
<li>主要是以太网的介质和无线网的介质两大类。<br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="1-物理层和数据链路层的区别"><a href="#1-物理层和数据链路层的区别" class="headerlink" title="1. 物理层和数据链路层的区别"></a>1. 物理层和数据链路层的区别</h2><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-8.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>第一层<ul>
<li>无法与上层通信    </li>
<li>无法确定哪台主机将会传输或接受二进制数据    </li>
<li>无法命名或标识主机    </li>
<li>仅仅能描述比特流</li>
</ul>
</li>
<li>第二层<ul>
<li>通过LLC与上层通信</li>
<li>通过MAC确定</li>
<li>通过寻址或命名过程来实现</li>
<li>通过帧来组织&#x2F;分组比特</li>
</ul>
</li>
</ul>
<h2 id="2-数据链路层-Data-Link-Layer"><a href="#2-数据链路层-Data-Link-Layer" class="headerlink" title="2. 数据链路层 Data Link Layer"></a>2. 数据链路层 Data Link Layer</h2><ol>
<li>问题：如何在不稳定(instable)的链路上正确传输数据？</li>
<li>数据链路层提供<ul>
<li>网络介质访问:</li>
<li>跨媒体物理传输(transmission)</li>
</ul>
</li>
<li>第二层协议明确了<ul>
<li>在链路上<strong>交换的数据格式</strong></li>
<li>链路上的<strong>两个节点的行为</strong></li>
</ul>
</li>
<li>在数据链路层，<em>过程就是协议</em>。</li>
<li>在两端<strong>校验</strong>，帧是否正确，如果正确则交付第三层，否则进行相应的处理</li>
</ol>
<h2 id="3-局域网和数据链路"><a href="#3-局域网和数据链路" class="headerlink" title="3. 局域网和数据链路"></a>3. 局域网和数据链路</h2><ol>
<li>主要工作<ul>
<li><strong>错误识别(notification)</strong></li>
<li><strong>网络拓扑(Network topology)</strong></li>
<li><strong>流控制(Flow control)</strong></li>
</ul>
</li>
<li>第一层和第二层的不同:<ul>
<li>第一层不可以<strong>访问更高层</strong>(upper-level layers)，而第二层是通过<strong>逻辑链路LLC</strong>(Logical Link Control)访问更高层</li>
<li>第1层<strong>无法决定哪个主机</strong>将发送(transmit)或接收(receive)来自组的二进制数据；第2层使用<strong>媒体访问控制MAC</strong>（Media Access Control）做到这一点，共用总线链路</li>
<li>第1层无法命名或识别计算机；<strong>第2层使用寻址(或命名)过程</strong>，以太网场景下</li>
<li>第1层只能描述比特流；第2层使用**成帧（framing）**对比特进行组织或分组。</li>
</ul>
</li>
</ol>
<h2 id="4-第二层提供的服务"><a href="#4-第二层提供的服务" class="headerlink" title="4. 第二层提供的服务"></a>4. 第二层提供的服务</h2><ol>
<li>提供给<strong>网络层</strong>的三层服务<ol>
<li>(最弱，最不靠谱的)<strong>没有确认(acknowledgement)的无连接(Connectionless)服务</strong><ul>
<li>发送取出就行，不用等收到确认</li>
<li><strong>可靠(Reliable)的链接</strong>(上层以确保数据正确性)</li>
<li><strong>实时</strong>任务，比较高效</li>
<li>适用于大多数<strong>局域网</strong></li>
</ul>
</li>
<li><strong>带有确认的无连接服务</strong>：<ul>
<li><strong>不可靠</strong>的链接，例如<strong>无线网络</strong>：需要保证一定的通信质量(比如无线网络的传输)，同时会损失一定的性能。</li>
</ul>
</li>
<li><strong>带有确认的连接服务</strong><ul>
<li>比如蓝牙:需要先确定绑定关系才能进行通信</li>
<li>手机和手机之间的蓝牙连接需要确定一些信息</li>
</ul>
</li>
</ol>
</li>
<li>三种服务的连接的不同和区别:<ul>
<li><strong>无线连接</strong>有<strong>确认</strong>的过程，<strong>有线连接没有</strong></li>
<li><strong>网线连接</strong>:我们通信的对象是<strong>路由器</strong>，由路由器进行转发</li>
<li>PPPoP是<strong>路由器和远端</strong>的服务器的连接</li>
<li>有线无线都接给路由器，都需要连接，但是无线网相对有线网需要确认(包确认)</li>
</ul>
</li>
</ol>
<h2 id="5-常见的局域网的介质访问控制-Media-Access-Control-in-common-LANs"><a href="#5-常见的局域网的介质访问控制-Media-Access-Control-in-common-LANs" class="headerlink" title="5. 常见的局域网的介质访问控制(Media Access Control in common LANs)"></a>5. 常见的局域网的介质访问控制(Media Access Control in common LANs)</h2><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-9.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>以太网(Ethernet):<ul>
<li>逻辑：<strong>总线拓扑</strong>(信息流在线性总线上)</li>
<li>物理：星形或扩展星形(连线为星形)</li>
</ul>
</li>
<li>令牌环(Token Ring):<ul>
<li>逻辑：<strong>环拓扑</strong>(信息流在一个环中)</li>
<li>物理：星形拓扑(以星形连接)</li>
<li>使用令牌传递机制来控制网络访问</li>
</ul>
</li>
<li>光纤分布式数据接口(FDDI, Fiber Distributed Data Interface):<ul>
<li>逻辑：<strong>环拓扑</strong>(信息流在一个环中)</li>
<li>物理：双环拓扑(作为双环连接)</li>
<li>光纤作为传输介质，曾经很常用，后来被以太网有线接入逐渐替代</li>
</ul>
</li>
</ol>
<h2 id="6-介质访问控制方法-Access-Methods-for-Media-Access-Control"><a href="#6-介质访问控制方法-Access-Methods-for-Media-Access-Control" class="headerlink" title="6. 介质访问控制方法 Access Methods for Media-Access Control"></a>6. 介质访问控制方法 Access Methods for Media-Access Control</h2><ol>
<li><strong>确定性轮流 Deterministic</strong> —— taking turns<ul>
<li>Token Ring 和 FDDI(Fiber Distributed Data Interface)</li>
</ul>
</li>
<li><strong>争用式 Non-deterministic (probabilistic)</strong> —— 先到先得 first come, first sesrved<ul>
<li>Ethernet&#x2F;802.3</li>
</ul>
</li>
</ol>
<h3 id="6-1-确定性轮流-Deterministic-MAC-Protocols"><a href="#6-1-确定性轮流-Deterministic-MAC-Protocols" class="headerlink" title="6.1 确定性轮流 Deterministic MAC Protocols"></a>6.1 确定性轮流 Deterministic MAC Protocols</h3><ol>
<li>一个特殊的<strong>数据令牌token在环中循环(circulates)</strong>。</li>
<li>当主机host收到令牌时，它可以传输数据而不是令牌。这称为“<strong>夺取(seizing)令牌</strong>”。</li>
<li>当<strong>传输的帧回到发送者</strong>时，站点会<strong>传输一个新的令牌</strong>；<ul>
<li>帧会从环中移除或剥离。(stripped)。</li>
</ul>
</li>
</ol>
<h3 id="6-2-非确定性MAC协议-Non-Deterministic-MAC-Protocols"><a href="#6-2-非确定性MAC协议-Non-Deterministic-MAC-Protocols" class="headerlink" title="6.2 非确定性MAC协议 Non-Deterministic MAC Protocols"></a>6.2 非确定性MAC协议 Non-Deterministic MAC Protocols</h3><ul>
<li>【重要！】此MAC协议称为<strong>载波监听多路访问&#x2F;碰撞检测(CSMA&#x2F;CD)</strong>，即<strong>带冲突检测的载波侦听多路访问</strong><ul>
<li>Carrier Sense Multiple Access with Collision Detection</li>
</ul>
</li>
<li>为了使用这种共享介质(shared-medium)技术，以太网允许网络设备为传输权进行仲裁(arbitrate)。</li>
</ul>
<h2 id="7-局域网数据传输-Transmitison-方式-三种"><a href="#7-局域网数据传输-Transmitison-方式-三种" class="headerlink" title="7. 局域网数据传输(Transmitison)方式: 三种"></a>7. 局域网数据传输(Transmitison)方式: 三种</h2><ol>
<li><strong>单播(unicast)</strong><ul>
<li>将<strong>单个数据包</strong>从<strong>源</strong>发送到<strong>网络上的单个目标</strong></li>
</ul>
</li>
<li><strong>多播(multicast)</strong><ul>
<li>由发送到网络上特定节点子集的单个数据包组成，这些节点都有同样的进程进行响应</li>
<li>发送<strong>单个数据包</strong>到<strong>网络上的特定子集节点</strong>。</li>
</ul>
</li>
<li><strong>广播(broadcast)</strong><ul>
<li>由单个数据包组成，该数据包传输到网络上的所有节点。(广播的目的地址是0x11111111)</li>
<li>发送<strong>单个数据包</strong>到<strong>网络上的所有节点</strong></li>
</ul>
</li>
</ol>
<hr>
<h1 id="二、-以太网-和-带冲突检测的载波侦听多路访问-Ethernet-and-CSMA-CD"><a href="#二、-以太网-和-带冲突检测的载波侦听多路访问-Ethernet-and-CSMA-CD" class="headerlink" title="二、 以太网 和 带冲突检测的载波侦听多路访问 Ethernet and CSMA&#x2F;CD"></a>二、 以太网 和 带冲突检测的载波侦听多路访问 Ethernet and CSMA&#x2F;CD</h1><h2 id="（一）逻辑链路和介质访问控制子层-LLC-and-MAC-Sub-layers"><a href="#（一）逻辑链路和介质访问控制子层-LLC-and-MAC-Sub-layers" class="headerlink" title="（一）逻辑链路和介质访问控制子层 LLC and MAC Sub-layers"></a>（一）逻辑链路和介质访问控制子层 LLC and MAC Sub-layers</h2><ul>
<li>(Logical Link Control)(Media Access Control)</li>
</ul>
<ol>
<li>无缘电缆的方式传播电波:以太网</li>
<li>帧传播速度提高了</li>
<li>帧的标准没有改变</li>
</ol>
<h3 id="1-局域网标准"><a href="#1-局域网标准" class="headerlink" title="1. 局域网标准"></a>1. 局域网标准</h3><ul>
<li>定义<strong>物理媒体</strong>（如双绞线、光纤）和用于将设备连接到媒体的<strong>连接器</strong></li>
<li>定义<strong>设备在数据链路层的通信方式</strong></li>
<li>数据链路层定义了如何<strong>在物理介质上传输数据</strong>。</li>
<li>数据链路层还定义了<strong>如何封装(encapsulate)特定协议的流量(traffic)</strong>，以使去往不同上层协议的流量在到达堆栈时可以使用相同的通道进行传输。<br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-10.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li>IEEE 802.2 对应 LLC，以太网则覆盖物理层和链路层</li>
</ul>
<ol>
<li><strong>IEEE 将数据链路层分为两部分</strong>：<ul>
<li><strong>媒体访问控制（MAC）</strong>（转换为媒体）</li>
<li><strong>逻辑链路控制（LLC）</strong>（过渡到网络层）</li>
</ul>
</li>
<li>乍一看，IEEE 标准似乎以两种方式违反了 OSI 模型。<ol>
<li><strong>定义了自己的层（LLC）</strong>：<ul>
<li>IEEE标准定义了逻辑链路控制（LLC）层，包括其接口等，这似乎与OSI模型的层次结构不一致。</li>
</ul>
</li>
<li><strong>MAC层标准跨越了第2层和第1层的接口</strong>：<ul>
<li>IEEE 802.3（以太网）和802.5（令牌环）标准似乎跨越了数据链路层（第2层）和物理层（第1层）的接口。</li>
</ul>
</li>
</ol>
</li>
<li>但是，802.3 和 802.5 定义了用于构建特定技术的命名，框架和媒体访问控制规则，都规范了对应的方案，不同方案不同解决标准</li>
</ol>
<h3 id="2-MAC-LLC"><a href="#2-MAC-LLC" class="headerlink" title="2. MAC &amp; LLC"></a>2. MAC &amp; LLC</h3><ul>
<li>MAC子层负责数据链路层的 <strong>物理传输</strong> 和 <strong>访问控制</strong>，其主要作用是确保数据能够有效地从源设备传送到目标设备。</li>
</ul>
<ol>
<li>MAC子层(802.3)<ul>
<li>定义如何在<strong>物理线路</strong>上<strong>传输帧(frames)</strong></li>
<li>处理<strong>物理寻址</strong><ul>
<li>在MAC子层中，设备是通过 MAC地址 来唯一标识的，MAC地址是硬件设备的唯一标识符，每个网络接口控制器（NIC）都有一个固定的MAC地址。当数据帧从一个设备发送到另一个设备时，MAC子层根据目标设备的MAC地址进行物理寻址。</li>
</ul>
</li>
<li><strong>定义网络拓扑</strong></li>
<li><strong>定义线路规则(discipline)</strong></li>
</ul>
</li>
</ol>
<ul>
<li>LLC子层则位于MAC子层之上，主要负责对数据的逻辑控制与协议管理</li>
</ul>
<ol start="2">
<li>LLC 子层(802.2)<ul>
<li><strong>为不同的上层协议提供逻辑上的标识</strong>，然后将其<strong>封装encapsulates</strong>，兼容不同介质的访问<ul>
<li>LLC会在数据帧中添加适当的标识符，使得上层协议能够知道数据的类型。</li>
</ul>
</li>
<li>使用SAP（Service Access Point）标识符用于标识数据包的接收方。<ul>
<li>它帮助MAC层识别数据包的目的地协议，指示它应该交给哪个上层协议进行处理。</li>
</ul>
</li>
<li>LLC帧的类型取决于上层协议期望的标识符，对于上层服务进行支持</li>
<li>LLC已经比较规范了，后来有的厂商已经放弃继续做</li>
</ul>
</li>
</ol>
<h2 id="（一-1）Media-Access-Control-Sublayer-介质访问控制子层"><a href="#（一-1）Media-Access-Control-Sublayer-介质访问控制子层" class="headerlink" title="（一.1）Media Access Control Sublayer 介质访问控制子层"></a>（一.1）Media Access Control Sublayer 介质访问控制子层</h2><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-1.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>以字节为单位进行<strong>帧结构描述</strong><ul>
<li>确保数据能够正确封装和解封装。</li>
</ul>
</li>
<li>有802.3的规范和以太网的规范</li>
<li>MAC 介质访问控制子层的帧结构<ul>
<li>控制多个设备如何共享同一物理介质，避免冲突和碰撞。</li>
</ul>
</li>
<li>物理地址寻址：<ul>
<li>使用MAC地址（物理地址）来唯一标识网络设备，确保数据帧能够正确传输到目标设备。</li>
</ul>
</li>
</ul>
<h3 id="1-前导码Preamble（8字节）"><a href="#1-前导码Preamble（8字节）" class="headerlink" title="1. 前导码Preamble（8字节）"></a>1. 前导码Preamble（8字节）</h3><ol>
<li>格式：从1和0的交替(alternating)模式开始，称为前同步码(preamble)。<ul>
<li><strong>告诉接收方，要来数据了</strong>，因为不是预约发数据的模式，这个码就是为了保证对方有相应准备时间，</li>
<li><strong>前面7个字节是0x10101010</strong>，用于进行<strong>时钟同步</strong></li>
<li>Start Frame Delimiter (SFD)（前导码）：<strong>最后一个字节是0x10101011</strong>，表示帧的开始，并且为接收方提供时钟同步的最后信号。</li>
</ul>
</li>
<li>作用：<ul>
<li>使用曼彻斯特编码的方案，无传输的时候是0电平的</li>
<li>前同步码告诉接收站一帧即将到来。</li>
</ul>
</li>
</ol>
<h3 id="2-目标和源物理地址字段-Dest-add-和-Source-add-（6字节-6字节）"><a href="#2-目标和源物理地址字段-Dest-add-和-Source-add-（6字节-6字节）" class="headerlink" title="2. 目标和源物理地址字段 Dest.add. 和 Source add.（6字节+6字节）"></a>2. 目标和源物理地址字段 Dest.add. 和 Source add.（6字节+6字节）</h3><ol>
<li>目的地址：单播地址，组播地址或广播地址。<ul>
<li>用于标识<strong>接收数据的设备的MAC地址</strong></li>
</ul>
</li>
<li>源地址：始终是<strong>单播地址</strong>。<ul>
<li>用于标识<strong>发送数据的设备的MAC地址</strong>。</li>
</ul>
</li>
</ol>
<ul>
<li>MAC地址：<strong>6个字节目的地址(Dest.add) 6个字节源地址(Source.add.)</strong>，和第三层第四层报文有差别</li>
<li><strong>先看目的地址</strong>的好处:交换机等看到目的地址就可以进行判断，<code>提高效率</code></li>
</ul>
<h3 id="3-长度字段Length（2字节）"><a href="#3-长度字段Length（2字节）" class="headerlink" title="3. 长度字段Length（2字节）"></a>3. 长度字段Length（2字节）</h3><ul>
<li>长度字段指示<strong>在该字段之后</strong>且<strong>在帧检查序列字段(FCS)之前</strong>的<strong>数据字节数</strong>。</li>
<li>确保接收方知道<strong>数据字段的长度</strong>，从而能够正确地解析和处理数据。</li>
</ul>
<h3 id="4-数据字段Data（字节长度可变）"><a href="#4-数据字段Data（字节长度可变）" class="headerlink" title="4. 数据字段Data（字节长度可变）"></a>4. 数据字段Data（字节长度可变）</h3><ul>
<li>数据字段<strong>包含要发送的信息</strong>。</li>
<li>若数据小于46字节，必须通过 填充 零来满足最小长度要求，确保帧的大小达到64字节。</li>
<li>以太网帧头部的前8个字节（如MAC地址、类型字段等）不算作数据字段内容。</li>
<li>发送多个64字节大小的帧可以确保链路带宽的有效利用，尤其在100M带宽的链路上，发送这些帧需要512微秒，占据了完整的传输带宽。</li>
</ul>
<h3 id="5-FCS字段（4个字节）"><a href="#5-FCS字段（4个字节）" class="headerlink" title="5. FCS字段（4个字节）"></a>5. FCS字段（4个字节）</h3><ul>
<li><strong>FCS（Frame Check Sequence，帧检验序列）</strong></li>
<li>FCS字段(四个字节)包含一个<strong>循环冗余校验值(CRC，cyclic redundancy check)</strong><ul>
<li>用于检测<strong>数据帧在传输过程中是否发生了错误</strong></li>
</ul>
<ol>
<li>发送设备生成CRC。</li>
<li>接收设备重新计算CRC，以检查在传输过程中帧是否发生了损坏。</li>
</ol>
</li>
</ul>
<h2 id="（一-2）LLC-逻辑链路控制子层"><a href="#（一-2）LLC-逻辑链路控制子层" class="headerlink" title="（一.2）LLC 逻辑链路控制子层"></a>（一.2）LLC 逻辑链路控制子层</h2><ul>
<li><strong>通信管理</strong>：逻辑链路控制（LLC）子层<strong>管理设备之间在单一链路上的通信</strong>。</li>
<li><strong>支持连接和无连接服务</strong>：<ul>
<li>无连接服务：类似于不需要建立正式连接的通信方式（例如UDP协议）。数据直接被发送，没有需要额外的握手或确认过程。</li>
<li>面向连接的服务：类似于需要事先建立连接的通信方式（例如TCP协议）。在数据传输前，设备需要进行连接建立、数据确认等操作。</li>
</ul>
</li>
<li>LLC子层允许数据链路层的一部分独立于现有技术进行工作。<ul>
<li>单个LLC子层可以与不同的MAC子层兼容。</li>
</ul>
</li>
<li>LLC子层的位置：位于MAC之上<ul>
<li>MAC层与物理层交互, LLC层与网络层交互</li>
</ul>
</li>
</ul>
<h3 id="1-LLC子层：封装"><a href="#1-LLC子层：封装" class="headerlink" title="1. LLC子层：封装"></a>1. LLC子层：封装</h3><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-11.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>LLC接收网络协议数据（数据包，packet），并添加更多的控制信息，帮助将数据包传递到目的地。</li>
<li>它在每端添加了IEEE 802.2标准中的两个地址组件，以标识上层协议：<ul>
<li>目标服务接入点（DSAP）</li>
<li>源服务接入点（SSAP）</li>
</ul>
</li>
<li>然后，这些重新封装的数据会传递给MAC子层，进行进一步的数据封装。</li>
</ol>
<h2 id="（二）-MAC子层上的介质访问控制-Media-Access-Control-in-MAC-Sub-layer"><a href="#（二）-MAC子层上的介质访问控制-Media-Access-Control-in-MAC-Sub-layer" class="headerlink" title="（二） MAC子层上的介质访问控制 Media Access Control in MAC Sub-layer"></a>（二） MAC子层上的介质访问控制 Media Access Control in MAC Sub-layer</h2><h3 id="1-十六进制数-Hexadecimal-作为MAC地址"><a href="#1-十六进制数-Hexadecimal-作为MAC地址" class="headerlink" title="1. 十六进制数(Hexadecimal)作为MAC地址"></a>1. 十六进制数(Hexadecimal)作为MAC地址</h3><ul>
<li>MAC地址<ul>
<li>MAC地址为48位</li>
<li>始终表示为<strong>12个十六进制数字</strong>。</li>
<li>分隔符：MAC地址的各个字节之间通常用冒号（:）或连字符（-）分隔。</li>
</ul>
</li>
<li>MAC地址的组成部分<ol>
<li><strong>组织唯一标识符（OUI）</strong>：<ul>
<li>前6个十六进制数字（从左到右），由IEEE管理，用于标识<strong>制造商</strong>或<strong>供应商</strong>，这部分被称为组织唯一标识符（OUI）。</li>
<li>例如：<code>00:1A:2B</code>。</li>
</ul>
</li>
<li><strong>接口序列号</strong>：<ul>
<li>剩下的6个十六进制数字组成了接口序列号，由具体的供应商管理，用于唯一标识设备。</li>
<li>例如：<code>3C:4D:5E</code>。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-12.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="2-以太网802-3广播"><a href="#2-以太网802-3广播" class="headerlink" title="2. 以太网802.3广播"></a>2. 以太网802.3广播</h3><ul>
<li>以太网802.3广播是指在以太网网络中，将数据帧发送给网络中的所有设备。</li>
</ul>
<ol>
<li>广播Broadcast<ul>
<li>目标MAC：48位全1(<code>FFFF.FFFF.FFFF</code>)<ul>
<li>保证<strong>所有设备</strong>都能收到这个地址</li>
<li>会导致非目的主机进行地址解析</li>
</ul>
</li>
</ul>
</li>
<li>广播会<em>不必要地打断</em> 电台(stations)，从而<strong>严重影响电台的性能</strong></li>
<li>因此，<strong>仅在以下情况下才使用</strong>广播：<ul>
<li><strong>目的地的MAC地址未知</strong></li>
<li><strong>T目的地是所有主机</strong></li>
</ul>
</li>
<li>非必要情况下我们不希望有很多广播，有可能会导致广播风暴</li>
</ol>
<h3 id="3-帧结构-Framing"><a href="#3-帧结构-Framing" class="headerlink" title="3. 帧结构 Framing"></a>3. 帧结构 Framing</h3><ul>
<li>帧结构是 数据链路层（Layer 2） 的<strong>封装</strong>过程。</li>
<li>一帧A frame是数据链路层<strong>协议数据单元（PDU）</strong>。</li>
<li>一帧由多个部分（字段）组成，每个字段由字节构成。<ul>
<li>帧开始字段（frame start field）</li>
<li>地址字段（address field）</li>
<li>长度&#x2F;类型&#x2F;控制字段（length&#x2F;type&#x2F;control field）</li>
<li>数据字段（data field）</li>
<li>帧检验序列字段（frame check sequence field）</li>
<li>帧停止字段（frame stop field）<br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-13.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
<h3 id="4-以太网的MAC机制-CSMA-CD"><a href="#4-以太网的MAC机制-CSMA-CD" class="headerlink" title="4. 以太网的MAC机制 CSMA&#x2F;CD"></a>4. 以太网的MAC机制 CSMA&#x2F;CD</h3><ol>
<li>历史（略）</li>
<li>CSMA&#x2F;CD（载波侦听多路访问&#x2F;碰撞检测）<ul>
<li>使用CSMA机制来判断主机是否应该发送数据。</li>
<li>在传输过程中，同时监听信道。<ul>
<li>当检测到碰撞时，广播干扰信号jam signal。</li>
<li>回退算法，确定发生碰撞的站点何时可以重新发送数据。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="5-以太网操作"><a href="#5-以太网操作" class="headerlink" title="5. 以太网操作"></a>5. 以太网操作</h3><ol>
<li>以太网是<strong>广播网络</strong>，也就是说，<strong>每个站都可以看到所有帧</strong>，而不管它们是否是目的地</li>
<li>通过 <strong>MAC 地址</strong>判断站点是否为<strong>目的地</strong></li>
<li>目标站在 OSI 层上发送数据。其他节点<strong>丢弃</strong>（discard）帧<br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-14.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<ul>
<li>上图中1是总线拓扑，1发送的数据帧会传达给所有在这个总线上的设备，非目的主机检查目的地址和本机MAC地址不同，则会将该帧丢弃。</li>
</ul>
<h3 id="6-广播操作步骤"><a href="#6-广播操作步骤" class="headerlink" title="6. 广播操作步骤"></a>6. 广播操作步骤</h3><ol>
<li>听然后传送</li>
<li>广播 jam 信号</li>
<li>发生碰撞(Collision)</li>
<li>设备退回(back off)适当的时间，然后重新传输(retransmit)发生冲突的设备<ul>
<li>根据特定的回退算法<br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-15.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ol>
<h3 id="7-以太网的-CSMA-CD"><a href="#7-以太网的-CSMA-CD" class="headerlink" title="7. 以太网的 CSMA&#x2F;CD"></a>7. 以太网的 CSMA&#x2F;CD</h3><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-16.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>首先host设备要发送数据</li>
<li>开始侦听链路是非忙，如果忙，则过一阵来再看看</li>
<li>如果不忙，则开始准备发送<ul>
<li>如果有冲突，则到 9，表示有冲突发送，广播一个 jam signal，把自己尝试的次数 + 1（重发有一定限度）</li>
<li>尝试次数过多（11），会像上层协议传输网络不可用（12）</li>
<li>尝试次数还可，则到 13 计算一个回退时间，来再次尝试，回退时间单位，会保证 A 和 D 的时间差能保证第一个人已经用完电路来避免冲突。</li>
</ul>
</li>
<li>如果没有错误，则一直传输到结束为止</li>
</ol>
<hr>
<h1 id="三、无线局域网Wireless-LAN和CSMA-CA"><a href="#三、无线局域网Wireless-LAN和CSMA-CA" class="headerlink" title="三、无线局域网Wireless LAN和CSMA&#x2F;CA"></a>三、无线局域网Wireless LAN和CSMA&#x2F;CA</h1><h2 id="（一）无线（Wireless）局域网"><a href="#（一）无线（Wireless）局域网" class="headerlink" title="（一）无线（Wireless）局域网"></a>（一）无线（Wireless）局域网</h2><h3 id="1-无线局域网"><a href="#1-无线局域网" class="headerlink" title="1. 无线局域网"></a>1. 无线局域网</h3><ul>
<li>基于单元的通信</li>
<li>电台发送的信号只能被附近的电台接收</li>
<li>短距离传输</li>
</ul>
<h3 id="2-无线局域网标准"><a href="#2-无线局域网标准" class="headerlink" title="2. 无线局域网标准"></a>2. 无线局域网标准</h3><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-17.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Wireless LAN Standard<ul>
<li>IEEE 802.11<ul>
<li>一种关键技术：直接序列扩频（DSSS）</li>
<li>DSSS适用于在1到2 Mbps范围内运行的无线设备。</li>
<li>DSSS可以在高达11 Mbps的速率下运行，但在超过2 Mbps时将不被视为合规。</li>
<li>也称为Wi-Fi™。</li>
</ul>
</li>
<li>IEEE 802.11b<ul>
<li>提高了传输能力，达到11 Mbps。</li>
<li>所有802.11b系统向后兼容，支持802.11的1 Mbps和2 Mbps数据速率，仅适用于DSSS。</li>
<li>通过使用不同于802.11的编码技术实现更高的数据吞吐率。</li>
<li>在2.4 GHz频段内运行。</li>
</ul>
</li>
<li>IEEE 802.11a<ul>
<li>覆盖在5 GHz传输频段内运行的无线局域网设备。</li>
<li>使用5 GHz频段。</li>
<li>802.11a能够提供54 Mbps的数据吞吐量，并且通过称为“速率倍增”的专有技术实现了108 Mbps。</li>
<li>实际上，更标准的速率为20-26 Mbps</li>
</ul>
</li>
<li>IEEE 802.11g<ul>
<li>提供与802.11a相同的吞吐量（54 Mbps），但向后兼容802.11b。</li>
<li>使用正交频分复用（OFDM）技术。</li>
</ul>
</li>
<li>IEEE 802.11n<ul>
<li>下一代无线局域网（WLAN）。</li>
<li>提供比802.11g双倍的带宽，即108 Mbps，理论上可达500-600 Mbps。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-Wireless-LAN-Topology-拓扑"><a href="#3-Wireless-LAN-Topology-拓扑" class="headerlink" title="3. Wireless LAN Topology 拓扑"></a>3. Wireless LAN Topology 拓扑</h3><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-18.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><strong>基础设施模式（Infrastructure Mode）</strong></li>
</ol>
<ul>
<li><strong>定义</strong>：设备通过无线接入点（AP）连接到网络。</li>
<li><strong>特点</strong>：<ul>
<li>中心化管理：所有通信都通过AP进行。</li>
<li>更适合大规模网络：支持更多设备和更广的覆盖范围。</li>
<li>提供更高的安全性和管理功能。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>自组织模式（Ad-hoc Mode）</strong></li>
</ol>
<ul>
<li><strong>定义</strong>：设备直接相互连接，不需要AP。</li>
<li><strong>特点</strong>：<ul>
<li>点对点通信：设备之间直接通信。</li>
<li>适合小规模网络：适用于临时或小范围的网络。</li>
<li>部署简单：无需额外的网络设备。</li>
</ul>
</li>
</ul>
<h3 id="4-访问过程（Accessing-Procedure）"><a href="#4-访问过程（Accessing-Procedure）" class="headerlink" title="4. 访问过程（Accessing Procedure）"></a>4. 访问过程（Accessing Procedure）</h3><ul>
<li>在 WLAN 中激活客户端时，它将开始“侦听”与之“关联”的兼容设备</li>
<li>这被称为“<strong>扫描</strong>”<ul>
<li><strong>主动扫描</strong></li>
<li><strong>被动扫描</strong></li>
</ul>
</li>
</ul>
<h4 id="4-1-主动扫描-Active-scanning"><a href="#4-1-主动扫描-Active-scanning" class="headerlink" title="4.1. 主动扫描 Active scanning"></a>4.1. 主动扫描 Active scanning</h4><ul>
<li>导致从寻求加入网络的无线节点发送探测（probe）请求。</li>
<li>探测请求将包含它希望加入的网络的服务集标识符（SSID）</li>
<li>当找到具有相同 SSID 的**接入点（AP）**时，该 AP 将发出探测响应</li>
<li>完成认证和关联步骤。</li>
</ul>
<h4 id="4-2-被动扫描-Passive-scanning"><a href="#4-2-被动扫描-Passive-scanning" class="headerlink" title="4.2. 被动扫描 Passive scanning"></a>4.2. 被动扫描 Passive scanning</h4><ol>
<li>客户端监听接入点（AP）广播的信标帧。这些帧由AP（基础设施模式）或对等节点（自组织模式）发送。</li>
<li>当节点接收到包含要尝试加入的网络的 SSID 的信标时，将尝试加入该网络。</li>
<li>被动扫描是一个连续的过程，节点可能会随着信号强度的变化与AP关联或取消关联。</li>
</ol>
<h3 id="5-无线局域网的帧结构"><a href="#5-无线局域网的帧结构" class="headerlink" title="5. 无线局域网的帧结构"></a>5. 无线局域网的帧结构</h3><ul>
<li>WLAN不使用标准的802.3帧。</li>
<li>有三种类型的帧：<ul>
<li><strong>控制帧（Control Frames）</strong></li>
<li><strong>管理帧（Management Frames）</strong></li>
<li><strong>数据帧（Data Frames，只有数据帧类似于802.3帧）</strong></li>
</ul>
</li>
<li>无线数据帧和802.3帧的有效载荷为1500字节。<ul>
<li>然而，以太网帧不得超过1518字节，而无线帧可以大到2346字节。</li>
<li>通常无线局域网帧的大小将限制在1518字节，因为它最常连接到有线以太网网络。</li>
</ul>
</li>
</ul>
<h4 id="5-1-数据帧结构-802-11-无线网"><a href="#5-1-数据帧结构-802-11-无线网" class="headerlink" title="5.1. 数据帧结构(802.11 无线网)"></a>5.1. 数据帧结构(802.11 无线网)</h4><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-2.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li><strong>帧控制</strong><ul>
<li>帧控制信息包含 16 bit（2字节）</li>
<li>去往AP和来自AP是我们需要重点确认</li>
<li>WEP规格，Wired Equivalent Privacy(有线等效保密)</li>
<li>持续期:参数，很重要，CSMA&#x2F;CA需要，这个信息</li>
<li>有时间窗口，如果超时没收到信号，则进行重传</li>
</ul>
</li>
<li><strong>数据帧的的地址分类</strong><ol>
<li>ad hoc(无线网地址)用地址4</li>
<li>有基础设施(<code>AP</code>)用的是地址1、2、3</li>
</ol>
</li>
<li><strong>数据帧中的地址详解</strong><br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-19.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<h2 id="（二）CSMA-CA"><a href="#（二）CSMA-CA" class="headerlink" title="（二）CSMA&#x2F;CA"></a>（二）CSMA&#x2F;CA</h2><h3 id="1-为什么我们在WLAN需要CSMA-CA？"><a href="#1-为什么我们在WLAN需要CSMA-CA？" class="headerlink" title="1. 为什么我们在WLAN需要CSMA&#x2F;CA？"></a>1. 为什么我们在WLAN需要CSMA&#x2F;CA？</h3><ul>
<li>CSMA&#x2F;CA（载波侦听多路访问&#x2F;碰撞避免）是无线网络中解决碰撞问题的一种机制。</li>
<li>与有线以太网（Ethernet）中的 CSMA&#x2F;CD 不同，无线网络中的 CSMA&#x2F;CD 机制不起作用，原因在于无线信号的传播特性。</li>
</ul>
<ol>
<li>碰撞(Collisions)可能发生在WLAN中，但是站点只能知道附近的传输，因此CSMA&#x2F;CD不是一个好的选择。<ol>
<li><strong>隐藏站问题</strong>（Hidden Station Problem）:当A将数据传输到B时，C无法检测到A和B之间的传输，因此C可能会决定将数据传输到B并导致B发生碰撞。</li>
<li><strong>暴露站问题</strong>（Exposed Station Problem）:当B将数据传输到A时，C可以检测到传输，因此C不会将数据传输到D。但这是一个错误。(<strong>听到不应该听到的信号</strong>)<br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
</li>
</ol>
<h3 id="2-多路复用机制-Multiple-Accessing-Mechanism"><a href="#2-多路复用机制-Multiple-Accessing-Mechanism" class="headerlink" title="2. 多路复用机制 Multiple Accessing Mechanism"></a>2. 多路复用机制 Multiple Accessing Mechanism</h3><ol>
<li>在Ethernet中：<ul>
<li><strong>信号传输</strong>：在以太网中，信号会被传输到网络中的<strong>所有站点</strong>。</li>
<li><strong>碰撞检测</strong>：<strong>发送站点检测</strong>碰撞的发生。</li>
<li><strong>共享信道</strong>：在同一时间，<strong>只能有一个有效的帧</strong>（数据包）在信道上传输。</li>
</ul>
</li>
<li>WLAN (无线局域网)<ul>
<li><strong>信号传输</strong>：在无线局域网中，信号只会传输到<strong>靠近发送站的设备</strong>。<ul>
<li>与有线以太网不同，无线信号的传输是通过空气传播的，因此它的范围受限，通常只有靠近发送设备的站点能接收到信号。</li>
</ul>
</li>
<li><strong>MAC协议的作用</strong>：无线局域网中的 MAC（媒体访问控制）协议 必须<strong>确保仅有一个设备向接收站发送数据</strong>。换句话说，发送站和接收站之间的通信是独占的，避免多个发送站同时占用同一个信道。</li>
<li><strong>碰撞检测</strong>：<strong>接收方</strong>检测确定冲突。</li>
<li><strong>共享信道</strong>：在无线局域网中，同一时刻可以有<strong>多个有效帧</strong>在信道上传输。<ul>
<li>通过多种机制，如时间分复用（TDMA）、频分复用（FDMA）以及载波侦听与碰撞避免（CSMA&#x2F;CA），无线网络能有效地让多个站点同时使用信道。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-CSMA-CA-避免冲突的载波侦听多路访问"><a href="#3-CSMA-CA-避免冲突的载波侦听多路访问" class="headerlink" title="3. CSMA&#x2F;CA 避免冲突的载波侦听多路访问"></a>3. CSMA&#x2F;CA 避免冲突的载波侦听多路访问</h3><ol>
<li><strong>CSMA&#x2F;CA(Carrier Sense Multiple Access with Collision Avoidance)</strong><ul>
<li><strong>发送站点在发送数据前</strong>，以<strong>控制短帧</strong>刺激接收站点发送<strong>应答短帧</strong>，使<strong>接收站点周围的站点监听到该帧</strong>，从而在一定时间内避免数据发送</li>
</ul>
</li>
<li>基本过程：<ol>
<li>A 向 B 发送 <strong>RTS（Request To Send，请求发送）帧</strong>，<strong>A 周围的站点</strong>在一定时间内不发送数据，以<strong>保证 CTS 帧</strong>返回给 A；</li>
<li>B 向 A 回答 <strong>CTS（Clear To Send，清除发送）帧</strong>，<strong>B 周围的站点</strong>在一定时间内不发送数据，以保证 A 发送完数据；</li>
<li>A 开始发送</li>
<li>若控制帧 RTS 或 CTS 发生<strong>冲突</strong>（比如A 和 C 同时向 B 发送 RTS），采用二进制指数<strong>后退算法</strong>等待随机时间，再重新开始。</li>
</ol>
</li>
<li>退避时间短的设备先传输</li>
<li>发现冲突所有设备同时退避</li>
<li>在ad hoc网络中比较无序，存在大量延时，比如CTS和RTS相碰撞，这种情况是比较少的，异常情况，不在本课程考虑范围内。</li>
</ol>
<ul>
<li>过程<ul>
<li>为避免冲突，802.11所有站点在完成一个事务后必须等待一段时间才能进行下一个动作，这个时间被称为IFS，具体取决于帧的类型。</li>
<li>源站需要收到确认信息CTS才能接着发送信息</li>
<li>多个源站向目的站发RTS给目的站，目的站发现冲突，告诉各自站点，PPT处理的是RTS<br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-5.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li>实例<ul>
<li>A的反应时间少，抢到使用权</li>
<li>E加入进来的话也会计算出一个退避时间<br><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-6.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ul>
<h3 id="4-实际数据传输率"><a href="#4-实际数据传输率" class="headerlink" title="4. 实际数据传输率"></a>4. 实际数据传输率</h3><ol>
<li>当源节点发送一个帧时，接收节点会返回一个正向确认（ACK）信号。<ul>
<li>这可能会消耗可用带宽的50%。</li>
<li>这将导致在一个802.11b无线局域网（标称速率为11 Mbps）中，实际数据吞吐量减少到5.0到5.5 Mbps。</li>
</ul>
</li>
<li>网络的性能还会受到信号强度的影响：<ul>
<li>当信号变弱时，可能会启用自适应速率选择（ARS）。</li>
<li>发送设备会将数据传输速率从11 Mbps降低到5.5 Mbps，再从5.5 Mbps降低到2 Mbps，或者从2 Mbps降低到1 Mbps。</li>
</ul>
</li>
</ol>
<h1 id="四-Layer-2-Devices-第二层设备"><a href="#四-Layer-2-Devices-第二层设备" class="headerlink" title="四. Layer 2 Devices 第二层设备"></a>四. Layer 2 Devices 第二层设备</h1><h2 id="1-NIC-网卡"><a href="#1-NIC-网卡" class="headerlink" title="1. NIC 网卡"></a>1. NIC 网卡</h2><ol>
<li><strong>逻辑链路控制</strong>（Logical Link Control, <strong>LLC</strong>）：与计算机中的<strong>上层</strong>通信。</li>
<li><strong>媒介访问控制</strong>（Media Access Control, <strong>MAC</strong>）：提供对共享访问媒介的结构化访问，确保数据不发生冲突。<ul>
<li>MAC使用不同的协议（如CSMA&#x2F;CD用于以太网，CSMA&#x2F;CA用于无线网络）来管理数据传输，确保数据帧能够有效地发送并避免冲突。</li>
</ul>
</li>
<li>【重要】<strong>命名</strong>（Naming）：<strong>提供唯一的MAC地址标识符</strong>。<ul>
<li>网卡的每一个接口都有一个唯一的MAC地址，这是一个48位的标识符，用于唯一标识网络接口。MAC地址确保在局域网中可以准确地找到和通信。</li>
</ul>
</li>
<li><strong>帧定界</strong>（Framing）：作为<strong>封装</strong>过程的一部分，<strong>将比特打包成帧</strong>以便传输。<ul>
<li><strong>帧</strong>是数据链路层传输的<strong>数据单位</strong></li>
<li>网卡负责将来自网络层（如IP层）的数据<strong>封装成帧</strong>，以便通过物理层进行传输。帧定界是封装过程的一部分，它确保数据在网络上传输时按照规定的格式进行封装。</li>
</ul>
</li>
<li><strong>信号传输</strong>（Signaling）：生成信号并通过内置的收发器与媒介进行接口。<ul>
<li>eg：在以太网中，网卡将数据转换成电信号通过电缆传输；在无线局域网中，网卡通过无线收发器将数据转换为电磁波并通过空气传播。</li>
</ul>
</li>
</ol>
<h2 id="2-网桥-Bridges"><a href="#2-网桥-Bridges" class="headerlink" title="2. 网桥(Bridges)"></a>2. 网桥(Bridges)</h2><ol>
<li>网桥<strong>将流量划分为多个段</strong>，并根据<strong>MAC地址</strong>而<strong>不是协议</strong>对流量<strong>进行过滤</strong>。<ul>
<li>桥接器并不像路由器那样根据协议（如IP协议）进行过滤，它只关注MAC地址，即设备的硬件地址。</li>
</ul>
</li>
<li>网桥可以通过<strong>减少较大的冲突域</strong>来提高网络性能。<ul>
<li>通过使用桥接器将网络划分为多个段，每个段可以独立地进行数据传输，减少了各段之间的冲突域。</li>
</ul>
</li>
<li>在从网络的<em>一个网段到其他网段</em>的<strong>流量较低</strong>的情况下，网桥<strong>最有效</strong><ul>
<li>当网段之间的流量变大时，网桥会成为<strong>瓶颈(bottleneck)</strong>，并减慢通信速度。</li>
</ul>
</li>
</ol>
<h3 id="2-1-以太网网桥的工作原理：透明网桥-Transparent-Bridge"><a href="#2-1-以太网网桥的工作原理：透明网桥-Transparent-Bridge" class="headerlink" title="2.1 以太网网桥的工作原理：透明网桥 Transparent Bridge"></a>2.1 以太网网桥的工作原理：透明网桥 Transparent Bridge</h3><p><img src="/2025/02/24/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-7.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>主要功能：是根据MAC地址来转发数据帧。</li>
</ul>
<ol>
<li>MAC表放到缓存的位置，刚启动时是<strong>空表</strong>，之后逐渐学习。<ul>
<li>Mac地址表是有生命周期的，如果计时超过一个阈值没有刺激刷新Mac表，则会刷新表</li>
</ul>
</li>
<li>“<strong>透明</strong>“指局域网中的站点并不知道所发送的帧将经过哪几个网桥，因为网桥对各站来说是看不见的</li>
<li>即插即用，其标准是IEEE 802.1D</li>
<li>过程：<ol>
<li>从A发出的帧从接口x进入了网桥，则从这个接口发出帧就一定能达到A。网桥每收到一个帧，就记下其<strong>源地址</strong>和进入网桥的<strong>接口</strong>，写入<strong>转发表</strong>。</li>
<li>在收到一个<strong>新的帧</strong>时，在<strong>转发表中匹配</strong>此帧的<strong>目的地址</strong>，找到<strong>对应的接口并转发</strong>。</li>
<li>在网桥的转发表中写入的信息除了<strong>地址和接口</strong>外，还有<strong>帧进入网桥的时间</strong>，因为<ul>
<li>拓扑可能经常变化</li>
<li>站点也可能会更换适配器(这就改变了站点的地址)</li>
<li>站点并非总是处于工作状态</li>
<li>把每个帧到达网桥的时间登记下来，就可以在转发表中只保留网络拓扑的最新状态信息，使得网桥中的转发表能反映当前网络的最新拓扑</li>
</ul>
</li>
</ol>
</li>
<li>问题：网络上的设备<strong>要发送数据但不知道目标地址</strong>时。<ul>
<li>向网络上的<strong>所有设备</strong>发送<strong>广播</strong>。因为希望数据帧能够发送到全网，尽可能到达目的地</li>
<li>由于网络上的每个设备都必须注意此类广播，因此网桥<strong>始终会转发这些广播</strong>。</li>
</ul>
</li>
<li>广播过多会导致广播风暴，并且可能导致：<ul>
<li>网络延时(network time-outs)</li>
<li>交通减速(traffic slowdowns)</li>
<li>低于可接受的性能</li>
</ul>
</li>
</ol>
<h3 id="2-2-源路由网桥-Source-Route-Bridge"><a href="#2-2-源路由网桥-Source-Route-Bridge" class="headerlink" title="2.2 源路由网桥 Source Route Bridge"></a>2.2 源路由网桥 Source Route Bridge</h3><ul>
<li>透明网桥容易安装，但网络资源的利用不充分</li>
<li>源路由(source route)网桥在<strong>发送帧</strong>时将<strong>详细的路由信息放在帧的首部</strong>中</li>
<li>原理<ul>
<li>源站以<strong>广播方式</strong>向欲通信的<strong>目的站</strong>发送一个<strong>发现帧</strong>，每个发现帧都<strong>记录所经过的路由</strong></li>
<li>发现帧<em>到达目的站时就沿各自的路由返回源站</em></li>
<li>源站在<strong>得知这些路由后</strong>，从所有可能的路由中<strong>选择出一个最佳路由</strong></li>
<li>凡从该源站向该目的站发送的帧的首部，都必须<em>携带源站所确定的这一路由信息</em></li>
</ul>
</li>
<li>在令牌环网络中被广泛使用</li>
</ul>
<h2 id="3-交换机-Switches"><a href="#3-交换机-Switches" class="headerlink" title="3. 交换机(Switches)"></a>3. 交换机(Switches)</h2><ol>
<li>执行两个基本操作：<ul>
<li><strong>切换数据帧</strong>（switching data frames）：<ul>
<li>在输入介质(medium)上接收帧，然后将其传输到输出<strong>介质</strong></li>
</ul>
</li>
<li><strong>维护交换操作</strong>（maintenance of switching operations）：<ul>
<li>交换器<strong>建立和维护交换表</strong>并<strong>搜索循环</strong>。 路由器构建并维护路由表和交换表。(STB协议避免回路)</li>
</ul>
</li>
</ul>
</li>
<li>交换是一项通过<strong>减少流量</strong>（<strong>reduce traffic</strong>）和<strong>增加带宽</strong>（<strong>increasing bandwidth</strong>）来缓解以太网LAN拥塞(alleviates congestion)的技术.<ul>
<li>交换机创建<em>专用的网络段或点对点连接</em>，并在交换机内连接这些段形成虚拟网络。</li>
<li>这被称为<strong>虚拟电路</strong>，因为它仅在两个节点需要通信时存在，并在交换机内建立。</li>
<li>可以将<em>每个交换端口</em>视为一个<em>微型网桥</em>；这个过程称为<strong>微分段</strong>（microsegmentation）。</li>
<li>每个交换端口为每个主机提供介质的全部带宽。</li>
<li>大多数现代交换机支持<em>全双工通信</em></li>
</ul>
</li>
<li>局域网交换机可<strong>减少冲突域的大小</strong></li>
<li>但是，连接到交换机的所有主机仍<strong>位于同一广播域</strong>中。<ul>
<li>也就是说，通过LAN交换机连接的所有其他节点仍将看到来自一个节点的广播。</li>
</ul>
</li>
</ol>
<h2 id="4-冲突域的分段方式"><a href="#4-冲突域的分段方式" class="headerlink" title="4. 冲突域的分段方式"></a>4. 冲突域的分段方式</h2><h3 id="4-1-网桥对冲突域的分段"><a href="#4-1-网桥对冲突域的分段" class="headerlink" title="4.1 网桥对冲突域的分段"></a>4.1 网桥对冲突域的分段</h3><ul>
<li>使用网桥对以太网局域网（LAN）进行分段，可以为<strong>每个用户提供更多带宽</strong>，因为每个网段上的用户更少。</li>
<li>网桥会<strong>增加网络的延迟（latency）</strong>（10%到30%），因为在转发数据之前需要进行<strong>决策过程</strong>。</li>
<li>网桥被认为是<strong>存储转发设备（store-and-forward device）</strong>，因为它必须先<strong>接收完整的帧</strong>并**验证循环冗余校验（CRC）**后才能进行转发。</li>
</ul>
<h3 id="4-2-交换机对冲突域的分段"><a href="#4-2-交换机对冲突域的分段" class="headerlink" title="4.2 交换机对冲突域的分段"></a>4.2 交换机对冲突域的分段</h3><ol>
<li>交换机转发的<strong>速度明显快于</strong>网桥，因为交换机在<strong>硬件</strong>中进行切换，而<strong>网桥</strong>在<strong>软件</strong>中进行切换。</li>
<li>可以使用交换机连接10 Mbps以太网LAN 和 100 Mbps以太网LAN。</li>
<li>在交换式以太网实现中，可用带宽接近100％。</li>
<li>共享以太网网络的容量不足其全部容量的30％至40％时，其<strong>性能最佳</strong>。(因为CSMA&#x2F;CD)</li>
<li>一些交换机<strong>支持直通交换cut-through switching</strong>，这减少了延迟和延迟，而网桥仅支持<strong>存储转发交换store-and-forward switching</strong>(存储转发，存下来检验转发)。<ul>
<li>直通交换:快速转发，不做校验，只看前6字节的MAC地址。</li>
<li>局域网:网速比较快，传输速率高，网线比较短，可以认为是基本没有错误的，所以可以进行直通转发</li>
</ul>
</li>
</ol>
<h3 id="4-3-路由器对冲突域的分段"><a href="#4-3-路由器对冲突域的分段" class="headerlink" title="4.3 路由器对冲突域的分段"></a>4.3 路由器对冲突域的分段</h3><ul>
<li>路由器可以<strong>创建最高级别的分段</strong>：<ul>
<li><strong>创建更小的冲突域</strong>。</li>
<li><strong>创建更小的广播域</strong>：路由器<strong>不会转发广播</strong>，除非被编程为这样做。</li>
</ul>
</li>
<li>路由器通过<strong>检查数据包上的目标逻辑地址</strong>，并在其<strong>路由表中查找转发指令</strong>来<strong>完成数据包的转发</strong>。</li>
<li>由于路由器执行的功能比网桥更多，它们的<strong>操作延迟率更高</strong>。</li>
<li>路由器可以作为<strong>网关</strong>：<ul>
<li>用于连接不同的网络介质和不同的局域网技术。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
