<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1-十进制二进制浮点数转换</title>
    <url>/2025/02/20/1-%E5%8D%81%E8%BF%9B%E5%88%B6%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="一、十进制整数-二进制补码"><a href="#一、十进制整数-二进制补码" class="headerlink" title="一、十进制整数-&gt;二进制补码"></a>一、十进制整数-&gt;二进制补码</h2><h3 id="1-用2整除的方式（正数）"><a href="#1-用2整除的方式（正数）" class="headerlink" title="1. 用2整除的方式（正数）"></a>1. 用2整除的方式（正数）</h3><ol>
<li>用2整除十进制整数，得到一个<strong>商</strong>和<strong>余数</strong>；</li>
<li>再<strong>用2去除商</strong>，又会得到一个商和余</li>
<li>如此重复，直到<strong>商为小于1</strong>时为止，</li>
<li>然后把<strong>先得到余数</strong>作为二进制数的<strong>低位有效位</strong>，<strong>后得到的余数</strong>作为二进制数的<strong>高位有效位</strong>，以此排列起来。<br><img src="/2025/02/20/1-%E5%8D%81%E8%BF%9B%E5%88%B6%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BD%AC%E6%8D%A2/image.png" alt="alt"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<h3 id="2-负数转化为其补码——（其绝对值转化成二进制后）逐位取反-加一"><a href="#2-负数转化为其补码——（其绝对值转化成二进制后）逐位取反-加一" class="headerlink" title="2. 负数转化为其补码——（其绝对值转化成二进制后）逐位取反+加一"></a>2. 负数转化为其补码——（其绝对值转化成二进制后）逐位取反+加一</h3><ol>
<li>将负数的<strong>绝对值</strong>转换为二进制。</li>
<li>对二进制数进行<strong>逐位取反</strong>（0变1，1变0）。</li>
<li>对<strong>取反后的二进制数加1</strong>。</li>
</ol>
<h3 id="3-将字符数组转换为字符串"><a href="#3-将字符数组转换为字符串" class="headerlink" title="3. 将字符数组转换为字符串"></a>3. 将字符数组转换为字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">binary</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(binaryStr);</span><br></pre></td></tr></table></figure>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>将字符串转换为整数：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">numInt</span> <span class="operator">=</span> Integer.parseInt(numStr);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>初始化一个长度为32的字符数组</strong>，用于存储二进制表示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] binaryStr = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">32</span>];</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>设置符号位</li>
<li>处理正数：使用除2取余法。从数组的末尾开始填充二进制位。</li>
<li>处理负数：<ul>
<li>先将负数转换为其<strong>绝对值</strong>。</li>
<li>使用<strong>除2取余法</strong>，将绝对值转换为二进制表示。</li>
<li>对二进制表示<strong>逐位取反</strong>。</li>
<li>对<strong>取反后的二进制数加一</strong>。注意<code>ifplus</code></li>
</ul>
</li>
<li>将<strong>字符数组转换为字符串</strong>并返回</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">binary</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(binaryStr);</span><br></pre></td></tr></table></figure>
<h3 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">intToBinary</span><span class="params">(String numStr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> numInt=Integer.parseInt(numStr);<span class="comment">//转成int</span></span><br><span class="line">    <span class="type">char</span> []binaryStr = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">if</span>(numInt&gt;=<span class="number">0</span>)&#123;<span class="comment">//符号位</span></span><br><span class="line">        binaryStr[<span class="number">0</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        binaryStr[<span class="number">0</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (numInt&gt;=<span class="number">0</span>)&#123;<span class="comment">//正数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numInt%<span class="number">2</span>==<span class="number">1</span>)&#123;<span class="comment">//余数是1</span></span><br><span class="line">                binaryStr[<span class="number">32</span>-i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//余数是0</span></span><br><span class="line">                binaryStr[<span class="number">32</span>-i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            numInt=numInt/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;<span class="comment">//负数，等于其正数的二进制数，逐位取反，再加一</span></span><br><span class="line">        numInt = -numInt;<span class="comment">//转正</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numInt % <span class="number">2</span> == <span class="number">1</span>) &#123;<span class="comment">//余数是1</span></span><br><span class="line">                binaryStr[<span class="number">32</span> - i] = <span class="string">&#x27;0&#x27;</span>;<span class="comment">//取反</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//余数是0</span></span><br><span class="line">                binaryStr[<span class="number">32</span> - i] = <span class="string">&#x27;1&#x27;</span>;<span class="comment">//取反</span></span><br><span class="line">            &#125;</span><br><span class="line">            numInt = numInt / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加一</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ifplus</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binaryStr[i] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; ifplus) &#123;</span><br><span class="line">                    binaryStr[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    ifplus = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (binaryStr[i] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; ifplus) &#123;</span><br><span class="line">                    binaryStr[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">binary</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(binaryStr);</span><br><span class="line">  <span class="keyword">return</span> binary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、二进制补码-十进制整数"><a href="#二、二进制补码-十进制整数" class="headerlink" title="二、二进制补码-&gt;十进制整数"></a>二、二进制补码-&gt;十进制整数</h2><h3 id="错误方法-无法通过最大-最小值测试"><a href="#错误方法-无法通过最大-最小值测试" class="headerlink" title="错误方法-无法通过最大&#x2F;最小值测试"></a>错误方法-无法通过最大&#x2F;最小值测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">binaryToInt</span><span class="params">(String binStr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(binStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>)&#123;<span class="comment">//正数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> temp=Integer.parseInt(String.valueOf(binStr.charAt(i)));</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">32</span>-i;j++)&#123;</span><br><span class="line">                temp*=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           temp/=<span class="number">2</span>;</span><br><span class="line">            num+=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;<span class="comment">//负数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> temp=Integer.parseInt(String.valueOf(binStr.charAt(i)));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">32</span>-i;j++)&#123;</span><br><span class="line">                temp*=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp/=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>) &#123;</span><br><span class="line">                num += temp;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num-=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String numStr=String.valueOf(num);</span><br><span class="line">    <span class="keyword">return</span> numStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-逐位累加（！！从左边开始！！）"><a href="#1-逐位累加（！！从左边开始！！）" class="headerlink" title="1.逐位累加（！！从左边开始！！）"></a>1.逐位累加（！！从左边开始！！）</h3><ul>
<li>逐位累加实现二进制转十进制的过程就是将二进制字符串中的每一位数字（<strong>从左到右</strong>）根据其所在的位置转换为相应的十进制值，并累加到最终结果中。</li>
</ul>
<ol>
<li>从二进制字符串的<strong>左边</strong>开始，对每个字符进行处理。</li>
<li>对每个字符，计算其<strong>对应的二进制值(1&#x2F;0)</strong>，然后将其加到累积结果中。</li>
<li>在处理每个字符时，将<strong>当前的累积值乘以 2</strong>，并<strong>加上当前字符所表示的数字（0 或 1）</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num = num * <span class="number">2</span> + (binStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>这样，最终的结果就是二进制转换成的十进制数。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (binStr.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>) &#123; <span class="comment">// 正数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        num = num * <span class="number">2</span> + (binStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-char转int"><a href="#2-char转int" class="headerlink" title="2. char转int"></a>2. char转int</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num = num * <span class="number">2</span> + (binStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="3-处理负数"><a href="#3-处理负数" class="headerlink" title="3. 处理负数"></a>3. 处理负数</h3><ol>
<li><strong>逐位取反</strong>：将二进制字符串逐位取反。</li>
<li><strong>加一</strong>：对取反后的二进制数加一。</li>
<li>累加计算：从第0位到第31位，逐位计算二进制数对应的十进制值。</li>
<li>取反：将结果取负。</li>
</ol>
<ul>
<li>注意：<strong>二进制负数取反后加一</strong>等价于相当于<strong>二进制负数先减一，再取反</strong></li>
</ul>
<h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol>
<li>正数处理：<ul>
<li>从第0位到第31位，逐位计算二进制数对应的十进制值。</li>
<li>num*2+(dinStr.charAt(i)-‘0’);</li>
</ul>
</li>
<li>负数处理：<ul>
<li>取反：将二进制字符串逐位取反。</li>
<li>加一：对取反后的二进制数加一。</li>
<li>累加计算：从第0位到第31位，逐位计算二进制数对应的十进制值。</li>
<li>取反：将结果取负。</li>
</ul>
</li>
<li>返回结果：<ul>
<li>将计算得到的十进制整数转换为字符串并返回。</li>
</ul>
</li>
</ol>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">binaryToInt</span><span class="params">(String binStr)</span> &#123;</span><br><span class="line">       <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span>(binStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>)&#123;<span class="comment">//正数</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;<span class="comment">//从0或者1开始都行，没影响</span></span><br><span class="line">               num=num*<span class="number">2</span>+(binStr.charAt(i)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;<span class="comment">//负数</span></span><br><span class="line">          <span class="comment">//1. 取反</span></span><br><span class="line">           <span class="type">char</span>[]binstr=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">32</span>];</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">               <span class="keyword">if</span> (binStr.charAt(i)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                   binstr[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   binstr[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//2. 加一</span></span><br><span class="line">           <span class="type">boolean</span> is_plus=<span class="literal">true</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">               <span class="keyword">if</span>(binstr[i]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;is_plus)&#123;</span><br><span class="line">                   binstr[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                   is_plus=<span class="literal">false</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(binstr[i]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;is_plus)&#123;</span><br><span class="line">                   binstr[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//3. 累加计算</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;<span class="comment">//从0或者1开始都行，没影响</span></span><br><span class="line">               num=num*<span class="number">2</span>+(binstr[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//4. 取反</span></span><br><span class="line">           num=-num;</span><br><span class="line">       &#125;</span><br><span class="line">       String numStr=String.valueOf(num);</span><br><span class="line">       <span class="keyword">return</span> numStr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结：二进制补码和十进制整数相互转换："><a href="#总结：二进制补码和十进制整数相互转换：" class="headerlink" title="总结：二进制补码和十进制整数相互转换："></a>总结：二进制补码和十进制整数相互转换：</h2><ol>
<li>负数补码和对应正数补码转换<ul>
<li><strong>负数转补码</strong>：<ol>
<li>将负数的<strong>绝对值转换为二进制</strong>。</li>
<li>对二进制数<em><strong>逐位取反</strong></em>（0变1，1变0）。</li>
<li>对取反后的<strong>二进制数加1</strong>。</li>
</ol>
</li>
<li><strong>补码转负数</strong>：<ol>
<li>对<strong>补码逐位取反</strong>（0变1，1变0）。</li>
<li>对取反后的<strong>二进制数加1</strong>。</li>
<li>将结果int<strong>取负</strong>。</li>
</ol>
</li>
</ul>
</li>
<li>十进制整数转二进制补码：<ul>
<li>正数：<ol>
<li>使用<strong>除2取余法</strong>，从<strong>低位到高位依次填充</strong>二进制位。</li>
<li>符号位为0。</li>
</ol>
</li>
<li>负数：<ol>
<li>将负数的<strong>绝对值</strong>转换为二进制。</li>
<li>对二进制数逐位取反（0变1，1变0）。</li>
<li>对取反后的二进制数加1。</li>
<li>符号位为1。</li>
</ol>
</li>
</ul>
</li>
<li>二进制补码转十进制整数：<ul>
<li>正数：<ul>
<li>从<strong>第0位到第31位（从左开始！！）</strong>，<strong>逐位计算</strong>二进制数对应的十进制值。</li>
</ul>
</li>
<li>负数：<ol>
<li>对二进制数逐位取反（0变1，1变0）。</li>
<li>对取反后的二进制数加1。</li>
<li>从第0位到第31位，逐位计算二进制数对应的十进制值。</li>
<li>将结果取负。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="三、十进制整数的真值转化成NBCD"><a href="#三、十进制整数的真值转化成NBCD" class="headerlink" title="三、十进制整数的真值转化成NBCD"></a>三、十进制整数的真值转化成NBCD</h2><h3 id="1-NBCD"><a href="#1-NBCD" class="headerlink" title="1. NBCD"></a>1. NBCD</h3><ol>
<li>NBCD格式：<ol>
<li>符号位<ul>
<li><strong>正数：1100</strong></li>
<li><strong>负数：1101</strong></li>
</ul>
</li>
<li>每个十进制数字用4位二进制数表示。</li>
<li>确保NBCD表示一定是32位。<ul>
<li>在<strong>符号位和有效位之间</strong>填充<strong>0</strong>!</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="2-将单位十进制数字转化为4位二进制形式"><a href="#2-将单位十进制数字转化为4位二进制形式" class="headerlink" title="2.将单位十进制数字转化为4位二进制形式"></a>2.将单位十进制数字转化为4位二进制形式</h3><ul>
<li>除2取余法<ul>
<li><strong>先得到的余数</strong>作为<strong>低位有效位</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">CharTo4bit</span><span class="params">(Character character)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> character-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="type">char</span>[] stringOf4=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        stringOf4[i] = <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 初始化字符数组为&#x27;0&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//转换为二进制[除二取余法]</span></span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            stringOf4[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(stringOf4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-步骤"><a href="#3-步骤" class="headerlink" title="3. 步骤"></a>3. 步骤</h3><ol>
<li>将字符串转换为<strong>整数</strong>。</li>
<li>初始化一个 StringBuilder 用于构建NBCD字符串。</li>
<li>根据整数的符号设置<strong>符号位</strong>：<ul>
<li>正数：1100</li>
<li>负数：1101</li>
</ul>
</li>
<li>计算需要<strong>填充的零</strong>的数量，以确保NBCD表示是<strong>32位</strong>。</li>
<li>将<strong>每个十进制数字转换为4位二进制形式</strong>，并<strong>添加</strong>到 StringBuilder 中。</li>
<li>返回NBCD字符串。</li>
</ol>
<h3 id="4-【注意】语法"><a href="#4-【注意】语法" class="headerlink" title="4. 【注意】语法"></a>4. 【注意】语法</h3><ol>
<li>return <strong>new String(stringOf4)</strong>;<ul>
<li>适用于将<strong>字符数组char[]转换为字符串</strong>的场景</li>
</ul>
</li>
<li>return <strong>nbcdStr.toString()</strong>;<ul>
<li>适用于将<strong>StringBuilder对象转换为字符串</strong>的场景</li>
</ul>
</li>
</ol>
<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">decimalToNBCD</span><span class="params">(String decimalStr)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">nbcdStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(decimalStr);</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> decimalStr.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">zero_length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        zero_length=<span class="number">28</span>-<span class="number">4</span>*length;</span><br><span class="line">        nbcdStr.append(<span class="number">1100</span>);<span class="comment">//符号位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;zero_length;i++)&#123;<span class="comment">//填充零</span></span><br><span class="line">            nbcdStr.append(<span class="number">0000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            nbcdStr.append(CharTo4bit(decimalStr.charAt(i)));<span class="comment">//转换每个十进制数字,并添加到 StringBuilder 中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        zero_length=<span class="number">28</span>-<span class="number">4</span>*(length-<span class="number">1</span>);</span><br><span class="line">        nbcdStr.append(<span class="number">1101</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;zero_length;i++)&#123;</span><br><span class="line">            nbcdStr.append(<span class="number">0000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;<span class="comment">//把负号跳过</span></span><br><span class="line">            nbcdStr.append(CharTo4bit(decimalStr.charAt(i)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nbcdStr.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、-NBCD（符号位用4位表示）转化成十进制整数的真值"><a href="#四、-NBCD（符号位用4位表示）转化成十进制整数的真值" class="headerlink" title="四、 NBCD（符号位用4位表示）转化成十进制整数的真值"></a>四、 NBCD（符号位用4位表示）转化成十进制整数的真值</h2><h3 id="1-4位二进制-转-1位十进制：bit4ToChar"><a href="#1-4位二进制-转-1位十进制：bit4ToChar" class="headerlink" title="1. 4位二进制 转 1位十进制：bit4ToChar"></a>1. 4位二进制 转 1位十进制：bit4ToChar</h3><ul>
<li>从左到右，累加</li>
<li>num&#x3D;num*2+(<strong>bit4.charAt(i)-‘0’</strong>);</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">bit4ToChar</span><span class="params">(String bit4)</span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        num=num*<span class="number">2</span>+(bit4.charAt(i)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>初始化一个 StringBuilder 用于构建十进制字符串。</li>
<li>从第4位开始，<strong>每4位表示一个十进制数字</strong>，使用 <strong>bit4ToChar</strong> 方法将其转换为<strong>对应的十进制字符</strong>，并添加到 StringBuilder 中。</li>
<li><strong>去除前面多余的0</strong>（<strong>保留至少一位，以满足数为0</strong>）。</li>
<li>将 StringBuilder 转换为字符串，并解析为整数。</li>
<li>根据符号位确定结果<strong>是否为负数</strong>。</li>
<li>返回十进制字符串。</li>
</ol>
<h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">NBCDToDecimal</span><span class="params">(String NBCDStr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    StringBuilder num_sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();   <span class="comment">//初始化 StringBuilder</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>;i&lt;<span class="number">32</span>;i+=<span class="number">4</span>)&#123;       <span class="comment">//转换每个4位二进制数字</span></span><br><span class="line">        num_sb.append(bit4ToChar(NBCDStr.substring(i,i+<span class="number">4</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去除前面多余的0（留一位，以满足数为0）</span></span><br><span class="line">    <span class="type">int</span> length=num_sb.length();</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num_sb.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>&amp;&amp;length!=<span class="number">1</span>)&#123;       <span class="comment">//去除前面多余的0(留1位)</span></span><br><span class="line">        num_sb.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">        length=num_sb.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">demical</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(num_sb);</span><br><span class="line">    num=Integer.parseInt(demical);      <span class="comment">//解析为整数</span></span><br><span class="line">    <span class="keyword">if</span> (NBCDStr.substring(<span class="number">0</span>, <span class="number">4</span>).equals(<span class="string">&quot;1101&quot;</span>))&#123;    <span class="comment">//负数判断</span></span><br><span class="line">        num=-num;</span><br><span class="line">    &#125;</span><br><span class="line">    demical=String.valueOf(num);        <span class="comment">//转为字符串</span></span><br><span class="line">    <span class="keyword">return</span> demical;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将4位二进制字符串转换为对应的十进制字符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">bit4ToChar</span><span class="params">(String binStr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        num = num * <span class="number">2</span> + (binStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>) (num + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、将浮点数真值转化成32位单精度浮点数表示"><a href="#五、将浮点数真值转化成32位单精度浮点数表示" class="headerlink" title="五、将浮点数真值转化成32位单精度浮点数表示"></a>五、将浮点数真值转化成32位单精度浮点数表示</h2><h3 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h3><ul>
<li>如果<strong>8位指数位全为0</strong>, 就代表当前数是个<strong>非规格数</strong>. 或者说, 形如 * 00000000 *********************** 格式的数就是非规格数.<ul>
<li>用于表示0, 以及非常靠近0的数, 比如1E-38.</li>
<li><strong>非规格数的实际指数固定为-126</strong></li>
</ul>
</li>
<li>如果<strong>8位指数位全为1</strong>, 就代表当前数是个<strong>特殊数</strong>. 或者说, 形如 * 11111111 *********************** 格式的数就是特殊数.<ul>
<li><strong>无穷大</strong>和<strong>NaN</strong></li>
</ul>
</li>
</ul>
<h3 id="1-0"><a href="#1-0" class="headerlink" title="1. 0"></a>1. 0</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (num == <span class="number">0.0f</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;00000000000000000000000000000000&quot;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="2-NaN"><a href="#2-NaN" class="headerlink" title="2.NaN"></a>2.NaN</h3><ol>
<li>符号位：0或1</li>
<li>指数位：<strong>11111111</strong></li>
<li>尾数位：任意非零值（通常为<strong>10000000000000000000000</strong>）</li>
</ol>
<ul>
<li>一般表示用：<strong>0 11111111 10000000000000000000000</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Float.isNaN(num)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;01111111110000000000000000000000&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-无穷大"><a href="#3-无穷大" class="headerlink" title="3. 无穷大"></a>3. 无穷大</h3><ol>
<li>8位指数位全为1：<strong>11111111</strong></li>
<li>23位尾数位全为0：<strong>00000000000000000000000</strong></li>
</ol>
<ul>
<li>正无穷：01111111100000000000000000000000</li>
<li>负无穷：11111111100000000000000000000000</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (num == Float.POSITIVE_INFINITY)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;+Inf&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&lt;=Float.NEGATIVE_INFINITY)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;-Inf&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-非规格数"><a href="#4-非规格数" class="headerlink" title="4. 非规格数"></a>4. 非规格数</h3><h3 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h3><ol>
<li>特殊情况处理<ol>
<li>零</li>
<li>正负无穷：num &#x3D;&#x3D; <strong>Float.POSITIVE_INFINITY</strong></li>
<li>NaN: <strong>if (Float.isNaN(num))</strong></li>
</ol>
</li>
<li>正常情况处理<ol>
<li>正负</li>
<li>调整尾数到1.f~2.f范围：（指数初始为0）<ul>
<li>尾数偏大时，除以2，指数加1。<code>while (num &gt;= 2.0f)</code></li>
<li>尾数偏小时，乘以2，指数减1。<code>while (num &lt; 1.0f &amp;&amp; exponent &gt; -126)</code><ul>
<li>如果指数减小到了<code>-126</code>，则<strong>非规格化数</strong>！</li>
</ul>
</li>
</ul>
</li>
<li>规格化判断<ul>
<li>非规格化数：如果<strong>实际指数为-126，则指数部分全为0</strong>，<strong>尾数不变</strong>（已经小于1.0f了）。</li>
<li>规格化数：尾数<strong>减去1.0f</strong>，指数<strong>加偏移量127</strong>。</li>
</ul>
</li>
<li>构建IEEE 754二进制字符串：<ul>
<li>符号位：1位</li>
<li>指数位：8位——<strong>除二取余法</strong></li>
<li><strong>尾数位</strong>：23位——<strong>乘二减一法</strong>：<ul>
<li>如果乘二之后大于1.0f，则1；否则0。</li>
<li>先出现的在左！</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">floatToBinary</span><span class="params">(String floatStr)</span> &#123;</span><br><span class="line">       <span class="type">float</span> <span class="variable">num</span> <span class="operator">=</span> Float.parseFloat(floatStr);</span><br><span class="line">       <span class="comment">//1、0</span></span><br><span class="line">       <span class="keyword">if</span>(num==<span class="number">0</span>)&#123;</span><br><span class="line">           String zeroStr=<span class="string">&quot;00000000000000000000000000000000&quot;</span>;</span><br><span class="line">           <span class="keyword">return</span> zeroStr;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2.+Inf和-Inf（正负无穷）</span></span><br><span class="line">       <span class="keyword">if</span> (num == Float.POSITIVE_INFINITY)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;+Inf&quot;</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&lt;=Float.NEGATIVE_INFINITY)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;-Inf&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3.NaN</span></span><br><span class="line">       <span class="keyword">if</span>(Float.isNaN(num))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;01111111110000000000000000000000&quot;</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Float.isNaN(-num))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;11111111110000000000000000000000&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//4. 正常情况</span></span><br><span class="line">       <span class="comment">//4.1判断正负</span></span><br><span class="line">       <span class="type">boolean</span> is_neg=<span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">if</span>(num&lt;<span class="number">0</span>)&#123;</span><br><span class="line">           is_neg=<span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> exponent=<span class="number">0</span>;<span class="comment">//指数</span></span><br><span class="line">       <span class="comment">//尾数</span></span><br><span class="line">       <span class="type">int</span> offset=<span class="number">127</span>;;<span class="comment">//偏移量</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//4.2 调整尾数到1.f~2.f范围</span></span><br><span class="line">       <span class="keyword">if</span>(num&lt;<span class="number">0</span>)&#123;</span><br><span class="line">           num=-num;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (num&gt;=<span class="number">2.0f</span>)&#123;   <span class="comment">//尾数偏大</span></span><br><span class="line">           num/=<span class="number">2.0f</span>;</span><br><span class="line">           exponent++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (num&lt;<span class="number">1.0f</span>&amp;&amp;exponent&gt;-<span class="number">126</span>)&#123;    <span class="comment">//尾数偏小</span></span><br><span class="line">           num*=<span class="number">2.0f</span>;</span><br><span class="line">           exponent--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//4.3 规格化判断</span></span><br><span class="line">       <span class="keyword">if</span> (exponent &lt;=-<span class="number">126</span>) &#123;</span><br><span class="line">           exponent = <span class="number">0</span>; <span class="comment">// 非规格化数，指数部分全为0(实际指数固定为-126)</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           num -= <span class="number">1.0f</span>; <span class="comment">// 规格化数，尾数减去1</span></span><br><span class="line">           exponent += offset; <span class="comment">// 加偏移量</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//4.4 化为IEEE</span></span><br><span class="line">       StringBuilder binFloat=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">       <span class="comment">//符号位</span></span><br><span class="line">       <span class="keyword">if</span> (is_neg)&#123;</span><br><span class="line">           binFloat.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           binFloat.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//指数位</span></span><br><span class="line">       <span class="type">char</span>[] exp = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">8</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">7</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">           <span class="keyword">if</span>(exponent%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">               exp[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               exp[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           exponent/=<span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//尾数位</span></span><br><span class="line">       <span class="type">char</span>[]wei=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">23</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">23</span>;i++)&#123;</span><br><span class="line">           num*=<span class="number">2.0f</span>;</span><br><span class="line">           <span class="keyword">if</span>(num&gt;=<span class="number">1.0f</span>)&#123;</span><br><span class="line">               wei[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">               num-=<span class="number">1.0f</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               wei[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">expStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(exp);</span><br><span class="line">       String weiStr=<span class="keyword">new</span> <span class="title class_">String</span>(wei);</span><br><span class="line">       binFloat.append(expStr);</span><br><span class="line">       binFloat.append(weiStr);</span><br><span class="line">       <span class="keyword">return</span> binFloat.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、32位单精度浮点数表示转化成浮点数真值"><a href="#六、32位单精度浮点数表示转化成浮点数真值" class="headerlink" title="六、32位单精度浮点数表示转化成浮点数真值"></a>六、32位单精度浮点数表示转化成浮点数真值</h2><h3 id="1-特殊情况"><a href="#1-特殊情况" class="headerlink" title="1. 特殊情况"></a>1. 特殊情况</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 0</span></span><br><span class="line">        <span class="keyword">if</span>(binStr==<span class="string">&quot;00000000000000000000000000000000&quot;</span>)&#123;</span><br><span class="line">            <span class="type">Float</span> <span class="variable">zero</span> <span class="operator">=</span> <span class="number">0.0f</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(zero);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. NaN</span></span><br><span class="line">        <span class="keyword">if</span>(binStr==<span class="string">&quot;01111111110000000000000000000000&quot;</span>)&#123;</span><br><span class="line">           <span class="type">Float</span> <span class="variable">nan</span> <span class="operator">=</span> Float.NaN;</span><br><span class="line">           <span class="keyword">return</span> String.valueOf(nan);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 正负无穷</span></span><br><span class="line">        <span class="keyword">if</span>(binStr==<span class="string">&quot;01111111100000000000000000000000&quot;</span>)&#123;</span><br><span class="line">           Float pos_inf=Float.POSITIVE_INFINITY;</span><br><span class="line">           <span class="keyword">return</span> String.valueOf(pos_inf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(binStr==<span class="string">&quot;11111111100000000000000000000000&quot;</span>)&#123;</span><br><span class="line">            Float neg_inf=Float.NEGATIVE_INFINITY;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(neg_inf);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-正常情况（规格化数-非规格化数）"><a href="#2-正常情况（规格化数-非规格化数）" class="headerlink" title="2. 正常情况（规格化数+非规格化数）"></a>2. 正常情况（规格化数+非规格化数）</h3><ol>
<li>符号位</li>
<li>指数位<ul>
<li>提取指数位的8位二进制数，并转换为整数。</li>
<li>对于<strong>规格化数</strong>，<strong>减去偏移量127</strong>。</li>
<li>对于<strong>非规格化数（指数位等于0）</strong>，<strong>实际指数为-126</strong>。</li>
</ul>
</li>
<li>尾数位：<ul>
<li>提取尾数位的23位二进制数，并转换为浮点数。</li>
<li>对于规格化数，尾数部分隐含一个1。<strong>规格化数，加1.0f</strong></li>
</ul>
</li>
<li>计算浮点数值：<ul>
<li>根据指数调整尾数的值&#x2F;直接算（注意<strong>double和float的转换</strong>）<ul>
<li><em><em>float num&#x3D;weishu</em>(float)Math.pow(2,exponent);</em>*</li>
</ul>
</li>
<li>如果符号位为1，则结果为负数。</li>
</ul>
</li>
</ol>
<h3 id="完整代码-4"><a href="#完整代码-4" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">binaryToFloat</span><span class="params">(String binStr)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 0</span></span><br><span class="line">        <span class="keyword">if</span>(binStr==<span class="string">&quot;00000000000000000000000000000000&quot;</span>)&#123;</span><br><span class="line">            <span class="type">Float</span> <span class="variable">zero</span> <span class="operator">=</span> <span class="number">0.0f</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(zero);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. NaN</span></span><br><span class="line">        <span class="keyword">if</span>(binStr==<span class="string">&quot;01111111110000000000000000000000&quot;</span>)&#123;</span><br><span class="line">           <span class="type">Float</span> <span class="variable">nan</span> <span class="operator">=</span> Float.NaN;</span><br><span class="line">           <span class="keyword">return</span> String.valueOf(nan);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 正负无穷</span></span><br><span class="line">        <span class="keyword">if</span>(binStr==<span class="string">&quot;01111111100000000000000000000000&quot;</span>)&#123;</span><br><span class="line">           Float pos_inf=Float.POSITIVE_INFINITY;</span><br><span class="line">           <span class="keyword">return</span> String.valueOf(pos_inf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(binStr==<span class="string">&quot;11111111100000000000000000000000&quot;</span>)&#123;</span><br><span class="line">            Float neg_inf=Float.NEGATIVE_INFINITY;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(neg_inf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4. 正常情况</span></span><br><span class="line">        <span class="comment">//4.1 正负</span></span><br><span class="line">        <span class="type">boolean</span> is_neg=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(binStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            is_neg=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.2指数</span></span><br><span class="line">        <span class="type">int</span> exponent=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">            exponent=exponent*<span class="number">2</span>+(binStr.charAt(i+<span class="number">1</span>)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(exponent!=<span class="number">0</span>)&#123;</span><br><span class="line">            exponent-=<span class="number">127</span>;<span class="comment">//规格数</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            exponent=-<span class="number">126</span>;<span class="comment">//非规格数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.3 尾数</span></span><br><span class="line">        <span class="type">float</span> weishu=<span class="number">0.0f</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">Add</span> <span class="operator">=</span> <span class="number">0.5f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">9</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(binStr.charAt(i)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                weishu+=Add;</span><br><span class="line">            &#125;</span><br><span class="line">            Add/=<span class="number">2.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exponent!=-<span class="number">126</span>)&#123;<span class="comment">//规格化数，加1.0f</span></span><br><span class="line">            weishu+=<span class="number">1.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.计算</span></span><br><span class="line">        <span class="keyword">while</span> (exponent&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            weishu*=<span class="number">2.0f</span>;</span><br><span class="line">            exponent--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (exponent&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            weishu/=<span class="number">2.0f</span>;</span><br><span class="line">            exponent++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(is_neg)&#123;</span><br><span class="line">            weishu=-weishu;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//法2：直接算</span></span><br><span class="line"><span class="comment">//        float num=weishu*(float)Math.pow(2,exponent);</span></span><br><span class="line"><span class="comment">//        if (is_neg)&#123;</span></span><br><span class="line"><span class="comment">//            num=-num;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">return</span> String.valueOf(weishu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>4-cache</title>
    <url>/2025/02/22/4.cache/</url>
    <content><![CDATA[<h1 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h1><h2 id="一、通用映射策略"><a href="#一、通用映射策略" class="headerlink" title="一、通用映射策略"></a>一、通用映射策略</h2><h3 id="1-fetch"><a href="#1-fetch" class="headerlink" title="1.fetch"></a>1.fetch</h3><ol>
<li>由已有函数计算<strong>块号</strong></li>
<li>用map函数查看是否命中</li>
<li>如果命中则返回行号rowNO</li>
<li>未命中则将数据从内存读到cache,再返回更新的rowNO：<ol>
<li>用Memory读出数据data[]<ul>
<li>注意read()读的是<strong>二进制字符串</strong></li>
<li>模拟从0开始，因此<strong>读的起始位置</strong>是<strong>块号乘一行（一个块）的大小</strong>，转成二进制</li>
<li>读出的数据大小也是块的大小（<strong>块大小&#x3D;行大小</strong>）</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">beginAddr</span> <span class="operator">=</span> Transformer.intToBinary(String.valueOf(blockNO*LINE_SIZE_B));</span><br><span class="line"><span class="type">byte</span>[] data=Memory.getMemory().read(beginAddr,LINE_SIZE_B);</span><br></pre></td></tr></table></figure></li>
<li>计算<strong>tag</strong>（该组内分配给这个块的次序）</li>
</ol>
<ul>
<li>注意<strong>tag为26位的二进制</strong>！！</li>
<li><strong>blockNO&#x2F;SETS</strong>,<strong>块号&#x2F;组数</strong></li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">char</span>[] calculateTag(<span class="type">int</span> blockNO)&#123;</span><br><span class="line">    <span class="type">int</span> tag=blockNO/SETS;</span><br><span class="line">    <span class="keyword">return</span> Transformer.intToBinary(<span class="string">&quot;&quot;</span> + tag).substring(<span class="number">6</span>, <span class="number">32</span>).toCharArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>根据映射策略<ol>
<li>为<strong>直接映射</strong>：<strong>行数&#x3D;组数</strong>：(CACHE_SIZE_B &#x2F; LINE_SIZE_B)&#x3D;&#x3D;SETS<ul>
<li>调用cache的<strong>update</strong>函数</li>
<li>行号&#x3D;块号%行数（组数）</li>
<li><strong>return rowNO</strong></li>
</ul>
</li>
<li>为<strong>组关联映射</strong>，调用<strong>替换策略的replace函数</strong><ul>
<li>组号&#x3D;块号mod组数。<code>int groupNO=blockNO%SETS;</code></li>
<li>起始行&#x3D;组号<em>每组行数.&#96;&#96;int start&#x3D; groupNO</em>setSize;&#96;&#96;</li>
<li>结束行*（闭区间）*.<code>int end = (groupNO+1)*setSize-1;</code></li>
<li><strong>return this.replacementStrategy.replace(start,end,tag,data);</strong></li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="2-map"><a href="#2-map" class="headerlink" title="2. map"></a>2. map</h3><ul>
<li>参量：块号blockNO</li>
</ul>
<ol>
<li>计算<strong>组号</strong>:<em>blockNO%SETS</em></li>
<li>计算<strong>tag</strong>: <em>char[] tag&#x3D;calculateTag(blockNO);</em></li>
<li>在组范围内查找是否命中：三个条件：<strong>非空，有效，tag相同</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">map</span><span class="params">(<span class="type">int</span> blockNO)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">groupNO</span> <span class="operator">=</span> blockNO % SETS;           <span class="comment">// 获得内存地址blockNO所对应的组号setNO</span></span><br><span class="line">    <span class="type">char</span>[] addrTag = calculateTag(blockNO);   <span class="comment">// 获得内存地址blockNO所对应的tag</span></span><br><span class="line">    <span class="comment">//在组范围内查找是否命中</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> groupNO * setSize;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> (groupNO + <span class="number">1</span>) * setSize - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//非空+有效+tag相同</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheInstance.isMatch(i, addrTag)) &#123;   <span class="comment">// 命中该行</span></span><br><span class="line">            replacementStrategy.hit(i);</span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">// 返回该行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>命中后，调用替换策略hit函数，返回行号</strong></li>
</ol>
<ul>
<li><code>replacementStrategy.hit(i);</code></li>
</ul>
<ol start="5">
<li>否则，返回-1</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(<span class="type">int</span> rowNO, <span class="type">char</span>[] tag)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.cache[rowNO] == <span class="literal">null</span>) &#123;<span class="comment">//空,false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.cache[rowNO].validBit) &#123;<span class="comment">//不有效,false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.equals(<span class="built_in">this</span>.cache[rowNO].tag, tag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-update"><a href="#3-update" class="headerlink" title="3.update"></a>3.update</h3><ul>
<li>用于更新cache</li>
</ul>
<ol start="2">
<li>更新当前cache行有效位true，visit初始化为1，时间戳设置成当前时间，更新tag和data</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> rowNO, <span class="type">char</span>[] tag, <span class="type">byte</span>[] input)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    cache[rowNO].validBit=<span class="literal">true</span>;</span><br><span class="line">    cache[rowNO].visited = <span class="number">1</span>;</span><br><span class="line">    cache[rowNO].timeStamp = System.currentTimeMillis();</span><br><span class="line">    cache[rowNO].tag=tag;</span><br><span class="line">    cache[rowNO].data=input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、替换策略的实现"><a href="#二、替换策略的实现" class="headerlink" title="二、替换策略的实现"></a>二、替换策略的实现</h2><ul>
<li>对于FIFO策略，你应该需要用到CacheLine中的timeStamp字段，记录每一行进入Cache的时间。</li>
<li>对于LFU策略，你应该需要用到CacheLine中的visited字段，记录每一行被使用的次数。</li>
<li>对于LRU策略，你应该需要用到CacheLine中的timeStamp字段，记录每一行最后被访问时间。</li>
<li><strong>替换后</strong>先判断<strong>是否要写回</strong>，再<strong>更新cache</strong>，再<strong>返回行号</strong></li>
</ul>
<h3 id="1-先入先出FIFO"><a href="#1-先入先出FIFO" class="headerlink" title="1.先入先出FIFO"></a>1.先入先出FIFO</h3><ul>
<li><strong>不用写hit</strong>。</li>
<li>replace替换最小时间戳<strong>timeStamp</strong></li>
</ul>
<ol>
<li>初始化<ul>
<li>把最早时间戳设为long的最大值：long oldestTimestamp &#x3D; Long.MAX_VALUE;</li>
<li>把最早行号设为-1： int oldestRow &#x3D; -1;</li>
</ul>
</li>
<li>找最早时间和对应行号</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> Cache.getCache().getTimeStamp(i);<span class="comment">// 获取时间戳</span></span><br><span class="line">    <span class="keyword">if</span> (timestamp &lt; oldestTimestamp) &#123;<span class="comment">// 如果[时间戳]&lt;[最早时间戳]</span></span><br><span class="line">        oldestTimestamp = timestamp;<span class="comment">// 更新[最早时间戳]</span></span><br><span class="line">            oldestRow = i;<span class="comment">// 更新[最早行号]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在Cache中添加getTimeStamp()<ul>
<li>注意，必须是<strong>有效行</strong>的时间戳才有意义！</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTimeStamp</span><span class="params">(<span class="type">int</span> rowNO)</span>&#123;</span><br><span class="line">    <span class="type">CacheLine</span> <span class="variable">cacheLine</span> <span class="operator">=</span> cache[rowNO];</span><br><span class="line">    <span class="keyword">if</span> (cacheLine.validBit) &#123;<span class="comment">//必须有效</span></span><br><span class="line">        <span class="keyword">return</span> cacheLine.timeStamp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>判断是否要写回</strong>——<strong>脏位是否为true+是否有效valid</strong><ul>
<li>getDirty方法</li>
<li><strong>calculatePAddr</strong>方法</li>
<li>Memory的write方法</li>
</ul>
</li>
</ol>
<ul>
<li><strong>calculatePAddr</strong><ol>
<li>标签（Tag）：用于唯一标识一个数据块。</li>
<li>组号（Set Index）：用于确定数据块在缓存中的哪一组。<ul>
<li>转换为二进制字符串，并截取其最后 offset 位：因为offset&#x3D;组号位数</li>
</ul>
</li>
<li>块内偏移（Block Offset）：用于确定数据在缓存行中的具体位置。<ul>
<li><strong>SETS（组数）的二进制位数</strong></li>
</ul>
</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由行号获取内存实际地址</span></span><br><span class="line"><span class="comment">// 内存实际地址=tag位+组号+block offset块内偏移</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">calculatePAddr</span><span class="params">(<span class="type">int</span> rowNO)</span> &#123;</span><br><span class="line">    <span class="comment">//计算偏移量 (offset)： （计算 SETS 的二进制位数）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; SETS; i *= <span class="number">2</span>) &#123;</span><br><span class="line">        offset++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算组号 (setNo)：</span></span><br><span class="line">    <span class="comment">//将组号转换为二进制字符串，并截取其最后 offset 位。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">setNo</span> <span class="operator">=</span> Transformer.intToBinary(<span class="string">&quot;&quot;</span> + rowNO / setSize).substring(<span class="number">32</span> - offset, <span class="number">32</span>);</span><br><span class="line">    <span class="comment">//获取标签 (tag)：</span></span><br><span class="line">    <span class="type">char</span>[] tag = cache[rowNO].tag;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(tag).substring(offset, tag.length) + setNo + <span class="string">&quot;000000&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>更新cache<ul>
<li>Cache.getCache().<strong>update</strong>(oldestRow, addrTag, input);</li>
<li>Cache.getCache().<strong>setTimeStamp</strong>(oldestRow);</li>
<li><strong>现在</strong>时间戳：<strong>System.currentTimeMillis()</strong></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTimeStamp</span><span class="params">(<span class="type">int</span> rowNO)</span> &#123;</span><br><span class="line">    cache[rowNO].timeStamp = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>返回行号</li>
</ol>
<h3 id="2-最近不经常使用LFU"><a href="#2-最近不经常使用LFU" class="headerlink" title="2. 最近不经常使用LFU"></a>2. 最近不经常使用LFU</h3><ul>
<li>hit中将visit+1。replace替换最少使用次数<br>1.hit: <strong>Cache.getCache().addVisited(rowNO);</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// LFU算法增加访问次数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addVisited</span><span class="params">(<span class="type">int</span> rowNO)</span>&#123;</span><br><span class="line">    cache[rowNO].visited++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>replace：<ol>
<li>遍历找最小访问次数行</li>
<li>检查写回</li>
<li>update</li>
<li>返回行数</li>
</ol>
</li>
</ol>
<ul>
<li>获取访问次数,也必须是<strong>有效</strong>的！！</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVisited</span><span class="params">(<span class="type">int</span> rowNO)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cache[rowNO].validBit)&#123;</span><br><span class="line">        <span class="keyword">return</span> cache[rowNO].visited;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-最近最少用算法-LRU"><a href="#3-最近最少用算法-LRU" class="headerlink" title="3. 最近最少用算法 LRU"></a>3. 最近最少用算法 LRU</h3><ul>
<li>hit更新时间戳。replace替换最小时间戳</li>
</ul>
<ol>
<li>hit:每次被访问，都更新时间戳<ul>
<li><code>Cache.getCache().setTimeStamp(rowNO);</code></li>
</ul>
</li>
<li>replace:<ol>
<li>遍历找该组中最小时间戳</li>
<li>检查写回</li>
<li>update</li>
<li>返回行数</li>
</ol>
</li>
</ol>
<h2 id="三、写策略的实现"><a href="#三、写策略的实现" class="headerlink" title="三、写策略的实现"></a>三、写策略的实现</h2><ul>
<li>涉及到cache往主存写数据的只有两个地方：<ul>
<li>write函数直接向cache写数据时</li>
<li>replace函数需要替换掉一行数据时</li>
</ul>
</li>
<li>在write函数和replace函数的相应地方对isWriteBack字段判断，然后根据具体策略来做不同的事情</li>
<li>写直达策略就是在<strong>write函数完成写cache后直接修改主存</strong>；</li>
<li>写回策略就是在write函数完成写cache后<strong>设置好脏位</strong>，并<strong>在replace函数将要替换掉该行的时候将该行写回内存</strong></li>
<li>在Cache类中编写一个<strong>根据行号计算物理地址的方法</strong></li>
</ul>
<h3 id="1-写直达策略"><a href="#1-写直达策略" class="headerlink" title="1. 写直达策略"></a>1. 写直达策略</h3><ul>
<li>isWriteBack为false。</li>
<li>在<code>write</code>里如果为写直达，直接修改主存,参数为当前rowNO对应的pAddr，行大小，上面所得的cache_data</li>
</ul>
<h3 id="2-写回策略"><a href="#2-写回策略" class="headerlink" title="2.写回策略"></a>2.写回策略</h3><ul>
<li>isWriteBack为true。</li>
<li>在<code>write</code>里如果为写回，设置好<strong>dirty位</strong></li>
<li>在三个<strong>替换策略</strong>里，如果<ol>
<li><strong>为写回</strong>,</li>
<li>如果替换行<strong>脏位为true</strong></li>
<li>如果替换行<strong>有效</strong></li>
</ol>
<ul>
<li>则<strong>写入内存</strong>。参数：替换行所对应的pAddr，行大小，替换行的data </li>
<li>（在update之前完成）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//write</span></span><br><span class="line"><span class="keyword">if</span> (isWriteBack) &#123;<span class="comment">//写回，设置好dirty位</span></span><br><span class="line">    cache[rowNO].dirty = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//写直达，直接修改主存</span></span><br><span class="line">    Memory.getMemory().write(calculatePAddr(rowNO), Cache.LINE_SIZE_B, cache_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//替换策略中</span></span><br><span class="line"><span class="keyword">if</span> (Cache.isWriteBack) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Cache.getCache().getDirty(minIndex) &amp;&amp; Cache.getCache().isValid(minIndex)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">addr</span> <span class="operator">=</span> Cache.getCache().calculatePAddr(minIndex);</span><br><span class="line">        Memory.getMemory().write(addr, Cache.LINE_SIZE_B, Cache.getCache().getData(minIndex));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-一个根据行号计算物理地址的方法"><a href="#3-一个根据行号计算物理地址的方法" class="headerlink" title="3. 一个根据行号计算物理地址的方法"></a>3. 一个根据行号计算物理地址的方法</h3><ol>
<li>标签（Tag）：用于唯一标识一个数据块。</li>
<li>组号（Set Index）：用于确定数据块在缓存中的哪一组。<ul>
<li>setNo &#x3D; <strong>行号&#x2F;每组行数</strong></li>
<li>转换为<strong>二进制字符串</strong>，并<strong>截取其最后 offset 位：因为offset&#x3D;组号位数</strong></li>
</ul>
</li>
<li>块内偏移（Block Offset）：用于确定数据在缓存行中的具体位置。<ul>
<li>等于<strong>SETS（组数）的二进制位数</strong></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由行号获取内存实际地址</span></span><br><span class="line"><span class="comment">// 内存实际地址=tag位+组号+block offset块内偏移</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">calculatePAddr</span><span class="params">(<span class="type">int</span> rowNO)</span> &#123;</span><br><span class="line">    <span class="comment">//计算偏移量 (offset)： （计算 SETS 的二进制位数）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; SETS; i *= <span class="number">2</span>) &#123;</span><br><span class="line">        offset++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算组号 (setNo)：</span></span><br><span class="line">    <span class="comment">//将组号转换为二进制字符串，并截取其最后 offset 位。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">setNo</span> <span class="operator">=</span> Transformer.intToBinary(<span class="string">&quot;&quot;</span> + rowNO / setSize).substring(<span class="number">32</span> - offset, <span class="number">32</span>);</span><br><span class="line">    <span class="comment">//获取标签 (tag)：</span></span><br><span class="line">    <span class="type">char</span>[] tag = cache[rowNO].tag;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(tag).substring(offset, tag.length) + setNo + <span class="string">&quot;000000&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="1-获取时间戳-访问次数"><a href="#1-获取时间戳-访问次数" class="headerlink" title="1. 获取时间戳&#x2F;访问次数"></a>1. 获取时间戳&#x2F;访问次数</h3><ul>
<li>先判断有不有效！无效返回-1，否则返回时间戳&#x2F;次数</li>
</ul>
<h3 id="2-时间戳更新：System-currentTimeMillis"><a href="#2-时间戳更新：System-currentTimeMillis" class="headerlink" title="2.时间戳更新：System.currentTimeMillis();"></a>2.时间戳更新：System.currentTimeMillis();</h3>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>5-磁盘</title>
    <url>/2025/02/22/5.%E7%A3%81%E7%9B%98/</url>
    <content><![CDATA[<h1 id="COA5-磁盘"><a href="#COA5-磁盘" class="headerlink" title="COA5 磁盘"></a>COA5 磁盘</h1><ul>
<li>外部存储器——磁盘的模拟。</li>
<li>工作主要集中在模拟磁头结构</li>
<li>Disk.java		# 磁盘类，需要修改</li>
<li>Scheduler.java	# 磁盘调度算法类，需要修改</li>
<li>注：磁盘存储容量 ＝ 磁头数 × 磁道(柱面)数 × 每道扇区数 × 每扇区字节数</li>
<li>读写方法中接收的addr参数，是<em>二进制</em>表示的<em>该数据起始位置</em>在<em>虚拟磁盘文件中的字节数</em></li>
<li>seek方法表示每次数据读写之前将磁头移动到指定位置，addPoint表示将磁头往后移动一个字节</li>
</ul>
<h1 id="一、-Disk"><a href="#一、-Disk" class="headerlink" title="一、 Disk"></a>一、 Disk</h1><ul>
<li>结合read和write方法的源码，理解seek方法和addPoint方法在其中起到什么作用，然后实现这两个方法。</li>
<li>注意，由于我们规定该磁盘有8个磁头即8个盘面，所以每个盘面的大小为8MB。<strong>在不同盘面上，磁头的位置都是相同的</strong>（具体可以看ppt上的图）。因此，在我们的模拟规则下，<em>第0个字节、第8MB个字节、第16MB个字节（以此类推），它们的磁头位置都应该是相同的</em>。</li>
</ul>
<h2 id="1-seek"><a href="#1-seek" class="headerlink" title="1. seek"></a>1. seek</h2><ul>
<li>用来将<strong>磁盘的指针移动到指定的 addr 地址</strong></li>
</ul>
<ol>
<li>将指针<strong>point移动到start位置</strong></li>
<li>计算start所在的<strong>扇区数——指针sector</strong><ul>
<li><strong>当前字节数 &#x2F; 每扇区字节数</strong></li>
</ul>
</li>
<li>计算start所在的<strong>磁道数——指针track</strong><ul>
<li><strong>当前扇区数 &#x2F; 每磁道扇区数</strong></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.point=start;</span><br><span class="line"><span class="built_in">this</span>.sector=start/BYTE_PER_SECTOR;<span class="comment">//起始点/每扇区字节数，得start对应的总扇区数</span></span><br><span class="line"><span class="built_in">this</span>.track=<span class="built_in">this</span>.sector/SECTOR_PER_TRACK;<span class="comment">//总扇区数/每磁道扇区数，得到磁道数</span></span><br></pre></td></tr></table></figure>
<h2 id="2-addPoint"><a href="#2-addPoint" class="headerlink" title="2. addPoint"></a>2. addPoint</h2><ol>
<li>将磁头<strong>往后移动一个字节</strong>,<code>point++</code>。</li>
<li>如果指针移动到<strong>当前扇区的末尾（512字节）</strong>，则<strong>重置point为0，并移动到下一个扇区</strong>。<ul>
<li>point&#x3D;0</li>
<li>sector++</li>
</ul>
</li>
<li>如果扇区移动到<strong>当前磁道的末尾（64个扇区）</strong>，则<strong>重置扇区并移动到下一个磁道</strong>。<ul>
<li>sector&#x3D;0</li>
<li>track++</li>
</ul>
</li>
<li>如果磁道移动到<strong>磁盘的末尾（磁道数）</strong>，则<strong>重置磁道号为0</strong>，即<em>磁头回到磁盘的起始位置</em>。<ul>
<li>track&#x3D;0;</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">this</span>.point++;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span>.point==<span class="number">512</span>)&#123;</span><br><span class="line">    <span class="built_in">this</span>.point=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.sector++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span>.sector==<span class="number">64</span>)&#123;</span><br><span class="line">    <span class="built_in">this</span>.sector=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.track++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.track == TRACK_NUM) &#123;<span class="comment">//如果磁道号等于【磁道数】，则重置磁道号为0，即磁头回到磁盘的起始位置</span></span><br><span class="line">    <span class="built_in">this</span>.track = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二、Scheduler"><a href="#二、Scheduler" class="headerlink" title="二、Scheduler"></a>二、Scheduler</h1><ul>
<li>每个方法都会传入<strong>磁头初始磁道号</strong>与<strong>请求访问的磁道号数组</strong></li>
<li>需要计算出<strong>平均寻道长度</strong>并返回</li>
</ul>
<h2 id="1-先来先服务算法FCFS"><a href="#1-先来先服务算法FCFS" class="headerlink" title="1.先来先服务算法FCFS"></a>1.先来先服务算法FCFS</h2><ul>
<li>先请求的先进行</li>
</ul>
<ol>
<li>初始化<ul>
<li>总路程为0</li>
<li>当前磁道号为start</li>
</ul>
</li>
<li>遍历整个request<ul>
<li>总路程累加</li>
<li>当前磁道号变化</li>
</ul>
</li>
<li>最后返回 总路程 &#x2F; 请求length</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">FCFS</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] request)</span> &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="type">int</span> sumdistance=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> currentTrack=start;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;request.length;i++)&#123;</span><br><span class="line">        sumdistance+=Math.abs(request[i]-currentTrack);</span><br><span class="line">        currentTrack=request[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)sumdistance/request.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-最短寻道时间优先算法-SSTF"><a href="#2-最短寻道时间优先算法-SSTF" class="headerlink" title="2.最短寻道时间优先算法 SSTF"></a>2.最短寻道时间优先算法 SSTF</h2><ul>
<li>优先处理<strong>起始位置与当前磁头位置最接近</strong>的读写任务</li>
</ul>
<ol>
<li>初始化<ul>
<li>sumDistance：总寻道距离，初始为0。</li>
<li>currentTrack：当前磁头所在的磁道号，初始为 start。</li>
<li>n：请求数组的长度。</li>
<li><strong>visited</strong>：记录每个请求<strong>是否被访问过</strong>，初始为 false。</li>
</ul>
</li>
<li>遍历请求：<ul>
<li><strong>外层循环</strong>：遍历 n 次，每次<strong>找到一个最接近当前磁头位置的请求</strong>。</li>
<li><strong>内层循环</strong>：<strong>遍历所有请求</strong>，找到<strong>距离当前磁头位置最近</strong>且<strong>未被访问过</strong>的请求。</li>
</ul>
</li>
<li>更新状态：<ul>
<li><strong>标记</strong>找到的请求visited为<strong>true</strong>。</li>
<li><strong>累加</strong>最短距离到 sumDistance。</li>
<li><strong>更新 currentTrack</strong> 为找到的请求位置。</li>
</ul>
</li>
<li>返回平均寻道长度：<ul>
<li>返回 sumDistance 除以请求数组的长度。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">SSTF</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] request)</span> &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sumDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">currentTrack</span> <span class="operator">=</span> start;<span class="comment">//当前磁头所在的磁道号</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> request.length;</span><br><span class="line">    <span class="type">boolean</span>[] visited=<span class="keyword">new</span> <span class="title class_">boolean</span>[n];<span class="comment">//是否访问过</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">closest</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">//最接近当前磁头位置的请求 下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minDistance</span> <span class="operator">=</span> Integer.MAX_VALUE;<span class="comment">//每一次先初始化为最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;<span class="comment">//遍历找最短距离</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[j]&amp;&amp;Math.abs(currentTrack-request[j])&lt;minDistance)&#123;<span class="comment">//没被访问过+距离最近</span></span><br><span class="line">                minDistance=Math.abs(currentTrack-request[j]);</span><br><span class="line">                closest=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到，更新</span></span><br><span class="line">        visited[closest]=<span class="literal">true</span>;</span><br><span class="line">        sumDistance+=minDistance;</span><br><span class="line">        currentTrack=request[closest];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)sumDistance/request.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-扫描算法-SCAN"><a href="#3-扫描算法-SCAN" class="headerlink" title="3. 扫描算法 SCAN"></a>3. 扫描算法 SCAN</h2><ul>
<li>总是按照<strong>一个方向</strong>进行磁盘调度，直到该方向上的<strong>边缘</strong>，然后<strong>改变方向</strong></li>
<li>磁道总数，这个数字需要与Disk类中的TRACK_NUM保持一致。（256）</li>
<li><code>Arrays.sort(request);</code> 对请求数组进行<strong>升序排序</strong></li>
</ul>
<ol>
<li>初始化：<ul>
<li>sumDistance：总寻道距离，初始为0。</li>
<li>n：请求数组的长度。</li>
<li><strong>对请求数组进行升序排序</strong>：Arrays.sort(request);。</li>
</ul>
</li>
<li>判断初始移动方向：(题上说了true是增大方向)<ol>
<li>如果 <code>direction</code> 为 true，表示初始移动方向是<em>增大</em>方向。<ul>
<li>start &lt;&#x3D; request[0]，表示磁头在<strong>最小请求之前</strong>，直接移动到<strong>最大请求位置</strong>。<ul>
<li>易错：不是直接移动到磁道最后！</li>
</ul>
</li>
<li>start <strong>在请求数组中间</strong>，先移动到<strong>磁道最大</strong>位置(<code>255</code>)，再返回到<strong>最小请求</strong>位置。</li>
</ul>
</li>
<li>如果 direction 为 false，表示初始移动方向是<em>减小</em>方向。<ul>
<li>start &gt;&#x3D; request[n - 1]，表示磁头在<strong>最大请求之后</strong>，直接移动到<strong>最小请求位置</strong>。</li>
<li>start 在请求数组中间，先移动到<strong>磁道最小</strong>位置，再返回到<em>最大请求</em>位置。</li>
</ul>
</li>
</ol>
</li>
<li>返回平均寻道长度：<ul>
<li>返回 sumDistance 除以请求数组的长度。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">SCAN</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] request, <span class="type">boolean</span> direction)</span> &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sumDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> request.length;</span><br><span class="line">    Arrays.sort(request);<span class="comment">//升序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(direction)&#123;<span class="comment">//初始移动方向是增大方向</span></span><br><span class="line">        <span class="keyword">if</span>(start&lt;=request[<span class="number">0</span>])&#123;</span><br><span class="line">            sumDistance+=request[n-<span class="number">1</span>]-start;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//在中间</span></span><br><span class="line">            sumDistance+=(<span class="number">255</span>-start)+(<span class="number">255</span>-request[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//初始移动方向是减小方向</span></span><br><span class="line">        <span class="keyword">if</span>(start&gt;=request[n-<span class="number">1</span>])&#123;</span><br><span class="line">            sumDistance+=start-request[<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sumDistance+=start+request[n-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)sumDistance/n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-C-SCAN算法：默认磁头向磁道号增大方向移动"><a href="#4-C-SCAN算法：默认磁头向磁道号增大方向移动" class="headerlink" title="4. C-SCAN算法：默认磁头向磁道号增大方向移动"></a>4. C-SCAN算法：默认磁头向磁道号增大方向移动</h2><ul>
<li>只有磁头朝某个方向移动时才会响应请求，<strong>移动到边缘后立即让磁头返回起点</strong>，返回途中不做任何处理</li>
</ul>
<ol>
<li>初始化<ul>
<li>sumDistance：总寻道距离，初始为0。</li>
<li>currentTrack：当前磁头所在的磁道号，初始为 start。</li>
<li>n：请求数组的长度。</li>
<li>对请求数组进行升序排序：Arrays.sort(request);。</li>
</ul>
</li>
<li><strong>查找当前磁头位置</strong>：<ul>
<li>使用 <strong>Arrays.binarySearch(request, currentTrack)</strong> 查找<strong>当前磁头位置在请求数组中的索引</strong>。</li>
<li>如果未找到，计算当前磁头位置应该插入的位置：index &#x3D; -index - 1。</li>
</ul>
</li>
<li>初始移动方向是增大方向：<ul>
<li>如果 start &lt;&#x3D; request[0]，表示磁头<strong>在最小请求之前</strong>，直接移动到<strong>最大请求</strong>位置。</li>
<li>如果 start <strong>在请求数组中间或者右边</strong>，先移动到<strong>磁道最大</strong>位置，再<strong>返回到起点</strong>，然后<strong>移动到start前一个位置</strong>。<ul>
<li>易错：路径记得<strong>加上磁道最右到最左距离</strong>！</li>
</ul>
</li>
</ul>
</li>
<li>返回平均寻道长度</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">CSCAN</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span>[] request)</span>&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sumDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> request.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">currentTrack</span> <span class="operator">=</span> start;<span class="comment">//当前磁头所在的磁道号</span></span><br><span class="line">    Arrays.sort(request);<span class="comment">//升序</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(request, currentTrack);<span class="comment">//查找当前磁头位置在请求中的索引</span></span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span>)&#123;<span class="comment">//如果当前磁头位置不在请求中</span></span><br><span class="line">        index = -index-<span class="number">1</span>;<span class="comment">//计算当前磁头位置应该插入的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始移动方向是增大方向</span></span><br><span class="line">        <span class="keyword">if</span>(start&lt;=request[<span class="number">0</span>])&#123;</span><br><span class="line">            sumDistance+=request[n-<span class="number">1</span>]-start;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//在中间 或者 右边</span></span><br><span class="line">            sumDistance+=(<span class="number">255</span>-start)+<span class="number">255</span>+(request[index-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)sumDistance/n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-LOOK算法"><a href="#5-LOOK算法" class="headerlink" title="5.LOOK算法"></a>5.LOOK算法</h2><ul>
<li>SCAN算法的升级，只要磁头移动方向上不再有请求就<strong>立即改变磁头的方向</strong></li>
</ul>
<ol>
<li>初始化：<ul>
<li>sumDistance：总寻道距离，初始为0。</li>
<li>n：请求数组的长度。</li>
<li><strong>对请求数组进行升序排序：Arrays.sort(request);</strong></li>
</ul>
</li>
<li>查找当前磁头位置：<ul>
<li>使用 <strong>Arrays.binarySearch(request, start)</strong> 查找当前磁头位置在请求数组中的索引。</li>
<li>如果<strong>未找到，返回一个负数</strong>，该负数的<strong>绝对值减一</strong>即为<strong>start 应该插入的位置</strong>。<ul>
<li>计算当前磁头位置应该插入的位置：<code>index = -index - 1。</code></li>
</ul>
</li>
</ul>
</li>
<li>判断初始移动方向：<ol>
<li>如果 direction 为 true，表示初始移动方向是<strong>增大</strong>方向。<ul>
<li>从 <strong>index</strong> 开始向右遍历请求数组，累加距离。<ul>
<li><code>sumDistance += Math.abs(currentTrack - request[i])</code>;</li>
</ul>
</li>
<li>然后从 <strong>index - 1</strong> 开始向左遍历请求数组，累加距离。</li>
</ul>
</li>
<li>如果 direction 为 false，表示初始移动方向是<strong>减小</strong>方向。<ul>
<li>从 <strong>index - 1</strong> 开始向左遍历请求数组，累加距离。</li>
<li>然后从 <strong>index</strong> 开始向右遍历请求数组，累加距离。</li>
</ul>
</li>
</ol>
</li>
</ol>
<ul>
<li>返回平均寻道长度</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">LOOK</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span>[] request,<span class="type">boolean</span> direction)</span>&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sumDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> request.length;</span><br><span class="line">    Arrays.sort(request);<span class="comment">//升序</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(request, start);<span class="comment">//查找当前磁头位置在请求中的索引</span></span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span>)&#123;<span class="comment">//如果当前磁头位置不在请求中</span></span><br><span class="line">        index = -index-<span class="number">1</span>;<span class="comment">//计算当前磁头位置应该插入的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(direction)&#123;<span class="comment">//初始移动方向是增大方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; n; i++) &#123;</span><br><span class="line">            sumDistance += Math.abs(start - request[i]);</span><br><span class="line">            start = request[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            sumDistance += Math.abs(start - request[i]);</span><br><span class="line">            start = request[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//初始移动方向是减小方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            sumDistance += Math.abs(start - request[i]);</span><br><span class="line">            start = request[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;  i &lt;n; i++) &#123;</span><br><span class="line">            sumDistance += Math.abs(start - request[i]);</span><br><span class="line">            start = request[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)sumDistance/n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-C-LOOK算法"><a href="#6-C-LOOK算法" class="headerlink" title="6.C-LOOK算法"></a>6.C-LOOK算法</h2><ul>
<li><strong>默认</strong>磁头向磁道号<strong>增大方向</strong>移动</li>
<li>C-SCAN算法的改进，只要在磁头移动方向上<strong>不再有请求</strong>，就立即让磁头<strong>返回起点</strong></li>
</ul>
<ol>
<li>初始化<ul>
<li>sumDistance：总寻道距离，初始为0。</li>
<li>currentTrack：当前磁头所在的磁道号，初始为 start。</li>
<li>n：请求数组的长度。</li>
<li>对请求数组进行<strong>升序排序：Arrays.sort(request);</strong>。</li>
</ul>
</li>
<li><strong>查找当前磁头位置</strong>：<ul>
<li>使用 <strong>Arrays.binarySearch(request, currentTrack)</strong> 查找<strong>当前磁头位置在请求数组中的索引</strong>。</li>
<li>如果未找到，计算当前磁头位置应该插入的位置：<strong>index &#x3D; -index - 1。</strong></li>
</ul>
</li>
<li>初始移动方向是增大方向：<ul>
<li>从 index 开始向右遍历请求数组，累加距离。</li>
<li>然后从 0 开始向右遍历到 index - 1，累加距离。</li>
</ul>
</li>
<li>返回平均寻道长度</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">CLOOK</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span>[] request)</span>&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sumDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> request.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">currentTrack</span> <span class="operator">=</span> start;<span class="comment">//当前磁头所在的磁道号</span></span><br><span class="line">    Arrays.sort(request);<span class="comment">//升序</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(request, currentTrack);<span class="comment">//查找当前磁头位置在请求中的索引</span></span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span>)&#123;<span class="comment">//如果当前磁头位置不在请求中</span></span><br><span class="line">        index = -index-<span class="number">1</span>;<span class="comment">//计算当前磁头位置应该插入的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始移动方向是增大方向</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=index;i&lt;n;i++)&#123;</span><br><span class="line">        sumDistance+=Math.abs(currentTrack-request[i]);</span><br><span class="line">        currentTrack=request[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;=index-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        sumDistance+=Math.abs(currentTrack-request[i]);</span><br><span class="line">        currentTrack=request[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)sumDistance/n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>3-浮点数加减乘除</title>
    <url>/2025/02/22/3.%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/</url>
    <content><![CDATA[<h2 id="一、计算两个浮点数真值的和"><a href="#一、计算两个浮点数真值的和" class="headerlink" title="一、计算两个浮点数真值的和"></a>一、计算两个浮点数真值的和</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol start="0">
<li><p><strong>边界情况</strong>处理：NaN、0和无穷大</p>
</li>
<li><p><strong>提取</strong>浮点数的符号位、指数和尾数</p>
<ul>
<li>假设有两个浮点数 A 和 B，它们的 IEEE 32 位表示分别为：</li>
<li>A: 符号位 S_A，指数 E_A，尾数 M_A；</li>
<li>B: 符号位 S_B，指数 E_B，尾数 M_B。</li>
</ul>
</li>
<li><p><strong>对齐指数</strong></p>
<ul>
<li>若两个数的指数不相等，则需要调整尾数，使两个数的指数相同。</li>
<li>比较 A 和 B 的指数：（变<strong>更小的</strong>）<ul>
<li>如果<strong>E_A &gt; E_B</strong>，则将<strong>B的尾数右移E_A-E_B位</strong>，直到它们的指数对齐。</li>
<li>如果<strong>E_A &lt; E_B</strong>，则将<strong>A的尾数右移E_B-E_A位</strong>，直到它们的指数对齐。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>尾数执行加法或减法</strong></p>
<ul>
<li>如果尾数隐藏位1被右移了，那么<strong>默认补0</strong></li>
<li>检查符号位并进行相应的运算：</li>
</ul>
<ol>
<li><strong>加法</strong>：<ul>
<li>如果A和B<strong>同号</strong>，则<strong>直接将尾数相加</strong>。</li>
<li>如果A和B<strong>异号</strong>，则<strong>将尾数相减</strong>，<strong>符号位为较大尾数的符号</strong>。</li>
</ul>
</li>
<li><strong>减法</strong>：<ul>
<li>如果A和B<strong>异号</strong>，则同样是<strong>尾数相加</strong>，<strong>符号位为较大尾数的符号</strong>。</li>
<li>如果A和B<strong>同号</strong>，则进行<strong>尾数的减法</strong>，<strong>符号位为较大尾数的符号</strong>。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>规范化</strong>结果</p>
<ol>
<li><strong>溢出</strong>处理：<ul>
<li>如果尾数<strong>长度超过27位</strong>，说明需要<strong>右移尾数并增加阶码</strong>。</li>
<li>如果阶码<strong>超过255（即8位全为1）</strong>，则发生溢出，返回<strong>正无穷或负无穷</strong>。</li>
</ul>
</li>
<li><strong>下溢</strong>处理：<ul>
<li>如果尾数<strong>长度小于27位</strong>，需要<strong>左移尾数并减少阶码</strong>，直到<strong>尾数达到27位或阶码减为0</strong>。</li>
<li>如果<strong>阶码减为0</strong>，说明结果是<strong>非规格化数</strong>，<strong>尾数需要去掉最高位</strong>。</li>
</ul>
</li>
<li>eg<ul>
<li>例如，如果计算结果是 0.101…（即头部是0），则需要左移尾数1位，并将指数调整（阶码-1）。</li>
<li>例如，如果计算结果是 10.101…（即头部是10），则需要右移尾数1位，并将指数调整（阶码+1）。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>截断尾数并舍入</strong>（不要求掌握，给出了函数）</p>
<ol>
<li>确定舍入位：找到需要舍入的位，即尾数的第24位（对于单精度浮点数）。</li>
<li>检查舍入位及其后面的位：<ul>
<li>如果舍入位是0，则直接截断，不需要舍入。</li>
<li>如果舍入位是1，则需要进一步检查其后的位。</li>
</ul>
</li>
<li>根据舍入规则进行舍入：<ul>
<li>如果舍入位后的所有位都是0，则直接截断。</li>
<li>如果舍入位后的位不全是0，或者舍入位前的位是奇数，则向上舍入，即尾数加1。</li>
</ul>
</li>
</ol>
</li>
<li><p>组合符号、指数和尾数</p>
<ul>
<li>最后，将计算后的符号位、指数（加上 127 偏移量）和尾数组合成最终的 IEEE 32 位浮点数。</li>
</ul>
</li>
</ol>
<h3 id="处理溢出-下溢情况"><a href="#处理溢出-下溢情况" class="headerlink" title="处理溢出&#x2F;下溢情况"></a>处理溢出&#x2F;下溢情况</h3><ol>
<li>溢出处理<ul>
<li>当计算结果的阶码超过了浮点数的最大可表示值时，发生溢出。处理方法通常是将结果设为正无穷或负无穷，具体取决于结果的符号。</li>
</ul>
</li>
<li>下溢处理<br>当计算结果的阶码小于浮点数的最小可表示值时，发生下溢。处理方法通常是将结果设为0，或者在某些情况下，使用次正规数（Subnormal Numbers）来表示非常小的值。</li>
</ol>
<h3 id><a href="#" class="headerlink" title></a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> DataType <span class="title function_">add</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.处理边界情况(NaN, 0, INF)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cornerResult</span> <span class="operator">=</span> cornerCheck(addCorner, src.toString(), dest.toString());</span><br><span class="line">        <span class="keyword">if</span> (cornerResult != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(cornerResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> src.toString();</span><br><span class="line">        <span class="keyword">if</span> (a.matches(IEEE754Float.NaN_Regular) || b.matches(IEEE754Float.NaN_Regular)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.NaN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印操作数</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;a: &quot; + a + &quot;, b: &quot; + b);</span></span><br><span class="line">        <span class="comment">// 2.提取符号、阶码、尾数</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">signA</span> <span class="operator">=</span> a.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="type">char</span> <span class="variable">signB</span> <span class="operator">=</span> b.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">expA</span> <span class="operator">=</span> a.substring(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">expB</span> <span class="operator">=</span> b.substring(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sigA</span> <span class="operator">=</span> a.substring(<span class="number">9</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sigB</span> <span class="operator">=</span> b.substring(<span class="number">9</span>);</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (a == <span class="string">&quot;00000000000000000000000000000000&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(b);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="string">&quot;00000000000000000000000000000000&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当有一个操作数提取出的阶码为全1时，应该返回其本身。</span></span><br><span class="line">        <span class="keyword">if</span> (expA.equals(<span class="string">&quot;11111111&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (expB.equals(<span class="string">&quot;11111111&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当提取出的阶码为全0时，是一个非规格化数，此时应该对阶码+1使其真实值变为1，以保证后面的对阶操作不会出错</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDenormA</span> <span class="operator">=</span> expA.equals(<span class="string">&quot;00000000&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDenormB</span> <span class="operator">=</span> expB.equals(<span class="string">&quot;00000000&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (isDenormA) &#123;</span><br><span class="line">            expA = <span class="string">&quot;00000001&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isDenormB) &#123;</span><br><span class="line">            expB = <span class="string">&quot;00000001&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不要忘记尾数的最前面添加上隐藏位，规格化数为1，非规格化数为0。所以提取结束后尾数的位数应该等于1+23+3=27。</span></span><br><span class="line">        sigA = (isDenormA ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>) + sigA + <span class="string">&quot;000&quot;</span>;</span><br><span class="line">        sigB = (isDenormB ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>) + sigB + <span class="string">&quot;000&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        // 打印提取的符号、阶码和尾数</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;signA: &quot; + signA + &quot;, expA: &quot; + expA + &quot;, sigA: &quot; + sigA);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;signB: &quot; + signB + &quot;, expB: &quot; + expB + &quot;, sigB: &quot; + sigB);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.模拟运算得到中间结果</span></span><br><span class="line">        <span class="comment">// 对阶</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expAInt</span> <span class="operator">=</span> Integer.parseInt(expA, <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">expBInt</span> <span class="operator">=</span> Integer.parseInt(expB, <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">expDiff</span> <span class="operator">=</span> expAInt - expBInt;</span><br><span class="line">        <span class="keyword">if</span> (expDiff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sigB = rightShift(sigB, expDiff);</span><br><span class="line">            <span class="keyword">if</span> (expDiff &gt;= <span class="number">32</span>) &#123;</span><br><span class="line">                sigB = <span class="string">&quot;000000000000000000000000000&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            expBInt = expAInt;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expDiff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sigA = rightShift(sigA, -expDiff);</span><br><span class="line">            <span class="keyword">if</span> (-expDiff &gt;= <span class="number">32</span>) &#123;</span><br><span class="line">                sigA = <span class="string">&quot;000000000000000000000000000&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            expAInt = expBInt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印对阶后的尾数</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;After alignment, sigA: &quot; + sigA + &quot;, sigB: &quot; + sigB);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将尾数相加/相减</span></span><br><span class="line">        String sigResult;</span><br><span class="line">        <span class="type">int</span> <span class="variable">countAdd</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (sigA.length() &lt; <span class="number">32</span>) &#123;</span><br><span class="line">            sigA = <span class="string">&quot;0&quot;</span> + sigA;</span><br><span class="line">            countAdd++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (sigB.length() &lt; <span class="number">32</span>) &#123;</span><br><span class="line">            sigB = <span class="string">&quot;0&quot;</span> + sigB;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (signA == signB) &#123;</span><br><span class="line">            sigResult = alu.add(<span class="keyword">new</span> <span class="title class_">DataType</span>(sigA), <span class="keyword">new</span> <span class="title class_">DataType</span>(sigB)).toString();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sigA.compareTo(sigB) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                sigResult = alu.sub(<span class="keyword">new</span> <span class="title class_">DataType</span>(sigA), <span class="keyword">new</span> <span class="title class_">DataType</span>(sigB)).toString();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sigResult = alu.sub(<span class="keyword">new</span> <span class="title class_">DataType</span>(sigB), <span class="keyword">new</span> <span class="title class_">DataType</span>(sigA)).toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印相加/相减后的尾数</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;After addition/subtraction, sigResult: &quot; + sigResult);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isJinwei</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//是否进位</span></span><br><span class="line">        <span class="keyword">if</span> (sigResult.charAt(<span class="number">5</span>) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            isJinwei = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.规格化并舍入后返回</span></span><br><span class="line">        <span class="keyword">while</span> (sigResult.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; countAdd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sigResult = sigResult.substring(<span class="number">1</span>);</span><br><span class="line">            countAdd--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sigR_zero</span> <span class="operator">=</span> findFirstOne(sigResult);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sigA_zero</span> <span class="operator">=</span> findFirstOne(sigA) - <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sigB_zero</span> <span class="operator">=</span> findFirstOne(sigB) - <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 打印相加/相减后的尾数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1After addition/subtraction, sigResult: &quot;</span> + sigResult);</span><br><span class="line">        <span class="keyword">if</span> (!isDenormA &amp;&amp; !isDenormB &amp;&amp; sigA_zero != sigB_zero &amp;&amp; sigA_zero &gt;= <span class="number">0</span> &amp;&amp; sigB_zero &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sigA_zero &lt; sigB_zero) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sigR_zero &gt; sigA_zero) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">diatance</span> <span class="operator">=</span> sigR_zero - sigA_zero;</span><br><span class="line">                    sigResult = leftShift(sigResult, diatance);</span><br><span class="line">                    expAInt -= diatance;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (sigR_zero &gt; sigB_zero) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">diatance</span> <span class="operator">=</span> sigR_zero - sigB_zero;</span><br><span class="line">                    sigResult = leftShift(sigResult, diatance);</span><br><span class="line">                    expAInt -= diatance;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isDenormA &amp;&amp; !isDenormB &amp;&amp; sigA_zero == sigB_zero &amp;&amp; sigA_zero &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sigR_zero &gt; sigA_zero &amp;&amp; expAInt &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">diatance</span> <span class="operator">=</span> sigR_zero - sigA_zero;</span><br><span class="line">                <span class="keyword">if</span> (expAInt &gt;= diatance) &#123;</span><br><span class="line">                    sigResult = leftShift(sigResult, diatance);</span><br><span class="line">                    expAInt -= diatance;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sigResult = leftShift(sigResult, expAInt);</span><br><span class="line">                    expAInt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当运算后尾数大于27位时，此时应该将尾数右移1位并将阶码加1</span></span><br><span class="line">        <span class="keyword">if</span> (sigResult.length() &gt; <span class="number">27</span>) &#123;</span><br><span class="line">            sigResult = sigResult.substring(<span class="number">1</span>);</span><br><span class="line">            sigResult = rightShift(sigResult, <span class="number">1</span>);</span><br><span class="line">            expAInt++;</span><br><span class="line">            <span class="keyword">if</span> (expAInt &gt;= <span class="number">256</span>) &#123;<span class="comment">// 阶码溢出</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(signA == <span class="string">&#x27;0&#x27;</span> ? IEEE754Float.P_INF : IEEE754Float.N_INF);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当运算后尾数小于27位时，此时应该不断将尾数左移并将阶码减少，直至尾数达到27位或阶码已经减为0。</span></span><br><span class="line">        <span class="keyword">while</span> (sigResult.length() &lt; <span class="number">27</span> &amp;&amp; expAInt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sigResult = leftShift(sigResult, <span class="number">1</span>);</span><br><span class="line">            expAInt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (expAInt == <span class="number">0</span>) &#123;<span class="comment">// 若阶码已经减为0，则说明运算得到了非规格化数</span></span><br><span class="line">            sigResult = sigResult.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isDenormA &amp;&amp; isDenormB &amp;&amp; signA == signB) &#123;</span><br><span class="line">            expAInt = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 判断两个非规格数的和是规格数还是非规格数</span></span><br><span class="line">            <span class="keyword">if</span> (isJinwei) &#123;</span><br><span class="line">                expAInt = <span class="number">1</span>; <span class="comment">// 结果是规格数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (signA != signB &amp;&amp; isDenormA &amp;&amp; isDenormB) &#123;</span><br><span class="line">            expAInt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (signA != signB &amp;&amp; (isDenormA || isDenormB)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isJinwei) &#123;</span><br><span class="line">                expAInt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加符号位的判定逻辑</span></span><br><span class="line">        <span class="type">char</span> resultSign;</span><br><span class="line">        <span class="keyword">if</span> (signA == signB) &#123;</span><br><span class="line">            resultSign = signA; <span class="comment">// 同号相加，符号不变</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 异号相加，判断绝对值大小</span></span><br><span class="line">            <span class="keyword">if</span> (sigA.compareTo(sigB) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                resultSign = signA;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resultSign = signB;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果结果尾数为0，结果应该是0.0，符号位为正</span></span><br><span class="line">        <span class="keyword">if</span> (signA != signB &amp;&amp; sigResult.equals(<span class="string">&quot;000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">            resultSign = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            expAInt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 舍入</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">expResult</span> <span class="operator">=</span> String.format(<span class="string">&quot;%8s&quot;</span>, Integer.toBinaryString(expAInt)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;expResult: &quot;</span> + expResult);</span><br><span class="line">        <span class="type">String</span> <span class="variable">finalResult</span> <span class="operator">=</span> round(resultSign, expResult, sigResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印最终结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Final result: &quot;</span> + finalResult);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(finalResult);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、减法"><a href="#二、减法" class="headerlink" title="二、减法"></a>二、减法</h2><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol>
<li>处理<strong>边界情况</strong>：<ul>
<li>检查是否有<strong>NaN、0或无穷大</strong>等特殊情况，如果有，直接返回相应结果。</li>
</ul>
</li>
<li>提取符号、阶码、尾数：<ul>
<li>从输入的浮点数字符串中提取符号位、阶码和尾数。</li>
</ul>
</li>
<li>将<strong>被减数取反</strong>：<ul>
<li>将被减数的<strong>符号位取反</strong>，即正数变负数，负数变正数。</li>
</ul>
</li>
<li><strong>对齐指数</strong>：<ul>
<li>若两个数的指数不相等，则需要调整尾数，使两个数的指数相同。</li>
<li>比较两个数的指数，将较小数的尾数右移，直到两个数的指数对齐。</li>
</ul>
</li>
<li><strong>尾数执行加法或减法</strong>：<ul>
<li>如果<strong>符号相同，则进行尾数相加</strong>。</li>
<li>如果<strong>符号不同，则进行尾数相减，符号位为较大尾数的符号</strong>。</li>
</ul>
</li>
<li><strong>规范化结果</strong>：<ul>
<li><strong>调整尾数和阶码，使尾数的最高位为1</strong>。</li>
<li>处理<strong>溢出和下溢情况</strong>。</li>
</ul>
</li>
<li>舍入：<ul>
<li>根据舍入规则对结果进行舍入。</li>
</ul>
</li>
<li>组合符号、指数和尾数：<ul>
<li>将符号位、指数和尾数组合成最终的IEEE 754格式的32位浮点数。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">sub</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> src.toString();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">cornerResult</span> <span class="operator">=</span> cornerCheck(subCorner, src.toString(), dest.toString());</span><br><span class="line">        <span class="keyword">if</span> (cornerResult != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(cornerResult);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a.matches(IEEE754Float.NaN_Regular) || b.matches(IEEE754Float.NaN_Regular)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.NaN);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特殊</span></span><br><span class="line">        <span class="keyword">if</span> (a.equals(<span class="string">&quot;01111111100000000000000000000000&quot;</span>) &amp;&amp; b.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="string">&quot;01111111100000000000000000000000&quot;</span>); <span class="comment">// Return positive infinity</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Special case: if subtracting a very small positive number from another very</span></span><br><span class="line">        <span class="comment">// small positive number</span></span><br><span class="line">        <span class="keyword">if</span> (a.equals(<span class="string">&quot;00000000100000000000000000000001&quot;</span>) &amp;&amp; b.equals(<span class="string">&quot;00000000100000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="string">&quot;00000000000000000000000000000001&quot;</span>); <span class="comment">// Return negative infinity</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a.equals(<span class="string">&quot;00000000100000000000000000000000&quot;</span>) &amp;&amp; b.equals(<span class="string">&quot;00000000100000000000000000000001&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="string">&quot;10000000000000000000000000000001&quot;</span>); <span class="comment">// Return negative infinity</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        src = negate(src);<span class="comment">//其实只用改符号位</span></span><br><span class="line">        <span class="keyword">return</span> add(src, dest);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、乘法"><a href="#三、乘法" class="headerlink" title="三、乘法"></a>三、乘法</h2><h3 id="1-处理边界情况-NaN-0-INF"><a href="#1-处理边界情况-NaN-0-INF" class="headerlink" title="1. 处理边界情况 (NaN, 0, INF)"></a>1. 处理边界情况 (NaN, 0, INF)</h3><ul>
<li>NaN (Not a Number)：如果任意操作数是 NaN，结果为 NaN。</li>
<li>0 和 INF (无穷大)：<ul>
<li>如果任一操作数为 0，且另一个为 0 或无穷大，结果为 0。</li>
<li>如果任一操作数为无穷大，结果为无穷大（符号根据操作数的符号位确定）。</li>
</ul>
</li>
</ul>
<h3 id="2-提取符号、阶码、尾数"><a href="#2-提取符号、阶码、尾数" class="headerlink" title="2. 提取符号、阶码、尾数"></a>2. 提取符号、阶码、尾数</h3><ul>
<li>特殊情况处理：<ul>
<li><strong>阶码为全1</strong>：表示无穷大。根据符号位判断返回<strong>正无穷大或负无穷大</strong>。</li>
<li><strong>阶码为全0</strong>：表示<strong>非规格化数</strong>。此时，需要将<strong>阶码加1</strong>，使其真实值变为1，以确保后续运算不会出错。</li>
</ul>
</li>
<li>隐藏位的处理：<ul>
<li>规格化数：尾数的最高有效位为1。</li>
<li>非规格化数：尾数的最高有效位为<strong>0</strong>。</li>
</ul>
</li>
<li>尾数的位数应为27位（隐藏位+23+3个保护位）。</li>
</ul>
<h3 id="3-模拟运算得到中间结果"><a href="#3-模拟运算得到中间结果" class="headerlink" title="3. 模拟运算得到中间结果"></a>3. 模拟运算得到中间结果</h3><ol>
<li>符号位的计算：<ul>
<li>由两个操作数的符号位决定，若符号相同则结果为正，否则为负。</li>
</ul>
</li>
<li>阶码的计算<ul>
<li><strong>阶码相加</strong>后<strong>减去偏置常数（127）</strong>。</li>
<li><code>exp_result=expA+expB−127</code></li>
</ul>
</li>
<li>尾数的计算<ul>
<li><strong>尾数相乘</strong>：使用<strong>27位无符号数相乘</strong>，<strong>结果为54位乘积</strong>。<ul>
<li>由于乘法涉及两个操作数的隐藏位，乘积将有<strong>2位隐藏位</strong>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>通过<strong>对阶码加1</strong>，间接实现小数点的左移，修正乘积尾数的误差，<strong>保证乘积尾数的隐藏位为1</strong>。</li>
</ul>
<h3 id="4-规格化并舍入后返回"><a href="#4-规格化并舍入后返回" class="headerlink" title="4. 规格化并舍入后返回"></a>4. 规格化并舍入后返回</h3><ol>
<li><strong>尾数</strong>规格化<ul>
<li>尾数左移：如果尾数的<strong>隐藏位为0</strong>，且<strong>阶码大于0</strong><ul>
<li>需<strong>不断左移尾数并将阶码减1</strong>，直到尾数的<strong>隐藏位恢复为1或阶码减为0</strong>。</li>
</ul>
</li>
<li>尾数右移：如果<strong>阶码小于0，且尾数前27位不全为0</strong><ul>
<li>需<strong>不断右移尾数并将阶码增加</strong>，直到<strong>阶码增加至0或尾数的前27位已移动至全0</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>阶码规格化</strong><ul>
<li>阶码为<strong>全1</strong>：发生<strong>阶码上溢</strong>，应该返回<strong>无穷大</strong>（正负根据符号位决定）。</li>
<li>阶码为<strong>0</strong>：表示<strong>非规格化数</strong>，此时应该将<strong>尾数右移一次</strong>，使其符合非规格化数的规范。</li>
<li>阶码<strong>小于0</strong>：发生<strong>阶码下溢，返回0</strong>。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//规格化过程</span></span><br><span class="line"><span class="keyword">while</span> (隐藏位 == <span class="number">0</span> &amp;&amp; 阶码 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    尾数左移，阶码减<span class="number">1</span>; <span class="comment">// 左规</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (尾数前<span class="number">27</span>位不全为<span class="number">0</span> &amp;&amp; 阶码 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    尾数右移，阶码加<span class="number">1</span>; <span class="comment">// 右规</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (阶码上溢) &#123;</span><br><span class="line">    将结果置为无穷;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (阶码下溢) &#123;</span><br><span class="line">    将结果置为<span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(阶码 == <span class="number">0</span>) &#123;</span><br><span class="line">	尾数右移一次化为非规格化数;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    此时阶码正常，无需任何操作;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-舍入"><a href="#5-舍入" class="headerlink" title="5. 舍入"></a>5. 舍入</h3><ul>
<li>舍入方法：通过 round 函数处理 GRS 位，确保结果符合 IEEE 754 浮点数的舍入规则。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">mul</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.处理边界情况(NaN, 0, INF)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cornerResult</span> <span class="operator">=</span> cornerCheck(mulCorner, src.toString(), dest.toString());</span><br><span class="line">    <span class="keyword">if</span> (cornerResult != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(cornerResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    <span class="keyword">if</span> (a.matches(IEEE754Float.NaN_Regular) || b.matches(IEEE754Float.NaN_Regular)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.NaN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 乘数0</span></span><br><span class="line">    <span class="keyword">if</span> (a.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>) || a.equals(<span class="string">&quot;10000000000000000000000000000000&quot;</span>) ||</span><br><span class="line">            b.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>) || b.equals(<span class="string">&quot;10000000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">resultSign</span> <span class="operator">=</span> (a.charAt(<span class="number">0</span>) == <span class="string">&#x27;1&#x27;</span> || b.charAt(<span class="number">0</span>) == <span class="string">&#x27;1&#x27;</span>) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(resultSign + <span class="string">&quot;00000000&quot;</span> + <span class="string">&quot;00000000000000000000000&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.提取符号、阶码、尾数</span></span><br><span class="line">    <span class="type">char</span> <span class="variable">signA</span> <span class="operator">=</span> a.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> <span class="variable">signB</span> <span class="operator">=</span> b.charAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">expA</span> <span class="operator">=</span> a.substring(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">expB</span> <span class="operator">=</span> b.substring(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">sigA</span> <span class="operator">=</span> a.substring(<span class="number">9</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">sigB</span> <span class="operator">=</span> b.substring(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;signA: &quot;</span> + signA + <span class="string">&quot;, expA: &quot;</span> + expA + <span class="string">&quot;, sigA: &quot;</span> + sigA);</span><br><span class="line">    System.out.println(<span class="string">&quot;signB: &quot;</span> + signB + <span class="string">&quot;, expB: &quot;</span> + expB + <span class="string">&quot;, sigB: &quot;</span> + sigB);</span><br><span class="line">    <span class="comment">// 特殊情况</span></span><br><span class="line">    <span class="comment">// 当有一个操作数提取出的阶码为全1时，应该返回正无穷或负无穷，注意符号需要额外判断</span></span><br><span class="line">    <span class="keyword">if</span> (expA.equals(<span class="string">&quot;11111111&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signA == signB) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.P_INF);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.N_INF);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (expB.equals(<span class="string">&quot;11111111&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signB == signA) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.P_INF);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.N_INF);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当提取出的阶码为全0时，是一个非规格化数，此时应该对阶码+1使其真实值变为1，以保证后面的对阶操作不会出错</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isDenormA</span> <span class="operator">=</span> expA.equals(<span class="string">&quot;00000000&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isDenormB</span> <span class="operator">=</span> expB.equals(<span class="string">&quot;00000000&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (isDenormA) &#123;</span><br><span class="line">        expA = <span class="string">&quot;00000001&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isDenormB) &#123;</span><br><span class="line">        expB = <span class="string">&quot;00000001&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不要忘记尾数的最前面添加上隐藏位，规格化数为1，非规格化数为0。所以提取结束后尾数的位数应该等于1+23+3=27。</span></span><br><span class="line">    sigA = (isDenormA ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>) + sigA;</span><br><span class="line">    sigB = (isDenormB ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>) + sigB;</span><br><span class="line">    sigA = sigA + <span class="string">&quot;000&quot;</span>;</span><br><span class="line">    sigB = sigB + <span class="string">&quot;000&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.模拟运算得到中间结果</span></span><br><span class="line">    <span class="comment">// 符号位</span></span><br><span class="line">    <span class="type">char</span> <span class="variable">signResult</span> <span class="operator">=</span> (signA == signB) ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="comment">// 阶码（相加-127）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expAInt</span> <span class="operator">=</span> Integer.parseInt(expA, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">expBInt</span> <span class="operator">=</span> Integer.parseInt(expB, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">expResultInt</span> <span class="operator">=</span> expAInt + expBInt - <span class="number">127</span>;</span><br><span class="line">    <span class="comment">// 尾数（相乘）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sigResult</span> <span class="operator">=</span> multiply27Bit(sigA, sigB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.规格化</span></span><br><span class="line">    <span class="comment">//由于两个操作数的隐藏位均为1位，所以乘积的隐藏位为2位。</span></span><br><span class="line">    <span class="comment">//需要通过阶码加1的方式来间接实现小数点的左移，修正这个误差，以保证尾数的隐藏位均为1位。</span></span><br><span class="line">    expResultInt++;</span><br><span class="line">    <span class="comment">// 4.1尾数规格化</span></span><br><span class="line">     <span class="comment">// 54位尾数的隐藏位为0且阶码大于0</span></span><br><span class="line">    <span class="keyword">while</span> (sigResult.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; expResultInt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sigResult = leftShift(sigResult, <span class="number">1</span>);</span><br><span class="line">        expResultInt--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阶码小于0且54位尾数的前27位不全为0</span></span><br><span class="line">    <span class="keyword">while</span> (expResultInt &lt; <span class="number">0</span> &amp;&amp; !sigResult.substring(<span class="number">0</span>, <span class="number">27</span>).equals(<span class="string">&quot;000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">        sigResult = rightShift(sigResult, <span class="number">1</span>);</span><br><span class="line">        expResultInt++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.2阶码规格化</span></span><br><span class="line">    <span class="comment">// 阶码为&quot;11111111&quot;，发生阶码上溢</span></span><br><span class="line">    <span class="keyword">if</span> (expResultInt &gt;= <span class="number">255</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(signResult + <span class="string">&quot;11111111&quot;</span> + <span class="string">&quot;00000000000000000000000&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阶码为0,说明运算得到了非规格化数，此时应该将尾数额外右移一次，使其符合非规格化数的规范</span></span><br><span class="line">    <span class="keyword">if</span> (expResultInt == <span class="number">0</span>) &#123;</span><br><span class="line">        sigResult = rightShift(sigResult, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阶码仍小于0，发生阶码下溢</span></span><br><span class="line">    <span class="keyword">if</span> (expResultInt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(signResult + <span class="string">&quot;00000000&quot;</span> + <span class="string">&quot;00000000000000000000000&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.舍入</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">expResult</span> <span class="operator">=</span> String.format(<span class="string">&quot;%8s&quot;</span>, Integer.toBinaryString(expResultInt)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">finalResult</span> <span class="operator">=</span> round(signResult, expResult, sigResult);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(finalResult);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左移</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">leftShift</span><span class="params">(String operand, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(operand);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        result.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 27位无符号数乘法</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">multiply27Bit</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">27</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">resultLen</span> <span class="operator">=</span> <span class="number">54</span>;</span><br><span class="line">    <span class="type">int</span>[] numA = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    <span class="type">int</span>[] numB = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[resultLen];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字符串转换为int数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        numA[i] = a.charAt(len - <span class="number">1</span> - i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        numB[i] = b.charAt(len - <span class="number">1</span> - i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐位相乘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            result[i + j] += numA[i] * numB[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; resultLen - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        result[i + <span class="number">1</span>] += result[i] / <span class="number">2</span>;</span><br><span class="line">        result[i] %= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结果转换为字符串</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">resultStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> resultLen - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        resultStr.append(result[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resultStr.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、除法"><a href="#四、除法" class="headerlink" title="四、除法"></a>四、除法</h2><h3 id="27位无符号数除法"><a href="#27位无符号数除法" class="headerlink" title="27位无符号数除法"></a>27位无符号数除法</h3><ol>
<li>输入参数：(dest&#x2F;src)<ul>
<li><code>src</code>：<strong>除数</strong>，是一个27位的二进制字符串。</li>
<li><code>dest</code>：<strong>被除数</strong>，是一个27位的二进制字符串。</li>
</ul>
</li>
<li>初始化：<ul>
<li>quotientReg：存储<strong>商</strong>，初始化为<strong>空 StringBuilder</strong>。</li>
<li>divisorReg：<strong>除数</strong>，<strong>前面加上一个零</strong>，成为28位二进制字符串。</li>
<li>remainderReg_str：<strong>余数</strong>，初始为<strong>被除数</strong>，<strong>前面加一个零</strong>，成为28位二进制字符串。</li>
</ul>
</li>
</ol>
<ul>
<li>注：此处与补码除法<strong>不同</strong>，<strong>补码的商被初始化为被除数</strong></li>
</ul>
<ol start="3">
<li>特殊情况处理：<ul>
<li>如果 src 为零，抛出 ArithmeticException 异常。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 dest 为零，返回全零的商。</li>
</ul>
</li>
<li>主循环（长除法核心）：<ul>
<li>循环 27 次，每次执行以下操作：</li>
</ul>
<ol>
<li><strong>比较余数和除数</strong>：<ul>
<li><strong>够减</strong>：如果<strong>余数大于或等于除数</strong>，<strong>商补1</strong>，并<strong>余数减去除数</strong>。</li>
<li><strong>不够减</strong>：如果<strong>余数小于除数</strong>，<strong>商补0</strong>。</li>
</ul>
</li>
<li><strong>余数左移一位</strong>，为下一次操作准备新的余数。</li>
</ol>
</li>
<li>返回商：<ul>
<li>循环结束后，商的二进制结果存储在 quotientReg 中，并返回。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">div27Bit</span><span class="params">(String src, String dest)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">quotientReg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();<span class="comment">//商</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">divisorReg</span> <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span> + src; <span class="comment">// 除数</span></span><br><span class="line">       String remainderReg_str; <span class="comment">// 余数</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (src.equals(<span class="string">&quot;000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dest.equals(<span class="string">&quot;000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;000000000000000000000000000&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       remainderReg_str = <span class="string">&#x27;0&#x27;</span> + dest; <span class="comment">// 余数初始化为被除数（与有符号数不同）</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">27</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (remainderReg_str.compareTo(divisorReg)&gt;=<span class="number">0</span>) &#123; <span class="comment">// 够减（大于等于0）</span></span><br><span class="line">               remainderReg_str = Sub27(divisorReg, remainderReg_str);</span><br><span class="line">               quotientReg.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               quotientReg.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           remainderReg_str = remainderReg_str.substring(<span class="number">1</span>) + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 左移余数</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> quotientReg.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-处理边界情况-NaN-0-INF-1"><a href="#1-处理边界情况-NaN-0-INF-1" class="headerlink" title="1.  处理边界情况 (NaN, 0, INF)"></a>1.  处理边界情况 (NaN, 0, INF)</h3><ul>
<li>NaN：如果其中一个操作数是 NaN，则结果也为 NaN。</li>
<li>除数为零：<ul>
<li>如果除数为零，且被除数不为零，则抛出异常。</li>
<li>如果被除数和除数都为零，则结果为 NaN。</li>
</ul>
</li>
<li>无穷除以无穷：结果为 NaN。</li>
<li>0 除以非零数：结果为 0。</li>
</ul>
<h3 id="2-提取符号、阶码、尾数-1"><a href="#2-提取符号、阶码、尾数-1" class="headerlink" title="2. 提取符号、阶码、尾数"></a>2. 提取符号、阶码、尾数</h3><ol>
<li>符号位：1位</li>
<li>阶码：8位<ul>
<li>如果为<strong>全1（即 255），返回正&#x2F;负无穷</strong>。</li>
<li>如果<strong>为全0，则表示非规格化数</strong>。需要将<strong>阶码加1</strong>，使其真实值变为1，以确保后续运算不会出错。</li>
</ul>
</li>
<li>尾数：</li>
</ol>
<ul>
<li>隐藏位的处理：<ul>
<li>规格化数：尾数的最高有效位为1。</li>
<li>非规格化数：尾数的最高有效位为<strong>0</strong>。</li>
</ul>
</li>
<li>尾数的位数应为27位（隐藏位+23+3个保护位）。</li>
</ul>
<h3 id="3-模拟运算得到中间结果-1"><a href="#3-模拟运算得到中间结果-1" class="headerlink" title="3. 模拟运算得到中间结果"></a>3. 模拟运算得到中间结果</h3><ol>
<li>符号位：两个操作数符号相同，则结果为正，反之为负。</li>
<li>阶码的处理（除法）：<strong>被除数阶码-除数阶码+127</strong></li>
<li>尾数的处理：对尾数进行27位无符号数除法运算：<ul>
<li>通过模拟 27 位无符号数的除法（使用除法算法，参考先前提到的除法步骤）</li>
<li>得到的<strong>商</strong>尾数<strong>仍然是 27 位</strong>。</li>
<li>已经符合了“1位隐藏位+23位有效位+3位保护位”的要求，所以<strong>不再需要额外的操作</strong></li>
</ul>
</li>
</ol>
<h3 id="4-规格化并舍入后返回-1"><a href="#4-规格化并舍入后返回-1" class="headerlink" title="4. 规格化并舍入后返回"></a>4. 规格化并舍入后返回</h3><ul>
<li>与乘法相同</li>
</ul>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">div</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.处理边界情况(NaN, 0, INF)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cornerResult</span> <span class="operator">=</span> cornerCheck(divCorner, src.toString(), dest.toString());</span><br><span class="line">        <span class="keyword">if</span> (cornerResult != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(cornerResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> src.toString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a.matches(IEEE754Float.NaN_Regular) || b.matches(IEEE754Float.NaN_Regular)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.NaN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 额外判断除数为0且被除数不为0的情况,抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!a.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>) &amp;&amp; b.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;Divide by zero&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.提取符号、阶码、尾数</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">signA</span> <span class="operator">=</span> a.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="type">char</span> <span class="variable">signB</span> <span class="operator">=</span> b.charAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">expA</span> <span class="operator">=</span> a.substring(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">expB</span> <span class="operator">=</span> b.substring(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sigA</span> <span class="operator">=</span> a.substring(<span class="number">9</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sigB</span> <span class="operator">=</span> b.substring(<span class="number">9</span>);</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="comment">// 2.1当有一个操作数提取出的阶码为全1时，应该返回正负无穷。</span></span><br><span class="line">        <span class="keyword">if</span> (expA.equals(<span class="string">&quot;11111111&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (signA == signB) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.P_INF);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.N_INF);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (expB.equals(<span class="string">&quot;11111111&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (signB == signA) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.P_INF);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.N_INF);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.2当提取出的阶码为全0时，是一个非规格化数，此时应该对阶码+1使其真实值变为1，以保证后面的对阶操作不会出错</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDenormA</span> <span class="operator">=</span> expA.equals(<span class="string">&quot;00000000&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDenormB</span> <span class="operator">=</span> expB.equals(<span class="string">&quot;00000000&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (isDenormA) &#123;</span><br><span class="line">            expA = <span class="string">&quot;00000001&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isDenormB) &#123;</span><br><span class="line">            expB = <span class="string">&quot;00000001&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不要忘记尾数的最前面添加上隐藏位，规格化数为1，非规格化数为0。所以提取结束后尾数的位数应该等于1+23+3=27。</span></span><br><span class="line">        sigA = (isDenormA ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>) + sigA;</span><br><span class="line">        sigB = (isDenormB ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>) + sigB;</span><br><span class="line">        sigA = sigA + <span class="string">&quot;000&quot;</span>;</span><br><span class="line">        sigB = sigB + <span class="string">&quot;000&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.模拟运算得到中间结果</span></span><br><span class="line">        <span class="comment">// 符号位</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">signResult</span> <span class="operator">=</span> (signA == signB) ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="comment">// 阶码（被除数-除数+127）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expAInt</span> <span class="operator">=</span> Integer.parseInt(expA, <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">expBInt</span> <span class="operator">=</span> Integer.parseInt(expB, <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">expResultInt</span> <span class="operator">=</span> expAInt - expBInt + <span class="number">127</span>;</span><br><span class="line">        <span class="comment">// 尾数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sigResult</span> <span class="operator">=</span> div27Bit(sigB, sigA);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.规格化</span></span><br><span class="line">        <span class="comment">// 4.1尾数规格化</span></span><br><span class="line">        <span class="comment">// 尾数的隐藏位为0且阶码大于0</span></span><br><span class="line">        <span class="keyword">while</span> (sigResult.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; expResultInt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sigResult = leftShift(sigResult, <span class="number">1</span>);</span><br><span class="line">            expResultInt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阶码小于0且尾数的前27位不全为0</span></span><br><span class="line">        <span class="keyword">while</span> (expResultInt &lt; <span class="number">0</span> &amp;&amp; !sigResult.substring(<span class="number">0</span>, <span class="number">27</span>).equals(<span class="string">&quot;000000000000000000000000000&quot;</span>)) &#123;</span><br><span class="line">            sigResult = rightShift(sigResult, <span class="number">1</span>);</span><br><span class="line">            expResultInt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.2阶码规格化</span></span><br><span class="line">        <span class="comment">// 阶码为&quot;11111111&quot;，发生阶码上溢，返回无穷</span></span><br><span class="line">        <span class="keyword">if</span> (expResultInt &gt;= <span class="number">255</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(signResult + <span class="string">&quot;11111111&quot;</span> + <span class="string">&quot;00000000000000000000000&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阶码为0,说明运算得到了非规格化数，此时应该将尾数额外右移一次，使其符合非规格化数的规范</span></span><br><span class="line">        <span class="keyword">if</span> (expResultInt == <span class="number">0</span>) &#123;</span><br><span class="line">            sigResult = rightShift(sigResult, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阶码仍小于0，发生阶码下溢，返回0</span></span><br><span class="line">        <span class="keyword">if</span> (expResultInt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(signResult + <span class="string">&quot;00000000&quot;</span> + <span class="string">&quot;00000000000000000000000&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.舍入</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">expResult</span> <span class="operator">=</span> String.format(<span class="string">&quot;%8s&quot;</span>, Integer.toBinaryString(expResultInt)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">finalResult</span> <span class="operator">=</span> round(signResult, expResult, sigResult);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(finalResult);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>7-控制器</title>
    <url>/2025/02/22/7.%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<h1 id="COA7-控制器"><a href="#COA7-控制器" class="headerlink" title="COA7 控制器"></a>COA7 控制器</h1><ul>
<li>完成tick方法，在每个时钟周期内根据ICC的状态进行对应操作</li>
<li>完成取指、间址、执行、中断四种操作</li>
</ul>
<h1 id="一、tick"><a href="#一、tick" class="headerlink" title="一、tick"></a>一、tick</h1><h2 id="1-时钟周期的实现"><a href="#1-时钟周期的实现" class="headerlink" title="1. 时钟周期的实现"></a>1. 时钟周期的实现</h2><ul>
<li>每个时钟周期中，我们需要完成三件事：<ol>
<li><strong>判断ICC中内容</strong>，得到当前处于哪个时钟周期</li>
<li>执行对应周期的<strong>指令微操作</strong>序列</li>
<li>根据指令执行情况<strong>判断ICC的下一个状态</strong></li>
</ol>
</li>
<li>ICC是一个2位的寄存器</li>
</ul>
<h3 id="00-取指"><a href="#00-取指" class="headerlink" title="00:取指"></a>00:取指</h3><ol>
<li>调用取指getInstruct();</li>
<li>判断下一步（间址 &#x2F; 执行）<ol>
<li>如果opcode为<strong>1101110</strong>，把ICC设为01，间址</li>
<li>不是的话，ICC设为10，执行</li>
</ol>
</li>
</ol>
<ul>
<li>注意1：<strong>IR是指令寄存器</strong>（Instruction Register），<em>取指后指令存在IR</em>。</li>
<li>注意2：<strong>opcode</strong>为指令的<strong>前8位</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ICC[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;ICC[<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">    getInstruct();</span><br><span class="line">    <span class="comment">//判断是否进入间址周期</span></span><br><span class="line">    <span class="comment">//额外规定一种间址指令addc，opcode为1101110</span></span><br><span class="line">    <span class="type">char</span>[] opcode=Arrays.copyOfRange(IR,<span class="number">0</span>,<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span> <span class="title class_">String</span>(opcode).equals(<span class="string">&quot;1101110&quot;</span>))&#123;</span><br><span class="line">        ICC[<span class="number">1</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ICC[<span class="number">0</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="01：间址"><a href="#01：间址" class="headerlink" title="01：间址"></a>01：间址</h3><ol>
<li>调用间址findOperand();</li>
<li>ICC设为10，执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ICC[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;ICC[<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">    findOperand();</span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    ICC[<span class="number">0</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    ICC[<span class="number">1</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10：执行"><a href="#10：执行" class="headerlink" title="10：执行"></a>10：执行</h3><ol>
<li>调用执行</li>
<li><strong>判断是否允许中断</strong>：（中断 &#x2F; 取指）<ul>
<li>通过<code>interruptController.signal</code>是否为true判断</li>
</ul>
<ol>
<li>中断则11</li>
<li>否则00，取指</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ICC[<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;ICC[<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">    operate();</span><br><span class="line">    <span class="comment">//是否允许中断</span></span><br><span class="line">    <span class="keyword">if</span>(interruptController.signal)&#123;</span><br><span class="line">        ICC[<span class="number">1</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ICC[<span class="number">0</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11：中断"><a href="#11：中断" class="headerlink" title="11：中断"></a>11：中断</h3><ol>
<li>执行中断</li>
<li>设为00，取指</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ICC[<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;ICC[<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">    interrupt();</span><br><span class="line">    <span class="comment">//设为00，取值</span></span><br><span class="line">    ICC[<span class="number">0</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    ICC[<span class="number">1</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-取指微操作序列"><a href="#2-取指微操作序列" class="headerlink" title="2. 取指微操作序列"></a>2. 取指微操作序列</h2><ol>
<li>将PC中的内容加载到MAR<ul>
<li><code>Arrays.copyOf(PC,32);</code></li>
</ul>
</li>
<li>根据MAR中保存的地址，读取memory中对应内容到MBR（请注意memory中读出的数据是byte数组类型，而寄存器类型是char数组）<ul>
<li>有给出的函数<code>getFromMemory(new String(MAR));</code></li>
</ul>
</li>
<li>增加PC到下一条指令的位置（此时PC应该加上多少？为什么？考虑指令的长度）<ul>
<li>PC<strong>加4</strong>（32位&#x3D;4字节）</li>
<li>用alu.add</li>
</ul>
</li>
<li>将MBR中的内容装载到IR中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getInstruct</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    MAR=Arrays.copyOf(PC,<span class="number">32</span>);</span><br><span class="line">    MBR=getFromMemory(<span class="keyword">new</span> <span class="title class_">String</span>(MAR));</span><br><span class="line"></span><br><span class="line">    String nextPC=alu.add(<span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="keyword">new</span> <span class="title class_">String</span>(PC)),<span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="string">&quot;00000000000000000000000000000100&quot;</span>)).toString();</span><br><span class="line">    PC=nextPC.toCharArray();</span><br><span class="line"></span><br><span class="line">    IR=Arrays.copyOf(MBR,<span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-间址周期的实现"><a href="#3-间址周期的实现" class="headerlink" title="3. 间址周期的实现"></a>3. 间址周期的实现</h2><ol>
<li>将<strong>rs2中的内容</strong>加载到MAR中<ul>
<li><strong>rs2: IR中的20~24位</strong></li>
<li>rs2中的内容：<strong>GPR[rs2]</strong><ul>
<li>化为int：<code>int rs2_int=getRegister(rs2);</code></li>
<li>读<strong>GPR[rs2_int]</strong></li>
</ul>
</li>
</ul>
</li>
<li>根据<strong>MAR中的地址</strong>读出内存中对应数据存回rs2中<ul>
<li>MAR中的地址:<code>getFromMemory()</code></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findOperand</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="comment">//1. 将rs2中的内容加载到MAR中</span></span><br><span class="line">        <span class="comment">//rs2：20到24位</span></span><br><span class="line">    <span class="type">char</span>[] rs2=Arrays.copyOfRange(IR,<span class="number">20</span>,t25);</span><br><span class="line">    <span class="type">int</span> rs2_int=getRegister(rs2);</span><br><span class="line">    MAR=Arrays.copyOf(GPR[rs2_int],<span class="number">32</span>);</span><br><span class="line">    <span class="comment">//2. 根据MAR中的地址读出内存中对应数据存回rs2中</span></span><br><span class="line">    GPR[rs2_int]=getFromMemory(<span class="keyword">new</span> <span class="title class_">String</span>(MAR));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-执行周期的实现"><a href="#4-执行周期的实现" class="headerlink" title="4. 执行周期的实现"></a>4. 执行周期的实现</h2><ul>
<li>根据不同的opcode进行不同的操作</li>
<li>add指令可以调用ALU中已经实现好的加法进行</li>
<li>对应结果存到相应的位置中</li>
<li>特殊关注：<ul>
<li>jalr: 保存并跳转指令。在改变PC之前，我们要先将返回的位置保存到ra寄存器中，我们规定GPR的第1个寄存器是返回地址寄存器（第0个GPR寄存器保存0）</li>
<li>ecall: 系统调用中断指令。同样要保存返回位置，同时要设置中断控制器。</li>
</ul>
</li>
<li>寄存器和立即数的下标在指令中为了方便处理采用大端存储的方式，即从低到高直接截取转化为十进制即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="type">char</span>[] opcode=Arrays.copyOfRange(IR,<span class="number">0</span>,<span class="number">7</span>);</span><br><span class="line">    String opcode_str=<span class="keyword">new</span> <span class="title class_">String</span>(opcode);</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1100110&quot;</span>))&#123;<span class="comment">//add</span></span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1110110&quot;</span>))&#123;<span class="comment">//lui</span></span><br><span class="line">        lui();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1100000&quot;</span>))&#123;<span class="comment">//lw</span></span><br><span class="line">        lw();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1100100&quot;</span>))&#123;<span class="comment">//addi</span></span><br><span class="line">        addi();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1101110&quot;</span>))&#123;<span class="comment">//addc但是add</span></span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1110011&quot;</span>))&#123;<span class="comment">//jalr</span></span><br><span class="line">        jalr();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opcode_str.equals(<span class="string">&quot;1100111&quot;</span>))&#123;<span class="comment">//ecall</span></span><br><span class="line">        ecall();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><ul>
<li><strong>rs1:15-19位</strong></li>
<li><strong>rs2:20-24位</strong></li>
<li><strong>rd:7-11</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//rs1:15-19位</span></span><br><span class="line">    <span class="comment">//rs2:20-24位</span></span><br><span class="line">    <span class="comment">//rd:7-11</span></span><br><span class="line">    <span class="type">char</span>[] rs1=Arrays.copyOfRange(IR,<span class="number">15</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="type">char</span>[] rs2=Arrays.copyOfRange(IR,<span class="number">20</span>,<span class="number">25</span>);</span><br><span class="line">    <span class="type">char</span>[] rd =Arrays.copyOfRange(IR,<span class="number">7</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rs1_num=getRegister(rs1);</span><br><span class="line">    <span class="type">int</span> rs2_num=getRegister(rs2);</span><br><span class="line">    <span class="type">int</span> rd_num=getRegister(rd);</span><br><span class="line"></span><br><span class="line">    GPR[rd_num]=alu.add(<span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="keyword">new</span> <span class="title class_">String</span>(GPR[rs1_num])),<span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="keyword">new</span> <span class="title class_">String</span>(GPR[rs2_num]))).toString().toCharArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lui：将12-31位的20位立即数加载到目标寄存器的高20位，低12位全0"><a href="#lui：将12-31位的20位立即数加载到目标寄存器的高20位，低12位全0" class="headerlink" title="lui：将12-31位的20位立即数加载到目标寄存器的高20位，低12位全0"></a>lui：将12-31位的20位立即数加载到目标寄存器的高20位，低12位全0</h3><ul>
<li>将一个 <strong>20 位的立即数</strong>加载到<strong>寄存器的高 20 位</strong>，而<strong>低 12 位则被置为 0</strong></li>
<li><strong>rd:7-11位</strong></li>
<li><strong>imm：12-31位</strong></li>
<li><strong>int IMM&#x3D;Integer.valueOf(String.valueOf(imm_num),2)&lt;&lt;12</strong>;<ul>
<li><code>String.valueOf(imm_num)</code>：将 imm_num 转换为字符串。</li>
<li><code>Integer.valueOf(String.valueOf(imm_num), 2)</code>：将上一步得到的字符串<strong>作为二进制数解析</strong>，并转换为一个<strong>整数</strong>。这里的 <strong>2 表示二进制</strong>。</li>
<li><code>&lt;&lt; 12</code>：将解析得到的整数<strong>左移 12 位</strong>。左移 12 位相当于将该整数乘以 2 的 12 次方（4096），这<strong>会将原来的低 12 位置为 0，并将高 20 位保留</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lui</span><span class="params">()</span>&#123;<span class="comment">//将一个 20 位的立即数加载到寄存器的高 20 位，而低 12 位则被置为 0</span></span><br><span class="line">    <span class="comment">//rd:7-11</span></span><br><span class="line">    <span class="comment">//imm:12-31</span></span><br><span class="line">    <span class="type">char</span>[] rd=Arrays.copyOfRange(IR,<span class="number">7</span>,<span class="number">12</span>);</span><br><span class="line">    <span class="type">char</span>[] imm=Arrays.copyOfRange(IR,<span class="number">12</span>,<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rd_num=getRegister(rd);</span><br><span class="line">    <span class="type">int</span> imm_num=getRegister(imm);</span><br><span class="line">    <span class="type">int</span> IMM=Integer.valueOf(String.valueOf(imm_num),<span class="number">2</span>)&lt;&lt;<span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    GPR[rd_num]=Transformer.intToBinary(String.valueOf(IMM)).toCharArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lw：基址寄存器内的值-偏移量得到新地址，将新地址内的值存到目标寄存器中"><a href="#lw：基址寄存器内的值-偏移量得到新地址，将新地址内的值存到目标寄存器中" class="headerlink" title="lw：基址寄存器内的值+偏移量得到新地址，将新地址内的值存到目标寄存器中"></a>lw：基址寄存器内的值+偏移量得到新地址，将新地址内的值存到目标寄存器中</h3><ol>
<li>提取指令字段<ul>
<li>基址寄存器rs1：15-19位</li>
<li>立即数（偏移量）imm：20-31位</li>
<li>目标寄存器rd：7-11位</li>
</ul>
</li>
<li>获取寄存器编号：getRegister()</li>
<li>计算<strong>新内存地址</strong>offset<ul>
<li>将 imm 转换为二进制整数 IMM。（变string，再string变二进制int）</li>
<li>将基址寄存器 GPR[rs1_num] 的值转换为二进制整数 RS1。</li>
<li>计算内存地址 offset，即 IMM 加上 RS1。</li>
</ul>
</li>
<li>从内存中读取数据<ul>
<li>使用 <code>Transformer.intToBinary</code> 方法将 offset 转换为二进制字符串。</li>
<li>调用 <code>getFromMemory</code> 方法从内存中读取数据，并将其存储到目标寄存器 GPR[rd_num] 中。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lw</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//rs1:15-19位</span></span><br><span class="line">    <span class="comment">//imm：20-31位</span></span><br><span class="line">    <span class="comment">//rd:7-11位</span></span><br><span class="line">    <span class="type">char</span>[] rs1=Arrays.copyOfRange(IR,<span class="number">15</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="type">char</span>[] imm=Arrays.copyOfRange(IR,<span class="number">20</span>,<span class="number">32</span>);</span><br><span class="line">    <span class="type">char</span>[] rd =Arrays.copyOfRange(IR,<span class="number">7</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rs1_num=getRegister(rs1);</span><br><span class="line">    <span class="type">int</span> rd_num=getRegister(rd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> IMM=Integer.valueOf(String.valueOf(imm),<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> RS1=Integer.valueOf(String.valueOf(GPR[rs1_num]),<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> offset=IMM+RS1;</span><br><span class="line"></span><br><span class="line">    GPR[rd_num]=getFromMemory(Transformer.intToBinary(String.valueOf(offset)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="addi-源寄存器内的值-偏移量，存入目标寄存器"><a href="#addi-源寄存器内的值-偏移量，存入目标寄存器" class="headerlink" title="addi 源寄存器内的值+偏移量，存入目标寄存器"></a>addi 源寄存器内的值+偏移量，存入目标寄存器</h3><ol>
<li>提取指令字段<ul>
<li>源寄存器rs1：15-19位</li>
<li>立即数（偏移量）imm：20-31位</li>
<li>目标寄存器rd：7-11位</li>
</ul>
</li>
<li>获取寄存器编号：getRegister()</li>
<li>计算<em>立即数</em>和<em>源寄存器内数据</em>的值，转换为<strong>二进制整数</strong></li>
<li>计算结果：立即数+源寄存器内数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addi</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//rs1:15-19位</span></span><br><span class="line">    <span class="comment">//imm：20-31位</span></span><br><span class="line">    <span class="comment">//rd:7-11位</span></span><br><span class="line">    <span class="type">char</span>[] rs1=Arrays.copyOfRange(IR,<span class="number">15</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="type">char</span>[] imm=Arrays.copyOfRange(IR,<span class="number">20</span>,<span class="number">32</span>);</span><br><span class="line">    <span class="type">char</span>[] rd =Arrays.copyOfRange(IR,<span class="number">7</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rs1_num=getRegister(rs1);</span><br><span class="line">    <span class="type">int</span> rd_num=getRegister(rd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> IMM=Integer.valueOf(String.valueOf(imm),<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> RS1=Integer.valueOf(String.valueOf(GPR[rs1_num]),<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=IMM+RS1;</span><br><span class="line"></span><br><span class="line">    GPR[rd_num]=Transformer.intToBinary(String.valueOf(res)).toCharArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="addc：直接add（间址）"><a href="#addc：直接add（间址）" class="headerlink" title="addc：直接add（间址）"></a>addc：直接add（间址）</h3><h3 id="jalr：保存当前程序计数器（PC）的值到返回地址寄存器（ra），然后跳转到新的地址"><a href="#jalr：保存当前程序计数器（PC）的值到返回地址寄存器（ra），然后跳转到新的地址" class="headerlink" title="jalr：保存当前程序计数器（PC）的值到返回地址寄存器（ra），然后跳转到新的地址"></a>jalr：保存当前程序计数器（PC）的值到返回地址寄存器（ra），然后跳转到新的地址</h3><ul>
<li>在<strong>改变PC之前</strong>，我们要先<strong>将返回的位置保存到ra寄存器</strong>中，我们<strong>规定GPR的第1个寄存器是返回地址寄存器</strong>（第0个GPR寄存器保存0）</li>
</ul>
<ol>
<li>提取指令字段<ul>
<li>基质寄存器rs1：15-19位</li>
<li>立即数（偏移量）imm：20-31位</li>
<li>返回地址寄存器ra：7-11位a</li>
</ul>
</li>
<li>获取寄存器编号</li>
<li>计算立即数IMM和基址寄存器内数RS1的值(化为二进制整数)</li>
<li>计算<strong>新地址</strong>，即 <strong>IMM 加上 RS1</strong></li>
<li><strong>保存当前 PC 到ra，并跳转到新地址</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jalr</span><span class="params">()</span>&#123;<span class="comment">//保存并跳转指令</span></span><br><span class="line">    <span class="comment">//rs1:15-19位</span></span><br><span class="line">    <span class="comment">//imm：20-31位</span></span><br><span class="line">    <span class="comment">//ra:7-11位</span></span><br><span class="line">    <span class="type">char</span>[] rs1=Arrays.copyOfRange(IR,<span class="number">15</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="type">char</span>[] imm=Arrays.copyOfRange(IR,<span class="number">20</span>,<span class="number">32</span>);</span><br><span class="line">    <span class="type">char</span>[] ra =Arrays.copyOfRange(IR,<span class="number">7</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rs1_num=getRegister(rs1);</span><br><span class="line">    <span class="type">int</span> ra_num=getRegister(ra);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> IMM=Integer.valueOf(String.valueOf(imm),<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> RS1=Integer.valueOf(String.valueOf(GPR[rs1_num]),<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> newAddr=IMM+RS1;</span><br><span class="line"></span><br><span class="line">    GPR[ra_num]=Arrays.copyOf(PC,<span class="number">32</span>);</span><br><span class="line">    PC=Transformer.intToBinary(String.valueOf(newAddr)).toCharArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ecall：系统调用中断指令。保存当前程序计数器（PC）的值，并设置中断控制器。"><a href="#ecall：系统调用中断指令。保存当前程序计数器（PC）的值，并设置中断控制器。" class="headerlink" title="ecall：系统调用中断指令。保存当前程序计数器（PC）的值，并设置中断控制器。"></a>ecall：系统调用中断指令。保存当前程序计数器（PC）的值，并设置中断控制器。</h3><ul>
<li>规定GPR的第1个寄存器是返回地址寄存器</li>
</ul>
<ol>
<li>PC保存到GPR[1]中</li>
<li>中断信号设置为true</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ecall</span><span class="params">()</span>&#123;<span class="comment">//系统调用中断指令。同样要保存返回位置，同时要设置中断控制器。</span></span><br><span class="line">    interruptController.signal=<span class="literal">true</span>;</span><br><span class="line">    GPR[<span class="number">1</span>]=Arrays.copyOf(PC,<span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-中断"><a href="#5-中断" class="headerlink" title="5. 中断"></a>5. 中断</h2><ul>
<li>使用ecall指令来模拟中断操作。在中断发生时，系统要保存程序的返回位置（是多少？），以便完成中断处理程序后返回原有程序。</li>
</ul>
<ol>
<li>此处我们使用<strong>handleInterrupt</strong>来模拟中断程序的实现。</li>
<li>执行完中断操作后，将<strong>允许中断位改为false</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    interruptController.handleInterrupt();</span><br><span class="line">    interruptController.signal=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>2-补码加减乘除</title>
    <url>/2025/02/22/2.%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/</url>
    <content><![CDATA[<h2 id="一-计算两个32位二进制整数补码真值的和"><a href="#一-计算两个32位二进制整数补码真值的和" class="headerlink" title="一. 计算两个32位二进制整数补码真值的和"></a>一. 计算两个32位二进制整数补码真值的和</h2><h3 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1. 步骤"></a>1. 步骤</h3><ol>
<li>初始化：将 src 和 dest 转换为字符串形式，并初始化一个 StringBuilder 来存储结果。</li>
<li>逐位相加：从最低位（第31位）开始逐位相加，<strong>考虑进位情况</strong>。</li>
<li>处理进位：根据<strong>当前位的和以及是否有进位</strong>，决定<strong>当前位的结果和是否产生新的进位</strong>。</li>
<li><strong>结果反转</strong>：由于结果是从最低位开始添加的，<strong>最终需要反转字符串以得到正确的顺序</strong>。</li>
<li>返回结果：将结果转换为 DataType 并返回。<ul>
<li>DataType ans &#x3D; <strong>new DataType(ansStr)</strong>;</li>
</ul>
</li>
</ol>
<h3 id="2-【注意】结果反转"><a href="#2-【注意】结果反转" class="headerlink" title="2. 【注意】结果反转"></a>2. 【注意】结果反转</h3><ul>
<li><code>String ans = ansStr.reverse().toString();</code></li>
<li><strong>StringBulider</strong>才能用<code>.reverse()</code>; String不能用</li>
</ul>
<h3 id="3-完整代码"><a href="#3-完整代码" class="headerlink" title="3. 完整代码"></a>3. 完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">add</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">       String srcStr=src.toString();</span><br><span class="line">       String destStr=dest.toString();</span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">ansStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">destInt</span> <span class="operator">=</span> destStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           <span class="type">int</span> <span class="variable">srcInt</span> <span class="operator">=</span> srcStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           <span class="keyword">if</span> (!carry) &#123;<span class="comment">//无进位</span></span><br><span class="line">               <span class="keyword">if</span> (destInt + srcInt == <span class="number">2</span>) &#123;</span><br><span class="line">                   carry = <span class="literal">true</span>;</span><br><span class="line">                   ansStr.append(<span class="number">0</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span>(destInt+srcInt==<span class="number">1</span>)&#123;</span><br><span class="line">                   ansStr.append(<span class="number">1</span>);</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   ansStr.append(<span class="number">0</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;<span class="comment">//有进位</span></span><br><span class="line">               <span class="keyword">if</span> (destInt + srcInt == <span class="number">2</span>) &#123;</span><br><span class="line">                   ansStr.append(<span class="number">1</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span>(destInt+srcInt==<span class="number">1</span>)&#123;</span><br><span class="line">                   ansStr.append(<span class="number">0</span>);</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   ansStr.append(<span class="number">1</span>);</span><br><span class="line">                   carry=<span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">DataType</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(ansStr.reverse().toString());</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-更简单："><a href="#4-更简单：" class="headerlink" title="4. 更简单："></a>4. 更简单：</h3><ul>
<li>int sum &#x3D; num1 + num2 + carry;</li>
<li>result.append(sum % 2);</li>
<li>carry &#x3D; sum &#x2F; 2;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">add</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">srcStr</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">destStr</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> srcStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> destStr.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> num1 + num2 + carry;</span><br><span class="line">        result.append(sum % <span class="number">2</span>);</span><br><span class="line">        carry = sum / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(result.reverse().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、计算两个32位二进制整数补码真值的差"><a href="#二、计算两个32位二进制整数补码真值的差" class="headerlink" title="二、计算两个32位二进制整数补码真值的差"></a>二、计算两个32位二进制整数补码真值的差</h2><ul>
<li>dest表示被减数，src表示减数(即计算dest - src)</li>
</ul>
<h3 id="1-取反操作"><a href="#1-取反操作" class="headerlink" title="1. 取反操作"></a>1. 取反操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">negation</span><span class="params">(String beforeStr)</span>&#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">afterStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">//逐位取反</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (beforeStr.charAt(i)==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            afterStr.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            afterStr.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加1</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(carry)&#123;<span class="comment">//有进位</span></span><br><span class="line">            <span class="keyword">if</span>(afterStr.charAt(i)==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                afterStr.replace(i,i+<span class="number">1</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                carry=<span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                afterStr.replace(i,i+<span class="number">1</span>,<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> afterStr.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-完整代码"><a href="#2-完整代码" class="headerlink" title="2.完整代码"></a>2.完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">sub</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    String srcStr=src.toString();</span><br><span class="line">    srcStr=negation(srcStr);</span><br><span class="line">    src = <span class="keyword">new</span> <span class="title class_">DataType</span>(srcStr);</span><br><span class="line">    <span class="keyword">return</span> add(src,dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、两个二进制整数的乘积-布斯乘法，结果低位截取后32位"><a href="#三、两个二进制整数的乘积-布斯乘法，结果低位截取后32位" class="headerlink" title="三、两个二进制整数的乘积(布斯乘法，结果低位截取后32位)"></a>三、两个二进制整数的乘积(布斯乘法，结果低位截取后32位)</h2><h3 id="1-布斯乘法"><a href="#1-布斯乘法" class="headerlink" title="1.布斯乘法"></a>1.布斯乘法</h3><ol>
<li>正负数处理：<ul>
<li>检查 src 和 dest 是否为负数，如果是负数，则将其<strong>转换为正数</strong>。</li>
</ul>
</li>
<li>初始化：<ol>
<li>初始化 <strong>resultStr</strong> 为<strong>65位字符串</strong>，其中<strong>前32位为0，后32位为 dest，并在末尾添一个0</strong>。<ul>
<li><strong>32个0+dest+0</strong></li>
</ul>
</li>
</ol>
</li>
<li>迭代计算：<ul>
<li>对 resultStr 进行<strong>32次迭代</strong>；第一次是<strong>0-最低位</strong></li>
<li>每次根据 resultStr 的最低位和次低位的组合（<strong>最低位-次低位</strong>）决定是否进行加法或减法操作。<ul>
<li>如果组合为 <strong>01（1）</strong>，则将 <strong>resultStr的高32位 + src</strong>。</li>
<li>如果组合为 10（-1），则将<strong>resultStr的高32位 - src</strong>。</li>
<li>如果组合为 11或00（0），则不变。</li>
<li>进行<strong>算术右移操作（保留符号位）</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>重复：<ul>
<li>重复上述迭代步骤，直到处理完乘数的所有位。</li>
</ul>
</li>
<li>结果：<ul>
<li>截取 resultStr 的**低32位（33~64）**作为最终结果</li>
<li>如果原始 src 和 dest 中有一个是负数，则将结果取反。</li>
</ul>
</li>
</ol>
<h3 id="2-算术右移方法："><a href="#2-算术右移方法：" class="headerlink" title="2. 算术右移方法："></a>2. 算术右移方法：</h3><ol>
<li>符号位不变</li>
<li>原本的64位整体右移</li>
</ol>
<ul>
<li>相当于<strong>前面变成两个符号位，最后一位丢掉</strong></li>
</ul>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">mul</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    String srcStr=src.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">destStr</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="comment">//1.判断正负，如果负，则标记并转为正</span></span><br><span class="line">    <span class="type">boolean</span> srcNeg=<span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> destNeg=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(srcStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">        srcNeg=<span class="literal">true</span>;</span><br><span class="line">        srcStr=negation(srcStr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(destStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">        destNeg=<span class="literal">true</span>;</span><br><span class="line">        destStr=negation(destStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.初始化</span></span><br><span class="line">    StringBuilder resultStr=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;0&quot;</span>.repeat(<span class="number">32</span>)+destStr+<span class="string">&quot;0&quot;</span>);<span class="comment">//result，32个0+dest+0组成</span></span><br><span class="line">    <span class="comment">//3.计算</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">32</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        DataType src1=<span class="keyword">new</span> <span class="title class_">DataType</span>(srcStr);</span><br><span class="line">        DataType dest1=<span class="keyword">new</span> <span class="title class_">DataType</span>(resultStr.substring(<span class="number">0</span>,<span class="number">32</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">32</span>)&#123;<span class="comment">//第1位（补充了一个0）</span></span><br><span class="line">            <span class="keyword">if</span>(destStr.charAt(<span class="number">31</span>)-<span class="string">&#x27;0&#x27;</span>==<span class="number">0</span>)&#123;<span class="comment">//0：右移</span></span><br><span class="line">                resultStr= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(rightshift(resultStr.toString()));<span class="comment">//右移</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//-1：减src，再右移</span></span><br><span class="line">                resultStr.replace(<span class="number">0</span>,<span class="number">32</span>,sub(src1,dest1).toString());</span><br><span class="line">                resultStr= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(rightshift(resultStr.toString()));<span class="comment">//右移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//其它位</span></span><br><span class="line">            <span class="keyword">if</span>(destStr.charAt(i)-destStr.charAt(i-<span class="number">1</span>)==<span class="number">0</span>)&#123;<span class="comment">//0：右移</span></span><br><span class="line">                resultStr= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(rightshift(resultStr.toString()));<span class="comment">//右移</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>  <span class="keyword">if</span>(destStr.charAt(i)-destStr.charAt(i-<span class="number">1</span>)==<span class="number">1</span>)&#123;<span class="comment">//1：加src，再右移</span></span><br><span class="line">                resultStr.replace(<span class="number">0</span>,<span class="number">32</span>,add(src1,dest1).toString());</span><br><span class="line">                resultStr= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(rightshift(resultStr.toString()));<span class="comment">//右移</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//-1：减src，再右移</span></span><br><span class="line">                resultStr.replace(<span class="number">0</span>,<span class="number">32</span>,sub(src1,dest1).toString());</span><br><span class="line">                resultStr= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(rightshift(resultStr.toString()));<span class="comment">//右移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.结果：截取低32位</span></span><br><span class="line">    String result=resultStr.substring(<span class="number">32</span>,<span class="number">64</span>);</span><br><span class="line">    <span class="comment">//正负调整</span></span><br><span class="line">    <span class="keyword">if</span>((srcNeg&amp;&amp;!destNeg)||(!srcNeg&amp;&amp;destNeg))&#123;</span><br><span class="line">        result =negation(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">rightshift</span><span class="params">(String beforeStr)</span>&#123;<span class="comment">//右移</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">afterStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    afterStr.append(beforeStr.charAt(<span class="number">0</span>));<span class="comment">//保留符号位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">64</span>;i++)&#123;</span><br><span class="line">        afterStr.append(beforeStr.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> afterStr.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、两个二进制整数的除法"><a href="#四、两个二进制整数的除法" class="headerlink" title="四、两个二进制整数的除法"></a>四、两个二进制整数的除法</h2><ul>
<li><strong>恢复余数除法</strong>和<strong>不恢复余数除法</strong>均可</li>
<li>dest ÷ src</li>
<li>将32位余数正确储存在余数寄存器remainderReg中</li>
<li>除数为0，且被除数不为0时要求能够正确抛出ArithmeticException<strong>异常</strong>。</li>
</ul>
<h3 id="1-恢复余数除法"><a href="#1-恢复余数除法" class="headerlink" title="1. 恢复余数除法"></a>1. 恢复余数除法</h3><ol start="0">
<li>（此代码中）正负调整(【Datatype】src和【String】srcStr都要)</li>
<li>初始化：<ul>
<li>被除数（Dividend）和除数（Divisor）分别存储在寄存器中。</li>
<li><strong>余数</strong>寄存器（Remainder）初始化为<strong>32位的0</strong>。</li>
<li><strong>商</strong>寄存器（Quotient）初始化为<strong>被除数</strong>。</li>
</ul>
</li>
<li>迭代：对<strong>被除数的每一位</strong>进行处理，从<strong>最高位到最低位</strong>。<ol>
<li>将<strong>余数左移一位</strong>，并将<strong>被除数的当前位移入余数的最低位</strong>。</li>
<li><strong>余数减去&#x2F;加上除数</strong>。<ul>
<li>如果余数<strong>与原本异号</strong>，则<strong>恢复余数（加回除数）</strong>，并将<strong>商的当前位设为0</strong>。</li>
<li>如果余数<strong>与原本同号</strong>，则将商的当前位<strong>设为1</strong>。</li>
</ul>
</li>
</ol>
</li>
<li>结果：<ul>
<li>（此代码中）调整<strong>余数和商的符号</strong></li>
<li>迭代完成后，商寄存器中存储的值即为商，余数寄存器中存储的值即为余数。</li>
</ul>
</li>
</ol>
<h3 id="2-不恢复余数除法"><a href="#2-不恢复余数除法" class="headerlink" title="2. 不恢复余数除法"></a>2. 不恢复余数除法</h3><ol>
<li>初始化：<ul>
<li>被除数（Dividend）和除数（Divisor）分别存储在寄存器中。</li>
<li>余数寄存器（Remainder）初始化为0。</li>
<li>商寄存器（Quotient）初始化为被除数。</li>
</ul>
</li>
<li>迭代： 对被除数的每一位进行处理，从最高位到最低位。<ol>
<li>将<strong>余数左移一位</strong>，并将<strong>被除数的当前位移入余数的最低位</strong>。</li>
<li>余数减去&#x2F;加上除数。<ul>
<li>如果余数<strong>与原本异号</strong>，则将商的当前位设为0，并在<strong>下一次迭代中将余数加回除数</strong>。</li>
<li>如果余数<strong>与原本同号</strong>，则将商的当前位设为1，并在<strong>下一次迭代中继续减去除数</strong>。</li>
</ul>
</li>
</ol>
</li>
<li>结果：<ul>
<li>根据被除数和除数的符号，调整商和余数的符号：<ul>
<li><strong>被除数和除数同号：余数+除数</strong>，商为正</li>
<li><strong>被除数和除数异号：余数-除数</strong>，商为负</li>
</ul>
</li>
<li>迭代完成后，商寄存器中存储的值即为商，余数寄存器中存储的值即为余数。</li>
</ul>
</li>
</ol>
<h3 id="3-调整余数和商的符号"><a href="#3-调整余数和商的符号" class="headerlink" title="3. 调整余数和商的符号"></a>3. 调整余数和商的符号</h3><ol>
<li><strong>余数和被除数同号</strong></li>
<li>其中<strong>一方为负，则商取负</strong></li>
</ol>
<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataType remainderReg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回两个二进制整数的除法结果</span></span><br><span class="line"><span class="comment"> * dest ÷ src</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src  32-bits</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest 32-bits</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 32-bits</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//用恢复余数除法</span></span><br><span class="line"><span class="keyword">public</span> DataType <span class="title function_">div</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">srcStr</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">destStr</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="comment">//0.判断除0情况</span></span><br><span class="line">    <span class="keyword">if</span>(srcStr.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;除0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 判断正负，如果是负就转正，并标记</span></span><br><span class="line">    <span class="type">boolean</span> srcNeg=<span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">destNeg</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(srcStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">        srcStr=negation(srcStr);</span><br><span class="line">        src=<span class="keyword">new</span> <span class="title class_">DataType</span>(srcStr);<span class="comment">//保证src也变号</span></span><br><span class="line">        srcNeg=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(destStr.charAt(<span class="number">0</span>)==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">        destStr=negation(destStr);</span><br><span class="line">        dest = <span class="keyword">new</span> <span class="title class_">DataType</span>(destStr);<span class="comment">//保证dest也变号</span></span><br><span class="line">        destNeg=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 初始化-商和余数寄存器</span></span><br><span class="line">    StringBuilder Shang=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(destStr);<span class="comment">//商，初始化为被除数</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">Yu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;0&quot;</span>.repeat(<span class="number">32</span>));<span class="comment">//余数，初始化为32个0</span></span><br><span class="line">    <span class="comment">//3. 计算</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//3.1左移</span></span><br><span class="line">        Yu=leftshift(Yu.toString());</span><br><span class="line">        Yu.append(Shang.charAt(<span class="number">0</span>));</span><br><span class="line">        Shang=leftshift(Shang.toString());</span><br><span class="line">        <span class="comment">//3.2 余数减去除数</span></span><br><span class="line">        String tmp=sub(src,<span class="keyword">new</span> <span class="title class_">DataType</span>(Yu.toString())).toString();</span><br><span class="line">        <span class="keyword">if</span>(tmp.charAt(<span class="number">0</span>)==<span class="string">&#x27;1&#x27;</span>)&#123;<span class="comment">//为负</span></span><br><span class="line">            Shang.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//非负</span></span><br><span class="line">            Yu=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(tmp);</span><br><span class="line">            Shang.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.结果</span></span><br><span class="line">    String YuStr= Yu.toString();</span><br><span class="line">    String ShangStr= Shang.toString();</span><br><span class="line">    <span class="comment">//被除数和余数同号</span></span><br><span class="line">    <span class="keyword">if</span>(!srcNeg&amp;&amp;destNeg)&#123;<span class="comment">//除数正，被除数负</span></span><br><span class="line">        YuStr=negation(YuStr);</span><br><span class="line">        ShangStr=negation(ShangStr);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (srcNeg&amp;&amp;!destNeg) &#123;<span class="comment">//除数负，被除数正</span></span><br><span class="line">        ShangStr=negation(YuStr);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(srcNeg&amp;&amp;destNeg)&#123;<span class="comment">//都是负</span></span><br><span class="line">        YuStr=negation(YuStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remainderReg=<span class="keyword">new</span> <span class="title class_">DataType</span>(YuStr);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(ShangStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左移</span></span><br><span class="line"><span class="keyword">public</span> StringBuilder <span class="title function_">leftshift</span><span class="params">(String beforeStr)</span>&#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">afterStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">32</span>;i++)&#123;<span class="comment">//跳过第一位</span></span><br><span class="line">        afterStr.append(beforeStr.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> afterStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>6-虚拟存储器</title>
    <url>/2025/02/22/6.%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    <content><![CDATA[<h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><ul>
<li>分别实现<strong>实模式、分段式、段页式</strong>三种内存的地址转换与数据加载功能。</li>
</ul>
<ol>
<li>地址转换<ul>
<li>在MMU类中，实现三个地址转换的方法，将逻辑地址转换为线性地址再转换为物理地址。</li>
<li>private String toRealLinearAddr(String logicAddr)</li>
<li>private String toSegLinearAddr(String logicAddr)</li>
<li>private String toPagePhysicalAddr(String linearAddr)</li>
</ul>
</li>
<li>数据加载<ul>
<li>在Memory类中，实现三个数据加载方法。</li>
<li>public void real_load(String pAddr, int len)</li>
<li>public void seg_load(int segIndex)</li>
<li>public void page_load(int vPageNo)</li>
</ul>
</li>
<li>融合cache与TLB<ul>
<li>将cache与TLB融合到MMU中。</li>
</ul>
</li>
</ol>
<ul>
<li>逻辑地址：<strong>指令</strong>中给出的地址， 48 位(16位段寄存器 + 32位段内偏移量)。<ul>
<li>CPU在运行指令时，如果想要访问内存，它并不是用直接使用内存的地址访问，而是给出一个由 16 位段寄存器和 32 位段内偏移量拼起来的 48 位的逻辑地址。<ul>
<li>比如，如果CPU想知道当前指令的地址，他给出的逻辑地址应该是(CS:EIP)。</li>
<li>其中，CS是 16 位代码段寄存器，EIP是 32 位指令指针寄存器（也就是程序计数器PC）。</li>
</ul>
</li>
</ul>
</li>
<li>线性地址：逻辑地址到物理地址的中间层， 32 位。<ul>
<li>如果<strong>没有启用分页机制</strong>，那么线性地址就<strong>等于物理地址</strong>。</li>
<li>如果启用了分页机制，那么线性地址需要通过再一次变换才能得到物理地址。</li>
</ul>
</li>
<li>物理地址：<strong>内存</strong>中的地址， 32 位。</li>
</ul>
<h1 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h1><h2 id="Memory的real-load方法"><a href="#Memory的real-load方法" class="headerlink" title="Memory的real_load方法"></a>Memory的<code>real_load</code>方法</h2><ul>
<li>SEGMENT和PAGE均为false时，为实模式</li>
<li>变量：<code>pAddr</code>与<code>len</code></li>
</ul>
<ol>
<li>直接用地址和长度从磁盘disk.read加载data</li>
<li>把data再写进内存(注意实模式下，内存地址对应磁盘地址，即pAddr)</li>
</ol>
<ul>
<li><code>System.arraycopy(data, 0, memory, start, len);</code><ul>
<li>将<strong>原数组</strong>data从<strong>起始位置</strong>0，复制到<strong>目标数组</strong>memory的start<strong>位置开始</strong>，复制的<strong>元素数量</strong>为len</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实模式下从磁盘中加载数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pAddr 实模式下，内存地址对应磁盘地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> len   数据段长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">real_load</span><span class="params">(String pAddr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] data = disk.read(pAddr, len);<span class="comment">//从磁盘中读取数据(方法在Disk.java中）</span></span><br><span class="line">    <span class="comment">//更新数据</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(pAddr));<span class="comment">//start,为内存地址</span></span><br><span class="line">    System.arraycopy(data, <span class="number">0</span>, memory, start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h2><ul>
<li>&#96;&#96;toRealLinearAddr&#96;方法: 逻辑地址转线性地址。<ul>
<li>段寄存器左移4位 + 段内偏移量的低16位 再补齐32位</li>
</ul>
</li>
</ul>
<ol>
<li><strong>截取前16位段寄存器</strong>；再<strong>截取offset低16位（实际截取32位）</strong>，转成int。<ul>
<li>在实际计算中，我们把高 16 位看作基址，低 32 位看作偏移量（实际有用的只有低 16 位）</li>
</ul>
</li>
<li>将段寄存器和偏移量<strong>化为整数</strong></li>
<li><strong>段寄存器左移4位</strong><ul>
<li>可以直接使用Java中的&lt;&lt;运算符将整数左移4位</li>
</ul>
</li>
<li>两个数字相加，转成二进制，高位补0到32位</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 实模式下的逻辑地址转线性地址</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> logicAddr 48位 = 16位段寄存器 + 32位offset，计算公式为：①(16-bits段寄存器左移4位 + offset的低16-bits) = 20-bits物理地址 ②高位补0到32-bits</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 32-bits实模式线性地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> String <span class="title function_">toRealLinearAddr</span><span class="params">(String logicAddr)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">segReg</span> <span class="operator">=</span> logicAddr.substring(<span class="number">0</span>, <span class="number">16</span>);<span class="comment">//取逻辑地址的前16位作为段寄存器</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">offset</span> <span class="operator">=</span> logicAddr.substring(<span class="number">16</span>, <span class="number">48</span>);<span class="comment">//取逻辑地址的后32位作为偏移量</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//将段寄存器和偏移量化为整数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">segRegInt</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(segReg));</span><br><span class="line">       <span class="type">int</span> <span class="variable">offsetLow16</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(offset));</span><br><span class="line"></span><br><span class="line">       <span class="comment">//计算20位物理地址</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">physicalAddr</span> <span class="operator">=</span> (segRegInt &lt;&lt; <span class="number">4</span>) + offsetLow16;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将20位物理地址转换为32位</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">linearAddr</span> <span class="operator">=</span> String.format(<span class="string">&quot;%32s&quot;</span>, Integer.toBinaryString(physicalAddr)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>);<span class="comment">//转换为32位，并用0填充高位</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> linearAddr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="分段式"><a href="#分段式" class="headerlink" title="分段式"></a>分段式</h1><h2 id="Memory类：实现seg-load段加载方法"><a href="#Memory类：实现seg-load段加载方法" class="headerlink" title="Memory类：实现seg_load段加载方法"></a>Memory类：实现seg_load段加载方法</h2><ol>
<li>从磁盘上加载该段的数据到内存。<ul>
<li>如何从磁盘上<strong>读取一整段</strong>呢？你应该使用<strong>段基址</strong>作为访问磁盘的地址，用**段限长（即段大小）**作为读取的长度。</li>
<li>至于段基址和段限长是多少，参考我们3.2.3的规定。<ul>
<li>private char[] base &#x3D; new char[32];  &#x2F;&#x2F; 32位基地址</li>
<li>private char[] limit &#x3D; new char[20]; &#x2F;&#x2F; 20位限长</li>
</ul>
</li>
<li>那么加载过来之后<strong>写到内存的哪里</strong>呢？由于分段式下每个段大小只有1MB，不会超出内存大小，所以我们<strong>默认把数据放在物理地址为 0 的地方</strong>。</li>
</ul>
</li>
<li>除了加载数据，你还需要<strong>填好全局描述符表GDT</strong>，需要填入的内容还是按照3.2.3的规定进行填写。下面为该规定的原文。<ul>
<li>每个由MMU装载进入GDT的段，<strong>其段基址均为全 0 ，其限长均为全 1</strong> ，<strong>未开启分页时粒度为false，开启分页后粒度为true</strong>。</li>
</ul>
</li>
</ol>
<ul>
<li>变量：segIndex段索引</li>
</ul>
<ol>
<li>获取段描述符：<ul>
<li>(有方法)通过 segIndex 获取对应的段描述符 segDes</li>
</ul>
</li>
<li>获取段基址和段限长：<ul>
<li><strong>段基址：32位全0</strong></li>
<li><strong>段限长：20位全1</strong></li>
</ul>
</li>
<li>判断是否开启分页<ul>
<li>如果<strong>未开启分页模式</strong>（PAGE 为 false），</li>
<li>则<strong>从磁盘中读取数据</strong>，并将数据<strong>写入内存</strong>的<strong>物理地址为0</strong>的地方。</li>
<li>注意，<strong>段限长</strong><em>是从0开始计数</em>，因此<strong>读取长度需要加1</strong>。</li>
</ul>
</li>
<li>更新段描述符：<ul>
<li>基址</li>
<li>限长</li>
<li>有效位：validBit 设置为 true 表示段已在内存中</li>
<li>粒度：granularity 设置为 PAGE（未开启分页时粒度为false，开启分页后粒度为true）</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 段式存储模式下，从磁盘中加载数据.段页式存储中，不用从磁盘中加载数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> segIndex 段索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//在段页式存储管理下，从磁盘加载数据应该是以页为单位的，不再是以段为单位。</span></span><br><span class="line"><span class="comment">// 开启分页之后，一个段应该是4GB。因此开启分页之后，seg_load应该跳过加载数据这一步，它的作用在开启分页之后仅仅是填写GDT，加载数据的任务应该交给page_load来完成。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">seg_load</span><span class="params">(<span class="type">int</span> segIndex)</span> &#123;</span><br><span class="line">    <span class="comment">//获取段描述符</span></span><br><span class="line">    <span class="type">SegDescriptor</span> <span class="variable">segDes</span> <span class="operator">=</span> getSegDescriptor(segIndex);</span><br><span class="line">   <span class="comment">//获取段基址(访问磁盘的地址)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">segBase</span> <span class="operator">=</span> <span class="string">&quot;00000000000000000000000000000000&quot;</span>; <span class="comment">// 32位基址，全0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">baseInt</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(segBase));</span><br><span class="line">    <span class="comment">//获取段限长(读取的长度)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="string">&quot;11111111111111111111&quot;</span>; <span class="comment">// 20位限长，全1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">limitInt</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(limit));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!PAGE) &#123;<span class="comment">//未开启分页,段式存储，要从磁盘中加载数据，并且写到内存的物理地址为0的地方</span></span><br><span class="line">        <span class="comment">//从磁盘中加载数据</span></span><br><span class="line">        <span class="type">byte</span>[] data = disk.read(segBase, limitInt + <span class="number">1</span>);<span class="comment">//注：段限长是一个从 0 开始的计数，因此需要+1才能表示实际的字节数</span></span><br><span class="line">        <span class="comment">//更新数据,写到内存的物理地址(destPost)为0的地方</span></span><br><span class="line">        System.arraycopy(data, <span class="number">0</span>, memory, <span class="number">0</span>, limitInt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填好全局描述符表GDT</span></span><br><span class="line">    segDes.base = segBase.toCharArray();</span><br><span class="line">    segDes.limit = limit.toCharArray();</span><br><span class="line">    segDes.validBit = <span class="literal">true</span>;<span class="comment">//有效位,为true表示被占用（段已在内存中）</span></span><br><span class="line">    segDes.granularity = PAGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MMU类：​​​​toSegLinearAddr​​​​-逻辑地址转线性地址。"><a href="#MMU类：​​​​toSegLinearAddr​​​​-逻辑地址转线性地址。" class="headerlink" title="MMU类：​​​​toSegLinearAddr​​​​ 逻辑地址转线性地址。"></a>MMU类：​​​​toSegLinearAddr​​​​ 逻辑地址转线性地址。</h2><ul>
<li>在分段式下，逻辑地址转线性地址应该要查全局描述符表GDT，按照2.3.4的流程进行计算。<ul>
<li>48 位的逻辑地址包含 16 位的段选择符和 32 位的段内偏移量。</li>
<li>MMU首先通过段选择符内的 13 位<strong>索引值</strong>，</li>
<li>从段描述符表中找到对应的段描述符，从中取出 32 位的<strong>基地址</strong>，与逻辑地址中 32 位的<strong>段内偏移量</strong>相加，就得到 32 位线性地址。</li>
</ul>
</li>
<li>注意，不要以为可以偷懒直接把逻辑地址的前 16 位去掉</li>
</ul>
<ol>
<li>直接调用已有的函数获得<strong>段索引</strong>​​​​segIndex​​​​</li>
<li>根据段索引获得<strong>段基址</strong>，也是直接调用函数。将段基址<strong>转成int</strong></li>
<li>截取32位段内偏移​​​​offset​​​​，<strong>转成int</strong></li>
<li>段基址与段内偏移<strong>相加</strong>，<strong>转成32位二进制</strong>，得到线性地址</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 分段模式下的逻辑地址转线性地址</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> logicAddr 48位 = 16位段选择符(高13位index选择段表项) + 32位段内偏移</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 32-bits 线性地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String <span class="title function_">toSegLinearAddr</span><span class="params">(String logicAddr)</span> &#123;</span><br><span class="line">       <span class="comment">//获取段索引(高13位index选择段表项)</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">segIndex</span> <span class="operator">=</span> getSegIndex(logicAddr);</span><br><span class="line">       <span class="comment">//从全局描述符表GDT中获取段描述符中的段基址base</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">segBaseAddr</span> <span class="operator">=</span> String.valueOf(Memory.getMemory().getBaseOfSegDes(segIndex));</span><br><span class="line">       <span class="comment">//提取段内偏移（32位）</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">offset</span> <span class="operator">=</span> logicAddr.substring(<span class="number">16</span>, <span class="number">48</span>);</span><br><span class="line">       <span class="comment">//将段基址和段内偏移转换为整数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">segBaseAddrInt</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(segBaseAddr));</span><br><span class="line">       <span class="type">int</span> <span class="variable">offsetInt</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(offset));</span><br><span class="line">       <span class="comment">//计算线性地址</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">linearAddr</span> <span class="operator">=</span> segBaseAddrInt + offsetInt;</span><br><span class="line">       <span class="comment">//将线性地址转换为32位</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">linearAddrStr</span> <span class="operator">=</span> String.format(<span class="string">&quot;%32s&quot;</span>, Integer.toBinaryString(linearAddr)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">       <span class="keyword">return</span> linearAddrStr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h1><h2 id="Memory类：page-load页加载方法。"><a href="#Memory类：page-load页加载方法。" class="headerlink" title="Memory类：page_load页加载方法。"></a>Memory类：page_load页加载方法。</h2><ol>
<li>从磁盘上加载该页数据到内存。<ul>
<li>如何在磁盘上读取该页数据呢？你应该使用<strong>该虚页的起始地址</strong>作为作为访问磁盘的地址，用<strong>页大小</strong>作为读取的长度。</li>
<li>至于<strong>该虚页的起始地址</strong>是多少，可以直接根据<strong>虚页号</strong>得到。</li>
<li>那么加载过来之后写到内存的哪里呢？这就需要你找出一个<strong>空闲的物理页框</strong>然后放下去啦。</li>
</ul>
</li>
<li>除了加载数据，你还需要<strong>填好页表</strong>，如果你使用有效位数组的话还需要<strong>填好有效位数组</strong>。</li>
</ol>
<ul>
<li>变量：​​​​vPageNo​​​​ 虚拟页号</li>
</ul>
<h3 id="1-加载页数据"><a href="#1-加载页数据" class="headerlink" title="1. 加载页数据"></a>1. 加载页数据</h3><ol>
<li>使用<strong>该虚页的起始地址</strong>作为访问磁盘的地址，<strong>起始地址&#x3D;虚页号×一页大小</strong></li>
<li>由于<strong>一页的大小是4KB</strong>，需要把虚拟页号乘以<strong>2的12次方</strong>，<ul>
<li>即转为二进制作为地址，<strong>二进制后面加12个0</strong></li>
</ul>
</li>
<li>从<strong>磁盘读</strong>出一页数据data。（长度为​​​​PAGE_SIZE_B​​​​页长）</li>
</ol>
<h3 id="2-写入内存"><a href="#2-写入内存" class="headerlink" title="2. 写入内存"></a>2. 写入内存</h3><ol>
<li>寻找<strong>空闲内存的物理页框</strong>——遍历valid找false。</li>
</ol>
<ul>
<li>范围<code>​​​​0 ~ pageValid.length​​​</code>​，<ul>
<li>当​​​pageValid[i]​​​​<strong>为​false​​​​，说明不在内存中，即空闲</strong>，将其<strong>改为占用</strong>，并<strong>记录页框号​​​​frameNO</strong>​​​​。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>接着将<em>数据装入页框</em>。将<strong>页框号×页大小</strong>，获得<strong>物理地址</strong>，将数据写入内存。（长度为​​​​PAGE_SIZE_B​​​​页长）</li>
</ol>
<h3 id="3-填页表"><a href="#3-填页表" class="headerlink" title="3. 填页表"></a>3. 填页表</h3><ol>
<li>由虚拟页号获得该页（​​​​getPageItem(vPageNo)​​​​），</li>
</ol>
<ul>
<li>将​​​​pageFrame​​​​设为页框号二进制的低20位转成的数组（物理页框号）</li>
<li>将​​​​isInMem​​​​设为true。（装入了内存）</li>
</ul>
<ol start="2">
<li>填好有效位（刚刚占用的设为true）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 段页式存储下，从磁盘中加载数据</span></span><br><span class="line"><span class="comment"> * 不考虑16MB内存用满的情况</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> vPageNo 虚拟页号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">page_load</span><span class="params">(<span class="type">int</span> vPageNo)</span> &#123;</span><br><span class="line">    <span class="comment">//虚拟页号的起始地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">vPageStartAddr</span> <span class="operator">=</span> Transformer.intToBinary(String.valueOf(vPageNo)).substring(<span class="number">12</span>) + <span class="string">&quot;000000000000&quot;</span>;</span><br><span class="line">    <span class="comment">//页大小作为读取的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> PAGE_SIZE_B;</span><br><span class="line">    <span class="comment">//从磁盘中加载数据</span></span><br><span class="line">    <span class="type">byte</span>[] data = disk.read(vPageStartAddr, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找出一个空闲的物理页框</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">freePageFrame</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;pageValid.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pageValid[i])&#123;<span class="comment">//如果该页不在内存中,即valid=false</span></span><br><span class="line">            freePageFrame = i;<span class="comment">//找到空闲的物理页框i</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (freePageFrame == -<span class="number">1</span>)&#123;<span class="comment">//无空闲</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;No free page frame&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据写到内存的物理地址为freePageFrame的地方</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">phyAddr</span> <span class="operator">=</span> freePageFrame * PAGE_SIZE_B;<span class="comment">//物理地址，即物理页框号*页大小</span></span><br><span class="line">    System.arraycopy(data, <span class="number">0</span>, memory, phyAddr, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填好页表</span></span><br><span class="line">    <span class="type">PageItem</span> <span class="variable">pageItem</span> <span class="operator">=</span> getPageItem(vPageNo);</span><br><span class="line">    pageItem.pageFrame = Transformer.intToBinary(String.valueOf(freePageFrame)).substring(<span class="number">12</span>).toCharArray();<span class="comment">//物理页框号</span></span><br><span class="line">    pageItem.isInMem = <span class="literal">true</span>;<span class="comment">//装入位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//填好有效位数组</span></span><br><span class="line">    pageValid[freePageFrame] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修改seg-load方法。"><a href="#修改seg-load方法。" class="headerlink" title="修改seg_load方法。"></a>修改seg_load方法。</h2><ul>
<li>因此开启分页之后，seg_load应该跳过加载数据这一步，它的作用在开启分页之后仅仅是填写GDT，加载数据的任务应该交给page_load来完成。</li>
<li>即<strong>if(!PAGE)</strong> {加载数据}</li>
</ul>
<h2 id="MMU类：toPagePhysicalAddr页级地址转换方法"><a href="#MMU类：toPagePhysicalAddr页级地址转换方法" class="headerlink" title="MMU类：toPagePhysicalAddr页级地址转换方法"></a>MMU类：toPagePhysicalAddr页级地址转换方法</h2><ul>
<li>在段页式下，线性地址转物理地址需要查页表，然后进行虚拟页号到物理页号的替换，具体流程可以参考课件。</li>
</ul>
<ol>
<li>从<strong>线性地址</strong>中<strong>提取前 20 位作为虚拟页号</strong>，<strong>后 12 位作为页内偏移</strong>。</li>
<li><strong>物理页号的获取</strong>（TLB是否可用）：都是使用 <code>getFrameOfPage</code> 函数，区别在于类不同<ol>
<li>如果开启了tlb，TLB<ul>
<li>调用<strong>tlb类的函数</strong>，由虚拟页号获取</li>
</ul>
</li>
<li>未开启，内存<ul>
<li>调用<strong>Memory类的函数</strong>，由虚拟页号获取</li>
</ul>
</li>
</ol>
</li>
<li>最后，将<strong>物理页号与页内偏移拼接</strong>获得物理地址。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 段页式下的线性地址转物理地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> linearAddr 32位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 32-bits 物理地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">toPagePhysicalAddr</span><span class="params">(String linearAddr)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="comment">//获取虚拟页号（线性地址的高20位）+获取页内偏移（线性地址的低12位）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">vPageNo</span> <span class="operator">=</span> linearAddr.substring(<span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">offset</span> <span class="operator">=</span> linearAddr.substring(<span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">vPageNoInt</span> <span class="operator">=</span> Integer.parseInt(Transformer.binaryToInt(vPageNo));</span><br><span class="line">    <span class="comment">//查页表，获取物理页号</span></span><br><span class="line">    <span class="type">char</span>[] pageFrame;</span><br><span class="line">    <span class="keyword">if</span>(TLB.isAvailable)&#123;</span><br><span class="line">        <span class="comment">//如果TLB可用，从TLB中获取物理页号</span></span><br><span class="line">        pageFrame = TLB.getTLB().getFrameOfPage(vPageNoInt);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果TLB不可用，从内存中获取物理页号</span></span><br><span class="line">        pageFrame = Memory.getMemory().getFrameOfPage(vPageNoInt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">pageFrameStr</span> <span class="operator">=</span> String.valueOf(pageFrame);</span><br><span class="line">    <span class="comment">//将物理页号和页内偏移拼接为物理地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">physicalAddr</span> <span class="operator">=</span> pageFrameStr + offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> physicalAddr;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> add tlb here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-cache与TLB的融合"><a href="#4-cache与TLB的融合" class="headerlink" title="4. cache与TLB的融合"></a>4. cache与TLB的融合</h1><h2 id="a-将cache融合进MMU中"><a href="#a-将cache融合进MMU中" class="headerlink" title="a. 将cache融合进MMU中"></a>a. 将cache融合进MMU中</h2><ul>
<li>这一步相对简单。需要注意，由于cache是memory的缓存，所以任何涉及到访问主存数据的地方都要添加对cache的调用。</li>
<li>只有两个标了todo的地方需要改，MMU类的read和write。直接加入<strong>当cache有效时，通过cache读&#x2F;写</strong>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] read(String logicAddr, <span class="type">int</span> length) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">physicalAddr</span> <span class="operator">=</span> addressTranslation(logicAddr, length);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> add cache here</span></span><br><span class="line">    <span class="keyword">if</span> (Cache.isAvailable) &#123;<span class="comment">//如果cache可用</span></span><br><span class="line">        <span class="keyword">return</span> cache.read(physicalAddr, length);<span class="comment">//从cache中读取数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果cache不可用,直接从内存中读取数据</span></span><br><span class="line">    <span class="keyword">return</span> memory.read(physicalAddr, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String logicAddr, <span class="type">int</span> length, <span class="type">byte</span>[] data)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">physicalAddr</span> <span class="operator">=</span> addressTranslation(logicAddr, length);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> add cache here</span></span><br><span class="line">    <span class="keyword">if</span> (Cache.isAvailable) &#123;<span class="comment">//如果cache可用</span></span><br><span class="line">        cache.write(physicalAddr, length, data);<span class="comment">//将数据写入cache</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无论cache是否可用，都要将数据写入内存</span></span><br><span class="line">    memory.write(physicalAddr, length, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="b-将TLB融合进MMU中"><a href="#b-将TLB融合进MMU中" class="headerlink" title="b. 将TLB融合进MMU中"></a>b. 将TLB融合进MMU中</h2><ol>
<li>MMU类<code>addressTranslation</code>函数。在标出的地方判断<ul>
<li>若TLB有效：若<strong>tlb中没有该页</strong>且<strong>内存中没有该页</strong>，缺页中断<ul>
<li>内存从磁盘加载该页的数据。</li>
<li>并且将该页写入tlb。<code>tlb.write(i);</code></li>
</ul>
</li>
<li>若TLB无效：<strong>直接判断内存</strong>中有没有该页（应该是有代码的）</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> add tlb here</span></span><br><span class="line"><span class="comment">//1. 启用TLB之后，判断是否缺页的工作应该首先交给TLB来完成。</span></span><br><span class="line"><span class="comment">//2. 如果发生缺页，page_load方法会进行填页表，填页表之后不要忘记填TLB。</span></span><br><span class="line"><span class="keyword">if</span> (TLB.isAvailable)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tlb.isValidPage(i))&#123;<span class="comment">//如果TLB中不存在该页</span></span><br><span class="line">    <span class="comment">// 缺页中断，该页不在内存中，内存从磁盘加载该页的数据</span></span><br><span class="line">        memory.page_load(i);<span class="comment">//从磁盘中加载数据,并填写页表</span></span><br><span class="line">        tlb.write(i);<span class="comment">//填写TLB</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (!memory.isValidPage(i)) &#123;</span><br><span class="line">    <span class="comment">// 缺页中断，该页不在内存中，内存从磁盘加载该页的数据</span></span><br><span class="line">    memory.page_load(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>toPagePhysicalAddr</code>方法，上面讲过了。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(TLB.isAvailable)&#123;</span><br><span class="line">    <span class="comment">//如果TLB可用，从TLB中获取物理页号</span></span><br><span class="line">    pageFrame = TLB.getTLB().getFrameOfPage(vPageNoInt);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果TLB不可用，从内存中获取物理页号</span></span><br><span class="line">    pageFrame = Memory.getMemory().getFrameOfPage(vPageNoInt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>COA上机</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/02/20/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
  </entry>
  <entry>
    <title>一、计算机网络及其参考模型</title>
    <url>/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="互联网计算"><a href="#互联网计算" class="headerlink" title="互联网计算"></a>互联网计算</h1><h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p> 10% 大作业 + 40% 上机 + 50% 期末</p>
<h2 id="课程资料"><a href="#课程资料" class="headerlink" title="课程资料"></a>课程资料</h2><p>219.219.113.233<br>用户:net<br>密码:net</p>
<h1 id="一、计算机网络概述"><a href="#一、计算机网络概述" class="headerlink" title="一、计算机网络概述"></a>一、计算机网络概述</h1><h3 id="1-What-is-a-network"><a href="#1-What-is-a-network" class="headerlink" title="1. What is a network?"></a>1. What is a network?</h3><ul>
<li>物体,事物,设备,人的连接</li>
<li><strong>LAN</strong>(Local Area Networks) 局域网</li>
<li><strong>WAN</strong>(Wide Area Networks) 广域网</li>
</ul>
<h2 id="2-数据网络分类：LAN-WAN"><a href="#2-数据网络分类：LAN-WAN" class="headerlink" title="2. 数据网络分类：LAN&#x2F;WAN"></a>2. 数据网络分类：LAN&#x2F;WAN</h2><ol>
<li>LANs 局域网 广播方式通信<ol>
<li>Operate locally</li>
<li>Multi-user access 连接可以被共享</li>
<li>High speeds expected 最高达到800G (距离短)</li>
<li>Error rate is easily controlled 因为范围小好判断出错</li>
</ol>
</li>
<li>WANs 广域网<ul>
<li>先于 LAN 网络产生</li>
</ul>
<ol>
<li>Operate over larger areas 现在主要使用光纤</li>
<li>Access over serial links, optical links, etc. <strong>点对点的连接</strong></li>
<li>Traditionally, have <strong>lower</strong> speeds</li>
<li>Error rate can <strong>not</strong> be easily controlled</li>
</ol>
</li>
<li>网络抽象模型<ul>
<li>node：节点</li>
<li>link：链路</li>
</ul>
</li>
</ol>
<h3 id="2-1-局域网和广域网差别"><a href="#2-1-局域网和广域网差别" class="headerlink" title="2.1 局域网和广域网差别"></a>2.1 局域网和广域网差别</h3><ol>
<li>局域网<ul>
<li>作用<strong>范围比较窄</strong></li>
<li>多用户<strong>同时复用链路介质</strong></li>
<li>网络<strong>性能比较高</strong>（一般是一个公司来管理处理，可以达到 GPS 甚至是 10GPS）</li>
<li><strong>出错率</strong>相对比较容易控制（<strong>低</strong>）</li>
</ul>
</li>
<li>广域网<ul>
<li>在比较<strong>大的地理范围</strong>上进行连接</li>
<li>要么<strong>串行连接（serial links）</strong>，要么<strong>光链路连接（optical links）</strong></li>
<li>传统上，<strong>传输速率比较低</strong>，因为一般是多公司管理，标准和介质等都不同</li>
<li><strong>出错率</strong>相对比较<strong>高</strong></li>
</ul>
</li>
</ol>
<h3 id="2-2-LAN-Devices-局域网设备"><a href="#2-2-LAN-Devices-局域网设备" class="headerlink" title="2.2 LAN Devices 局域网设备"></a>2.2 LAN Devices 局域网设备</h3><ol>
<li>Hub 集线器：工作在第一层<ul>
<li>多端口中继器（Reapter），连接 PC</li>
<li>重复信号</li>
</ul>
</li>
<li>Bridge 网桥：工作在第二层<ul>
<li>将局域网分段</li>
<li>进行 MAC 地址的计算</li>
</ul>
</li>
<li>Switch 交换机，多端口网桥：工作在第二层<ul>
<li>多端口网桥</li>
<li>全带宽（满带宽）</li>
<li>大规模集成电路实现：相对于网桥的优点</li>
</ul>
</li>
<li>Router 路由器 ：工作在第三层<ul>
<li>路径选择</li>
<li>分组交换<br><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-1.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ol>
<h3 id="2-3-WAN-Devices-广域网设备"><a href="#2-3-WAN-Devices-广域网设备" class="headerlink" title="2.3 WAN Devices 广域网设备"></a>2.3 WAN Devices 广域网设备</h3><ol>
<li>Router 路由器<ul>
<li>路径选择</li>
<li>分组交换</li>
</ul>
</li>
<li>Modem: 调制解调器</li>
<li>CSU&#x2F;DSU: 通道服务单元&#x2F;数据服务单元</li>
<li>TA&#x2F;NT1: 终端适配器&#x2F;网络终端1</li>
</ol>
<ul>
<li>234都是将<em>模拟信号转换为数字信号</em>, 还可以进行<em>远程局域网连接</em></li>
</ul>
<h3 id="2-4-LAN-Services-and-WAN-Services"><a href="#2-4-LAN-Services-and-WAN-Services" class="headerlink" title="2.4 LAN Services and WAN Services"></a>2.4 LAN Services and WAN Services</h3><ol>
<li>LAN Service: <strong>Ethernet</strong> (以太网) 最流行的局域网服务</li>
<li>WAN Service: 有很多,不是本节课重点</li>
</ol>
<h2 id="3-Internet-互联网"><a href="#3-Internet-互联网" class="headerlink" title="3. Internet 互联网"></a>3. Internet 互联网</h2><ol>
<li>简介</li>
</ol>
<ul>
<li>互联网, 全球性的计算机网络系统, 将世界各地的局域网（LAN）,广域网（WAN）和其他类型的网络连接在一起</li>
<li>全球最大的开放性广域网</li>
<li>TCP&#x2F;IP 作为参考标准</li>
<li>从 ARPNET 发展出来</li>
</ul>
<h3 id="3-1-Internet-with-Multi-layer-ISP-structure（多层-ISP-结构的-Internet"><a href="#3-1-Internet-with-Multi-layer-ISP-structure（多层-ISP-结构的-Internet" class="headerlink" title="3.1 Internet with Multi-layer ISP structure（多层 ISP 结构的 Internet"></a>3.1 Internet with Multi-layer ISP structure（多层 ISP 结构的 Internet</h3><ol>
<li><strong>Internet Service Providers（ISP）：互联网服务提供商</strong><ul>
<li>user——ISP——Internet</li>
</ul>
</li>
<li>具有多层 ISP 结构的 Internet<ul>
<li>主机A → 本地 ISP → 第二层 ISP → NAP → 第一层 ISP → NAP → 第二层 ISP → 本地 ISP → 主机B<br><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-2.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
</ol>
<ul>
<li><strong>第一层 ISP 是核心层</strong>，主要负责<strong>远距离连通。</strong></li>
<li>这种多层 ISP 结构可以将大量的流量本地化</li>
<li>NAP（Network Access Point）：第一二层之间的接入点，也可以是 google（大公司）直接和第一层 ISP 进行链接</li>
<li>ICP（Internet Content Provider）：互联网内容提供商，不提供接入服务</li>
<li>在低层次的 ISP 可以解决的问题就不进入上一层进行解决，将大量的流量分流。</li>
</ul>
<h1 id="二、计算机网络基本概念"><a href="#二、计算机网络基本概念" class="headerlink" title="二、计算机网络基本概念"></a>二、计算机网络基本概念</h1><h2 id="1-Data数据"><a href="#1-Data数据" class="headerlink" title="1. Data数据"></a>1. Data数据</h2><ul>
<li>Data is sent in bits, 1s and 0s.<ul>
<li><strong>数据按位（1 和 0）为单位发送</strong></li>
</ul>
</li>
<li>Data is not the information itself.<ul>
<li><strong>数据不是信息本身</strong>，不同方式解析数据会是不同信息<ul>
<li>数据都是 0-1 序列，需要按照一定编码格式翻译转码才成为信息</li>
</ul>
</li>
</ul>
</li>
<li>Data is an encoded form of information which is a series of electrical impulses&#x2F;optical signals into which information is transmitted for sending.<ul>
<li><strong>数据是信息的一种编码形式</strong>，它是一系列电脉冲&#x2F;光信号，信息被传输到其中进行发送</li>
</ul>
</li>
</ul>
<h3 id="1-1-Data-Packets数据包"><a href="#1-1-Data-Packets数据包" class="headerlink" title="1.1 Data Packets数据包"></a>1.1 Data Packets数据包</h3><ol>
<li>为了传输，计算机数据通常被分解成<strong>小的、易于传输的单元</strong><ul>
<li>使用 OSI 模型</li>
<li>这些单元可以称为：包packets、帧frames、段segments</li>
<li>具体取决于OSI模型的不同层次<ul>
<li>网络层称为 packets 报文，数据链路层称为 frames 帧，数据段层称为 segments 段</li>
</ul>
</li>
</ul>
</li>
<li>why data packets? 为什么使用数据包？<ul>
<li>Computers can take turns sending packets<ul>
<li><strong>计算机可以轮流发送数据包</strong>，分时段处理不同报文，使得<em>多进程</em>处理事务。</li>
</ul>
</li>
<li>If packet is lost, only small amount of data must be retransmitted重新传输.<ul>
<li>如果数据包<strong>丢失，则只需重新传输少量数据</strong></li>
</ul>
</li>
<li>Data can take different paths.<ul>
<li>数据可以采用<strong>不同的路径</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="1-2-Protocol协议"><a href="#1-2-Protocol协议" class="headerlink" title="1.2 Protocol协议"></a>1.2 Protocol协议</h3><ol>
<li>It is possible for different types of computer systems to communicate<ul>
<li><strong>不同类型的计算机系统可</strong>以进行<strong>通信</strong></li>
</ul>
</li>
<li>All devices must speak the same “language” or use the same <strong>protocol</strong> (use same set of rules).<ul>
<li>所有设备必须使用<strong>相同的“语言”或使用相同的协议</strong>（使用同一套规则）。</li>
</ul>
</li>
</ol>
<h3 id="1-3-Source-and-Destination源地址和目标地址"><a href="#1-3-Source-and-Destination源地址和目标地址" class="headerlink" title="1.3 Source and Destination源地址和目标地址"></a>1.3 Source and Destination源地址和目标地址</h3><ul>
<li><strong>源地址</strong> Source address specifies the identity of the computer sending the packet.<ul>
<li><strong>发送数据包</strong>的计算机的身份</li>
</ul>
</li>
<li><strong>目标地址</strong> Destination address specifies the identity of the computer designated to receive the packet.<ul>
<li><strong>接收数据包</strong>的计算机的身份</li>
</ul>
</li>
</ul>
<h3 id="1-4-传输介质-Media-Types"><a href="#1-4-传输介质-Media-Types" class="headerlink" title="1.4 传输介质 Media Types"></a>1.4 传输介质 Media Types</h3><ol>
<li>Media—material through which data packets travel<ul>
<li>介质是数据包传输所通过的介质。</li>
</ul>
</li>
<li><strong>带宽 Bandwidth</strong>：<ul>
<li>is the measure of how much information can flow from one place to another in a given amount of time.带宽是指在单位时间内可以传输的最大数据量</li>
<li>Measured in: bits&#x2F;second (bps)通常以比特每秒（bps）为单位。<ul>
<li>单位：bps，计算时注意要<strong>将字转换为位</strong></li>
</ul>
</li>
<li>作用: 带宽决定了网络的最大传输能力。带宽越高，网络能够传输的数据量就越大。</li>
<li>类比: 可以将带宽类比为高速公路的车道数，车道越多，能够同时通过的车辆就越多。</li>
</ul>
</li>
<li>通量 Throughput：<ul>
<li>Actual measured bandwidth at a specific time <em>单位时间</em>内<strong>实际</strong>传输的数据量，也以*比特每秒（bps）*为单位。</li>
<li><strong>Throughput &lt;&#x3D; Bandwidth</strong></li>
<li>作用: 通量反映了网络的实际性能，通常会受到网络拥塞、延迟、丢包等因素的影响。</li>
<li>类比: 通量可以类比为高速公路上实际通过的车辆数，即使高速公路有很多车道，但如果有交通堵塞，实际通过的车辆数也会减少。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="三、OSI-参考模型"><a href="#三、OSI-参考模型" class="headerlink" title="三、OSI 参考模型"></a>三、OSI 参考模型</h1><h2 id="1-OSI-Open-System-Interconnection-Model开放系统互连参考模型"><a href="#1-OSI-Open-System-Interconnection-Model开放系统互连参考模型" class="headerlink" title="1. OSI (Open System Interconnection) Model开放系统互连参考模型"></a>1. OSI (Open System Interconnection) Model开放系统互连参考模型</h2><ul>
<li>由国际标准化组织 （ISO） 提议 </li>
<li>是一个<strong>分层的网络架构模型</strong>，用于<em>标准化网络通信的功能</em></li>
<li>帮助网络构建者实现<strong>可以通信和协同工作</strong>的网络模型 </li>
<li>描述<em>信息或数据</em>如何<em>通过网络</em>从一台计算机<em>移动到另一台计算机</em> </li>
<li><strong>分层通信</strong>过程：每一层执行一项特定任务</li>
</ul>
<h2 id="2-The-OSI-Reference-Model层次模型"><a href="#2-The-OSI-Reference-Model层次模型" class="headerlink" title="2. The OSI Reference Model层次模型"></a>2. The OSI Reference Model层次模型</h2><p>+——————-+<br>|   应用层 (Layer 7)<br>|   Application<br>+——————-+<br>|   表示层 (Layer 6)<br>|   Presentation<br>+——————-+<br>|   会话层 (Layer 5)<br>|   Session<br>+——————-+<br>|   传输层 (Layer 4)<br>|   Transport<br>+——————-+<br>|   网络层 (Layer 3)<br>|   Network<br>+——————-+<br>|   数据链路层 (Layer 2)<br>|   Data Link<br>+——————-+<br>|   物理层 (Layer 1)<br>|   Physical<br>+——————-+</p>
<h2 id="3-OSI模型的七层结构"><a href="#3-OSI模型的七层结构" class="headerlink" title="3. OSI模型的七层结构"></a>3. OSI模型的七层结构</h2><ul>
<li><ol>
<li><strong>物理层</strong> (Physical Layer)</li>
</ol>
<ul>
<li>Keywords: <strong>Signal and Media 信号和介质</strong></li>
<li>Binary transmission 二进制传输</li>
<li>功能: 负责传输原始的比特流。</li>
</ul>
</li>
<li><ol start="2">
<li><strong>数据链路层</strong> (Data Link Layer)</li>
</ol>
<ul>
<li>Keywords: <strong>frame, media access control 帧和介质访问控制</strong></li>
<li>Access to media 介质访问</li>
<li>功能: 负责节点之间的可靠传输。负责帧的创建、传输和错误检测。</li>
</ul>
</li>
<li><ol start="3">
<li><strong>网络层</strong> (Network Layer)</li>
</ol>
<ul>
<li>Keywords: <strong>Path selection路径选择, Routing路由, Addressing寻址</strong></li>
<li>Addresses and best path <strong>路径选择，最优路径</strong></li>
<li>功能: 在进行路由的两个终端系统之间提供连接和路径选择</li>
</ul>
</li>
<li><ol start="4">
<li><strong>传输层</strong> (Transport Layer)</li>
</ol>
<ul>
<li>Keywords: <strong>Reliability可靠性, Flow control流量控制, Error correction纠错</strong></li>
<li>End-to-end connections 终端到终端通信</li>
<li>功能: 负责终端节点之间的可靠网络通信，负责数据传输的流量控制，并为虚拟电路的建立、维护和终止、传输故障检测和恢复提供机制</li>
</ul>
</li>
<li><ol start="5">
<li><strong>会话层</strong> (Session Layer)</li>
</ol>
<ul>
<li>Keywords: <strong>Dialog and Conversations 对话和交流</strong></li>
<li>Inter-host connection 进程之间通信如何用户交流</li>
<li>功能: 管理和控制（建立、维护和终止）应用程序之间的会话；manages data exchange between presentation layer entities管理表示层实体之间的数据交换。</li>
</ul>
</li>
<li><ol start="6">
<li><strong>表示层</strong> (Presentation Layer)</li>
</ol>
<ul>
<li>Keywords:<strong>Common Format 标准</strong></li>
<li>Data presentation and encryption 展示</li>
<li>功能: 负责数据的格式化、加密和解密，确保数据的语法和语义正确。</li>
</ul>
</li>
<li><ol start="7">
<li><strong>应用层</strong> (Application Layer)</li>
</ol>
<ul>
<li>Keyword: <strong>Browser 浏览</strong></li>
<li>User interface 给用户展示交互接口</li>
<li>功能: 提供网络服务和应用程序接口，直接为用户和应用程序提供服务。</li>
</ul>
</li>
</ul>
<h2 id="4-分组"><a href="#4-分组" class="headerlink" title="4. 分组"></a>4. 分组</h2><ul>
<li>（1）application layers<strong>应用层</strong><ul>
<li>Application应用</li>
<li>Presentation展示</li>
<li>Session会话</li>
<li>deal with the user interface, data formatting, and the application access<ul>
<li>处理了用户接口，数据格式和应用权限</li>
</ul>
</li>
</ul>
</li>
<li>（2）data flow layers<strong>数据流层</strong><ul>
<li>Transport传输<br> Network网络<br> Data Link数据链路<br> Physical物理</li>
<li>control the physical delivery of messages over the network.<ul>
<li>控制着通过网络传输的数据信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-Data-Encapsulation数据封装"><a href="#5-Data-Encapsulation数据封装" class="headerlink" title="5. Data Encapsulation数据封装"></a>5. Data Encapsulation数据封装</h2><ul>
<li><p>定义：<br>数据封装是指在网络通信中，数据在传输过程中<code>通过各层协议逐层添加协议头（header）和协议尾（trailer）</code>的过程。每一层协议都在数据包的<code>前面或后面添加特定的信息</code>，以便在接收端能够正确地解析和处理数据。</p>
</li>
<li><p>基本步骤：</p>
<ol start="7">
<li>应用层（Application Layer）：<br> 数据生成并准备传输。</li>
<li>表示层（Presentation Layer）：<br> 数据格式化和加密。</li>
<li>会话层（Session Layer）：<br> 管理会话和数据交换。</li>
<li>传输层（Transport Layer）：<br> 添加<strong>传输层头部</strong>（如TCP&#x2F;UDP头），用于数据分段和重组。</li>
<li>网络层（Network Layer）：<br> 添加网<strong>络层头部</strong>（如IP头），用于路由和寻址。</li>
<li>数据链路层（Data Link Layer）：<br> 添加<strong>数据链路层头部和尾部</strong>（如MAC地址和帧<em>校验</em>序列），用于帧的传输和错误检测。</li>
<li>物理层（Physical Layer）：<br> 将数据转换为电信号或光信号，通过物理介质传输。</li>
</ol>
</li>
<li><p>数据封装过程</p>
<ul>
<li>5-&gt;4：添加首部 H5，应用程序数据作为数据部分</li>
<li>4-&gt;3：添加首部 H4，第五层的作为数据部分</li>
<li>3-&gt;2：添加首部 H3，第四层的作为数据部分</li>
<li>2-&gt;1：添加首部 H2 和尾部 T2（校验位），第三层的作为数据部分</li>
<li>1：转成比特流进行发送</li>
</ul>
</li>
<li><p>在接收端，数据封装的过程将逆向进行，即逐层剥离协议头和协议尾，直到还原出原始数据。</p>
</li>
</ul>
<h2 id="6-Peer-to-Peer-Communications-点对点通信"><a href="#6-Peer-to-Peer-Communications-点对点通信" class="headerlink" title="6. Peer-to-Peer Communications 点对点通信"></a>6. Peer-to-Peer Communications 点对点通信</h2><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/peertopeer%20communications.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h1 id="四、TCP-IP-Model"><a href="#四、TCP-IP-Model" class="headerlink" title="四、TCP&#x2F;IP Model"></a>四、TCP&#x2F;IP Model</h1><h2 id="1-组成"><a href="#1-组成" class="headerlink" title="1. 组成"></a>1. 组成</h2><ul>
<li>含有<strong>四层</strong><ul>
<li>应用层Application</li>
<li>传输层Transport</li>
<li>网络层Internet</li>
<li>网络访问层Network Access</li>
</ul>
</li>
</ul>
<h2 id="2-功能"><a href="#2-功能" class="headerlink" title="2.功能"></a>2.功能</h2><ul>
<li>（1）<strong>Application Layer 应用层</strong><ul>
<li>处理高级协议、表示、编码和会话控制问题<ul>
<li>包含[OSI]中上三层（应用层、表示层、会话层）的全部功能</li>
</ul>
</li>
<li>Handles <strong>high-level protocols</strong>, issues of <strong>representation, encoding, and session control</strong></li>
<li>TCP&#x2F;IP将所有与应用程序相关的问题合并到一个层中，并确保这些数据被正确打包到下一层。</li>
</ul>
</li>
<li>（2）<strong>Transport Layer 传输层</strong><ul>
<li>处理服务质量问题，如可靠性、流量控制和错误校正 <ul>
<li>对应[OSI]中第4层：传输层</li>
</ul>
</li>
<li>Deals with the quality-of-service issues of <strong>reliability, flow control, and error correction</strong>.</li>
</ul>
</li>
<li>（3）<strong>Internet Layer 网络层</strong><ul>
<li>最优路径的选择（报文从一方发送给另一方，报文传输经过<em>路由器</em>进行路径选择）<ul>
<li>对应[OSI]中第3层：网络层</li>
</ul>
</li>
<li><strong>Best path determination and packet switching</strong></li>
</ul>
</li>
<li>（4）<strong>Network Access 网络接入层</strong><ul>
<li>也称为<strong>host-to-network layer 主机到网络层</strong>。 <ul>
<li>包含[OSI]中下两层：物理层和数据链路层</li>
</ul>
</li>
<li>它关注 IP 分组实际建立物理链路，然后建立另一个物理链路所需的所有问题。</li>
<li>它包括 LAN 和 WAN 技术的细节，以及 OSI 物理和数据链路层中的所有细节。</li>
</ul>
</li>
</ul>
<h2 id="3-名词解释——常见的TCP-IP协议"><a href="#3-名词解释——常见的TCP-IP协议" class="headerlink" title="3.名词解释——常见的TCP&#x2F;IP协议"></a>3.名词解释——常见的TCP&#x2F;IP协议</h2><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-3.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>FTP <ul>
<li>File Transfer Protocol 文件传输协议</li>
</ul>
</li>
<li>HTTP <ul>
<li>Hypertext Transfer Protocol 超文本传输协议</li>
<li>主要用于浏览器</li>
</ul>
</li>
<li>SMTP <ul>
<li>Simple Mail Transfer protocol 简单邮件传输协议</li>
</ul>
</li>
<li>DNS <ul>
<li>Domain Name System 域名解析系统</li>
<li>将域名解析成IP地址</li>
</ul>
</li>
<li>TFTP <ul>
<li>Trivial File Transfer Protocol 简单文件传输协议</li>
<li>基于UDP，在局域网发送较小文件</li>
</ul>
</li>
</ul>
<h2 id="4-TCP-IP-和-OSI-的相似点"><a href="#4-TCP-IP-和-OSI-的相似点" class="headerlink" title="4. TCP&#x2F;IP 和 OSI 的相似点"></a>4. TCP&#x2F;IP 和 OSI 的相似点</h2><ul>
<li>both have layers, networking professionals need to know both<ul>
<li>层次</li>
</ul>
</li>
<li>both have application layers, though they include very different services <ul>
<li>应用层（虽然服务不同）</li>
</ul>
</li>
<li>both have comparable transport and network layers <ul>
<li>相同的传输层和网络层</li>
</ul>
</li>
<li>packet-switched (not circuit-switched) technology is assumed <ul>
<li>假设采用<strong>分组交换（非电路交换）技术</strong></li>
</ul>
</li>
<li>OSI 是<strong>基于报文交换</strong>来进行实现的，TCP&#x2F;IP 也是基于报文交换来完成实现的。</li>
</ul>
<h2 id="5-TCP-IP-和-OSI-的不同点"><a href="#5-TCP-IP-和-OSI-的不同点" class="headerlink" title="5.TCP&#x2F;IP 和 OSI 的不同点"></a>5.TCP&#x2F;IP 和 OSI 的不同点</h2><ol>
<li>TCP&#x2F;IP 看起来更简单，因为它有更少的层</li>
<li><strong>TCP&#x2F;IP 协议是因特网发展的标准，因此 TCP&#x2F;IP 模型正是因为它的协议才获得了可信性</strong>。</li>
<li>通常网络不是建立在 OSI 协议之上的，即使 OSI 模型被用作指南。</li>
<li><strong>TCP&#x2F;IP 标准是大家都在使用的标准（实施标准）</strong>，5 层和 7 层都只是讲课使用的</li>
<li>本课程我们一般使用<strong>5 层</strong>来进行分割讲解。<br><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-4.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ol>
<hr>
<h1 id="五-Network-Topology-网络拓扑"><a href="#五-Network-Topology-网络拓扑" class="headerlink" title="五.Network Topology 网络拓扑"></a>五.Network Topology 网络拓扑</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><ul>
<li>网络拓扑是指<strong>网络中各个节点</strong>（如计算机、路由器、交换机等）之间的<strong>物理或逻辑连接方式</strong>。不同的网络拓扑结构有不同的特点和适用场景。</li>
</ul>
<h2 id="2-常见的网络拓扑结构包括："><a href="#2-常见的网络拓扑结构包括：" class="headerlink" title="2.常见的网络拓扑结构包括："></a>2.常见的网络拓扑结构包括：</h2><ul>
<li>物理拓扑：导线（介质）的实际布局<ul>
<li>总线、星形、环形、扩展星形、分层（树形）、渔网型（mesh）</li>
<li>如何把节点具体连接起来<br><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-5.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li>逻辑拓扑：定义主机如何访问媒体<ul>
<li>令牌传递，使用 token 来获取通信的权利</li>
<li>主要涉及到管理介质如何被访问</li>
</ul>
</li>
<li>逻辑拓扑：主要是指如何在逻辑上如何控制网络</li>
</ul>
<h3 id="1-总线拓扑（Bus-Topology）"><a href="#1-总线拓扑（Bus-Topology）" class="headerlink" title="1. 总线拓扑（Bus Topology）"></a>1. 总线拓扑（Bus Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-6.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Physical Perspective：<ul>
<li><strong>所有节点通过一条主干电缆连接</strong>。</li>
<li>数据在主干电缆上传输，所有节点都能接收到数据。</li>
<li>优点：<ul>
<li>所有主机都可以直接通信。</li>
</ul>
</li>
<li>缺点：<ul>
<li>主干电缆故障会导致整个网络瘫痪，断开主机之间的连接。</li>
</ul>
</li>
</ul>
</li>
<li>Logical Perspective：<ul>
<li>Every networking device to see all signals from all other devices</li>
<li><strong>每个网络设备都可以看到来自所有其他设备的所有信号</strong>，实际上是广播式传播</li>
<li>优点：比较简单，所有的设备都可以监听到总线的信号。</li>
<li>缺点：<ul>
<li>信号冲突，需要进行复杂的介质访问权限控制来保证通信正常</li>
<li>如果<strong>一处断开，则全部无法</strong>进行网络传输</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-环形拓扑（Ring-Topology）"><a href="#2-环形拓扑（Ring-Topology）" class="headerlink" title="2. 环形拓扑（Ring Topology）"></a>2. 环形拓扑（Ring Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-7.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Physical Perspective：<ul>
<li><strong>所有的设备直接首尾相连，组成一个菊花链（daisy-chain）</strong></li>
<li>数据沿着环路单向或双向传输。</li>
<li>优点：<ul>
<li>数据传输延迟较小。</li>
<li>适用于负载均衡。</li>
</ul>
</li>
<li>缺点：<ul>
<li><strong>任意一个节点或连接故障都会影响整个网络</strong>。</li>
<li>故障定位和修复较为复杂。</li>
</ul>
</li>
</ul>
</li>
<li>Logical Perspective<ul>
<li>为了使信息流动，每个站点必须将信息传递给其相邻的站点。</li>
<li>我们需要对于链路进行访问控制，防止很多设备同时使用环，我们使用 token 来进行控制访问权力</li>
</ul>
</li>
</ul>
<h3 id="3-双环拓扑（Dual-Ring-Topology）"><a href="#3-双环拓扑（Dual-Ring-Topology）" class="headerlink" title="3. 双环拓扑（Dual Ring Topology）"></a>3. 双环拓扑（Dual Ring Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-8.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Physical Perspective<ul>
<li>每个节点通过两条环形链路连接到相邻节点，形成<code>两个</code>独立的环。</li>
<li>双环拓扑是指一个节点有两个点，同时只能一个环在传输信息，两个环的传输时的方向是不能确定的。</li>
</ul>
</li>
<li>Logical Perspective<ul>
<li>双环拓扑就像两个独立的环，<strong>同一时间只有一个环被应用</strong>。</li>
<li>有 token 令牌才有发送权力发送信息（使用总线）</li>
</ul>
</li>
<li>优点:<ul>
<li>提供可靠性和灵活性</li>
<li>容错性：一个环出现故障时，数据可以通过另一个环继续传输，确保网络的可靠性。</li>
</ul>
</li>
<li>Eg.优先使用外环，如果外环出现物理错误，则切换到内环上使用，并且对外环进行物理修复。</li>
</ul>
<h3 id="4-星型拓扑（Star-Topology）"><a href="#4-星型拓扑（Star-Topology）" class="headerlink" title="4. 星型拓扑（Star Topology）"></a>4. 星型拓扑（Star Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-9.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Physical Perspective：<ul>
<li>星型拓扑结构有一个<strong>中心节点</strong>，所有的链路都从它辐射（radiating）出去。</li>
</ul>
</li>
<li>Logical Perspective<ul>
<li><strong>所有信息的流动将通过一个设备</strong>。</li>
</ul>
</li>
<li>优点：<ul>
<li>它允许所有其他节点相互通信，方便。出于安全或限制访问的原因，它也可能是可取的</li>
</ul>
</li>
<li>缺点：<ul>
<li><strong>中央节点故障会导致整个网络瘫痪</strong>。</li>
<li>根据使用的网络设备类型，冲突可能是一个问题，中心点会有很大的负担，并且容易造成通信阻塞</li>
</ul>
</li>
</ul>
<h3 id="5-树形拓扑（Tree-Topology）"><a href="#5-树形拓扑（Tree-Topology）" class="headerlink" title="5. 树形拓扑（Tree Topology）"></a>5. 树形拓扑（Tree Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-10.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>树拓扑使用一个主干节点（Trunk Node），从该节点分支到其他节点。</li>
<li>物理观点：主干是一条有几层分支的电线。</li>
<li>逻辑观点：信息流是层次性的。</li>
<li>在根一级数据节点可以对数据进行汇总和统计</li>
</ul>
<h3 id="6-渔网状拓扑（Mesh-Topology）"><a href="#6-渔网状拓扑（Mesh-Topology）" class="headerlink" title="6. 渔网状拓扑（Mesh Topology）"></a>6. 渔网状拓扑（Mesh Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-11.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>Physical Perspective：</li>
<li><strong>每个节点</strong>与网络中的<strong>其他节点直接相连</strong>。<ul>
<li>优点：<ul>
<li>高度冗余，任意节点或连接故障不会影响网络整体。</li>
<li>高可靠性和稳定性。 the maximum connectivity and reliability.</li>
</ul>
</li>
<li>缺点：<ul>
<li>结构复杂，成本高。</li>
<li>需要大量的电缆和端口。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-蜂窝拓扑（Cellular-Topology）"><a href="#7-蜂窝拓扑（Cellular-Topology）" class="headerlink" title="7. 蜂窝拓扑（Cellular Topology）"></a>7. 蜂窝拓扑（Cellular Topology）</h3><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-12.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>物理视角（Physical Perspective）<ul>
<li>蜂窝拓扑结构是用于<strong>无线技术</strong>的拓扑结构</li>
<li>有时接收节点移动（如<em>手机</em>），有时发送节点移动（如<em>卫星</em>）</li>
</ul>
</li>
<li>逻辑视角（Logical Perspective）<ul>
<li>节点之间直接通信（尽管有时非常困难），或者只与相邻的单元通信，这是<strong>非常低效</strong>的。</li>
<li>每一个节点都是无线的连通方式：远节点需要进行转发。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="六-Network-Devices-网络设备"><a href="#六-Network-Devices-网络设备" class="headerlink" title="六.Network Devices 网络设备"></a>六.Network Devices 网络设备</h1><h2 id="1-LAN-Devices-in-a-Topology"><a href="#1-LAN-Devices-in-a-Topology" class="headerlink" title="1.LAN Devices in a Topology"></a>1.LAN Devices in a Topology</h2><ul>
<li>主机<strong>Hosts</strong> （网络终端设备）：<ul>
<li><strong>直接连接到网段的设备</strong></li>
<li>打印机、计算机、服务器、传真机、复印机</li>
</ul>
</li>
<li>Hosts（网络中间设备）<ul>
<li><strong>主机不属于任何层</strong>，但 OSI 模型的功能在主机内部的软件中执行</li>
</ul>
</li>
</ul>
<h2 id="2-NIC-网络接口卡-–-Layer-2（Data-Link数据链路层）"><a href="#2-NIC-网络接口卡-–-Layer-2（Data-Link数据链路层）" class="headerlink" title="2.NIC 网络接口卡 – Layer 2（Data Link数据链路层）"></a>2.NIC 网络接口卡 – Layer 2（Data Link数据链路层）</h2><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-13.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>NIC，第二层，网卡（Network Interface Controller），<strong>网络终端设备</strong></li>
<li>携带称为 MAC 地址的唯一代码，固定地址，在芯片上</li>
<li>用于控制网络上主机的数据通信</li>
<li>将计算机产生的并行信号转换成串行格式通过网络发送</li>
<li>用于转换信号以及发送和接收比特的收发器</li>
<li>提供主机对媒体的访问权限</li>
<li>为什么是第二层的设备：<ul>
<li>可以识别帧</li>
<li>帮助主机接入网络</li>
</ul>
</li>
<li>计算机母线：并行通信；网卡总线：串行通信<ul>
<li>所以网卡需要完成两者之间的交换。</li>
</ul>
</li>
<li>也是可以完成第一层的工作的</li>
</ul>
<h2 id="3-Media介质-–-Layer-1"><a href="#3-Media介质-–-Layer-1" class="headerlink" title="3.Media介质 – Layer 1"></a>3.Media介质 – Layer 1</h2><ul>
<li>网络中间设备，第一层</li>
</ul>
<ol>
<li><strong>以位为单位携带信息流</strong></li>
<li>信号从一个网络设备传送到另一个网络设备的方式</li>
<li>0-1 信号变为电信号或者无线电波光信号等。</li>
</ol>
<h2 id="4-Repeaters中继器-Layer-1（物理层）"><a href="#4-Repeaters中继器-Layer-1（物理层）" class="headerlink" title="4.Repeaters中继器 - Layer 1（物理层）"></a>4.Repeaters中继器 - Layer 1（物理层）</h2><ul>
<li>网络中间设备</li>
<li>主要功能：<ul>
<li><strong>延长网络长度</strong>：<ul>
<li>用于延长网络的物理长度，实现传输超出一段介质传输的介质</li>
</ul>
</li>
<li>清理、放大和重发信号：<ul>
<li>清理、放大和重发由于长电缆传输而减弱的信号。</li>
</ul>
</li>
<li>信号再生和重定时：<ul>
<li>在<em>比特级别</em>重新生成（放大）和重定时网络信号（<strong>数字信号</strong>），以允许它们在媒体上传播更长的距离</li>
</ul>
</li>
<li>不进行过滤：<ul>
<li>中继器不对数据包进行任何过滤或处理，只是简单地转发信号。</li>
</ul>
</li>
</ul>
</li>
<li>这些功能确保了信号在长距离传输中的完整性和可靠性。</li>
</ul>
<h2 id="5-Hubs（集线器）-–-Layer-1"><a href="#5-Hubs（集线器）-–-Layer-1" class="headerlink" title="5.Hubs（集线器） – Layer 1"></a>5.Hubs（集线器） – Layer 1</h2><ul>
<li>网络中间设备</li>
<li>信号再生和重定时：用于重新生成和重定时网络信号，连接多个端口，可以比中继器做更多的事情</li>
<li>传播信号propagate signals<ul>
<li><code>不能过滤流量</code>cannot filter traffic</li>
<li><code>不能确定最佳路径</code>cannot determine the best path</li>
<li>网络中心节点used as network concentration points</li>
<li>有时称为多端口中继器sometimes called multiport repeaters</li>
</ul>
</li>
<li>逻辑拓扑：<strong>总线方式连接</strong>，一个端口入，所有端口出</li>
<li>不允许总线上同时有两路信号进行传输</li>
<li>冲突域：可能出现冲突的区域，但是集线器不进行这些控制，而是由交换机或者路由器来完成控制，不能降低冲突概率</li>
<li>而放大器方法的是模拟信号。</li>
</ul>
<h3 id="Repeaters-Hubs-Difference中继器和集线器的不同"><a href="#Repeaters-Hubs-Difference中继器和集线器的不同" class="headerlink" title="Repeaters&#x2F;Hubs - Difference中继器和集线器的不同"></a>Repeaters&#x2F;Hubs - Difference中继器和集线器的不同</h3><ul>
<li>中继器通常只有两个端口，而集线器通常有4个到20个或更多端口。</li>
<li>中继器在<strong>一个端口接收</strong>信号，并在<strong>另一个端口重复</strong>信号，而集线器在<strong>一个端口接收</strong>信号并在<strong>所有其他端口传输</strong>信号。</li>
<li>集线器最常见于以太网10Base-T或100Base-T网络中。</li>
<li>都是转发，<strong>都不做过滤功能</strong></li>
<li>两个设备之间最多有 4 个集线器和网桥</li>
</ul>
<h2 id="6-Bridges（网桥）-–-Layer-2（数据链路层）"><a href="#6-Bridges（网桥）-–-Layer-2（数据链路层）" class="headerlink" title="6.Bridges（网桥） – Layer 2（数据链路层）"></a>6.Bridges（网桥） – Layer 2（数据链路层）</h2><ul>
<li>网络中间设备</li>
</ul>
<ol>
<li>目的是在 LAN 上过滤流量，以保持本地流量，但允许连接到 LAN 的其他部分以定向到那里的流量</li>
<li>跟踪网桥两侧的 MAC 地址，并根据此 MAC 地址列表进行决策<ul>
<li>目的地址如果在同一端，就不进行转发（不必进行转发，MAC Table）</li>
<li>而在不同侧（不同的 segments）就进行尽量向外转发</li>
</ul>
</li>
<li>比集线器更智能</li>
<li>收集并在段之间传递数据包</li>
<li>创建冲突域<ul>
<li>通过网桥划分冲突域</li>
<li>每个冲突域中都有一定的主机</li>
<li>第一层以上的设备才能划分冲突域</li>
</ul>
</li>
<li>维护地址表</li>
</ol>
<ul>
<li>这些功能使得网桥在局域网中能够有效地管理和优化流量，提高网络的整体性能和效率。</li>
</ul>
<h2 id="7-Switches（交换机）-–-Layer-2"><a href="#7-Switches（交换机）-–-Layer-2" class="headerlink" title="7.Switches（交换机） – Layer 2"></a>7.Switches（交换机） – Layer 2</h2><ul>
<li>网络中间设备</li>
<li>集中连接 used to concentrate connectivity</li>
<li>结合集线器的连接性和网桥的流量调节 combine the connectivity of a hub with the traffic regulation of a bridge</li>
<li>switch frames from incoming ports to outgoing ports providing each port with full bandwidth 根据MAC地址表将帧从输入端口切换到相应的输出端口，为每个端口提供全带宽。</li>
<li>provide separate data paths 为每个连接的设备提供独立的数据路径，避免冲突，提高网络性能。</li>
</ul>
<h2 id="8-Routers路由器-–-Layer-3"><a href="#8-Routers路由器-–-Layer-3" class="headerlink" title="8.Routers路由器 – Layer 3"></a>8.Routers路由器 – Layer 3</h2><ul>
<li>网络中间设备</li>
<li>在大型网络中调节流量。</li>
<li>基于网络地址（如IP地址）做出转发决策。<ul>
<li>主要是进行网段的划分，根据网络地址（包含在 IP 地址中）进行转化</li>
</ul>
</li>
<li>检查数据包的第三层数据，选择最佳路径，并通过适当的输出端口转发数据包。</li>
<li><code>主要目的</code>：<ul>
<li>用于<strong>路径选择</strong>和<strong>将数据包切换到最佳路由</strong>。</li>
</ul>
</li>
</ul>
<h2 id="9-Evolution-of-Networking-Devices-and-the-OSI-Layers"><a href="#9-Evolution-of-Networking-Devices-and-the-OSI-Layers" class="headerlink" title="9.Evolution of Networking Devices and the OSI Layers"></a>9.Evolution of Networking Devices and the OSI Layers</h2><p><img src="/2025/02/22/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image.png" alt="alt text"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ol>
<li>网络设备的工作层次和主机情况<ul>
<li>物理层：<strong>介质、中继器、集线器</strong></li>
<li>数据链路层：<strong>网桥、交换机、电路交换设备</strong></li>
<li>网络层：<strong>路由器</strong></li>
</ul>
</li>
</ol>
<ul>
<li>高层设备可以识别低层设备的信号，但是低层设备不能识别高层次的数据逻辑</li>
<li>Host 下层通过网卡进行实现，上层通过网络操作系统、应用实现</li>
</ul>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
